CCS PCH C Compiler, Version 4.130, 13671               23-Jul-14 14:38

               Filename: C:\SOURCE\PIC\FLX PIC\main.lst

               ROM used: 49358 bytes (75%)
                         Largest free fragment is 16178
               RAM used: 2081 (53%) at main() level
                         2301 (59%) worst case
               Stack:    16 worst case (9 in main + 7 for interrupts)

*
00000:  GOTO   BBE2
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0C7C
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   250A
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   2852
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   299A
00084:  BTFSS  FA3.5
00086:  GOTO   0090
0008A:  BTFSC  FA4.5
0008C:  GOTO   0BAE
00090:  MOVFF  0E,00
00094:  MOVFF  0F,01
00098:  MOVFF  10,02
0009C:  MOVFF  11,03
000A0:  MOVFF  0C,FE9
000A4:  MOVFF  07,FEA
000A8:  BSF    07.7
000AA:  MOVFF  08,FE1
000AE:  MOVFF  09,FE2
000B2:  MOVFF  0A,FD9
000B6:  MOVFF  0B,FDA
000BA:  MOVFF  12,FF3
000BE:  MOVFF  13,FF4
000C2:  MOVFF  14,FFA
000C6:  MOVFF  15,FF5
000CA:  MOVFF  16,FF6
000CE:  MOVFF  17,FF7
000D2:  MOVF   04,W
000D4:  MOVFF  06,FE0
000D8:  MOVFF  05,FD8
000DC:  RETFIE 0
.................... #include <18LF46K22.h> 
.................... //////// Standard Header file for the PIC18LF46K22 device //////////////// 
.................... #device PIC18LF46K22 
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSM                   	//High speed Osc, medium power 4MHz-16MHz 
.................... #FUSES NOPLLEN               	//4X HW PLL disabled, 4X PLL enabled in software 
.................... #FUSES PUT                   	//Power Up Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES WDT_SW                	//No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=14745600) 
*
05A08:  MOVLW  08
05A0A:  MOVWF  FEA
05A0C:  MOVLW  74
05A0E:  MOVWF  FE9
05A10:  MOVF   FEF,W
05A12:  BZ    5A2E
05A14:  MOVLW  04
05A16:  MOVWF  01
05A18:  CLRF   00
05A1A:  DECFSZ 00,F
05A1C:  BRA    5A1A
05A1E:  DECFSZ 01,F
05A20:  BRA    5A18
05A22:  MOVLW  C7
05A24:  MOVWF  00
05A26:  DECFSZ 00,F
05A28:  BRA    5A26
05A2A:  DECFSZ FEF,F
05A2C:  BRA    5A14
05A2E:  RETURN 0
....................  
.................... /* 
.................... #define BOOTLOADER_START        0x2A  
.................... #define BOOTLOADER_END          0x3FF + 0x400 
.................... #build (reset=BOOTLOADER_END +1  , interrupt=0x408 + 0x400 )  
.................... #org 0, BOOTLOADER_END {}  
.................... */ 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
013DC:  MOVLB  8
013DE:  BCF    xE8.0
....................    y = x; 
013E0:  MOVFF  8DC,8E1
013E4:  MOVFF  8DB,8E0
013E8:  MOVFF  8DA,8DF
013EC:  MOVFF  8D9,8DE
....................  
....................    if (x < 0) 
013F0:  MOVFF  8DC,8EC
013F4:  MOVFF  8DB,8EB
013F8:  MOVFF  8DA,8EA
013FC:  MOVFF  8D9,8E9
01400:  CLRF   xF0
01402:  CLRF   xEF
01404:  CLRF   xEE
01406:  CLRF   xED
01408:  MOVLB  0
0140A:  RCALL  1326
0140C:  BNC   1418
....................    { 
....................       s = 1; 
0140E:  MOVLB  8
01410:  BSF    xE8.0
....................       y = -y; 
01412:  MOVF   xDF,W
01414:  XORLW  80
01416:  MOVWF  xDF
....................    } 
....................  
....................    if (y <= 32768.0) 
01418:  MOVFF  8E1,8EC
0141C:  MOVFF  8E0,8EB
01420:  MOVFF  8DF,8EA
01424:  MOVFF  8DE,8E9
01428:  MOVLB  8
0142A:  CLRF   xF0
0142C:  CLRF   xEF
0142E:  CLRF   xEE
01430:  MOVLW  8E
01432:  MOVWF  xED
01434:  MOVLB  0
01436:  RCALL  1326
01438:  BC    143C
0143A:  BNZ   146A
....................       res = (float32)(unsigned int16)y; 
0143C:  MOVFF  8E1,8EC
01440:  MOVFF  8E0,8EB
01444:  MOVFF  8DF,8EA
01448:  MOVFF  8DE,8E9
0144C:  RCALL  13A0
0144E:  MOVFF  02,8EE
01452:  MOVFF  01,8ED
01456:  RCALL  0E24
01458:  MOVFF  03,8E5
0145C:  MOVFF  02,8E4
01460:  MOVFF  01,8E3
01464:  MOVFF  00,8E2
....................  
....................  else if (y < 10000000.0) 
01468:  BRA    15F8
0146A:  MOVFF  8E1,8EC
0146E:  MOVFF  8E0,8EB
01472:  MOVFF  8DF,8EA
01476:  MOVFF  8DE,8E9
0147A:  MOVLW  80
0147C:  MOVLB  8
0147E:  MOVWF  xF0
01480:  MOVLW  96
01482:  MOVWF  xEF
01484:  MOVLW  18
01486:  MOVWF  xEE
01488:  MOVLW  96
0148A:  MOVWF  xED
0148C:  MOVLB  0
0148E:  RCALL  1326
01490:  BTFSS  FD8.0
01492:  BRA    15E8
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
01494:  MOVFF  8E1,8EC
01498:  MOVFF  8E0,8EB
0149C:  MOVFF  8DF,8EA
014A0:  MOVFF  8DE,8E9
014A4:  MOVLB  8
014A6:  CLRF   xF0
014A8:  CLRF   xEF
014AA:  CLRF   xEE
014AC:  MOVLW  70
014AE:  MOVWF  xED
014B0:  MOVLB  0
014B2:  RCALL  1230
014B4:  MOVFF  03,8EC
014B8:  MOVFF  02,8EB
014BC:  MOVFF  01,8EA
014C0:  MOVFF  00,8E9
014C4:  RCALL  13A0
014C6:  MOVFF  02,8E7
014CA:  MOVFF  01,8E6
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
014CE:  MOVFF  8E1,8EC
014D2:  MOVFF  8E0,8EB
014D6:  MOVFF  8DF,8EA
014DA:  MOVFF  8DE,8E9
014DE:  MOVLB  8
014E0:  CLRF   xF0
014E2:  CLRF   xEF
014E4:  CLRF   xEE
014E6:  MOVLW  70
014E8:  MOVWF  xED
014EA:  MOVLB  0
014EC:  RCALL  1230
014EE:  MOVFF  00,8E9
014F2:  MOVFF  01,8EA
014F6:  MOVFF  02,8EB
014FA:  MOVFF  03,8EC
014FE:  MOVFF  8E7,8EE
01502:  MOVFF  8E6,8ED
01506:  RCALL  0E24
01508:  BSF    FD8.1
0150A:  MOVFF  8EC,8F0
0150E:  MOVFF  8EB,8EF
01512:  MOVFF  8EA,8EE
01516:  MOVFF  8E9,8ED
0151A:  MOVFF  03,8F4
0151E:  MOVFF  02,8F3
01522:  MOVFF  01,8F2
01526:  MOVFF  00,8F1
0152A:  RCALL  0E5A
0152C:  MOVLB  8
0152E:  CLRF   xEC
01530:  CLRF   xEB
01532:  CLRF   xEA
01534:  MOVLW  8E
01536:  MOVWF  xE9
01538:  MOVFF  03,8F0
0153C:  MOVFF  02,8EF
01540:  MOVFF  01,8EE
01544:  MOVFF  00,8ED
01548:  MOVLB  0
0154A:  RCALL  1230
0154C:  MOVFF  03,8E1
01550:  MOVFF  02,8E0
01554:  MOVFF  01,8DF
01558:  MOVFF  00,8DE
....................       res = 32768.0*(float32)l; 
0155C:  MOVFF  8E7,8EE
01560:  MOVFF  8E6,8ED
01564:  RCALL  0E24
01566:  MOVLB  8
01568:  CLRF   xEC
0156A:  CLRF   xEB
0156C:  CLRF   xEA
0156E:  MOVLW  8E
01570:  MOVWF  xE9
01572:  MOVFF  03,8F0
01576:  MOVFF  02,8EF
0157A:  MOVFF  01,8EE
0157E:  MOVFF  00,8ED
01582:  MOVLB  0
01584:  RCALL  1230
01586:  MOVFF  03,8E5
0158A:  MOVFF  02,8E4
0158E:  MOVFF  01,8E3
01592:  MOVFF  00,8E2
....................       res += (float32)(unsigned int16)y; 
01596:  MOVFF  8E1,8EC
0159A:  MOVFF  8E0,8EB
0159E:  MOVFF  8DF,8EA
015A2:  MOVFF  8DE,8E9
015A6:  RCALL  13A0
015A8:  MOVFF  02,8EE
015AC:  MOVFF  01,8ED
015B0:  RCALL  0E24
015B2:  BCF    FD8.1
015B4:  MOVFF  8E5,8F0
015B8:  MOVFF  8E4,8EF
015BC:  MOVFF  8E3,8EE
015C0:  MOVFF  8E2,8ED
015C4:  MOVFF  03,8F4
015C8:  MOVFF  02,8F3
015CC:  MOVFF  01,8F2
015D0:  MOVFF  00,8F1
015D4:  RCALL  0E5A
015D6:  MOVFF  03,8E5
015DA:  MOVFF  02,8E4
015DE:  MOVFF  01,8E3
015E2:  MOVFF  00,8E2
....................    } 
....................  
....................  else 
015E6:  BRA    15F8
....................   res = y; 
015E8:  MOVFF  8E1,8E5
015EC:  MOVFF  8E0,8E4
015F0:  MOVFF  8DF,8E3
015F4:  MOVFF  8DE,8E2
....................  
....................  y = y - (float32)(unsigned int16)y; 
015F8:  MOVFF  8E1,8EC
015FC:  MOVFF  8E0,8EB
01600:  MOVFF  8DF,8EA
01604:  MOVFF  8DE,8E9
01608:  RCALL  13A0
0160A:  MOVFF  02,8EE
0160E:  MOVFF  01,8ED
01612:  RCALL  0E24
01614:  BSF    FD8.1
01616:  MOVFF  8E1,8F0
0161A:  MOVFF  8E0,8EF
0161E:  MOVFF  8DF,8EE
01622:  MOVFF  8DE,8ED
01626:  MOVFF  03,8F4
0162A:  MOVFF  02,8F3
0162E:  MOVFF  01,8F2
01632:  MOVFF  00,8F1
01636:  RCALL  0E5A
01638:  MOVFF  03,8E1
0163C:  MOVFF  02,8E0
01640:  MOVFF  01,8DF
01644:  MOVFF  00,8DE
....................  
....................  if (s) 
01648:  MOVLB  8
0164A:  BTFSS  xE8.0
0164C:  BRA    1654
....................   res = -res; 
0164E:  MOVF   xE3,W
01650:  XORLW  80
01652:  MOVWF  xE3
....................  
....................  if (y != 0) 
01654:  MOVFF  8E1,8EC
01658:  MOVFF  8E0,8EB
0165C:  MOVFF  8DF,8EA
01660:  MOVFF  8DE,8E9
01664:  CLRF   xF0
01666:  CLRF   xEF
01668:  CLRF   xEE
0166A:  CLRF   xED
0166C:  MOVLB  0
0166E:  RCALL  1326
01670:  BZ    16EA
....................  { 
....................   if (s == 1 && n == 0) 
01672:  MOVLB  8
01674:  BTFSS  xE8.0
01676:  BRA    16B0
01678:  MOVF   xDD,F
0167A:  BNZ   16B0
....................    res -= 1.0; 
0167C:  BSF    FD8.1
0167E:  MOVFF  8E5,8F0
01682:  MOVFF  8E4,8EF
01686:  MOVFF  8E3,8EE
0168A:  MOVFF  8E2,8ED
0168E:  CLRF   xF4
01690:  CLRF   xF3
01692:  CLRF   xF2
01694:  MOVLW  7F
01696:  MOVWF  xF1
01698:  MOVLB  0
0169A:  CALL   0E5A
0169E:  MOVFF  03,8E5
016A2:  MOVFF  02,8E4
016A6:  MOVFF  01,8E3
016AA:  MOVFF  00,8E2
016AE:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
016B0:  BTFSC  xE8.0
016B2:  BRA    16EC
016B4:  DECFSZ xDD,W
016B6:  BRA    16EC
....................    res += 1.0; 
016B8:  BCF    FD8.1
016BA:  MOVFF  8E5,8F0
016BE:  MOVFF  8E4,8EF
016C2:  MOVFF  8E3,8EE
016C6:  MOVFF  8E2,8ED
016CA:  CLRF   xF4
016CC:  CLRF   xF3
016CE:  CLRF   xF2
016D0:  MOVLW  7F
016D2:  MOVWF  xF1
016D4:  MOVLB  0
016D6:  CALL   0E5A
016DA:  MOVFF  03,8E5
016DE:  MOVFF  02,8E4
016E2:  MOVFF  01,8E3
016E6:  MOVFF  00,8E2
016EA:  MOVLB  8
....................  } 
....................  if (x == 0) 
016EC:  MOVFF  8DC,8EC
016F0:  MOVFF  8DB,8EB
016F4:  MOVFF  8DA,8EA
016F8:  MOVFF  8D9,8E9
016FC:  CLRF   xF0
016FE:  CLRF   xEF
01700:  CLRF   xEE
01702:  CLRF   xED
01704:  MOVLB  0
01706:  RCALL  1326
01708:  BNZ   1716
....................     res = 0; 
0170A:  MOVLB  8
0170C:  CLRF   xE5
0170E:  CLRF   xE4
01710:  CLRF   xE3
01712:  CLRF   xE2
01714:  MOVLB  0
....................  
....................  return (res); 
01716:  MOVFF  8E2,00
0171A:  MOVFF  8E3,01
0171E:  MOVFF  8E4,02
01722:  MOVFF  8E5,03
.................... } 
01726:  RETURN 0
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
01744:  MOVFF  8D8,8DC
01748:  MOVFF  8D7,8DB
0174C:  MOVFF  8D6,8DA
01750:  MOVFF  8D5,8D9
01754:  MOVLB  8
01756:  CLRF   xDD
01758:  MOVLB  0
0175A:  RCALL  13DC
.................... } 
0175C:  RETURN 0
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
01728:  MOVFF  8D8,8DC
0172C:  MOVFF  8D7,8DB
01730:  MOVFF  8D6,8DA
01734:  MOVFF  8D5,8D9
01738:  MOVLW  01
0173A:  MOVLB  8
0173C:  MOVWF  xDD
0173E:  MOVLB  0
01740:  RCALL  13DC
.................... } 
01742:  RETURN 0
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0175E:  MOVFF  8CC,8EC
01762:  MOVFF  8CB,8EB
01766:  MOVFF  8CA,8EA
0176A:  MOVFF  8C9,8E9
0176E:  MOVLB  8
01770:  CLRF   xF0
01772:  CLRF   xEF
01774:  CLRF   xEE
01776:  CLRF   xED
01778:  MOVLB  0
0177A:  RCALL  1326
0177C:  BTFSC  FD8.2
0177E:  BRA    18B8
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
01780:  MOVFF  8C8,8E5
01784:  MOVFF  8C7,8E4
01788:  MOVFF  8C6,8E3
0178C:  MOVFF  8C5,8E2
01790:  MOVFF  8CC,8E9
01794:  MOVFF  8CB,8E8
01798:  MOVFF  8CA,8E7
0179C:  MOVFF  8C9,8E6
017A0:  RCALL  10D2
017A2:  MOVFF  00,8D1
017A6:  MOVFF  01,8D2
017AA:  MOVFF  02,8D3
017AE:  MOVFF  03,8D4
017B2:  MOVFF  03,8EC
017B6:  MOVFF  02,8EB
017BA:  MOVFF  01,8EA
017BE:  MOVFF  00,8E9
017C2:  MOVLB  8
017C4:  CLRF   xF0
017C6:  CLRF   xEF
017C8:  CLRF   xEE
017CA:  CLRF   xED
017CC:  MOVLB  0
017CE:  RCALL  1326
017D0:  BNC   1818
017D2:  MOVFF  8C8,8E5
017D6:  MOVFF  8C7,8E4
017DA:  MOVFF  8C6,8E3
017DE:  MOVFF  8C5,8E2
017E2:  MOVFF  8CC,8E9
017E6:  MOVFF  8CB,8E8
017EA:  MOVFF  8CA,8E7
017EE:  MOVFF  8C9,8E6
017F2:  RCALL  10D2
017F4:  MOVFF  00,8D1
017F8:  MOVFF  01,8D2
017FC:  MOVFF  02,8D3
01800:  MOVFF  03,8D4
01804:  MOVFF  03,8D8
01808:  MOVFF  02,8D7
0180C:  MOVFF  01,8D6
01810:  MOVFF  00,8D5
01814:  RCALL  1728
01816:  BRA    185C
01818:  MOVFF  8C8,8E5
0181C:  MOVFF  8C7,8E4
01820:  MOVFF  8C6,8E3
01824:  MOVFF  8C5,8E2
01828:  MOVFF  8CC,8E9
0182C:  MOVFF  8CB,8E8
01830:  MOVFF  8CA,8E7
01834:  MOVFF  8C9,8E6
01838:  RCALL  10D2
0183A:  MOVFF  00,8D1
0183E:  MOVFF  01,8D2
01842:  MOVFF  02,8D3
01846:  MOVFF  03,8D4
0184A:  MOVFF  03,8D8
0184E:  MOVFF  02,8D7
01852:  MOVFF  01,8D6
01856:  MOVFF  00,8D5
0185A:  RCALL  1744
0185C:  MOVFF  03,8D0
01860:  MOVFF  02,8CF
01864:  MOVFF  01,8CE
01868:  MOVFF  00,8CD
....................       return(x-(i*y)); 
0186C:  MOVFF  8D0,8EC
01870:  MOVFF  8CF,8EB
01874:  MOVFF  8CE,8EA
01878:  MOVFF  8CD,8E9
0187C:  MOVFF  8CC,8F0
01880:  MOVFF  8CB,8EF
01884:  MOVFF  8CA,8EE
01888:  MOVFF  8C9,8ED
0188C:  RCALL  1230
0188E:  BSF    FD8.1
01890:  MOVFF  8C8,8F0
01894:  MOVFF  8C7,8EF
01898:  MOVFF  8C6,8EE
0189C:  MOVFF  8C5,8ED
018A0:  MOVFF  03,8F4
018A4:  MOVFF  02,8F3
018A8:  MOVFF  01,8F2
018AC:  MOVFF  00,8F1
018B0:  CALL   0E5A
018B4:  BRA    18B8
....................    } 
....................    else 
018B6:  BRA    18B8
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
018B8:  RETURN 0
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
01C98:  MOVFF  8CC,8EC
01C9C:  MOVFF  8CB,8EB
01CA0:  MOVFF  8CA,8EA
01CA4:  MOVFF  8C9,8E9
01CA8:  MOVLW  3B
01CAA:  MOVLB  8
01CAC:  MOVWF  xF0
01CAE:  MOVLW  AA
01CB0:  MOVWF  xEF
01CB2:  MOVLW  38
01CB4:  MOVWF  xEE
01CB6:  MOVLW  7F
01CB8:  MOVWF  xED
01CBA:  MOVLB  0
01CBC:  CALL   1230
01CC0:  MOVFF  03,8EC
01CC4:  MOVFF  02,8EB
01CC8:  MOVFF  01,8EA
01CCC:  MOVFF  00,8E9
01CD0:  CALL   13A0
01CD4:  MOVFF  01,8D9
....................    s = 0; 
01CD8:  MOVLB  8
01CDA:  BCF    xDA.0
....................    y = x; 
01CDC:  MOVFF  8CC,8D0
01CE0:  MOVFF  8CB,8CF
01CE4:  MOVFF  8CA,8CE
01CE8:  MOVFF  8C9,8CD
....................  
....................    if (x < 0) 
01CEC:  MOVFF  8CC,8EC
01CF0:  MOVFF  8CB,8EB
01CF4:  MOVFF  8CA,8EA
01CF8:  MOVFF  8C9,8E9
01CFC:  CLRF   xF0
01CFE:  CLRF   xEF
01D00:  CLRF   xEE
01D02:  CLRF   xED
01D04:  MOVLB  0
01D06:  CALL   1326
01D0A:  BNC   1D18
....................    { 
....................       s = 1; 
01D0C:  MOVLB  8
01D0E:  BSF    xDA.0
....................       n = -n; 
01D10:  NEGF   xD9
....................       y = -y; 
01D12:  MOVF   xCE,W
01D14:  XORLW  80
01D16:  MOVWF  xCE
....................    } 
....................  
....................    res = 0.0; 
01D18:  MOVLB  8
01D1A:  CLRF   xD4
01D1C:  CLRF   xD3
01D1E:  CLRF   xD2
01D20:  CLRF   xD1
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
01D22:  MOVLW  08
01D24:  MOVWF  xDC
01D26:  MOVLW  D1
01D28:  MOVWF  FE9
01D2A:  MOVFF  8DC,FEA
01D2E:  MOVLW  7F
01D30:  ADDWF  xD9,W
01D32:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
01D34:  MOVFF  8D0,8EC
01D38:  MOVFF  8CF,8EB
01D3C:  MOVFF  8CE,8EA
01D40:  MOVFF  8CD,8E9
01D44:  MOVLW  3B
01D46:  MOVWF  xF0
01D48:  MOVLW  AA
01D4A:  MOVWF  xEF
01D4C:  MOVLW  38
01D4E:  MOVWF  xEE
01D50:  MOVLW  7F
01D52:  MOVWF  xED
01D54:  MOVLB  0
01D56:  CALL   1230
01D5A:  MOVFF  00,8DB
01D5E:  MOVFF  01,8DC
01D62:  MOVFF  02,8DD
01D66:  MOVFF  03,8DE
01D6A:  MOVLB  8
01D6C:  CLRF   xE0
01D6E:  MOVFF  8D9,8DF
01D72:  BTFSC  xDF.7
01D74:  DECF   xE0,F
01D76:  MOVLB  0
01D78:  RCALL  18BA
01D7A:  BSF    FD8.1
01D7C:  MOVFF  8DE,8F0
01D80:  MOVFF  8DD,8EF
01D84:  MOVFF  8DC,8EE
01D88:  MOVFF  8DB,8ED
01D8C:  MOVFF  03,8F4
01D90:  MOVFF  02,8F3
01D94:  MOVFF  01,8F2
01D98:  MOVFF  00,8F1
01D9C:  CALL   0E5A
01DA0:  MOVFF  03,8D0
01DA4:  MOVFF  02,8CF
01DA8:  MOVFF  01,8CE
01DAC:  MOVFF  00,8CD
....................  
....................    r = pe[0]*y + pe[1]; 
01DB0:  MOVLW  7C
01DB2:  MOVLB  8
01DB4:  MOVWF  xEC
01DB6:  MOVLW  88
01DB8:  MOVWF  xEB
01DBA:  MOVLW  59
01DBC:  MOVWF  xEA
01DBE:  MOVLW  72
01DC0:  MOVWF  xE9
01DC2:  MOVFF  8D0,8F0
01DC6:  MOVFF  8CF,8EF
01DCA:  MOVFF  8CE,8EE
01DCE:  MOVFF  8CD,8ED
01DD2:  MOVLB  0
01DD4:  CALL   1230
01DD8:  MOVFF  00,8DB
01DDC:  MOVFF  01,8DC
01DE0:  MOVFF  02,8DD
01DE4:  MOVFF  03,8DE
01DE8:  BCF    FD8.1
01DEA:  MOVFF  03,8F0
01DEE:  MOVFF  02,8EF
01DF2:  MOVFF  01,8EE
01DF6:  MOVFF  00,8ED
01DFA:  MOVLW  E0
01DFC:  MOVLB  8
01DFE:  MOVWF  xF4
01E00:  MOVLW  97
01E02:  MOVWF  xF3
01E04:  MOVLW  26
01E06:  MOVWF  xF2
01E08:  MOVLW  75
01E0A:  MOVWF  xF1
01E0C:  MOVLB  0
01E0E:  CALL   0E5A
01E12:  MOVFF  03,8D8
01E16:  MOVFF  02,8D7
01E1A:  MOVFF  01,8D6
01E1E:  MOVFF  00,8D5
....................    r = r*y + pe[2]; 
01E22:  MOVFF  8D8,8EC
01E26:  MOVFF  8D7,8EB
01E2A:  MOVFF  8D6,8EA
01E2E:  MOVFF  8D5,8E9
01E32:  MOVFF  8D0,8F0
01E36:  MOVFF  8CF,8EF
01E3A:  MOVFF  8CE,8EE
01E3E:  MOVFF  8CD,8ED
01E42:  CALL   1230
01E46:  MOVFF  00,8DB
01E4A:  MOVFF  01,8DC
01E4E:  MOVFF  02,8DD
01E52:  MOVFF  03,8DE
01E56:  BCF    FD8.1
01E58:  MOVFF  03,8F0
01E5C:  MOVFF  02,8EF
01E60:  MOVFF  01,8EE
01E64:  MOVFF  00,8ED
01E68:  MOVLW  C4
01E6A:  MOVLB  8
01E6C:  MOVWF  xF4
01E6E:  MOVLW  1D
01E70:  MOVWF  xF3
01E72:  MOVLW  1E
01E74:  MOVWF  xF2
01E76:  MOVLW  78
01E78:  MOVWF  xF1
01E7A:  MOVLB  0
01E7C:  CALL   0E5A
01E80:  MOVFF  03,8D8
01E84:  MOVFF  02,8D7
01E88:  MOVFF  01,8D6
01E8C:  MOVFF  00,8D5
....................    r = r*y + pe[3]; 
01E90:  MOVFF  8D8,8EC
01E94:  MOVFF  8D7,8EB
01E98:  MOVFF  8D6,8EA
01E9C:  MOVFF  8D5,8E9
01EA0:  MOVFF  8D0,8F0
01EA4:  MOVFF  8CF,8EF
01EA8:  MOVFF  8CE,8EE
01EAC:  MOVFF  8CD,8ED
01EB0:  CALL   1230
01EB4:  MOVFF  00,8DB
01EB8:  MOVFF  01,8DC
01EBC:  MOVFF  02,8DD
01EC0:  MOVFF  03,8DE
01EC4:  BCF    FD8.1
01EC6:  MOVFF  03,8F0
01ECA:  MOVFF  02,8EF
01ECE:  MOVFF  01,8EE
01ED2:  MOVFF  00,8ED
01ED6:  MOVLW  5E
01ED8:  MOVLB  8
01EDA:  MOVWF  xF4
01EDC:  MOVLW  50
01EDE:  MOVWF  xF3
01EE0:  MOVLW  63
01EE2:  MOVWF  xF2
01EE4:  MOVLW  7A
01EE6:  MOVWF  xF1
01EE8:  MOVLB  0
01EEA:  CALL   0E5A
01EEE:  MOVFF  03,8D8
01EF2:  MOVFF  02,8D7
01EF6:  MOVFF  01,8D6
01EFA:  MOVFF  00,8D5
....................    r = r*y + pe[4]; 
01EFE:  MOVFF  8D8,8EC
01F02:  MOVFF  8D7,8EB
01F06:  MOVFF  8D6,8EA
01F0A:  MOVFF  8D5,8E9
01F0E:  MOVFF  8D0,8F0
01F12:  MOVFF  8CF,8EF
01F16:  MOVFF  8CE,8EE
01F1A:  MOVFF  8CD,8ED
01F1E:  CALL   1230
01F22:  MOVFF  00,8DB
01F26:  MOVFF  01,8DC
01F2A:  MOVFF  02,8DD
01F2E:  MOVFF  03,8DE
01F32:  BCF    FD8.1
01F34:  MOVFF  03,8F0
01F38:  MOVFF  02,8EF
01F3C:  MOVFF  01,8EE
01F40:  MOVFF  00,8ED
01F44:  MOVLW  1A
01F46:  MOVLB  8
01F48:  MOVWF  xF4
01F4A:  MOVLW  FE
01F4C:  MOVWF  xF3
01F4E:  MOVLW  75
01F50:  MOVWF  xF2
01F52:  MOVLW  7C
01F54:  MOVWF  xF1
01F56:  MOVLB  0
01F58:  CALL   0E5A
01F5C:  MOVFF  03,8D8
01F60:  MOVFF  02,8D7
01F64:  MOVFF  01,8D6
01F68:  MOVFF  00,8D5
....................    r = r*y + pe[5]; 
01F6C:  MOVFF  8D8,8EC
01F70:  MOVFF  8D7,8EB
01F74:  MOVFF  8D6,8EA
01F78:  MOVFF  8D5,8E9
01F7C:  MOVFF  8D0,8F0
01F80:  MOVFF  8CF,8EF
01F84:  MOVFF  8CE,8EE
01F88:  MOVFF  8CD,8ED
01F8C:  CALL   1230
01F90:  MOVFF  00,8DB
01F94:  MOVFF  01,8DC
01F98:  MOVFF  02,8DD
01F9C:  MOVFF  03,8DE
01FA0:  BCF    FD8.1
01FA2:  MOVFF  03,8F0
01FA6:  MOVFF  02,8EF
01FAA:  MOVFF  01,8EE
01FAE:  MOVFF  00,8ED
01FB2:  MOVLW  18
01FB4:  MOVLB  8
01FB6:  MOVWF  xF4
01FB8:  MOVLW  72
01FBA:  MOVWF  xF3
01FBC:  MOVLW  31
01FBE:  MOVWF  xF2
01FC0:  MOVLW  7E
01FC2:  MOVWF  xF1
01FC4:  MOVLB  0
01FC6:  CALL   0E5A
01FCA:  MOVFF  03,8D8
01FCE:  MOVFF  02,8D7
01FD2:  MOVFF  01,8D6
01FD6:  MOVFF  00,8D5
....................  
....................    res = res*(1.0 + y*r); 
01FDA:  MOVFF  8D0,8EC
01FDE:  MOVFF  8CF,8EB
01FE2:  MOVFF  8CE,8EA
01FE6:  MOVFF  8CD,8E9
01FEA:  MOVFF  8D8,8F0
01FEE:  MOVFF  8D7,8EF
01FF2:  MOVFF  8D6,8EE
01FF6:  MOVFF  8D5,8ED
01FFA:  CALL   1230
01FFE:  BCF    FD8.1
02000:  MOVLB  8
02002:  CLRF   xF0
02004:  CLRF   xEF
02006:  CLRF   xEE
02008:  MOVLW  7F
0200A:  MOVWF  xED
0200C:  MOVFF  03,8F4
02010:  MOVFF  02,8F3
02014:  MOVFF  01,8F2
02018:  MOVFF  00,8F1
0201C:  MOVLB  0
0201E:  CALL   0E5A
02022:  MOVFF  8D4,8EC
02026:  MOVFF  8D3,8EB
0202A:  MOVFF  8D2,8EA
0202E:  MOVFF  8D1,8E9
02032:  MOVFF  03,8F0
02036:  MOVFF  02,8EF
0203A:  MOVFF  01,8EE
0203E:  MOVFF  00,8ED
02042:  CALL   1230
02046:  MOVFF  03,8D4
0204A:  MOVFF  02,8D3
0204E:  MOVFF  01,8D2
02052:  MOVFF  00,8D1
....................  
....................    if (s) 
02056:  MOVLB  8
02058:  BTFSS  xDA.0
0205A:  BRA    208E
....................       res = 1.0/res; 
0205C:  CLRF   xE5
0205E:  CLRF   xE4
02060:  CLRF   xE3
02062:  MOVLW  7F
02064:  MOVWF  xE2
02066:  MOVFF  8D4,8E9
0206A:  MOVFF  8D3,8E8
0206E:  MOVFF  8D2,8E7
02072:  MOVFF  8D1,8E6
02076:  MOVLB  0
02078:  CALL   10D2
0207C:  MOVFF  03,8D4
02080:  MOVFF  02,8D3
02084:  MOVFF  01,8D2
02088:  MOVFF  00,8D1
0208C:  MOVLB  8
....................    return(res); 
0208E:  MOVFF  8D1,00
02092:  MOVFF  8D2,01
02096:  MOVFF  8D3,02
0209A:  MOVFF  8D4,03
.................... } 
0209E:  MOVLB  0
020A0:  RETURN 0
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0190A:  MOVFF  8CC,8D0
0190E:  MOVFF  8CB,8CF
01912:  MOVFF  8CA,8CE
01916:  MOVFF  8C9,8CD
....................  
....................    if (y != 1.0) 
0191A:  MOVFF  8D0,8EC
0191E:  MOVFF  8CF,8EB
01922:  MOVFF  8CE,8EA
01926:  MOVFF  8CD,8E9
0192A:  MOVLB  8
0192C:  CLRF   xF0
0192E:  CLRF   xEF
01930:  CLRF   xEE
01932:  MOVLW  7F
01934:  MOVWF  xED
01936:  MOVLB  0
01938:  RCALL  1326
0193A:  BTFSC  FD8.2
0193C:  BRA    1C7A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0193E:  MOVLW  08
01940:  MOVLB  8
01942:  MOVWF  xDF
01944:  MOVLW  CD
01946:  MOVWF  FE9
01948:  MOVFF  8DF,FEA
0194C:  MOVLW  7E
0194E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
01950:  BSF    FD8.1
01952:  MOVFF  8D0,8F0
01956:  MOVFF  8CF,8EF
0195A:  MOVFF  8CE,8EE
0195E:  MOVFF  8CD,8ED
01962:  CLRF   xF4
01964:  CLRF   xF3
01966:  CLRF   xF2
01968:  MOVLW  7F
0196A:  MOVWF  xF1
0196C:  MOVLB  0
0196E:  CALL   0E5A
01972:  MOVFF  00,8DE
01976:  MOVFF  01,8DF
0197A:  MOVFF  02,8E0
0197E:  MOVFF  03,8E1
01982:  BCF    FD8.1
01984:  MOVFF  8D0,8F0
01988:  MOVFF  8CF,8EF
0198C:  MOVFF  8CE,8EE
01990:  MOVFF  8CD,8ED
01994:  MOVLB  8
01996:  CLRF   xF4
01998:  CLRF   xF3
0199A:  CLRF   xF2
0199C:  MOVLW  7F
0199E:  MOVWF  xF1
019A0:  MOVLB  0
019A2:  CALL   0E5A
019A6:  MOVFF  8E1,8E5
019AA:  MOVFF  8E0,8E4
019AE:  MOVFF  8DF,8E3
019B2:  MOVFF  8DE,8E2
019B6:  MOVFF  03,8E9
019BA:  MOVFF  02,8E8
019BE:  MOVFF  01,8E7
019C2:  MOVFF  00,8E6
019C6:  CALL   10D2
019CA:  MOVFF  03,8D0
019CE:  MOVFF  02,8CF
019D2:  MOVFF  01,8CE
019D6:  MOVFF  00,8CD
....................  
....................       y2=y*y; 
019DA:  MOVFF  8D0,8EC
019DE:  MOVFF  8CF,8EB
019E2:  MOVFF  8CE,8EA
019E6:  MOVFF  8CD,8E9
019EA:  MOVFF  8D0,8F0
019EE:  MOVFF  8CF,8EF
019F2:  MOVFF  8CE,8EE
019F6:  MOVFF  8CD,8ED
019FA:  RCALL  1230
019FC:  MOVFF  03,8DC
01A00:  MOVFF  02,8DB
01A04:  MOVFF  01,8DA
01A08:  MOVFF  00,8D9
....................  
....................       res = pl[0]*y2 + pl[1]; 
01A0C:  MOVLW  99
01A0E:  MOVLB  8
01A10:  MOVWF  xEC
01A12:  MOVLW  47
01A14:  MOVWF  xEB
01A16:  MOVLW  8A
01A18:  MOVWF  xEA
01A1A:  MOVLW  7F
01A1C:  MOVWF  xE9
01A1E:  MOVFF  8DC,8F0
01A22:  MOVFF  8DB,8EF
01A26:  MOVFF  8DA,8EE
01A2A:  MOVFF  8D9,8ED
01A2E:  MOVLB  0
01A30:  CALL   1230
01A34:  MOVFF  00,8DE
01A38:  MOVFF  01,8DF
01A3C:  MOVFF  02,8E0
01A40:  MOVFF  03,8E1
01A44:  BCF    FD8.1
01A46:  MOVFF  03,8F0
01A4A:  MOVFF  02,8EF
01A4E:  MOVFF  01,8EE
01A52:  MOVFF  00,8ED
01A56:  MOVLB  8
01A58:  CLRF   xF4
01A5A:  CLRF   xF3
01A5C:  CLRF   xF2
01A5E:  MOVLW  80
01A60:  MOVWF  xF1
01A62:  MOVLB  0
01A64:  CALL   0E5A
01A68:  MOVFF  03,8D4
01A6C:  MOVFF  02,8D3
01A70:  MOVFF  01,8D2
01A74:  MOVFF  00,8D1
....................  
....................       r = ql[0]*y2 + ql[1]; 
01A78:  MOVLW  4C
01A7A:  MOVLB  8
01A7C:  MOVWF  xEC
01A7E:  MOVLW  F3
01A80:  MOVWF  xEB
01A82:  MOVLW  3A
01A84:  MOVWF  xEA
01A86:  MOVLW  7B
01A88:  MOVWF  xE9
01A8A:  MOVFF  8DC,8F0
01A8E:  MOVFF  8DB,8EF
01A92:  MOVFF  8DA,8EE
01A96:  MOVFF  8D9,8ED
01A9A:  MOVLB  0
01A9C:  CALL   1230
01AA0:  MOVFF  00,8DE
01AA4:  MOVFF  01,8DF
01AA8:  MOVFF  02,8E0
01AAC:  MOVFF  03,8E1
01AB0:  BCF    FD8.1
01AB2:  MOVFF  03,8F0
01AB6:  MOVFF  02,8EF
01ABA:  MOVFF  01,8EE
01ABE:  MOVFF  00,8ED
01AC2:  MOVLW  2B
01AC4:  MOVLB  8
01AC6:  MOVWF  xF4
01AC8:  MOVLW  9D
01ACA:  MOVWF  xF3
01ACC:  MOVLW  DF
01ACE:  MOVWF  xF2
01AD0:  MOVLW  7E
01AD2:  MOVWF  xF1
01AD4:  MOVLB  0
01AD6:  CALL   0E5A
01ADA:  MOVFF  03,8D8
01ADE:  MOVFF  02,8D7
01AE2:  MOVFF  01,8D6
01AE6:  MOVFF  00,8D5
....................       r = r*y2 + 1.0; 
01AEA:  MOVFF  8D8,8EC
01AEE:  MOVFF  8D7,8EB
01AF2:  MOVFF  8D6,8EA
01AF6:  MOVFF  8D5,8E9
01AFA:  MOVFF  8DC,8F0
01AFE:  MOVFF  8DB,8EF
01B02:  MOVFF  8DA,8EE
01B06:  MOVFF  8D9,8ED
01B0A:  CALL   1230
01B0E:  MOVFF  00,8DE
01B12:  MOVFF  01,8DF
01B16:  MOVFF  02,8E0
01B1A:  MOVFF  03,8E1
01B1E:  BCF    FD8.1
01B20:  MOVFF  03,8F0
01B24:  MOVFF  02,8EF
01B28:  MOVFF  01,8EE
01B2C:  MOVFF  00,8ED
01B30:  MOVLB  8
01B32:  CLRF   xF4
01B34:  CLRF   xF3
01B36:  CLRF   xF2
01B38:  MOVLW  7F
01B3A:  MOVWF  xF1
01B3C:  MOVLB  0
01B3E:  CALL   0E5A
01B42:  MOVFF  03,8D8
01B46:  MOVFF  02,8D7
01B4A:  MOVFF  01,8D6
01B4E:  MOVFF  00,8D5
....................  
....................       res = y*res/r; 
01B52:  MOVFF  8D0,8EC
01B56:  MOVFF  8CF,8EB
01B5A:  MOVFF  8CE,8EA
01B5E:  MOVFF  8CD,8E9
01B62:  MOVFF  8D4,8F0
01B66:  MOVFF  8D3,8EF
01B6A:  MOVFF  8D2,8EE
01B6E:  MOVFF  8D1,8ED
01B72:  CALL   1230
01B76:  MOVFF  00,8DE
01B7A:  MOVFF  01,8DF
01B7E:  MOVFF  02,8E0
01B82:  MOVFF  03,8E1
01B86:  MOVFF  03,8E5
01B8A:  MOVFF  02,8E4
01B8E:  MOVFF  01,8E3
01B92:  MOVFF  00,8E2
01B96:  MOVFF  8D8,8E9
01B9A:  MOVFF  8D7,8E8
01B9E:  MOVFF  8D6,8E7
01BA2:  MOVFF  8D5,8E6
01BA6:  CALL   10D2
01BAA:  MOVFF  03,8D4
01BAE:  MOVFF  02,8D3
01BB2:  MOVFF  01,8D2
01BB6:  MOVFF  00,8D1
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
01BBA:  MOVLW  08
01BBC:  MOVLB  8
01BBE:  MOVWF  xDF
01BC0:  MOVLW  C9
01BC2:  MOVWF  FE9
01BC4:  MOVFF  8DF,FEA
01BC8:  MOVLW  7E
01BCA:  SUBWF  FEF,W
01BCC:  MOVWF  xDD
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
01BCE:  BTFSC  xDD.7
01BD0:  BRA    1BD4
01BD2:  BRA    1BFC
....................          r = -(float32)-n; 
01BD4:  MOVLW  00
01BD6:  BSF    FD8.0
01BD8:  SUBFWB xDD,W
01BDA:  CLRF   xE0
01BDC:  MOVWF  xDF
01BDE:  BTFSC  xDF.7
01BE0:  DECF   xE0,F
01BE2:  MOVLB  0
01BE4:  RCALL  18BA
01BE6:  MOVFF  00,8D5
01BEA:  MOVF   01,W
01BEC:  XORLW  80
01BEE:  MOVLB  8
01BF0:  MOVWF  xD6
01BF2:  MOVFF  02,8D7
01BF6:  MOVFF  03,8D8
....................       else 
01BFA:  BRA    1C1C
....................          r = (float32)n; 
01BFC:  CLRF   xE0
01BFE:  MOVFF  8DD,8DF
01C02:  BTFSC  xDF.7
01C04:  DECF   xE0,F
01C06:  MOVLB  0
01C08:  RCALL  18BA
01C0A:  MOVFF  03,8D8
01C0E:  MOVFF  02,8D7
01C12:  MOVFF  01,8D6
01C16:  MOVFF  00,8D5
01C1A:  MOVLB  8
....................  
....................       res += r*LN2; 
01C1C:  MOVFF  8D8,8EC
01C20:  MOVFF  8D7,8EB
01C24:  MOVFF  8D6,8EA
01C28:  MOVFF  8D5,8E9
01C2C:  MOVLW  18
01C2E:  MOVWF  xF0
01C30:  MOVLW  72
01C32:  MOVWF  xEF
01C34:  MOVLW  31
01C36:  MOVWF  xEE
01C38:  MOVLW  7E
01C3A:  MOVWF  xED
01C3C:  MOVLB  0
01C3E:  CALL   1230
01C42:  BCF    FD8.1
01C44:  MOVFF  8D4,8F0
01C48:  MOVFF  8D3,8EF
01C4C:  MOVFF  8D2,8EE
01C50:  MOVFF  8D1,8ED
01C54:  MOVFF  03,8F4
01C58:  MOVFF  02,8F3
01C5C:  MOVFF  01,8F2
01C60:  MOVFF  00,8F1
01C64:  CALL   0E5A
01C68:  MOVFF  03,8D4
01C6C:  MOVFF  02,8D3
01C70:  MOVFF  01,8D2
01C74:  MOVFF  00,8D1
....................    } 
....................  
....................    else 
01C78:  BRA    1C86
....................       res = 0.0; 
01C7A:  MOVLB  8
01C7C:  CLRF   xD4
01C7E:  CLRF   xD3
01C80:  CLRF   xD2
01C82:  CLRF   xD1
01C84:  MOVLB  0
....................  
....................    return(res); 
01C86:  MOVFF  8D1,00
01C8A:  MOVFF  8D2,01
01C8E:  MOVFF  8D3,02
01C92:  MOVFF  8D4,03
.................... } 
01C96:  RETURN 0
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
020A2:  MOVFF  8C0,8EC
020A6:  MOVFF  8BF,8EB
020AA:  MOVFF  8BE,8EA
020AE:  MOVFF  8BD,8E9
020B2:  MOVLB  8
020B4:  CLRF   xF0
020B6:  CLRF   xEF
020B8:  CLRF   xEE
020BA:  CLRF   xED
020BC:  MOVLB  0
020BE:  CALL   1326
020C2:  BTFSS  FD8.0
020C4:  BRA    2278
020C6:  MOVFF  8C4,8C8
020CA:  MOVFF  8C3,8C7
020CE:  MOVFF  8C2,8C6
020D2:  MOVFF  8C1,8C5
020D6:  MOVLB  8
020D8:  CLRF   xCC
020DA:  CLRF   xCB
020DC:  CLRF   xCA
020DE:  MOVLW  7F
020E0:  MOVWF  xC9
020E2:  MOVLB  0
020E4:  CALL   175E
020E8:  MOVFF  00,8C5
020EC:  MOVFF  01,8C6
020F0:  MOVFF  02,8C7
020F4:  MOVFF  03,8C8
020F8:  MOVFF  03,8EC
020FC:  MOVFF  02,8EB
02100:  MOVFF  01,8EA
02104:  MOVFF  00,8E9
02108:  MOVLB  8
0210A:  CLRF   xF0
0210C:  CLRF   xEF
0210E:  CLRF   xEE
02110:  CLRF   xED
02112:  MOVLB  0
02114:  CALL   1326
02118:  BTFSS  FD8.2
0211A:  BRA    2278
....................       if(fmod(y, 2) == 0) { 
0211C:  MOVFF  8C4,8C8
02120:  MOVFF  8C3,8C7
02124:  MOVFF  8C2,8C6
02128:  MOVFF  8C1,8C5
0212C:  MOVLB  8
0212E:  CLRF   xCC
02130:  CLRF   xCB
02132:  CLRF   xCA
02134:  MOVLW  80
02136:  MOVWF  xC9
02138:  MOVLB  0
0213A:  CALL   175E
0213E:  MOVFF  00,8C5
02142:  MOVFF  01,8C6
02146:  MOVFF  02,8C7
0214A:  MOVFF  03,8C8
0214E:  MOVFF  03,8EC
02152:  MOVFF  02,8EB
02156:  MOVFF  01,8EA
0215A:  MOVFF  00,8E9
0215E:  MOVLB  8
02160:  CLRF   xF0
02162:  CLRF   xEF
02164:  CLRF   xEE
02166:  CLRF   xED
02168:  MOVLB  0
0216A:  CALL   1326
0216E:  BNZ   21F2
....................          return (exp(log(-x) * y)); 
02170:  MOVFF  8BD,8C5
02174:  MOVLB  8
02176:  MOVF   xBE,W
02178:  XORLW  80
0217A:  MOVWF  xC6
0217C:  MOVFF  8BF,8C7
02180:  MOVFF  8C0,8C8
02184:  MOVFF  8C0,8CC
02188:  MOVFF  8BF,8CB
0218C:  MOVWF  xCA
0218E:  MOVFF  8BD,8C9
02192:  MOVLB  0
02194:  CALL   190A
02198:  MOVFF  00,8C5
0219C:  MOVFF  01,8C6
021A0:  MOVFF  02,8C7
021A4:  MOVFF  03,8C8
021A8:  MOVFF  03,8EC
021AC:  MOVFF  02,8EB
021B0:  MOVFF  01,8EA
021B4:  MOVFF  00,8E9
021B8:  MOVFF  8C4,8F0
021BC:  MOVFF  8C3,8EF
021C0:  MOVFF  8C2,8EE
021C4:  MOVFF  8C1,8ED
021C8:  CALL   1230
021CC:  MOVFF  00,8C5
021D0:  MOVFF  01,8C6
021D4:  MOVFF  02,8C7
021D8:  MOVFF  03,8C8
021DC:  MOVFF  03,8CC
021E0:  MOVFF  02,8CB
021E4:  MOVFF  01,8CA
021E8:  MOVFF  00,8C9
021EC:  RCALL  1C98
021EE:  BRA    23AC
....................       } else { 
021F0:  BRA    2276
....................          return (-exp(log(-x) * y)); 
021F2:  MOVFF  8BD,8C5
021F6:  MOVLB  8
021F8:  MOVF   xBE,W
021FA:  XORLW  80
021FC:  MOVWF  xC6
021FE:  MOVFF  8BF,8C7
02202:  MOVFF  8C0,8C8
02206:  MOVFF  8C0,8CC
0220A:  MOVFF  8BF,8CB
0220E:  MOVWF  xCA
02210:  MOVFF  8BD,8C9
02214:  MOVLB  0
02216:  CALL   190A
0221A:  MOVFF  00,8C5
0221E:  MOVFF  01,8C6
02222:  MOVFF  02,8C7
02226:  MOVFF  03,8C8
0222A:  MOVFF  03,8EC
0222E:  MOVFF  02,8EB
02232:  MOVFF  01,8EA
02236:  MOVFF  00,8E9
0223A:  MOVFF  8C4,8F0
0223E:  MOVFF  8C3,8EF
02242:  MOVFF  8C2,8EE
02246:  MOVFF  8C1,8ED
0224A:  CALL   1230
0224E:  MOVFF  00,8C5
02252:  MOVFF  01,8C6
02256:  MOVFF  02,8C7
0225A:  MOVFF  03,8C8
0225E:  MOVFF  03,8CC
02262:  MOVFF  02,8CB
02266:  MOVFF  01,8CA
0226A:  MOVFF  00,8C9
0226E:  RCALL  1C98
02270:  MOVLW  80
02272:  XORWF  01,F
02274:  BRA    23AC
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
02276:  BRA    23AC
02278:  MOVFF  8C0,8EC
0227C:  MOVFF  8BF,8EB
02280:  MOVFF  8BE,8EA
02284:  MOVFF  8BD,8E9
02288:  MOVLB  8
0228A:  CLRF   xF0
0228C:  CLRF   xEF
0228E:  CLRF   xEE
02290:  CLRF   xED
02292:  MOVLB  0
02294:  CALL   1326
02298:  BNC   22FA
0229A:  MOVFF  8C4,8C8
0229E:  MOVFF  8C3,8C7
022A2:  MOVFF  8C2,8C6
022A6:  MOVFF  8C1,8C5
022AA:  MOVLB  8
022AC:  CLRF   xCC
022AE:  CLRF   xCB
022B0:  CLRF   xCA
022B2:  MOVLW  7F
022B4:  MOVWF  xC9
022B6:  MOVLB  0
022B8:  CALL   175E
022BC:  MOVFF  00,8C5
022C0:  MOVFF  01,8C6
022C4:  MOVFF  02,8C7
022C8:  MOVFF  03,8C8
022CC:  MOVFF  03,8EC
022D0:  MOVFF  02,8EB
022D4:  MOVFF  01,8EA
022D8:  MOVFF  00,8E9
022DC:  MOVLB  8
022DE:  CLRF   xF0
022E0:  CLRF   xEF
022E2:  CLRF   xEE
022E4:  CLRF   xED
022E6:  MOVLB  0
022E8:  CALL   1326
022EC:  BZ    22FA
....................       return 0; 
022EE:  CLRF   00
022F0:  CLRF   01
022F2:  CLRF   02
022F4:  CLRF   03
022F6:  BRA    23AC
....................    } else { 
022F8:  BRA    23AC
....................       if(x != 0 || 0 >= y) { 
022FA:  MOVFF  8C0,8EC
022FE:  MOVFF  8BF,8EB
02302:  MOVFF  8BE,8EA
02306:  MOVFF  8BD,8E9
0230A:  MOVLB  8
0230C:  CLRF   xF0
0230E:  CLRF   xEF
02310:  CLRF   xEE
02312:  CLRF   xED
02314:  MOVLB  0
02316:  CALL   1326
0231A:  BNZ   2340
0231C:  MOVFF  8C4,8EC
02320:  MOVFF  8C3,8EB
02324:  MOVFF  8C2,8EA
02328:  MOVFF  8C1,8E9
0232C:  MOVLB  8
0232E:  CLRF   xF0
02330:  CLRF   xEF
02332:  CLRF   xEE
02334:  CLRF   xED
02336:  MOVLB  0
02338:  CALL   1326
0233C:  BC    2340
0233E:  BNZ   23AC
....................          return (exp(log(x) * y)); 
02340:  MOVFF  8C0,8CC
02344:  MOVFF  8BF,8CB
02348:  MOVFF  8BE,8CA
0234C:  MOVFF  8BD,8C9
02350:  CALL   190A
02354:  MOVFF  00,8C5
02358:  MOVFF  01,8C6
0235C:  MOVFF  02,8C7
02360:  MOVFF  03,8C8
02364:  MOVFF  03,8EC
02368:  MOVFF  02,8EB
0236C:  MOVFF  01,8EA
02370:  MOVFF  00,8E9
02374:  MOVFF  8C4,8F0
02378:  MOVFF  8C3,8EF
0237C:  MOVFF  8C2,8EE
02380:  MOVFF  8C1,8ED
02384:  CALL   1230
02388:  MOVFF  00,8C5
0238C:  MOVFF  01,8C6
02390:  MOVFF  02,8C7
02394:  MOVFF  03,8C8
02398:  MOVFF  03,8CC
0239C:  MOVFF  02,8CB
023A0:  MOVFF  01,8CA
023A4:  MOVFF  00,8C9
023A8:  RCALL  1C98
023AA:  BRA    23AC
....................       } 
....................    } 
.................... } 
023AC:  RETURN 0
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <FLX_PINS.h> 
.................... // File DSP4x4_PINS.h 
....................  
.................... #define PIN_EEPROM_SDA  	PIN_C3  
.................... #define PIN_EEPROM_SCL  	PIN_C2  
....................  
.................... #define PIN_DSP_nRESET 		PIN_A4 
.................... #define PIN_DSP_SDA 		PIN_B0 
.................... #define PIN_DSP_SCL 		PIN_B1 
.................... #define PIN_DSP_IRQ			PIN_B2 
....................  
.................... #define PIN_AMP_nRESET 		PIN_A5 
.................... #define PIN_AMP_nMUTE		PIN_C1 
.................... #define PIN_AMP_READY		PIN_E2 
....................  
.................... #define PIN_AMP_M1			PIN_A1 
.................... #define PIN_AMP_M2			PIN_A2 
.................... #define PIN_AMP_M3			PIN_A3 
....................  
.................... #define PIN_USB_TX			PIN_C5 
.................... #define PIN_USB_RX			PIN_C4		 
....................  
.................... #define PIN_RS232_TX		PIN_D6 
.................... #define PIN_RS232_RX		PIN_D7 
....................  
.................... #define PIN_PHANTOM_ENABLE 	PIN_D5 
.................... #define PIN_PHANTOM_CH1 	PIN_B4 
.................... #define PIN_PHANTOM_CH2 	PIN_B5 
....................  
.................... #define AUD_MUTE			PIN_D3 
....................  
.................... // to be removed 
.................... #define PIN_CLIP1			PIN_A5 
.................... #define PIN_CLIP2			PIN_E0 
.................... #define PIN_CLIP3			PIN_E2 
.................... #define PIN_CLIP4			PIN_E1 
....................  
.................... #define PIN_PSON			PIN_B4 
....................  
.................... #define PIN_AUDIODETECT		PIN_B0 
....................  
....................  
....................  
....................  
....................  
.................... #include <FLX_CONFIG.h> 
.................... // File DSP4x4_CONFIG.h 
....................  
.................... #define POWERUP_DELAY	200 
....................  
.................... #define IEEPROM_PRESET_LOC	0x10 
.................... #define IEEPROM_DEVICE_CONFIG_LOC 0x64 
.................... #define IEEPROM_FLAG_LOC 0x20 
....................  
.................... #define FLASH_PHANTOM_LOC 0x200 
.................... #define NUM_PRESETS			10 
.................... #define DEFAULT_PRESET		0 
....................  
.................... long int num_dsp_values = 478; // Not a define since the software will automatically change this if necessary 
....................  
.................... #define NUM_PRESET_PAGES			12 
.................... #define NUM_DSP_VALUE_PAGES			8		 
.................... #define NUM_PLAIN_VALUE_PAGES		4 
.................... #define PLAIN_VALUE_PAGES_OFFSET	8	 
.................... #define NUM_ADDRESS_PAGES			4 
.................... #define IOLABEL_PAGE				11 
....................  
.................... #define DEFAULT_ADDR_BLOCK			14 
.................... #define DEFAULT_VALUE_BLOCK			15 
....................  
.................... long int AUDIODETECT_HOLDTIME_SECONDS = 2; 
....................  
....................  
.................... #define DELAY_POWERUP			100 
.................... #define DELAY_AMP_MODE_SETTLE	1000 
.................... #define DELAY_DSP_RESET_SETTLE	50 
....................  
.................... unsigned int RVC_NOISE_FLOOR = 0; // Higher the number the fewer the subdivisions 
....................  
.................... /* store in EEPROM */ 
....................  
.................... const int DEBUG = 0; 
....................  
.................... double DEFAULT_ADC_CALIBRATION_MIN	= 30.0; 
.................... double DEFAULT_ADC_CALIBRATION_MAX	= 240.0; 
....................  
.................... int DEFAULT_AMP_MODE = 0; // 0 = 4CH, 1 = 2CH, 2 = 1CH 
.................... int DEFAULT_IS_70V = 0; 
....................  
.................... int DEFAULT_RVC_ENABLE = 1; 
.................... int DEFAULT_USBDETECT_ENABLE = 1; 
.................... int DEFAULT_AMPBOOT_DELAY_ENABLE = 1; 
.................... int DEFAULT_PS_PIN_ENABLE = 0; 
.................... int DEFAULT_DSP_VALUESEND_ENABLE = 1; 
.................... int DEFAULT_SLEEP_ENABLE = 0; 
.................... int16 DEFAULT_SLEEP_SECONDS = 65; 
.................... int16 DEFAULT_SLEEP_HOLDTIME = 60; 
....................  
.................... #define DEVICE_ID_MSB	0 
.................... #define DEVICE_ID_LSB	0x0A 
....................  
.................... typedef struct { 
.................... 	 
.................... 	int AMP_MODE; 
.................... 	int IS_70V; 
.................... 	 
.................... 	double ADC_CALIBRATION_MIN; 
.................... 	double ADC_CALIBRATION_MAX; 
....................  
.................... 	 
.................... 	int RVC_ENABLE; 
.................... 	int USBDETECT_ENABLE; 
.................... 	int AMPBOOT_DELAY_ENABLE; 
.................... 	int PS_PIN_ENABLE; 
.................... 	int DSP_VALUESEND_ENABLE; 
.................... 	int SLEEP_ENABLE; 
.................... 	int16 SLEEP_SECONDS; 
.................... 	int16 SLEEP_HOLDTIME; 
.................... 	char SERIAL[20]; 
.................... } device_configuration; 
....................  
.................... device_configuration DEVICE_CONFIG; 
....................  
.................... 	 
....................  
....................  
.................... #include <main.h> 
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // VERSION INFO 
.................... int MAJOR_REVISION = 1; 
.................... int MINOR_REVISION = 3; 
.................... char REVISION_TEXT[20] = "d-FLX80-4"; 
....................  
.................... // USEFUL DEFINES 
.................... #define hi(x) (*((int8*)&x+1))  
.................... #define ON     0x00000001 
.................... #define OFF    0x00000000 
....................  
.................... // Used for eeprom.c 
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... // EEPROM DEFINES 
.................... #use I2C(MASTER, SDA=PIN_C3, SCL=PIN_C2) 
*
00CF0:  MOVLW  08
00CF2:  MOVWF  01
00CF4:  MOVLW  03
00CF6:  MOVWF  00
00CF8:  DECFSZ 00,F
00CFA:  BRA    0CF8
00CFC:  BCF    F8B.2
00CFE:  BCF    F94.2
00D00:  MOVLW  03
00D02:  MOVWF  00
00D04:  DECFSZ 00,F
00D06:  BRA    0D04
00D08:  MOVLB  8
00D0A:  RLCF   xCC,F
00D0C:  BCF    F8B.3
00D0E:  BTFSC  FD8.0
00D10:  BSF    F94.3
00D12:  BTFSS  FD8.0
00D14:  BCF    F94.3
00D16:  BSF    F94.2
00D18:  BTFSS  F82.2
00D1A:  BRA    0D18
00D1C:  DECFSZ 01,F
00D1E:  BRA    0D22
00D20:  BRA    0D26
00D22:  MOVLB  0
00D24:  BRA    0CF4
00D26:  MOVLW  03
00D28:  MOVWF  00
00D2A:  DECFSZ 00,F
00D2C:  BRA    0D2A
00D2E:  BCF    F8B.2
00D30:  BCF    F94.2
00D32:  NOP   
00D34:  BSF    F94.3
00D36:  MOVLW  03
00D38:  MOVWF  00
00D3A:  DECFSZ 00,F
00D3C:  BRA    0D3A
00D3E:  MOVLW  03
00D40:  MOVWF  00
00D42:  DECFSZ 00,F
00D44:  BRA    0D42
00D46:  BSF    F94.2
00D48:  BTFSS  F82.2
00D4A:  BRA    0D48
00D4C:  CLRF   01
00D4E:  MOVLW  03
00D50:  MOVWF  00
00D52:  DECFSZ 00,F
00D54:  BRA    0D52
00D56:  BTFSC  F82.3
00D58:  BSF    01.0
00D5A:  BCF    F8B.2
00D5C:  BCF    F94.2
00D5E:  BCF    F8B.3
00D60:  BCF    F94.3
00D62:  MOVLB  0
00D64:  RETURN 0
*
06EAC:  MOVLW  08
06EAE:  MOVLB  8
06EB0:  MOVWF  x72
06EB2:  MOVFF  00,873
06EB6:  BSF    F94.3
06EB8:  MOVLW  03
06EBA:  MOVWF  00
06EBC:  DECFSZ 00,F
06EBE:  BRA    6EBC
06EC0:  BSF    F94.2
06EC2:  BTFSS  F82.2
06EC4:  BRA    6EC2
06EC6:  BTFSC  F82.3
06EC8:  BSF    FD8.0
06ECA:  BTFSS  F82.3
06ECC:  BCF    FD8.0
06ECE:  RLCF   01,F
06ED0:  MOVLW  03
06ED2:  MOVWF  00
06ED4:  DECFSZ 00,F
06ED6:  BRA    6ED4
06ED8:  BCF    F94.2
06EDA:  BCF    F8B.2
06EDC:  DECFSZ x72,F
06EDE:  BRA    6EB6
06EE0:  BSF    F94.3
06EE2:  MOVLW  03
06EE4:  MOVWF  00
06EE6:  DECFSZ 00,F
06EE8:  BRA    6EE6
06EEA:  BCF    F8B.3
06EEC:  MOVF   x73,W
06EEE:  BTFSS  FD8.2
06EF0:  BCF    F94.3
06EF2:  NOP   
06EF4:  BSF    F94.2
06EF6:  BTFSS  F82.2
06EF8:  BRA    6EF6
06EFA:  MOVLW  03
06EFC:  MOVWF  00
06EFE:  DECFSZ 00,F
06F00:  BRA    6EFE
06F02:  BCF    F8B.2
06F04:  BCF    F94.2
06F06:  MOVLW  03
06F08:  MOVWF  00
06F0A:  DECFSZ 00,F
06F0C:  BRA    6F0A
06F0E:  BCF    F8B.3
06F10:  BCF    F94.3
06F12:  MOVLB  0
06F14:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int  
.................... #define EEPROM_SIZE   (128*8*8)  
....................  
.................... // RS232 DEFINES 
....................  
.................... #use rs232(baud=19200,parity=N,xmit=PIN_USB_TX,rcv=PIN_USB_RX,bits=8,errors,stream=USB,FORCE_SW) 
*
06D20:  BSF    F94.4
06D22:  BTFSC  F82.4
06D24:  BRA    6D22
06D26:  MOVLW  08
06D28:  MOVWF  00
06D2A:  MOVLB  8
06D2C:  CLRF   x73
06D2E:  BSF    00.7
06D30:  BRA    6D4E
06D32:  BCF    00.7
06D34:  BRA    6D4E
06D36:  BCF    FD8.0
06D38:  BTFSC  F82.4
06D3A:  BSF    FD8.0
06D3C:  RRCF   x73,F
06D3E:  BSF    00.6
06D40:  BRA    6D4E
06D42:  BCF    00.6
06D44:  DECFSZ 00,F
06D46:  BRA    6D36
06D48:  MOVFF  873,01
06D4C:  BRA    6D66
06D4E:  MOVLW  39
06D50:  BTFSC  00.7
06D52:  MOVLW  0F
06D54:  MOVWF  01
06D56:  DECFSZ 01,F
06D58:  BRA    6D56
06D5A:  BRA    6D5C
06D5C:  BTFSC  00.7
06D5E:  BRA    6D32
06D60:  BTFSC  00.6
06D62:  BRA    6D42
06D64:  BRA    6D36
06D66:  MOVLB  0
06D68:  RETURN 0
*
06DBC:  BCF    F94.5
06DBE:  BCF    F8B.5
06DC0:  MOVLW  08
06DC2:  MOVWF  01
06DC4:  BRA    6DC6
06DC6:  NOP   
06DC8:  BSF    01.7
06DCA:  BRA    6DEC
06DCC:  BCF    01.7
06DCE:  MOVLB  8
06DD0:  RRCF   x72,F
06DD2:  MOVLB  0
06DD4:  BTFSC  FD8.0
06DD6:  BSF    F8B.5
06DD8:  BTFSS  FD8.0
06DDA:  BCF    F8B.5
06DDC:  BSF    01.6
06DDE:  BRA    6DEC
06DE0:  BCF    01.6
06DE2:  DECFSZ 01,F
06DE4:  BRA    6DCE
06DE6:  BRA    6DE8
06DE8:  NOP   
06DEA:  BSF    F8B.5
06DEC:  MOVLW  39
06DEE:  MOVWF  FE9
06DF0:  DECFSZ FE9,F
06DF2:  BRA    6DF0
06DF4:  BRA    6DF6
06DF6:  NOP   
06DF8:  BTFSC  01.7
06DFA:  BRA    6DCC
06DFC:  BTFSC  01.6
06DFE:  BRA    6DE0
06E00:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_RS232_TX,rcv=PIN_RS232_RX,bits=8,errors, stream=RS232) 
*
00B96:  BTFSS  FA4.5
00B98:  BRA    0B96
00B9A:  MOVFF  F71,77
00B9E:  MOVFF  F74,01
00BA2:  BTFSS  x77.1
00BA4:  BRA    0BAA
00BA6:  BCF    F71.4
00BA8:  BSF    F71.4
00BAA:  GOTO   0BC6 (RETURN)
*
07366:  BTFSS  FA4.4
07368:  BRA    7366
0736A:  MOVWF  F73
0736C:  RETURN 0
....................  
.................... #define FLASH_CS	PIN_D2 
....................  
.................... #use SPI(DO = PIN_D4, DI = PIN_D1, CLK = PIN_D0,BITS = 8,MSB_FIRST, SAMPLE_RISE)  
*
056F2:  MOVLB  8
056F4:  MOVF   x8E,W
056F6:  SUBLW  08
056F8:  BZ    5702
056FA:  MOVWF  x8F
056FC:  RLCF   x8D,F
056FE:  DECFSZ x8F,F
05700:  BRA    56FC
05702:  BSF    F95.1
05704:  BCF    F95.4
05706:  BCF    F95.0
05708:  BCF    F8C.0
0570A:  MOVFF  88E,88F
0570E:  BTFSS  x8D.7
05710:  BCF    F8C.4
05712:  BTFSC  x8D.7
05714:  BSF    F8C.4
05716:  RLCF   x8D,F
05718:  BSF    F8C.0
0571A:  RLCF   01,F
0571C:  BTFSS  F83.1
0571E:  BCF    01.0
05720:  BTFSC  F83.1
05722:  BSF    01.0
05724:  BCF    F8C.0
05726:  DECFSZ x8F,F
05728:  BRA    570E
0572A:  MOVLB  0
0572C:  RETURN 0
....................  
.................... int IS_USB_CONNECTED; 
....................  
.................... #define RS232_BUFFER_SIZE 32 
.................... #define rs232_data_available (next_in!=next_out)  
....................  
.................... int buffer_unread = 0; 
.................... BYTE RS232_BYTE1, RS232_BYTE2, RS232_BYTE3, RS232_BYTE4, RS232_BYTE5; 
.................... BYTE buffer[RS232_BUFFER_SIZE]; 
.................... BYTE next_in = 0; 
.................... BYTE next_out = 0; 
....................  
.................... double rs232_premix_vol[4]; 
.................... int rs232_premix_mute[4]; 
....................  
.................... double rs232_output_vol[4]; 
.................... int rs232_output_mute[4]; 
....................  
.................... int rs232_log_output_vol_index[4]; 
....................  
.................... // DSP DEFINES 
.................... #define DSP_I2C_ADDRESS 0x80 
....................  
.................... // MEMORY DEFINES 
.................... int CURRENT_FLASH_PROGRAM = 0; 
....................  
.................... #define PAGE_SIZE  64  
.................... #define NUM_PAGES 9 
.................... #define TOTAL_ARRAY_SIZE (PAGE_SIZE*NUM_PAGES) 
....................  
.................... int32 PAGE_BUFFER_A[PAGE_SIZE]; 
....................  
....................  
.................... /* VARIABLES FOR RVC */ 
.................... unsigned int last_adc = 0; 
.................... unsigned int current_adc = 0; 
....................  
.................... int is_muted = 0; 
.................... int pin_in_mute_state = 0; 
....................  
....................  
.................... /* VARIABLES FOR SLEEP TIMER */ 
.................... int16 sleepseconds; 
.................... int16 sleeptimeout_seconds = 10; 
....................  
.................... int is_in_sleep = 0; 
.................... int sleep_timer_active = 0; 
....................  
.................... double log_values[61] = { 
.................... 	0.0000,0.0011,0.0013,0.0014,0.0016,0.0018, 
.................... 	0.0020,0.0022,0.0025,0.0028,0.0032,0.0035, 
.................... 	0.0040,0.0045,0.0050,0.0056,0.0063,0.0071, 
.................... 	0.0079,0.0089,0.0100,0.0112,0.0126,0.0141, 
.................... 	0.0158,0.0178,0.0200,0.0224,0.0251,0.0282, 
.................... 	0.0316,0.0355,0.0398,0.0447,0.0501,0.0562, 
.................... 	0.0631,0.0708,0.0794,0.0891,0.1000,0.1122, 
.................... 	0.1259,0.1413,0.1585,0.1778,0.1995,0.2239, 
.................... 	0.2512,0.2818,0.3162,0.3548,0.3981,0.4467, 
.................... 	0.5012,0.5623,0.6310,0.7079,0.7943,0.8913, 
.................... 	1.0000}; 
....................  
.................... typedef struct { 
.................... 	int16 ADDRESSES_1[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_2[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_3[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_4[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_5[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_6[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_7[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_8[PAGE_SIZE]; 
.................... } dsp_addresses; 
....................  
.................... dsp_addresses DSP_ADDR; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP_mapping.h> 
.................... // This map is for FLX4CHANNEL_WITHNET_REVI 
.................... // Map generated 1-30-14 by Patrick Paul 
....................  
.................... #define DSP_ADDRESS_WRITE_PREFIX 0xF000 
.................... #define DSP_ADDRESS_READ_PREFIX 0xF0C0 
....................  
.................... /** 'AUDIO MANAGER' **/ 
.................... #define AM_MASTERGAIN		0x83000000	 
.................... #define AM_ANALOG1_TRIM		0x8300000a 
.................... #define AM_ANALOG2_TRIM		0x8300000b 
.................... #define AM_ANALOG3_TRIM		0x8300000c 
.................... #define AM_ANALOG4_TRIM		0x8300000d 
....................  
.................... #define PREGAIN_CH1 0x0373 
.................... #define PREGAIN_MUTE_CH1 0x0443 
.................... #define PREGAIN_CH2 0x03cf 
.................... #define PREGAIN_MUTE_CH2 0x0441 
.................... #define PREGAIN_CH3 0x03cb 
.................... #define PREGAIN_MUTE_CH3 0x043f 
.................... #define PREGAIN_CH4 0x03c7 
.................... #define PREGAIN_MUTE_CH4 0x043d 
.................... #define PREGAIN_CH5 0x03c3 
.................... #define PREGAIN_MUTE_CH5 0x043b 
.................... #define PREGAIN_CH6 0x03bf 
.................... #define PREGAIN_MUTE_CH6 0x0439 
.................... #define PREGAIN_CH7 0x03bb 
.................... #define PREGAIN_MUTE_CH7 0x0437 
.................... #define PREGAIN_CH8 0x03b7 
.................... #define PREGAIN_MUTE_CH8 0x0435 
.................... #define PREMIX_CH1 0x03b3 
.................... #define PREMIX_MUTE_CH1 0x0433 
.................... #define PREMIX_CH2 0x03af 
.................... #define PREMIX_MUTE_CH2 0x0431 
.................... #define PREMIX_CH3 0x03ab 
.................... #define PREMIX_MUTE_CH3 0x042f 
.................... #define PREMIX_CH4 0x03a7 
.................... #define PREMIX_MUTE_CH4 0x042d 
.................... #define PREMIX_CH5 0x03a3 
.................... #define PREMIX_MUTE_CH5 0x042b 
.................... #define PREMIX_CH6 0x039f 
.................... #define PREMIX_MUTE_CH6 0x0429 
.................... #define PREMIX_CH7 0x039b 
.................... #define PREMIX_MUTE_CH7 0x0427 
.................... #define PREMIX_CH8 0x0397 
.................... #define PREMIX_MUTE_CH8 0x0425 
.................... #define TRIM_CH1 0x0393 
.................... #define TRIM_MUTE_CH1 0x0423 
.................... #define TRIM_CH2 0x038f 
.................... #define TRIM_MUTE_CH2 0x0421 
.................... #define TRIM_CH3 0x038b 
.................... #define TRIM_MUTE_CH3 0x041f 
.................... #define TRIM_CH4 0x0387 
.................... #define TRIM_MUTE_CH4 0x041d 
.................... #define OUTPUTGAIN_CH1 0x0383 
.................... #define OUTPUT_MUTE_CH1 0x041b 
.................... #define OUTPUTGAIN_CH2 0x037f 
.................... #define OUTPUT_MUTE_CH2 0x0419 
.................... #define OUTPUTGAIN_CH3 0x037b 
.................... #define OUTPUT_MUTE_CH3 0x0417 
.................... #define OUTPUTGAIN_CH4 0x0377 
.................... #define OUTPUT_MUTE_CH4 0x0415 
.................... #define INDUCKROUTER_SELECT0 0x020e 
.................... #define INDUCKROUTER_SELECT1 0x020f 
.................... #define INDUCKROUTER_SELECT2 0x0210 
.................... #define INDUCKROUTER_SELECT3 0x0211 
.................... #define INDUCKROUTER_SELECT4 0x0212 
.................... #define INDUCKROUTER_SELECT5 0x0213 
.................... #define INDUCKROUTER_SELECT6 0x0214 
.................... #define INDUCKROUTER_SELECT7 0x0215 
.................... #define OUTDUCKROUTER_SELECT0 0x0205 
.................... #define OUTDUCKROUTER_SELECT1 0x0206 
.................... #define OUTDUCKROUTER_SELECT2 0x0207 
.................... #define OUTDUCKROUTER_SELECT3 0x0208 
.................... #define OUTDUCKROUTER_SELECT4 0x0209 
.................... #define OUTDUCKROUTER_SELECT5 0x020a 
.................... #define OUTDUCKROUTER_SELECT6 0x020b 
.................... #define OUTDUCKROUTER_SELECT7 0x020c 
.................... #define DUCKER_THRESHOLD 0x0276 
.................... #define DUCKER_HOLD 0x0277 
.................... #define DUCKER_DEPTH 0x0278 
.................... #define DUCKER_ATTACK 0x0279 
.................... #define DUCKER_RELEASE 0x027a 
.................... #define DUCKER_BYPASS 0x027b 
.................... #define IN_1_1_FILTER_B0 0x036d 
.................... #define IN_1_1_FILTER_B1 0x036e 
.................... #define IN_1_1_FILTER_B2 0x036f 
.................... #define IN_1_1_FILTER_MINUSA1 0x0370 
.................... #define IN_1_1_FILTER_MINUSA2 0x0371 
.................... #define IN_1_2_FILTER_B0 0x0368 
.................... #define IN_1_2_FILTER_B1 0x0369 
.................... #define IN_1_2_FILTER_B2 0x036a 
.................... #define IN_1_2_FILTER_MINUSA1 0x036b 
.................... #define IN_1_2_FILTER_MINUSA2 0x036c 
.................... #define IN_1_3_FILTER_B0 0x0363 
.................... #define IN_1_3_FILTER_B1 0x0364 
.................... #define IN_1_3_FILTER_B2 0x0365 
.................... #define IN_1_3_FILTER_MINUSA1 0x0366 
.................... #define IN_1_3_FILTER_MINUSA2 0x0367 
.................... #define IN_2_1_FILTER_B0 0x035e 
.................... #define IN_2_1_FILTER_B1 0x035f 
.................... #define IN_2_1_FILTER_B2 0x0360 
.................... #define IN_2_1_FILTER_MINUSA1 0x0361 
.................... #define IN_2_1_FILTER_MINUSA2 0x0362 
.................... #define IN_2_2_FILTER_B0 0x0359 
.................... #define IN_2_2_FILTER_B1 0x035a 
.................... #define IN_2_2_FILTER_B2 0x035b 
.................... #define IN_2_2_FILTER_MINUSA1 0x035c 
.................... #define IN_2_2_FILTER_MINUSA2 0x035d 
.................... #define IN_2_3_FILTER_B0 0x0354 
.................... #define IN_2_3_FILTER_B1 0x0355 
.................... #define IN_2_3_FILTER_B2 0x0356 
.................... #define IN_2_3_FILTER_MINUSA1 0x0357 
.................... #define IN_2_3_FILTER_MINUSA2 0x0358 
.................... #define IN_3_1_FILTER_B0 0x034f 
.................... #define IN_3_1_FILTER_B1 0x0350 
.................... #define IN_3_1_FILTER_B2 0x0351 
.................... #define IN_3_1_FILTER_MINUSA1 0x0352 
.................... #define IN_3_1_FILTER_MINUSA2 0x0353 
.................... #define IN_3_2_FILTER_B0 0x034a 
.................... #define IN_3_2_FILTER_B1 0x034b 
.................... #define IN_3_2_FILTER_B2 0x034c 
.................... #define IN_3_2_FILTER_MINUSA1 0x034d 
.................... #define IN_3_2_FILTER_MINUSA2 0x034e 
.................... #define IN_3_3_FILTER_B0 0x0345 
.................... #define IN_3_3_FILTER_B1 0x0346 
.................... #define IN_3_3_FILTER_B2 0x0347 
.................... #define IN_3_3_FILTER_MINUSA1 0x0348 
.................... #define IN_3_3_FILTER_MINUSA2 0x0349 
.................... #define IN_4_1_FILTER_B0 0x0340 
.................... #define IN_4_1_FILTER_B1 0x0341 
.................... #define IN_4_1_FILTER_B2 0x0342 
.................... #define IN_4_1_FILTER_MINUSA1 0x0343 
.................... #define IN_4_1_FILTER_MINUSA2 0x0344 
.................... #define IN_4_2_FILTER_B0 0x033b 
.................... #define IN_4_2_FILTER_B1 0x033c 
.................... #define IN_4_2_FILTER_B2 0x033d 
.................... #define IN_4_2_FILTER_MINUSA1 0x033e 
.................... #define IN_4_2_FILTER_MINUSA2 0x033f 
.................... #define IN_4_3_FILTER_B0 0x0336 
.................... #define IN_4_3_FILTER_B1 0x0337 
.................... #define IN_4_3_FILTER_B2 0x0338 
.................... #define IN_4_3_FILTER_MINUSA1 0x0339 
.................... #define IN_4_3_FILTER_MINUSA2 0x033a 
.................... #define IN_5_1_FILTER_B0 0x0331 
.................... #define IN_5_1_FILTER_B1 0x0332 
.................... #define IN_5_1_FILTER_B2 0x0333 
.................... #define IN_5_1_FILTER_MINUSA1 0x0334 
.................... #define IN_5_1_FILTER_MINUSA2 0x0335 
.................... #define IN_5_2_FILTER_B0 0x032c 
.................... #define IN_5_2_FILTER_B1 0x032d 
.................... #define IN_5_2_FILTER_B2 0x032e 
.................... #define IN_5_2_FILTER_MINUSA1 0x032f 
.................... #define IN_5_2_FILTER_MINUSA2 0x0330 
.................... #define IN_5_3_FILTER_B0 0x0327 
.................... #define IN_5_3_FILTER_B1 0x0328 
.................... #define IN_5_3_FILTER_B2 0x0329 
.................... #define IN_5_3_FILTER_MINUSA1 0x032a 
.................... #define IN_5_3_FILTER_MINUSA2 0x032b 
.................... #define IN_6_1_FILTER_B0 0x0322 
.................... #define IN_6_1_FILTER_B1 0x0323 
.................... #define IN_6_1_FILTER_B2 0x0324 
.................... #define IN_6_1_FILTER_MINUSA1 0x0325 
.................... #define IN_6_1_FILTER_MINUSA2 0x0326 
.................... #define IN_6_2_FILTER_B0 0x031d 
.................... #define IN_6_2_FILTER_B1 0x031e 
.................... #define IN_6_2_FILTER_B2 0x031f 
.................... #define IN_6_2_FILTER_MINUSA1 0x0320 
.................... #define IN_6_2_FILTER_MINUSA2 0x0321 
.................... #define IN_6_3_FILTER_B0 0x0318 
.................... #define IN_6_3_FILTER_B1 0x0319 
.................... #define IN_6_3_FILTER_B2 0x031a 
.................... #define IN_6_3_FILTER_MINUSA1 0x031b 
.................... #define IN_6_3_FILTER_MINUSA2 0x031c 
.................... #define IN_7_1_FILTER_B0 0x0313 
.................... #define IN_7_1_FILTER_B1 0x0314 
.................... #define IN_7_1_FILTER_B2 0x0315 
.................... #define IN_7_1_FILTER_MINUSA1 0x0316 
.................... #define IN_7_1_FILTER_MINUSA2 0x0317 
.................... #define IN_7_2_FILTER_B0 0x030e 
.................... #define IN_7_2_FILTER_B1 0x030f 
.................... #define IN_7_2_FILTER_B2 0x0310 
.................... #define IN_7_2_FILTER_MINUSA1 0x0311 
.................... #define IN_7_2_FILTER_MINUSA2 0x0312 
.................... #define IN_7_3_FILTER_B0 0x0309 
.................... #define IN_7_3_FILTER_B1 0x030a 
.................... #define IN_7_3_FILTER_B2 0x030b 
.................... #define IN_7_3_FILTER_MINUSA1 0x030c 
.................... #define IN_7_3_FILTER_MINUSA2 0x030d 
.................... #define IN_8_1_FILTER_B0 0x0304 
.................... #define IN_8_1_FILTER_B1 0x0305 
.................... #define IN_8_1_FILTER_B2 0x0306 
.................... #define IN_8_1_FILTER_MINUSA1 0x0307 
.................... #define IN_8_1_FILTER_MINUSA2 0x0308 
.................... #define IN_8_2_FILTER_B0 0x02ff 
.................... #define IN_8_2_FILTER_B1 0x0300 
.................... #define IN_8_2_FILTER_B2 0x0301 
.................... #define IN_8_2_FILTER_MINUSA1 0x0302 
.................... #define IN_8_2_FILTER_MINUSA2 0x0303 
.................... #define IN_8_3_FILTER_B0 0x02fa 
.................... #define IN_8_3_FILTER_B1 0x02fb 
.................... #define IN_8_3_FILTER_B2 0x02fc 
.................... #define IN_8_3_FILTER_MINUSA1 0x02fd 
.................... #define IN_8_3_FILTER_MINUSA2 0x02fe 
.................... #define CH1COMP_THRESHOLD 0x026e 
.................... #define CH1COMP_KNEE 0x026f 
.................... #define CH1COMP_RATIO 0x0270 
.................... #define CH1COMP_ATTACK 0x0271 
.................... #define CH1COMP_RELEASE 0x0272 
.................... #define CH1COMP_BYPASS 0x0273 
.................... #define CH2COMP_THRESHOLD 0x0266 
.................... #define CH2COMP_KNEE 0x0267 
.................... #define CH2COMP_RATIO 0x0268 
.................... #define CH2COMP_ATTACK 0x0269 
.................... #define CH2COMP_RELEASE 0x026a 
.................... #define CH2COMP_BYPASS 0x026b 
.................... #define CH3COMP_THRESHOLD 0x025e 
.................... #define CH3COMP_KNEE 0x025f 
.................... #define CH3COMP_RATIO 0x0260 
.................... #define CH3COMP_ATTACK 0x0261 
.................... #define CH3COMP_RELEASE 0x0262 
.................... #define CH3COMP_BYPASS 0x0263 
.................... #define CH4COMP_THRESHOLD 0x0256 
.................... #define CH4COMP_KNEE 0x0257 
.................... #define CH4COMP_RATIO 0x0258 
.................... #define CH4COMP_ATTACK 0x0259 
.................... #define CH4COMP_RELEASE 0x025a 
.................... #define CH4COMP_BYPASS 0x025b 
.................... #define CH5COMP_THRESHOLD 0x024e 
.................... #define CH5COMP_KNEE 0x024f 
.................... #define CH5COMP_RATIO 0x0250 
.................... #define CH5COMP_ATTACK 0x0251 
.................... #define CH5COMP_RELEASE 0x0252 
.................... #define CH5COMP_BYPASS 0x0253 
.................... #define CH6COMP_THRESHOLD 0x0246 
.................... #define CH6COMP_KNEE 0x0247 
.................... #define CH6COMP_RATIO 0x0248 
.................... #define CH6COMP_ATTACK 0x0249 
.................... #define CH6COMP_RELEASE 0x024a 
.................... #define CH6COMP_BYPASS 0x024b 
.................... #define CH7COMP_THRESHOLD 0x023e 
.................... #define CH7COMP_KNEE 0x023f 
.................... #define CH7COMP_RATIO 0x0240 
.................... #define CH7COMP_ATTACK 0x0241 
.................... #define CH7COMP_RELEASE 0x0242 
.................... #define CH7COMP_BYPASS 0x0243 
.................... #define CH8COMP_THRESHOLD 0x0236 
.................... #define CH8COMP_KNEE 0x0237 
.................... #define CH8COMP_RATIO 0x0238 
.................... #define CH8COMP_ATTACK 0x0239 
.................... #define CH8COMP_RELEASE 0x023a 
.................... #define CH8COMP_BYPASS 0x023b 
.................... #define MIXER_SELECT0 0x0003 
.................... #define MIXER_SELECT1 0x0004 
.................... #define MIXER_SELECT2 0x0005 
.................... #define MIXER_SELECT3 0x0006 
.................... #define MIXER_SELECT4 0x0007 
.................... #define MIXER_SELECT5 0x0008 
.................... #define MIXER_SELECT6 0x0009 
.................... #define MIXER_SELECT7 0x000a 
.................... #define MIXER_SELECT8 0x000b 
.................... #define MIXER_SELECT9 0x000c 
.................... #define MIXER_SELECT10 0x000d 
.................... #define MIXER_SELECT11 0x000e 
.................... #define MIXER_SELECT12 0x000f 
.................... #define MIXER_SELECT13 0x0010 
.................... #define MIXER_SELECT14 0x0011 
.................... #define MIXER_SELECT15 0x0012 
.................... #define MIXER_SELECT16 0x0013 
.................... #define MIXER_SELECT17 0x0014 
.................... #define MIXER_SELECT18 0x0015 
.................... #define MIXER_SELECT19 0x0016 
.................... #define MIXER_SELECT20 0x0017 
.................... #define MIXER_SELECT21 0x0018 
.................... #define MIXER_SELECT22 0x0019 
.................... #define MIXER_SELECT23 0x001a 
.................... #define MIXER_SELECT24 0x001b 
.................... #define MIXER_SELECT25 0x001c 
.................... #define MIXER_SELECT26 0x001d 
.................... #define MIXER_SELECT27 0x001e 
.................... #define MIXER_SELECT28 0x001f 
.................... #define MIXER_SELECT29 0x0020 
.................... #define MIXER_SELECT30 0x0021 
.................... #define MIXER_SELECT31 0x0022 
.................... #define MIXER_SELECT32 0x0023 
.................... #define MIXER_SELECT33 0x0024 
.................... #define MIXER_SELECT34 0x0025 
.................... #define MIXER_SELECT35 0x0026 
.................... #define MIXER_SELECT36 0x0027 
.................... #define MIXER_SELECT37 0x0028 
.................... #define MIXER_SELECT38 0x0029 
.................... #define MIXER_SELECT39 0x002a 
.................... #define MIXER_SELECT40 0x002b 
.................... #define MIXER_SELECT41 0x002c 
.................... #define MIXER_SELECT42 0x002d 
.................... #define MIXER_SELECT43 0x002e 
.................... #define MIXER_SELECT44 0x002f 
.................... #define MIXER_SELECT45 0x0030 
.................... #define MIXER_SELECT46 0x0031 
.................... #define MIXER_SELECT47 0x0032 
.................... #define MIXER_SELECT48 0x0033 
.................... #define MIXER_SELECT49 0x0034 
.................... #define MIXER_SELECT50 0x0035 
.................... #define MIXER_SELECT51 0x0036 
.................... #define MIXER_SELECT52 0x0037 
.................... #define MIXER_SELECT53 0x0038 
.................... #define MIXER_SELECT54 0x0039 
.................... #define MIXER_SELECT55 0x003a 
.................... #define MIXER_SELECT56 0x003b 
.................... #define MIXER_SELECT57 0x003c 
.................... #define MIXER_SELECT58 0x003d 
.................... #define MIXER_SELECT59 0x003e 
.................... #define MIXER_SELECT60 0x003f 
.................... #define MIXER_SELECT61 0x0040 
.................... #define MIXER_SELECT62 0x0041 
.................... #define MIXER_SELECT63 0x0042 
.................... #define MIXER_SELECT64 0x0043 
.................... #define MIXER_SELECT65 0x0044 
.................... #define MIXER_SELECT66 0x0045 
.................... #define MIXER_SELECT67 0x0046 
.................... #define MIXER_SELECT68 0x0047 
.................... #define MIXER_SELECT69 0x0048 
.................... #define MIXER_SELECT70 0x0049 
.................... #define MIXER_SELECT71 0x004a 
.................... #define MIXER_SELECT72 0x004b 
.................... #define MIXER_SELECT73 0x004c 
.................... #define MIXER_SELECT74 0x004d 
.................... #define MIXER_SELECT75 0x004e 
.................... #define MIXER_SELECT76 0x004f 
.................... #define MIXER_SELECT77 0x0050 
.................... #define MIXER_SELECT78 0x0051 
.................... #define MIXER_SELECT79 0x0052 
.................... #define OUT_1_1_FILTER_B0 0x02f5 
.................... #define OUT_1_1_FILTER_B1 0x02f6 
.................... #define OUT_1_1_FILTER_B2 0x02f7 
.................... #define OUT_1_1_FILTER_NEGATIVEA1 0x02f8 
.................... #define OUT_1_1_FILTER_NEGATIVEA2 0x02f9 
.................... #define OUT_1_2_FILTER_B0 0x02f0 
.................... #define OUT_1_2_FILTER_B1 0x02f1 
.................... #define OUT_1_2_FILTER_B2 0x02f2 
.................... #define OUT_1_2_FILTER_NEGATIVEA1 0x02f3 
.................... #define OUT_1_2_FILTER_NEGATIVEA2 0x02f4 
.................... #define OUT_1_3_FILTER_B0 0x02eb 
.................... #define OUT_1_3_FILTER_B1 0x02ec 
.................... #define OUT_1_3_FILTER_B2 0x02ed 
.................... #define OUT_1_3_FILTER_NEGATIVEA1 0x02ee 
.................... #define OUT_1_3_FILTER_NEGATIVEA2 0x02ef 
.................... #define OUT_1_4_FILTER_B0 0x02b9 
.................... #define OUT_1_4_FILTER_B1 0x02ba 
.................... #define OUT_1_4_FILTER_B2 0x02bb 
.................... #define OUT_1_4_FILTER_NEGATIVEA1 0x02bc 
.................... #define OUT_1_4_FILTER_NEGATIVEA2 0x02bd 
.................... #define OUT_1_5_FILTER_B0 0x02b4 
.................... #define OUT_1_5_FILTER_B1 0x02b5 
.................... #define OUT_1_5_FILTER_B2 0x02b6 
.................... #define OUT_1_5_FILTER_NEGATIVEA1 0x02b7 
.................... #define OUT_1_5_FILTER_NEGATIVEA2 0x02b8 
.................... #define OUT_1_6_FILTER_B0 0x02af 
.................... #define OUT_1_6_FILTER_B1 0x02b0 
.................... #define OUT_1_6_FILTER_B2 0x02b1 
.................... #define OUT_1_6_FILTER_NEGATIVEA1 0x02b2 
.................... #define OUT_1_6_FILTER_NEGATIVEA2 0x02b3 
.................... #define OUT_2_1_FILTER_B0 0x02e6 
.................... #define OUT_2_1_FILTER_B1 0x02e7 
.................... #define OUT_2_1_FILTER_B2 0x02e8 
.................... #define OUT_2_1_FILTER_NEGATIVEA1 0x02e9 
.................... #define OUT_2_1_FILTER_NEGATIVEA2 0x02ea 
.................... #define OUT_2_2_FILTER_B0 0x02e1 
.................... #define OUT_2_2_FILTER_B1 0x02e2 
.................... #define OUT_2_2_FILTER_B2 0x02e3 
.................... #define OUT_2_2_FILTER_NEGATIVEA1 0x02e4 
.................... #define OUT_2_2_FILTER_NEGATIVEA2 0x02e5 
.................... #define OUT_2_3_FILTER_B0 0x02dc 
.................... #define OUT_2_3_FILTER_B1 0x02dd 
.................... #define OUT_2_3_FILTER_B2 0x02de 
.................... #define OUT_2_3_FILTER_NEGATIVEA1 0x02df 
.................... #define OUT_2_3_FILTER_NEGATIVEA2 0x02e0 
.................... #define OUT_2_4_FILTER_B0 0x02aa 
.................... #define OUT_2_4_FILTER_B1 0x02ab 
.................... #define OUT_2_4_FILTER_B2 0x02ac 
.................... #define OUT_2_4_FILTER_NEGATIVEA1 0x02ad 
.................... #define OUT_2_4_FILTER_NEGATIVEA2 0x02ae 
.................... #define OUT_2_5_FILTER_B0 0x02a5 
.................... #define OUT_2_5_FILTER_B1 0x02a6 
.................... #define OUT_2_5_FILTER_B2 0x02a7 
.................... #define OUT_2_5_FILTER_NEGATIVEA1 0x02a8 
.................... #define OUT_2_5_FILTER_NEGATIVEA2 0x02a9 
.................... #define OUT_2_6_FILTER_B0 0x02a0 
.................... #define OUT_2_6_FILTER_B1 0x02a1 
.................... #define OUT_2_6_FILTER_B2 0x02a2 
.................... #define OUT_2_6_FILTER_NEGATIVEA1 0x02a3 
.................... #define OUT_2_6_FILTER_NEGATIVEA2 0x02a4 
.................... #define OUT_3_1_FILTER_B0 0x02d7 
.................... #define OUT_3_1_FILTER_B1 0x02d8 
.................... #define OUT_3_1_FILTER_B2 0x02d9 
.................... #define OUT_3_1_FILTER_NEGATIVEA1 0x02da 
.................... #define OUT_3_1_FILTER_NEGATIVEA2 0x02db 
.................... #define OUT_3_2_FILTER_B0 0x02d2 
.................... #define OUT_3_2_FILTER_B1 0x02d3 
.................... #define OUT_3_2_FILTER_B2 0x02d4 
.................... #define OUT_3_2_FILTER_NEGATIVEA1 0x02d5 
.................... #define OUT_3_2_FILTER_NEGATIVEA2 0x02d6 
.................... #define OUT_3_3_FILTER_B0 0x02cd 
.................... #define OUT_3_3_FILTER_B1 0x02ce 
.................... #define OUT_3_3_FILTER_B2 0x02cf 
.................... #define OUT_3_3_FILTER_NEGATIVEA1 0x02d0 
.................... #define OUT_3_3_FILTER_NEGATIVEA2 0x02d1 
.................... #define OUT_3_4_FILTER_B0 0x029b 
.................... #define OUT_3_4_FILTER_B1 0x029c 
.................... #define OUT_3_4_FILTER_B2 0x029d 
.................... #define OUT_3_4_FILTER_NEGATIVEA1 0x029e 
.................... #define OUT_3_4_FILTER_NEGATIVEA2 0x029f 
.................... #define OUT_3_5_FILTER_B0 0x0296 
.................... #define OUT_3_5_FILTER_B1 0x0297 
.................... #define OUT_3_5_FILTER_B2 0x0298 
.................... #define OUT_3_5_FILTER_NEGATIVEA1 0x0299 
.................... #define OUT_3_5_FILTER_NEGATIVEA2 0x029a 
.................... #define OUT_3_6_FILTER_B0 0x0291 
.................... #define OUT_3_6_FILTER_B1 0x0292 
.................... #define OUT_3_6_FILTER_B2 0x0293 
.................... #define OUT_3_6_FILTER_NEGATIVEA1 0x0294 
.................... #define OUT_3_6_FILTER_NEGATIVEA2 0x0295 
.................... #define OUT_4_1_FILTER_B0 0x02c8 
.................... #define OUT_4_1_FILTER_B1 0x02c9 
.................... #define OUT_4_1_FILTER_B2 0x02ca 
.................... #define OUT_4_1_FILTER_NEGATIVEA1 0x02cb 
.................... #define OUT_4_1_FILTER_NEGATIVEA2 0x02cc 
.................... #define OUT_4_2_FILTER_B0 0x02c3 
.................... #define OUT_4_2_FILTER_B1 0x02c4 
.................... #define OUT_4_2_FILTER_B2 0x02c5 
.................... #define OUT_4_2_FILTER_NEGATIVEA1 0x02c6 
.................... #define OUT_4_2_FILTER_NEGATIVEA2 0x02c7 
.................... #define OUT_4_3_FILTER_B0 0x02be 
.................... #define OUT_4_3_FILTER_B1 0x02bf 
.................... #define OUT_4_3_FILTER_B2 0x02c0 
.................... #define OUT_4_3_FILTER_NEGATIVEA1 0x02c1 
.................... #define OUT_4_3_FILTER_NEGATIVEA2 0x02c2 
.................... #define OUT_4_4_FILTER_B0 0x028c 
.................... #define OUT_4_4_FILTER_B1 0x028d 
.................... #define OUT_4_4_FILTER_B2 0x028e 
.................... #define OUT_4_4_FILTER_NEGATIVEA1 0x028f 
.................... #define OUT_4_4_FILTER_NEGATIVEA2 0x0290 
.................... #define OUT_4_5_FILTER_B0 0x0287 
.................... #define OUT_4_5_FILTER_B1 0x0288 
.................... #define OUT_4_5_FILTER_B2 0x0289 
.................... #define OUT_4_5_FILTER_NEGATIVEA1 0x028a 
.................... #define OUT_4_5_FILTER_NEGATIVEA2 0x028b 
.................... #define OUT_4_6_FILTER_B0 0x0282 
.................... #define OUT_4_6_FILTER_B1 0x0283 
.................... #define OUT_4_6_FILTER_B2 0x0284 
.................... #define OUT_4_6_FILTER_NEGATIVEA1 0x0285 
.................... #define OUT_4_6_FILTER_NEGATIVEA2 0x0286 
.................... #define CH1LIM_THRESHOLD 0x022e 
.................... #define CH1LIM_KNEE 0x022f 
.................... #define CH1LIM_RATIO 0x0230 
.................... #define CH1LIM_ATTACK 0x0231 
.................... #define CH1LIM_RELEASE 0x0232 
.................... #define CH1LIM_BYPASS 0x0233 
.................... #define CH2LIM_THRESHOLD 0x0226 
.................... #define CH2LIM_KNEE 0x0227 
.................... #define CH2LIM_RATIO 0x0228 
.................... #define CH2LIM_ATTACK 0x0229 
.................... #define CH2LIM_RELEASE 0x022a 
.................... #define CH2LIM_BYPASS 0x022b 
.................... #define CH3LIM_THRESHOLD 0x021e 
.................... #define CH3LIM_KNEE 0x021f 
.................... #define CH3LIM_RATIO 0x0220 
.................... #define CH3LIM_ATTACK 0x0221 
.................... #define CH3LIM_RELEASE 0x0222 
.................... #define CH3LIM_BYPASS 0x0223 
.................... #define CH4LIM_THRESHOLD 0x0216 
.................... #define CH4LIM_KNEE 0x0217 
.................... #define CH4LIM_RATIO 0x0218 
.................... #define CH4LIM_ATTACK 0x0219 
.................... #define CH4LIM_RELEASE 0x021a 
.................... #define CH4LIM_BYPASS 0x021b 
.................... #define DELAY_CH1 0x03dd 
.................... #define DELAY_CH2 0x03da 
.................... #define DELAY_CH3 0x03d7 
.................... #define DELAY_CH4 0x03d4 
.................... #define DELAY_BYPASS_CH1 0x0448 
.................... #define DELAY_BYPASS_CH2 0x0447 
.................... #define DELAY_BYPASS_CH3 0x0446 
.................... #define DELAY_BYPASS_CH4 0x0445 
.................... #define BRIDGEROUTER_SELECT0 0x027e 
.................... #define BRIDGEROUTER_SELECT1 0x027f 
.................... #define BRIDGEROUTER_SELECT2 0x0280 
.................... #define BRIDGEROUTER_SELECT3 0x0281 
.................... #define GEN_PINK_GAIN 0x0411 
.................... #define GEN_SINE_OMEGA 0x03eb 
.................... #define GEN_SINE_GAIN 0x03ec 
.................... #define SEVENTYVHP_BYPASS 0x0444 
.................... #define MUTE_OUTPUTS 0x0413 
....................  
....................  
.................... #include <memory.c> 
.................... /*void WRITE_CONFIG_BOTH(int16 index, int16 address, int32 value) 
.................... { 
.................... 	if(index > num_dsp_values) { 
.................... 		num_dsp_values = index; 
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE * 2)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
.................... 		DSP_CONFIG.VALUES_2[index - (PAGE_SIZE*1)] = value;   
....................   	}  else if(index < (PAGE_SIZE * 3)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;    
.................... 		DSP_CONFIG.VALUES_3[index - (PAGE_SIZE*2)] = value;    
....................   	}  else if(index < ((PAGE_SIZE*4))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;    
.................... 		DSP_CONFIG.VALUES_4[index - (PAGE_SIZE*3)] = value;    
....................   	} else if(index < ((PAGE_SIZE*5))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;    
.................... 		DSP_CONFIG.VALUES_5[index - (PAGE_SIZE*4)] = value;    
....................   	} else if(index < ((PAGE_SIZE*6))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;    
.................... 		DSP_CONFIG.VALUES_6[index - (PAGE_SIZE*5)] = value;    
....................   	} else if(index < ((PAGE_SIZE*7))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;    
.................... 		DSP_CONFIG.VALUES_7[index - (PAGE_SIZE*6)] = value;    
....................   	} else if(index < ((PAGE_SIZE*8))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
.................... 		//DSP_CONFIG.VALUES_8[index - (PAGE_SIZE*7)] = value;    
....................   	} 
....................  
.................... } 
.................... */ 
.................... void WRITE_CONFIG_ADDRESS(int16 index, int16 address) 
.................... { 
.................... 	if(index > num_dsp_values) { 
*
02AA8:  MOVF   1B,W
02AAA:  MOVLB  8
02AAC:  SUBWF  x22,W
02AAE:  BNC   2AC0
02AB0:  BNZ   2AB8
02AB2:  MOVF   x21,W
02AB4:  SUBWF  1A,W
02AB6:  BC    2AC0
.................... 		num_dsp_values = index; 
02AB8:  MOVFF  822,1B
02ABC:  MOVFF  821,1A
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
02AC0:  MOVF   x22,F
02AC2:  BNZ   2AEC
02AC4:  MOVF   x21,W
02AC6:  SUBLW  3F
02AC8:  BNC   2AEC
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
02ACA:  BCF    FD8.0
02ACC:  RLCF   x21,W
02ACE:  MOVWF  02
02AD0:  RLCF   x22,W
02AD2:  MOVWF  03
02AD4:  MOVF   02,W
02AD6:  ADDLW  CC
02AD8:  MOVWF  FE9
02ADA:  MOVLW  02
02ADC:  ADDWFC 03,W
02ADE:  MOVWF  FEA
02AE0:  MOVFF  824,FEC
02AE4:  MOVF   FED,F
02AE6:  MOVFF  823,FEF
....................   	} else if(index < (PAGE_SIZE * 2)) 
02AEA:  BRA    2C76
02AEC:  MOVF   x22,F
02AEE:  BNZ   2B24
02AF0:  MOVF   x21,W
02AF2:  SUBLW  7F
02AF4:  BNC   2B24
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
02AF6:  MOVLW  40
02AF8:  SUBWF  x21,W
02AFA:  MOVWF  x25
02AFC:  MOVLW  00
02AFE:  SUBWFB x22,W
02B00:  MOVWF  x26
02B02:  BCF    FD8.0
02B04:  RLCF   x25,W
02B06:  MOVWF  02
02B08:  RLCF   x26,W
02B0A:  MOVWF  03
02B0C:  MOVF   02,W
02B0E:  ADDLW  4C
02B10:  MOVWF  FE9
02B12:  MOVLW  03
02B14:  ADDWFC 03,W
02B16:  MOVWF  FEA
02B18:  MOVFF  824,FEC
02B1C:  MOVF   FED,F
02B1E:  MOVFF  823,FEF
....................   	}  else if(index < (PAGE_SIZE * 3)) 
02B22:  BRA    2C76
02B24:  MOVF   x22,F
02B26:  BNZ   2B5C
02B28:  MOVF   x21,W
02B2A:  SUBLW  BF
02B2C:  BNC   2B5C
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;  
02B2E:  MOVLW  80
02B30:  SUBWF  x21,W
02B32:  MOVWF  x25
02B34:  MOVLW  00
02B36:  SUBWFB x22,W
02B38:  MOVWF  x26
02B3A:  BCF    FD8.0
02B3C:  RLCF   x25,W
02B3E:  MOVWF  02
02B40:  RLCF   x26,W
02B42:  MOVWF  03
02B44:  MOVF   02,W
02B46:  ADDLW  CC
02B48:  MOVWF  FE9
02B4A:  MOVLW  03
02B4C:  ADDWFC 03,W
02B4E:  MOVWF  FEA
02B50:  MOVFF  824,FEC
02B54:  MOVF   FED,F
02B56:  MOVFF  823,FEF
....................   	}  else if(index < ((PAGE_SIZE*4))) 
02B5A:  BRA    2C76
02B5C:  MOVF   x22,W
02B5E:  SUBLW  00
02B60:  BNC   2B90
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;   
02B62:  MOVLW  C0
02B64:  SUBWF  x21,W
02B66:  MOVWF  x25
02B68:  MOVLW  00
02B6A:  SUBWFB x22,W
02B6C:  MOVWF  x26
02B6E:  BCF    FD8.0
02B70:  RLCF   x25,W
02B72:  MOVWF  02
02B74:  RLCF   x26,W
02B76:  MOVWF  03
02B78:  MOVF   02,W
02B7A:  ADDLW  4C
02B7C:  MOVWF  FE9
02B7E:  MOVLW  04
02B80:  ADDWFC 03,W
02B82:  MOVWF  FEA
02B84:  MOVFF  824,FEC
02B88:  MOVF   FED,F
02B8A:  MOVFF  823,FEF
....................   	} else if(index < ((PAGE_SIZE*5))) 
02B8E:  BRA    2C76
02B90:  MOVF   x22,W
02B92:  SUBLW  01
02B94:  BNC   2BCC
02B96:  BNZ   2B9E
02B98:  MOVF   x21,W
02B9A:  SUBLW  3F
02B9C:  BNC   2BCC
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;  
02B9E:  MOVLW  00
02BA0:  SUBWF  x21,W
02BA2:  MOVWF  x25
02BA4:  MOVLW  01
02BA6:  SUBWFB x22,W
02BA8:  MOVWF  x26
02BAA:  BCF    FD8.0
02BAC:  RLCF   x25,W
02BAE:  MOVWF  02
02BB0:  RLCF   x26,W
02BB2:  MOVWF  03
02BB4:  MOVF   02,W
02BB6:  ADDLW  CC
02BB8:  MOVWF  FE9
02BBA:  MOVLW  04
02BBC:  ADDWFC 03,W
02BBE:  MOVWF  FEA
02BC0:  MOVFF  824,FEC
02BC4:  MOVF   FED,F
02BC6:  MOVFF  823,FEF
....................   	} else if(index < ((PAGE_SIZE*6))) 
02BCA:  BRA    2C76
02BCC:  MOVF   x22,W
02BCE:  SUBLW  01
02BD0:  BNC   2C08
02BD2:  BNZ   2BDA
02BD4:  MOVF   x21,W
02BD6:  SUBLW  7F
02BD8:  BNC   2C08
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;  
02BDA:  MOVLW  40
02BDC:  SUBWF  x21,W
02BDE:  MOVWF  x25
02BE0:  MOVLW  01
02BE2:  SUBWFB x22,W
02BE4:  MOVWF  x26
02BE6:  BCF    FD8.0
02BE8:  RLCF   x25,W
02BEA:  MOVWF  02
02BEC:  RLCF   x26,W
02BEE:  MOVWF  03
02BF0:  MOVF   02,W
02BF2:  ADDLW  4C
02BF4:  MOVWF  FE9
02BF6:  MOVLW  05
02BF8:  ADDWFC 03,W
02BFA:  MOVWF  FEA
02BFC:  MOVFF  824,FEC
02C00:  MOVF   FED,F
02C02:  MOVFF  823,FEF
....................   	} else if(index < ((PAGE_SIZE*7))) 
02C06:  BRA    2C76
02C08:  MOVF   x22,W
02C0A:  SUBLW  01
02C0C:  BNC   2C44
02C0E:  BNZ   2C16
02C10:  MOVF   x21,W
02C12:  SUBLW  BF
02C14:  BNC   2C44
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;  
02C16:  MOVLW  80
02C18:  SUBWF  x21,W
02C1A:  MOVWF  x25
02C1C:  MOVLW  01
02C1E:  SUBWFB x22,W
02C20:  MOVWF  x26
02C22:  BCF    FD8.0
02C24:  RLCF   x25,W
02C26:  MOVWF  02
02C28:  RLCF   x26,W
02C2A:  MOVWF  03
02C2C:  MOVF   02,W
02C2E:  ADDLW  CC
02C30:  MOVWF  FE9
02C32:  MOVLW  05
02C34:  ADDWFC 03,W
02C36:  MOVWF  FEA
02C38:  MOVFF  824,FEC
02C3C:  MOVF   FED,F
02C3E:  MOVFF  823,FEF
....................   	} else if(index < ((PAGE_SIZE*8))) 
02C42:  BRA    2C76
02C44:  MOVF   x22,W
02C46:  SUBLW  01
02C48:  BNC   2C76
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
02C4A:  MOVLW  C0
02C4C:  SUBWF  x21,W
02C4E:  MOVWF  x25
02C50:  MOVLW  01
02C52:  SUBWFB x22,W
02C54:  MOVWF  x26
02C56:  BCF    FD8.0
02C58:  RLCF   x25,W
02C5A:  MOVWF  02
02C5C:  RLCF   x26,W
02C5E:  MOVWF  03
02C60:  MOVF   02,W
02C62:  ADDLW  4C
02C64:  MOVWF  FE9
02C66:  MOVLW  06
02C68:  ADDWFC 03,W
02C6A:  MOVWF  FEA
02C6C:  MOVFF  824,FEC
02C70:  MOVF   FED,F
02C72:  MOVFF  823,FEF
....................   	} 
....................  
.................... } 
02C76:  MOVLB  0
02C78:  RETURN 0
....................  
....................  
.................... int16 READ_CONFIG_ADDRESS(int16 index)  
.................... {  
.................... 	int16 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
*
06394:  MOVLB  8
06396:  MOVF   x74,F
06398:  BNZ   63C6
0639A:  MOVF   x73,W
0639C:  SUBLW  3F
0639E:  BNC   63C6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_1[index]; 
063A0:  BCF    FD8.0
063A2:  RLCF   x73,W
063A4:  MOVWF  02
063A6:  RLCF   x74,W
063A8:  MOVWF  03
063AA:  MOVF   02,W
063AC:  ADDLW  CC
063AE:  MOVWF  FE9
063B0:  MOVLW  02
063B2:  ADDWFC 03,W
063B4:  MOVWF  FEA
063B6:  MOVFF  FEC,03
063BA:  MOVF   FED,F
063BC:  MOVFF  FEF,875
063C0:  MOVFF  03,876
....................   	} else if(index < (PAGE_SIZE * 2)) 
063C4:  BRA    656C
063C6:  MOVF   x74,F
063C8:  BNZ   6402
063CA:  MOVF   x73,W
063CC:  SUBLW  7F
063CE:  BNC   6402
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)]; 
063D0:  MOVLW  40
063D2:  SUBWF  x73,W
063D4:  MOVWF  x77
063D6:  MOVLW  00
063D8:  SUBWFB x74,W
063DA:  MOVWF  x78
063DC:  BCF    FD8.0
063DE:  RLCF   x77,W
063E0:  MOVWF  02
063E2:  RLCF   x78,W
063E4:  MOVWF  03
063E6:  MOVF   02,W
063E8:  ADDLW  4C
063EA:  MOVWF  FE9
063EC:  MOVLW  03
063EE:  ADDWFC 03,W
063F0:  MOVWF  FEA
063F2:  MOVFF  FEC,03
063F6:  MOVF   FED,F
063F8:  MOVFF  FEF,875
063FC:  MOVFF  03,876
....................   	}  else if(index < (PAGE_SIZE * 3)) 
06400:  BRA    656C
06402:  MOVF   x74,F
06404:  BNZ   643E
06406:  MOVF   x73,W
06408:  SUBLW  BF
0640A:  BNC   643E
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)]; 
0640C:  MOVLW  80
0640E:  SUBWF  x73,W
06410:  MOVWF  x77
06412:  MOVLW  00
06414:  SUBWFB x74,W
06416:  MOVWF  x78
06418:  BCF    FD8.0
0641A:  RLCF   x77,W
0641C:  MOVWF  02
0641E:  RLCF   x78,W
06420:  MOVWF  03
06422:  MOVF   02,W
06424:  ADDLW  CC
06426:  MOVWF  FE9
06428:  MOVLW  03
0642A:  ADDWFC 03,W
0642C:  MOVWF  FEA
0642E:  MOVFF  FEC,03
06432:  MOVF   FED,F
06434:  MOVFF  FEF,875
06438:  MOVFF  03,876
....................   	}  else if(index < ((PAGE_SIZE*4))) 
0643C:  BRA    656C
0643E:  MOVF   x74,W
06440:  SUBLW  00
06442:  BNC   6476
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)]; 
06444:  MOVLW  C0
06446:  SUBWF  x73,W
06448:  MOVWF  x77
0644A:  MOVLW  00
0644C:  SUBWFB x74,W
0644E:  MOVWF  x78
06450:  BCF    FD8.0
06452:  RLCF   x77,W
06454:  MOVWF  02
06456:  RLCF   x78,W
06458:  MOVWF  03
0645A:  MOVF   02,W
0645C:  ADDLW  4C
0645E:  MOVWF  FE9
06460:  MOVLW  04
06462:  ADDWFC 03,W
06464:  MOVWF  FEA
06466:  MOVFF  FEC,03
0646A:  MOVF   FED,F
0646C:  MOVFF  FEF,875
06470:  MOVFF  03,876
....................   	} else if(index < ((PAGE_SIZE*5))) 
06474:  BRA    656C
06476:  MOVF   x74,W
06478:  SUBLW  01
0647A:  BNC   64B6
0647C:  BNZ   6484
0647E:  MOVF   x73,W
06480:  SUBLW  3F
06482:  BNC   64B6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)];   
06484:  MOVLW  00
06486:  SUBWF  x73,W
06488:  MOVWF  x77
0648A:  MOVLW  01
0648C:  SUBWFB x74,W
0648E:  MOVWF  x78
06490:  BCF    FD8.0
06492:  RLCF   x77,W
06494:  MOVWF  02
06496:  RLCF   x78,W
06498:  MOVWF  03
0649A:  MOVF   02,W
0649C:  ADDLW  CC
0649E:  MOVWF  FE9
064A0:  MOVLW  04
064A2:  ADDWFC 03,W
064A4:  MOVWF  FEA
064A6:  MOVFF  FEC,03
064AA:  MOVF   FED,F
064AC:  MOVFF  FEF,875
064B0:  MOVFF  03,876
....................   	} else if(index < ((PAGE_SIZE*6))) 
064B4:  BRA    656C
064B6:  MOVF   x74,W
064B8:  SUBLW  01
064BA:  BNC   64F6
064BC:  BNZ   64C4
064BE:  MOVF   x73,W
064C0:  SUBLW  7F
064C2:  BNC   64F6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)]; 
064C4:  MOVLW  40
064C6:  SUBWF  x73,W
064C8:  MOVWF  x77
064CA:  MOVLW  01
064CC:  SUBWFB x74,W
064CE:  MOVWF  x78
064D0:  BCF    FD8.0
064D2:  RLCF   x77,W
064D4:  MOVWF  02
064D6:  RLCF   x78,W
064D8:  MOVWF  03
064DA:  MOVF   02,W
064DC:  ADDLW  4C
064DE:  MOVWF  FE9
064E0:  MOVLW  05
064E2:  ADDWFC 03,W
064E4:  MOVWF  FEA
064E6:  MOVFF  FEC,03
064EA:  MOVF   FED,F
064EC:  MOVFF  FEF,875
064F0:  MOVFF  03,876
....................   	} else if(index < ((PAGE_SIZE*7))) 
064F4:  BRA    656C
064F6:  MOVF   x74,W
064F8:  SUBLW  01
064FA:  BNC   6536
064FC:  BNZ   6504
064FE:  MOVF   x73,W
06500:  SUBLW  BF
06502:  BNC   6536
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)]; 
06504:  MOVLW  80
06506:  SUBWF  x73,W
06508:  MOVWF  x77
0650A:  MOVLW  01
0650C:  SUBWFB x74,W
0650E:  MOVWF  x78
06510:  BCF    FD8.0
06512:  RLCF   x77,W
06514:  MOVWF  02
06516:  RLCF   x78,W
06518:  MOVWF  03
0651A:  MOVF   02,W
0651C:  ADDLW  CC
0651E:  MOVWF  FE9
06520:  MOVLW  05
06522:  ADDWFC 03,W
06524:  MOVWF  FEA
06526:  MOVFF  FEC,03
0652A:  MOVF   FED,F
0652C:  MOVFF  FEF,875
06530:  MOVFF  03,876
....................   	} else if(index < ((PAGE_SIZE*8))) 
06534:  BRA    656C
06536:  MOVF   x74,W
06538:  SUBLW  01
0653A:  BNC   656C
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)]; 
0653C:  MOVLW  C0
0653E:  SUBWF  x73,W
06540:  MOVWF  x77
06542:  MOVLW  01
06544:  SUBWFB x74,W
06546:  MOVWF  x78
06548:  BCF    FD8.0
0654A:  RLCF   x77,W
0654C:  MOVWF  02
0654E:  RLCF   x78,W
06550:  MOVWF  03
06552:  MOVF   02,W
06554:  ADDLW  4C
06556:  MOVWF  FE9
06558:  MOVLW  06
0655A:  ADDWFC 03,W
0655C:  MOVWF  FEA
0655E:  MOVFF  FEC,03
06562:  MOVF   FED,F
06564:  MOVFF  FEF,875
06568:  MOVFF  03,876
....................   	} 
....................  
.................... 	return(retval);  
0656C:  MOVFF  875,01
06570:  MOVFF  876,02
.................... } 
06574:  MOVLB  0
06576:  RETURN 0
....................  
.................... /* 
.................... int32 READ_CONFIG_VALUE(int16 index)  
.................... {  
.................... 	int32 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_1[index];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_2[index - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE- PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else 
....................   	{  
....................    		retval = 0;  
....................   	}  
....................  
.................... 	return(retval);  
.................... } 
....................  
.................... void WRITE_CONFIG_VALUE(int16 index, int32 value)  
.................... {  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_2[index - PAGE_SIZE] = value;   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{     
.................... 		DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} 
.................... } 
....................  
.................... */ 
....................  
....................  
.................... #include <w25q80bv.c> 
.................... #define W25Q80BV_PAGE_LEN     		256  // in bytes 
.................... #define W25Q80BV_PAGES_PER_SECTOR	16 
....................  
.................... #define W25Q80BV_SECTOR_LEN			W25Q80BV_PAGE_LEN*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_SECTORS_PER_BLOCK	16 
....................  
.................... #define W25Q80BV_BLOCK_LEN			W25Q80BV_SECTOR_LEN*W25Q80BV_SECTORS_PER_BLOCK 
....................   	 
.................... #define W25Q80BV_NUM_BLOCKS			16 
.................... #define W25Q80BV_NUM_SECTORS		W25Q80BV_NUM_BLOCKS*W25Q80BV_SECTORS_PER_BLOCK 
.................... #define W25Q80BV_NUM_PAGES    		W25Q80BV_NUM_SECTORS*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_NUM_BYTES    		W25Q80BV_NUM_BLOCKS*W25Q80BV_BLOCK_LEN 
....................  
.................... #define W25Q80BV_WRITE_ENABLE 0x06 
.................... #define W25Q80BV_CHIP_ERASE   0xC7 
.................... #define W25Q80BV_SECTOR_ERASE 0x20 
.................... #define W25Q80BV_READ_STATUS1 0x05 
.................... #define W25Q80BV_PAGE_PROGRAM 0x02 
.................... #define W25Q80BV_DEVICE_ID    0xAB 
.................... #define W25Q80BV_UNIQUE_ID    0x4B 
....................  
.................... #define W25Q80BV_STATUS_BUSY  0x01 
....................  
.................... #define W25Q80BV_READ 0x03 
....................  
.................... #define W25Q80BV_DEVICE_ID_RES  0x13 /* Expected device_id for W25Q80BV */ 
....................  
.................... unsigned int32 page_address(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
*
0561A:  MOVFF  892,89B
0561E:  MOVFF  891,89A
05622:  MOVFF  890,899
05626:  MOVLB  8
05628:  CLRF   x98
0562A:  CLRF   x9C
0562C:  RLCF   x9C,W
0562E:  MOVWF  00
05630:  RLCF   x8C,W
05632:  MOVWF  01
05634:  RLCF   x8D,W
05636:  MOVWF  02
05638:  RLCF   x8E,W
0563A:  MOVWF  03
0563C:  RLCF   00,F
0563E:  RLCF   01,F
05640:  RLCF   02,F
05642:  RLCF   03,F
05644:  RLCF   00,F
05646:  RLCF   01,F
05648:  RLCF   02,F
0564A:  RLCF   03,F
0564C:  RLCF   00,F
0564E:  RLCF   01,F
05650:  RLCF   02,F
05652:  RLCF   03,F
05654:  MOVLW  F0
05656:  ANDWF  00,F
05658:  MOVF   00,W
0565A:  ADDWF  x98,F
0565C:  MOVF   01,W
0565E:  ADDWFC x99,F
05660:  MOVF   02,W
05662:  ADDWFC x9A,F
05664:  MOVF   03,W
05666:  ADDWFC x9B,F
05668:  MOVFF  88A,89F
0566C:  MOVFF  889,89E
05670:  MOVFF  888,89D
05674:  CLRF   x9C
05676:  RLCF   x9C,F
05678:  RLCF   x9D,F
0567A:  RLCF   x9E,F
0567C:  RLCF   x9F,F
0567E:  RLCF   x9C,F
05680:  RLCF   x9D,F
05682:  RLCF   x9E,F
05684:  RLCF   x9F,F
05686:  RLCF   x9C,F
05688:  RLCF   x9D,F
0568A:  RLCF   x9E,F
0568C:  RLCF   x9F,F
0568E:  RLCF   x9C,F
05690:  RLCF   x9D,F
05692:  RLCF   x9E,F
05694:  RLCF   x9F,F
05696:  MOVLW  F0
05698:  ANDWF  x9C,F
0569A:  RLCF   x9C,W
0569C:  MOVWF  00
0569E:  RLCF   x9D,W
056A0:  MOVWF  01
056A2:  RLCF   x9E,W
056A4:  MOVWF  02
056A6:  RLCF   x9F,W
056A8:  MOVWF  03
056AA:  RLCF   00,F
056AC:  RLCF   01,F
056AE:  RLCF   02,F
056B0:  RLCF   03,F
056B2:  RLCF   00,F
056B4:  RLCF   01,F
056B6:  RLCF   02,F
056B8:  RLCF   03,F
056BA:  RLCF   00,F
056BC:  RLCF   01,F
056BE:  RLCF   02,F
056C0:  RLCF   03,F
056C2:  MOVLW  F0
056C4:  ANDWF  00,F
056C6:  MOVF   00,W
056C8:  ADDWF  x98,W
056CA:  MOVWF  x94
056CC:  MOVF   01,W
056CE:  ADDWFC x99,W
056D0:  MOVWF  x95
056D2:  MOVF   02,W
056D4:  ADDWFC x9A,W
056D6:  MOVWF  x96
056D8:  MOVF   03,W
056DA:  ADDWFC x9B,W
056DC:  MOVWF  x97
.................... 	unsigned int32 return_address = (page_index*W25Q80BV_PAGE_LEN) + (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
056DE:  MOVFF  894,00
056E2:  MOVFF  895,01
056E6:  MOVFF  896,02
056EA:  MOVFF  897,03
.................... } 
056EE:  MOVLB  0
056F0:  RETURN 0
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
.................... 	unsigned int32 return_address = (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index) 
.................... { 
.................... 	unsigned int32 return_address = (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
....................  
.................... int flash_get_device_id() 
.................... { 
*
0572E:  MOVLB  8
05730:  CLRF   x88
.................... 	int data = 0; 
....................  
....................     output_low(FLASH_CS); 
05732:  BCF    F95.2
05734:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_DEVICE_ID); 
05736:  MOVLW  AB
05738:  MOVWF  x8D
0573A:  MOVLW  08
0573C:  MOVWF  x8E
0573E:  MOVLB  0
05740:  RCALL  56F2
.................... 	 
.................... 	data = spi_xfer(0x00); 
05742:  MOVLB  8
05744:  CLRF   x8D
05746:  MOVLW  08
05748:  MOVWF  x8E
0574A:  MOVLB  0
0574C:  RCALL  56F2
0574E:  MOVF   01,W
05750:  MOVFF  01,888
.................... 	data = spi_xfer(0x00); 
05754:  MOVLB  8
05756:  CLRF   x8D
05758:  MOVLW  08
0575A:  MOVWF  x8E
0575C:  MOVLB  0
0575E:  RCALL  56F2
05760:  MOVF   01,W
05762:  MOVFF  01,888
.................... 	data = spi_xfer(0x00); 
05766:  MOVLB  8
05768:  CLRF   x8D
0576A:  MOVLW  08
0576C:  MOVWF  x8E
0576E:  MOVLB  0
05770:  RCALL  56F2
05772:  MOVF   01,W
05774:  MOVFF  01,888
....................  
.................... 	data = spi_xfer(0xFF); 
05778:  MOVLB  8
0577A:  SETF   x8D
0577C:  MOVLW  08
0577E:  MOVWF  x8E
05780:  MOVLB  0
05782:  RCALL  56F2
05784:  MOVF   01,W
05786:  MOVFF  01,888
....................  
.................... 	output_high(FLASH_CS); 
0578A:  BCF    F95.2
0578C:  BSF    F8C.2
....................  
.................... 	return data; 
0578E:  MOVLB  8
05790:  MOVFF  888,01
.................... } 
05794:  MOVLB  0
05796:  GOTO   5840 (RETURN)
....................  
.................... short verify_device_id() 
.................... { 
.................... 	if(flash_get_device_id() == W25Q80BV_DEVICE_ID_RES) { 
.................... 		return 1; 
.................... 	} else { 
.................... 		return 0; 
.................... 	} 
.................... } 
....................  
.................... int flash_get_status() 
.................... { 
0579A:  MOVLB  8
0579C:  CLRF   x88
.................... 	int value = 0; 
.................... 	output_low(FLASH_CS); 
0579E:  BCF    F95.2
057A0:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ_STATUS1); 
057A2:  MOVLW  05
057A4:  MOVWF  x8D
057A6:  MOVLW  08
057A8:  MOVWF  x8E
057AA:  MOVLB  0
057AC:  RCALL  56F2
....................     value = spi_xfer(0x00); 
057AE:  MOVLB  8
057B0:  CLRF   x8D
057B2:  MOVLW  08
057B4:  MOVWF  x8E
057B6:  MOVLB  0
057B8:  RCALL  56F2
057BA:  MOVF   01,W
057BC:  MOVFF  01,888
....................     output_high(FLASH_CS); 
057C0:  BCF    F95.2
057C2:  BSF    F8C.2
.................... 	 
.................... 	return value; 
057C4:  MOVLB  8
057C6:  MOVFF  888,01
.................... } 
057CA:  MOVLB  0
057CC:  RETURN 0
....................  
.................... void flash_wait_while_busy() 
.................... { 
.................... 	while ((flash_get_status() & W25Q80BV_STATUS_BUSY)) 
.................... 	{ 
057CE:  RCALL  579A
057D0:  BTFSS  01.0
057D2:  BRA    57D6
.................... 	} 
057D4:  BRA    57CE
.................... } 
057D6:  RETURN 0
....................  
.................... void flash_write_enable() 
.................... { 
.................... 	flash_wait_while_busy(); 
057D8:  RCALL  57CE
.................... 	output_low(FLASH_CS); 
057DA:  BCF    F95.2
057DC:  BCF    F8C.2
.................... 	spi_xfer(0x06); 
057DE:  MOVLW  06
057E0:  MOVLB  8
057E2:  MOVWF  x8D
057E4:  MOVLW  08
057E6:  MOVWF  x8E
057E8:  MOVLB  0
057EA:  RCALL  56F2
....................     output_high(FLASH_CS); 
057EC:  BCF    F95.2
057EE:  BSF    F8C.2
.................... } 
057F0:  RETURN 0
....................  
.................... void flash_chip_erase() 
.................... { 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting chip erase...\r\n"); 
.................... 		} 
....................         int device_id = 0; 
....................  
....................         device_id = 0; 
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
....................                 device_id = flash_get_device_id(); 
....................         } 
....................  
....................         flash_write_enable(); 
....................         flash_wait_while_busy(); 
.................... 		output_low(PIN_C0); 
....................         output_low(FLASH_CS); 
....................         spi_xfer(W25Q80BV_CHIP_ERASE); 
....................         output_high(FLASH_CS); 
.................... 		 
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
.................... 		} 
.................... 		output_high(PIN_C0); 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
.................... } 
....................  
.................... void flash_sector_erase(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
057F2:  MOVLB  8
057F4:  CLRF   x83
057F6:  MOVFF  87E,88B
057FA:  MOVFF  87D,88A
057FE:  MOVFF  87C,889
05802:  MOVFF  87B,888
05806:  MOVFF  882,88F
0580A:  MOVFF  881,88E
0580E:  MOVFF  880,88D
05812:  MOVFF  87F,88C
05816:  CLRF   x93
05818:  CLRF   x92
0581A:  CLRF   x91
0581C:  CLRF   x90
0581E:  MOVLB  0
05820:  RCALL  561A
05822:  MOVFF  03,887
05826:  MOVFF  02,886
0582A:  MOVFF  01,885
0582E:  MOVFF  00,884
....................         int device_id = 0; 
....................  
.................... 		unsigned int32 starting_address = page_address(block_index,sector_index,0); 
....................  
....................         device_id = 0; 
05832:  MOVLB  8
05834:  CLRF   x83
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
05836:  MOVF   x83,W
05838:  SUBLW  13
0583A:  BZ    5848
....................                 device_id = flash_get_device_id(); 
0583C:  MOVLB  0
0583E:  BRA    572E
05840:  MOVFF  01,883
....................         } 
05844:  MOVLB  8
05846:  BRA    5836
....................  
....................         flash_write_enable(); 
05848:  MOVLB  0
0584A:  RCALL  57D8
....................         flash_wait_while_busy(); 
0584C:  RCALL  57CE
....................         output_low(FLASH_CS); 
0584E:  BCF    F95.2
05850:  BCF    F8C.2
....................         spi_xfer(W25Q80BV_SECTOR_ERASE); 
05852:  MOVLW  20
05854:  MOVLB  8
05856:  MOVWF  x8D
05858:  MOVLW  08
0585A:  MOVWF  x8E
0585C:  MOVLB  0
0585E:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05860:  MOVLB  8
05862:  CLRF   x88
05864:  CLRF   x89
05866:  MOVFF  886,88A
0586A:  CLRF   x8B
0586C:  MOVFF  886,888
05870:  MOVFF  88B,889
05874:  CLRF   x8A
05876:  CLRF   x8B
05878:  MOVFF  886,88D
0587C:  MOVLW  08
0587E:  MOVWF  x8E
05880:  MOVLB  0
05882:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05884:  MOVLB  8
05886:  CLRF   x88
05888:  CLRF   x8A
0588A:  CLRF   x8B
0588C:  MOVFF  885,888
05890:  MOVFF  88A,889
05894:  MOVFF  88B,88A
05898:  CLRF   x8B
0589A:  MOVFF  885,88D
0589E:  MOVLW  08
058A0:  MOVWF  x8E
058A2:  MOVLB  0
058A4:  RCALL  56F2
.................... 		spi_xfer(starting_address & 0xFF); 
058A6:  MOVLB  8
058A8:  MOVFF  884,888
058AC:  CLRF   x89
058AE:  CLRF   x8A
058B0:  CLRF   x8B
058B2:  MOVFF  884,88D
058B6:  MOVLW  08
058B8:  MOVWF  x8E
058BA:  MOVLB  0
058BC:  RCALL  56F2
....................         output_high(FLASH_CS); 
058BE:  BCF    F95.2
058C0:  BSF    F8C.2
....................  
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
058C2:  RCALL  579A
058C4:  BTFSS  01.0
058C6:  BRA    58CA
.................... 		} 
058C8:  BRA    58C2
....................  
.................... } 
058CA:  RETURN 0
....................  
.................... int flash_write_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		spi_xfer(ptr[i]); 
.................... 		rolling_checksum += ptr[i]; 
.................... 	} 
.................... 	 
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void flash_read_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_read_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < number_of_bytes; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_write_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(block_index,sector_index); 
....................  
.................... 	starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
.................... 	 
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 	for (value_counter = 0; value_counter < number_of_bytes; value_counter++) 
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
....................  
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... /* DEBUG STUFF */ 
....................  
.................... void flash_print_page(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	//starting_address = 0; 
.................... 	fprintf(RS232,"\r\nPrinting flash at starting address (%u,%u,%u) %lu\r\n",block_index,sector_index,page_index,starting_address); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		printf("%x",data); 
....................  
.................... 		if((i % 4) == 3) { 
.................... 			printf(" "); 
.................... 		} 
....................  
.................... 		if((i % 32) == 31) { 
.................... 			printf("\r\n"); 
.................... 		} 
.................... 	} 
.................... 	output_high(FLASH_CS); 
.................... } 
....................  
....................  
.................... int flash_page_checksum(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		rolling_checksum += data; 
.................... 	} 
.................... 	output_high(FLASH_CS); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
.................... /* 
.................... void FLASH_PROGRAM_WRITE(int program_index) {  
....................     
....................  
....................     // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		flash_sector_erase(program_index,sector_counter); 
.................... 		//fprintf(RS232,"Status1: %x\r\n",flash_get_status()); 
.................... 		//delay_ms(40); 
.................... 		//fprintf(RS232,"Status2: %x\r\n",flash_get_status()); 
.................... 		//ptr = &DSP_CONFIG.TEST_VALUES[0]; 
.................... 		starting_address = page_address(program_index,sector_counter,0); 
.................... 		flash_write_enable(); 
.................... 		flash_wait_while_busy(); 
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			spi_xfer(ptr[value_counter]); 
.................... 			test_val++; 
.................... 			value_counter++; 
.................... 		} 
.................... 		 
.................... 		output_high(FLASH_CS); 
....................  
.................... 		flash_wait_while_busy(); 
.................... 	} 
.................... } 
.................... */ 
.................... /* 
.................... void FLASH_PROGRAM_READ(int program_index) 
.................... { 
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
....................  
.................... 		starting_address = page_address(program_index,sector_counter,0); 
....................  
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_READ); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
.................... 			ptr[value_counter] = data; 
.................... 			value_counter++; 
....................  
.................... 			//fprintf(RS232,"%x||",data); 
.................... 		} 
....................  
.................... 		output_high(FLASH_CS); 
.................... 	} 
.................... } 
.................... */ 
.................... void FLASH_ADDR_WRITE(int block_index) {  
058CC:  MOVLB  8
058CE:  CLRF   x23
058D0:  CLRF   x22
....................     
....................  
....................    // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
058D2:  MOVLW  02
058D4:  MOVWF  x23
058D6:  MOVLW  CC
058D8:  MOVWF  x22
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
058DA:  CLRF   x25
058DC:  CLRF   x24
058DE:  CLRF   x29
058E0:  CLRF   x28
058E2:  CLRF   x27
058E4:  CLRF   x26
058E6:  CLRF   x2B
058E8:  CLRF   x2A
058EA:  CLRF   x2D
058EC:  CLRF   x2C
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
058EE:  CLRF   x2E
058F0:  MOVF   x2E,W
058F2:  SUBLW  03
058F4:  BTFSS  FD8.0
058F6:  BRA    5A02
.................... 		 
.................... 		flash_sector_erase(block_index,sector_counter); 
058F8:  CLRF   x7E
058FA:  CLRF   x7D
058FC:  CLRF   x7C
058FE:  MOVFF  821,87B
05902:  CLRF   x82
05904:  CLRF   x81
05906:  CLRF   x80
05908:  MOVFF  82E,87F
0590C:  MOVLB  0
0590E:  RCALL  57F2
.................... 		starting_address = page_address(block_index,sector_counter,0); 
05910:  MOVLB  8
05912:  CLRF   x8B
05914:  CLRF   x8A
05916:  CLRF   x89
05918:  MOVFF  821,888
0591C:  CLRF   x8F
0591E:  CLRF   x8E
05920:  CLRF   x8D
05922:  MOVFF  82E,88C
05926:  CLRF   x93
05928:  CLRF   x92
0592A:  CLRF   x91
0592C:  CLRF   x90
0592E:  MOVLB  0
05930:  RCALL  561A
05932:  MOVFF  03,829
05936:  MOVFF  02,828
0593A:  MOVFF  01,827
0593E:  MOVFF  00,826
.................... 		flash_write_enable(); 
05942:  RCALL  57D8
.................... 		flash_wait_while_busy(); 
05944:  RCALL  57CE
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
05946:  BCF    F95.2
05948:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
0594A:  MOVLW  02
0594C:  MOVLB  8
0594E:  MOVWF  x8D
05950:  MOVLW  08
05952:  MOVWF  x8E
05954:  MOVLB  0
05956:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05958:  MOVLB  8
0595A:  CLRF   x2F
0595C:  CLRF   x30
0595E:  MOVFF  828,831
05962:  CLRF   x32
05964:  MOVFF  828,82F
05968:  MOVFF  832,830
0596C:  CLRF   x31
0596E:  CLRF   x32
05970:  MOVFF  828,88D
05974:  MOVLW  08
05976:  MOVWF  x8E
05978:  MOVLB  0
0597A:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
0597C:  MOVLB  8
0597E:  CLRF   x2F
05980:  CLRF   x31
05982:  CLRF   x32
05984:  MOVFF  827,82F
05988:  MOVFF  831,830
0598C:  MOVFF  832,831
05990:  CLRF   x32
05992:  MOVFF  827,88D
05996:  MOVLW  08
05998:  MOVWF  x8E
0599A:  MOVLB  0
0599C:  RCALL  56F2
.................... 		spi_xfer(starting_address & 0xFF); 
0599E:  MOVLB  8
059A0:  MOVFF  826,82F
059A4:  CLRF   x30
059A6:  CLRF   x31
059A8:  CLRF   x32
059AA:  MOVFF  826,88D
059AE:  MOVLW  08
059B0:  MOVWF  x8E
059B2:  MOVLB  0
059B4:  RCALL  56F2
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
059B6:  MOVLB  8
059B8:  CLRF   x2D
059BA:  CLRF   x2C
059BC:  MOVF   x2D,W
059BE:  SUBLW  00
059C0:  BNC   59F4
.................... 		{ 
.................... 			//spi_xfer(value_counter); 
.................... 			spi_xfer(ptr[value_counter]); 
059C2:  MOVF   x22,W
059C4:  ADDWF  x24,W
059C6:  MOVWF  FE9
059C8:  MOVF   x23,W
059CA:  ADDWFC x25,W
059CC:  MOVWF  FEA
059CE:  MOVFF  FEF,82F
059D2:  MOVFF  82F,88D
059D6:  MOVLW  08
059D8:  MOVWF  x8E
059DA:  MOVLB  0
059DC:  RCALL  56F2
.................... 			test_val++; 
059DE:  MOVLB  8
059E0:  INCF   x2A,F
059E2:  BTFSC  FD8.2
059E4:  INCF   x2B,F
.................... 			value_counter++; 
059E6:  INCF   x24,F
059E8:  BTFSC  FD8.2
059EA:  INCF   x25,F
.................... 		} 
059EC:  INCF   x2C,F
059EE:  BTFSC  FD8.2
059F0:  INCF   x2D,F
059F2:  BRA    59BC
.................... 		 
.................... 		output_high(FLASH_CS); 
059F4:  BCF    F95.2
059F6:  BSF    F8C.2
....................  
.................... 		flash_wait_while_busy(); 
059F8:  MOVLB  0
059FA:  RCALL  57CE
....................  
.................... 		//fprintf(RS232,"Wrote %lu bytes\r\n",test_val); 
.................... 		 
.................... 	} 
059FC:  MOVLB  8
059FE:  INCF   x2E,F
05A00:  BRA    58F0
.................... } 
05A02:  MOVLB  0
05A04:  GOTO   C0AC (RETURN)
....................  
....................  
.................... void FLASH_ADDR_READ() 
.................... { 
*
05B4C:  MOVLB  8
05B4E:  CLRF   x24
05B50:  CLRF   x23
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
05B52:  MOVLW  02
05B54:  MOVWF  x24
05B56:  MOVLW  CC
05B58:  MOVWF  x23
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
05B5A:  CLRF   x28
05B5C:  CLRF   x27
05B5E:  CLRF   x26
05B60:  CLRF   x25
05B62:  CLRF   x2A
05B64:  CLRF   x29
05B66:  CLRF   x2B
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
05B68:  CLRF   x2C
05B6A:  MOVF   x2C,W
05B6C:  SUBLW  03
05B6E:  BNC   5C54
....................  
.................... 		starting_address = page_address(DEFAULT_ADDR_BLOCK,sector_counter,0); 
05B70:  CLRF   x8B
05B72:  CLRF   x8A
05B74:  CLRF   x89
05B76:  MOVLW  0E
05B78:  MOVWF  x88
05B7A:  CLRF   x8F
05B7C:  CLRF   x8E
05B7E:  CLRF   x8D
05B80:  MOVFF  82C,88C
05B84:  CLRF   x93
05B86:  CLRF   x92
05B88:  CLRF   x91
05B8A:  CLRF   x90
05B8C:  MOVLB  0
05B8E:  RCALL  561A
05B90:  MOVFF  03,828
05B94:  MOVFF  02,827
05B98:  MOVFF  01,826
05B9C:  MOVFF  00,825
....................  
.................... 		output_low(FLASH_CS); 
05BA0:  BCF    F95.2
05BA2:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_READ); 
05BA4:  MOVLW  03
05BA6:  MOVLB  8
05BA8:  MOVWF  x8D
05BAA:  MOVLW  08
05BAC:  MOVWF  x8E
05BAE:  MOVLB  0
05BB0:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05BB2:  MOVLB  8
05BB4:  CLRF   x2F
05BB6:  CLRF   x30
05BB8:  MOVFF  827,831
05BBC:  CLRF   x32
05BBE:  MOVFF  827,82F
05BC2:  MOVFF  832,830
05BC6:  CLRF   x31
05BC8:  CLRF   x32
05BCA:  MOVFF  827,88D
05BCE:  MOVLW  08
05BD0:  MOVWF  x8E
05BD2:  MOVLB  0
05BD4:  RCALL  56F2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05BD6:  MOVLB  8
05BD8:  CLRF   x2F
05BDA:  CLRF   x31
05BDC:  CLRF   x32
05BDE:  MOVFF  826,82F
05BE2:  MOVFF  831,830
05BE6:  MOVFF  832,831
05BEA:  CLRF   x32
05BEC:  MOVFF  826,88D
05BF0:  MOVLW  08
05BF2:  MOVWF  x8E
05BF4:  MOVLB  0
05BF6:  RCALL  56F2
.................... 		spi_xfer(starting_address & 0xFF); 
05BF8:  MOVLB  8
05BFA:  MOVFF  825,82F
05BFE:  CLRF   x30
05C00:  CLRF   x31
05C02:  CLRF   x32
05C04:  MOVFF  825,88D
05C08:  MOVLW  08
05C0A:  MOVWF  x8E
05C0C:  MOVLB  0
05C0E:  RCALL  56F2
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
05C10:  MOVLB  8
05C12:  CLRF   x2E
05C14:  CLRF   x2D
05C16:  MOVF   x2E,W
05C18:  SUBLW  00
05C1A:  BNC   5C4C
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
05C1C:  CLRF   x8D
05C1E:  MOVLW  08
05C20:  MOVWF  x8E
05C22:  MOVLB  0
05C24:  RCALL  56F2
05C26:  MOVF   01,W
05C28:  MOVFF  01,82B
.................... 			ptr[value_counter] = data; 
05C2C:  MOVLB  8
05C2E:  MOVF   x23,W
05C30:  ADDWF  x29,W
05C32:  MOVWF  FE9
05C34:  MOVF   x24,W
05C36:  ADDWFC x2A,W
05C38:  MOVWF  FEA
05C3A:  MOVFF  82B,FEF
.................... 			value_counter++; 
05C3E:  INCF   x29,F
05C40:  BTFSC  FD8.2
05C42:  INCF   x2A,F
.................... 			 
.................... 		} 
05C44:  INCF   x2D,F
05C46:  BTFSC  FD8.2
05C48:  INCF   x2E,F
05C4A:  BRA    5C16
....................  
.................... 		output_high(FLASH_CS); 
05C4C:  BCF    F95.2
05C4E:  BSF    F8C.2
.................... 	} 
05C50:  INCF   x2C,F
05C52:  BRA    5B6A
.................... } 
05C54:  MOVLB  0
05C56:  GOTO   6168 (RETURN)
....................  
.................... /* 
.................... void PRINT_READ_PROGRAM() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
.................... */ 
.................... void PRINT_READ_ADDR() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void FLASH_COPY_PROGRAM(int from_index, int to_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\nCopying program from %u to %u ... ",from_index,to_index); 
*
070EA:  MOVLW  3E
070EC:  MOVWF  FF6
070EE:  MOVLW  01
070F0:  MOVWF  FF7
070F2:  MOVLW  17
070F4:  MOVLB  8
070F6:  MOVWF  x77
070F8:  MOVLB  0
070FA:  CALL   5A52
070FE:  MOVFF  869,877
07102:  MOVLW  1B
07104:  MOVLB  8
07106:  MOVWF  x78
07108:  MOVLB  0
0710A:  CALL   5AA8
0710E:  MOVLW  57
07110:  MOVWF  FF6
07112:  MOVLW  01
07114:  MOVWF  FF7
07116:  MOVLW  04
07118:  MOVLB  8
0711A:  MOVWF  x77
0711C:  MOVLB  0
0711E:  CALL   5A52
07122:  MOVFF  86A,877
07126:  MOVLW  1B
07128:  MOVLB  8
0712A:  MOVWF  x78
0712C:  MOVLB  0
0712E:  CALL   5AA8
07132:  MOVLW  5D
07134:  MOVWF  FF6
07136:  MOVLW  01
07138:  MOVWF  FF7
0713A:  MOVLW  05
0713C:  MOVLB  8
0713E:  MOVWF  x77
07140:  MOVLB  0
07142:  CALL   5A52
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int32 read_starting_address = 0; 
.................... 	int32 write_starting_address = 0; 
.................... 	 
.................... 	int read_data = 0; 
07146:  MOVLB  8
07148:  CLRF   x6E
0714A:  CLRF   x6D
0714C:  CLRF   x6C
0714E:  CLRF   x6B
07150:  CLRF   x72
07152:  CLRF   x71
07154:  CLRF   x70
07156:  CLRF   x6F
07158:  CLRF   x73
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
0715A:  CLRF   x74
0715C:  MOVF   x74,W
0715E:  SUBLW  0B
07160:  BTFSS  FD8.0
07162:  BRA    7354
....................  
.................... 		flash_sector_erase(to_index,sector_counter); 
07164:  CLRF   x7E
07166:  CLRF   x7D
07168:  CLRF   x7C
0716A:  MOVFF  86A,87B
0716E:  CLRF   x82
07170:  CLRF   x81
07172:  CLRF   x80
07174:  MOVFF  874,87F
07178:  MOVLB  0
0717A:  CALL   57F2
....................  
.................... 		write_starting_address = page_address(to_index,sector_counter,0); 
0717E:  MOVLB  8
07180:  CLRF   x8B
07182:  CLRF   x8A
07184:  CLRF   x89
07186:  MOVFF  86A,888
0718A:  CLRF   x8F
0718C:  CLRF   x8E
0718E:  CLRF   x8D
07190:  MOVFF  874,88C
07194:  CLRF   x93
07196:  CLRF   x92
07198:  CLRF   x91
0719A:  CLRF   x90
0719C:  MOVLB  0
0719E:  CALL   561A
071A2:  MOVFF  03,872
071A6:  MOVFF  02,871
071AA:  MOVFF  01,870
071AE:  MOVFF  00,86F
.................... 		read_starting_address = page_address(from_index,sector_counter,0); 
071B2:  MOVLB  8
071B4:  CLRF   x8B
071B6:  CLRF   x8A
071B8:  CLRF   x89
071BA:  MOVFF  869,888
071BE:  CLRF   x8F
071C0:  CLRF   x8E
071C2:  CLRF   x8D
071C4:  MOVFF  874,88C
071C8:  CLRF   x93
071CA:  CLRF   x92
071CC:  CLRF   x91
071CE:  CLRF   x90
071D0:  MOVLB  0
071D2:  CALL   561A
071D6:  MOVFF  03,86E
071DA:  MOVFF  02,86D
071DE:  MOVFF  01,86C
071E2:  MOVFF  00,86B
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
071E6:  MOVLB  8
071E8:  CLRF   x76
071EA:  CLRF   x75
071EC:  MOVF   x76,W
071EE:  SUBLW  00
071F0:  BTFSS  FD8.0
071F2:  BRA    7350
.................... 		{ 
.................... 			output_low(FLASH_CS); 
071F4:  BCF    F95.2
071F6:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_READ); 
071F8:  MOVLW  03
071FA:  MOVWF  x8D
071FC:  MOVLW  08
071FE:  MOVWF  x8E
07200:  MOVLB  0
07202:  CALL   56F2
.................... 			spi_xfer((read_starting_address & 0xFF0000) >> 16); 
07206:  MOVLB  8
07208:  CLRF   x77
0720A:  CLRF   x78
0720C:  MOVFF  86D,879
07210:  CLRF   x7A
07212:  MOVFF  879,877
07216:  MOVFF  87A,878
0721A:  CLRF   x79
0721C:  CLRF   x7A
0721E:  MOVFF  877,88D
07222:  MOVLW  08
07224:  MOVWF  x8E
07226:  MOVLB  0
07228:  CALL   56F2
.................... 			spi_xfer((read_starting_address & 0xFF00) >> 8); 
0722C:  MOVLB  8
0722E:  CLRF   x77
07230:  MOVFF  86C,878
07234:  CLRF   x79
07236:  CLRF   x7A
07238:  MOVFF  878,877
0723C:  MOVFF  879,878
07240:  MOVFF  87A,879
07244:  CLRF   x7A
07246:  MOVFF  877,88D
0724A:  MOVLW  08
0724C:  MOVWF  x8E
0724E:  MOVLB  0
07250:  CALL   56F2
.................... 			spi_xfer(read_starting_address & 0xFF); 
07254:  MOVLB  8
07256:  MOVFF  86B,877
0725A:  CLRF   x78
0725C:  CLRF   x79
0725E:  CLRF   x7A
07260:  MOVFF  877,88D
07264:  MOVLW  08
07266:  MOVWF  x8E
07268:  MOVLB  0
0726A:  CALL   56F2
.................... 		 
.................... 			read_data = spi_xfer(0x00); 
0726E:  MOVLB  8
07270:  CLRF   x8D
07272:  MOVLW  08
07274:  MOVWF  x8E
07276:  MOVLB  0
07278:  CALL   56F2
0727C:  MOVF   01,W
0727E:  MOVFF  01,873
....................  
.................... 			output_high(FLASH_CS); 
07282:  BCF    F95.2
07284:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
07286:  CALL   57CE
....................  
.................... 			flash_write_enable(); 
0728A:  CALL   57D8
.................... 			flash_wait_while_busy(); 
0728E:  CALL   57CE
....................  
.................... 			output_low(FLASH_CS); 
07292:  BCF    F95.2
07294:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_PAGE_PROGRAM); 
07296:  MOVLW  02
07298:  MOVLB  8
0729A:  MOVWF  x8D
0729C:  MOVLW  08
0729E:  MOVWF  x8E
072A0:  MOVLB  0
072A2:  CALL   56F2
.................... 			spi_xfer((write_starting_address & 0xFF0000) >> 16); 
072A6:  MOVLB  8
072A8:  CLRF   x77
072AA:  CLRF   x78
072AC:  MOVFF  871,879
072B0:  CLRF   x7A
072B2:  MOVFF  879,877
072B6:  MOVFF  87A,878
072BA:  CLRF   x79
072BC:  CLRF   x7A
072BE:  MOVFF  877,88D
072C2:  MOVLW  08
072C4:  MOVWF  x8E
072C6:  MOVLB  0
072C8:  CALL   56F2
.................... 			spi_xfer((write_starting_address & 0xFF00) >> 8); 
072CC:  MOVLB  8
072CE:  CLRF   x77
072D0:  MOVFF  870,878
072D4:  CLRF   x79
072D6:  CLRF   x7A
072D8:  MOVFF  878,877
072DC:  MOVFF  879,878
072E0:  MOVFF  87A,879
072E4:  CLRF   x7A
072E6:  MOVFF  877,88D
072EA:  MOVLW  08
072EC:  MOVWF  x8E
072EE:  MOVLB  0
072F0:  CALL   56F2
.................... 			spi_xfer(write_starting_address & 0xFF); 
072F4:  MOVLB  8
072F6:  MOVFF  86F,877
072FA:  CLRF   x78
072FC:  CLRF   x79
072FE:  CLRF   x7A
07300:  MOVFF  877,88D
07304:  MOVLW  08
07306:  MOVWF  x8E
07308:  MOVLB  0
0730A:  CALL   56F2
....................  
.................... 			spi_xfer(read_data); 
0730E:  MOVFF  873,88D
07312:  MOVLW  08
07314:  MOVLB  8
07316:  MOVWF  x8E
07318:  MOVLB  0
0731A:  CALL   56F2
....................  
.................... 			output_high(FLASH_CS); 
0731E:  BCF    F95.2
07320:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
07322:  CALL   57CE
....................  
.................... 			read_starting_address++; 
07326:  MOVLW  01
07328:  MOVLB  8
0732A:  ADDWF  x6B,F
0732C:  BTFSC  FD8.0
0732E:  INCF   x6C,F
07330:  BTFSC  FD8.2
07332:  INCF   x6D,F
07334:  BTFSC  FD8.2
07336:  INCF   x6E,F
.................... 			write_starting_address++; 
07338:  MOVLW  01
0733A:  ADDWF  x6F,F
0733C:  BTFSC  FD8.0
0733E:  INCF   x70,F
07340:  BTFSC  FD8.2
07342:  INCF   x71,F
07344:  BTFSC  FD8.2
07346:  INCF   x72,F
....................  
.................... 			//fprintf(RS232,"%x||",read_data); 
.................... 		} 
07348:  INCF   x75,F
0734A:  BTFSC  FD8.2
0734C:  INCF   x76,F
0734E:  BRA    71EC
.................... 	} 
07350:  INCF   x74,F
07352:  BRA    715C
....................  
.................... 	fprintf(RS232,"DONE!\r\n"); 
07354:  MOVLW  64
07356:  MOVWF  FF6
07358:  MOVLW  01
0735A:  MOVWF  FF7
0735C:  MOVLB  0
0735E:  CALL   5A30
.................... } 
07362:  GOTO   8B60 (RETURN)
....................  
.................... void FLASH_COMPARE_PROGRAM(int a_index, int b_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\Comparing programs %u and %u ... ",a_index,b_index); 
....................  
.................... 	int32 compare_a_starting_address = 0; 
.................... 	int32 compare_b_starting_address = 0; 
.................... 	 
.................... 	int read_data_a = 0; 
.................... 	int read_data_b = 0; 
....................  
.................... 	int errors_found = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
....................  
....................  
.................... 		compare_a_starting_address = page_address(a_index,sector_counter,0); 
.................... 		compare_b_starting_address = page_address(b_index,sector_counter,0); 
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_a_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_a = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
....................  
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_b_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_b = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
.................... 			compare_a_starting_address++; 
.................... 			compare_b_starting_address++; 
....................  
.................... 			if(read_data_a != read_data_b) { 
.................... 				fprintf(RS232,"[ERROR] found in sector %u at address %lu. A = %x, B = %x\r\n",sector_counter,i,read_data_a,read_data_b); 
.................... 				errors_found++; 
.................... 			} else { 
.................... 				//fprintf(RS232,"%x == %x ",read_data_a,read_data_b); 
.................... 				 
.................... 			} 
.................... 		} 
....................  
.................... 		//fprintf(RS232,"Completed sector %u, %u errors found.\r\n",sector_counter,errors_in_sector); 
.................... 	} 
....................  
.................... 	fprintf(RS232,"%u errors found\r\n",errors_found); 
.................... } 
....................  
.................... int addr_index_to_page_index(int16 addr_index) { 
.................... 	return (int)(addr_index / PAGE_SIZE); 
*
06E70:  MOVLB  8
06E72:  RRCF   x6A,W
06E74:  MOVWF  03
06E76:  RRCF   x69,W
06E78:  MOVWF  02
06E7A:  RRCF   03,F
06E7C:  RRCF   02,F
06E7E:  RRCF   03,F
06E80:  RRCF   02,F
06E82:  RRCF   03,F
06E84:  RRCF   02,F
06E86:  RRCF   03,F
06E88:  RRCF   02,F
06E8A:  RRCF   03,F
06E8C:  RRCF   02,F
06E8E:  MOVLW  03
06E90:  ANDWF  03,F
06E92:  MOVFF  02,01
.................... } 
06E96:  MOVLB  0
06E98:  RETURN 0
....................  
.................... int addr_index_to_buffer_index(int16 addr_index) { 
.................... 	return (int)(addr_index % PAGE_SIZE); 
06E9A:  MOVLB  8
06E9C:  MOVF   x69,W
06E9E:  ANDLW  3F
06EA0:  MOVWF  00
06EA2:  CLRF   03
06EA4:  MOVWF  01
.................... } 
06EA6:  MOVLB  0
06EA8:  GOTO   8524 (RETURN)
....................  
.................... void read_flash_page_into_buffer(int *ptr,int program_index, int page_index)  
.................... { 
*
05E08:  MOVLB  8
05E0A:  CLRF   x7A
05E0C:  CLRF   x79
05E0E:  CLRF   x78
05E10:  CLRF   x77
05E12:  CLRF   x7B
.................... 	int32 starting_address = 0; 
.................... 	int data = 0; 
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
05E14:  CLRF   x8B
05E16:  CLRF   x8A
05E18:  CLRF   x89
05E1A:  MOVFF  875,888
05E1E:  CLRF   x8F
05E20:  CLRF   x8E
05E22:  CLRF   x8D
05E24:  MOVFF  876,88C
05E28:  CLRF   x93
05E2A:  CLRF   x92
05E2C:  CLRF   x91
05E2E:  CLRF   x90
05E30:  MOVLB  0
05E32:  CALL   561A
05E36:  MOVFF  03,87A
05E3A:  MOVFF  02,879
05E3E:  MOVFF  01,878
05E42:  MOVFF  00,877
....................  
.................... 	output_low(FLASH_CS); 
05E46:  BCF    F95.2
05E48:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ); 
05E4A:  MOVLW  03
05E4C:  MOVLB  8
05E4E:  MOVWF  x8D
05E50:  MOVLW  08
05E52:  MOVWF  x8E
05E54:  MOVLB  0
05E56:  RCALL  56F2
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
05E58:  MOVLB  8
05E5A:  CLRF   x7E
05E5C:  CLRF   x7F
05E5E:  MOVFF  879,880
05E62:  CLRF   x81
05E64:  MOVFF  879,87E
05E68:  MOVFF  881,87F
05E6C:  CLRF   x80
05E6E:  CLRF   x81
05E70:  MOVFF  879,88D
05E74:  MOVLW  08
05E76:  MOVWF  x8E
05E78:  MOVLB  0
05E7A:  RCALL  56F2
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
05E7C:  MOVLB  8
05E7E:  CLRF   x7E
05E80:  CLRF   x80
05E82:  CLRF   x81
05E84:  MOVFF  878,87E
05E88:  MOVFF  880,87F
05E8C:  MOVFF  881,880
05E90:  CLRF   x81
05E92:  MOVFF  878,88D
05E96:  MOVLW  08
05E98:  MOVWF  x8E
05E9A:  MOVLB  0
05E9C:  RCALL  56F2
.................... 	spi_xfer(starting_address & 0xFF); 
05E9E:  MOVLB  8
05EA0:  MOVFF  877,87E
05EA4:  CLRF   x7F
05EA6:  CLRF   x80
05EA8:  CLRF   x81
05EAA:  MOVFF  877,88D
05EAE:  MOVLW  08
05EB0:  MOVWF  x8E
05EB2:  MOVLB  0
05EB4:  RCALL  56F2
.................... 	 
.................... 	for (int16 i = 0; i < 256; i++) 
05EB6:  MOVLB  8
05EB8:  CLRF   x7D
05EBA:  CLRF   x7C
05EBC:  MOVF   x7D,W
05EBE:  SUBLW  00
05EC0:  BNC   5EEC
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
05EC2:  CLRF   x8D
05EC4:  MOVLW  08
05EC6:  MOVWF  x8E
05EC8:  MOVLB  0
05ECA:  RCALL  56F2
05ECC:  MOVF   01,W
05ECE:  MOVFF  01,87B
.................... 		ptr[i] = data; 
05ED2:  MOVLB  8
05ED4:  MOVF   x73,W
05ED6:  ADDWF  x7C,W
05ED8:  MOVWF  FE9
05EDA:  MOVF   x74,W
05EDC:  ADDWFC x7D,W
05EDE:  MOVWF  FEA
05EE0:  MOVFF  87B,FEF
.................... 	} 
05EE4:  INCF   x7C,F
05EE6:  BTFSC  FD8.2
05EE8:  INCF   x7D,F
05EEA:  BRA    5EBC
....................  
.................... 	output_high(FLASH_CS); 
05EEC:  BCF    F95.2
05EEE:  BSF    F8C.2
.................... } 
05EF0:  MOVLB  0
05EF2:  RETURN 0
....................  
....................  
.................... void write_buffer_to_flash_page(int *ptr,int program_index, int page_index)  
.................... { 
05EF4:  MOVLB  8
05EF6:  CLRF   x78
05EF8:  CLRF   x77
05EFA:  CLRF   x76
05EFC:  CLRF   x75
05EFE:  CLRF   x7A
05F00:  CLRF   x79
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(program_index,page_index); 
05F02:  CLRF   x7E
05F04:  CLRF   x7D
05F06:  CLRF   x7C
05F08:  MOVFF  873,87B
05F0C:  CLRF   x82
05F0E:  CLRF   x81
05F10:  CLRF   x80
05F12:  MOVFF  874,87F
05F16:  MOVLB  0
05F18:  RCALL  57F2
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
05F1A:  MOVLB  8
05F1C:  CLRF   x8B
05F1E:  CLRF   x8A
05F20:  CLRF   x89
05F22:  MOVFF  873,888
05F26:  CLRF   x8F
05F28:  CLRF   x8E
05F2A:  CLRF   x8D
05F2C:  MOVFF  874,88C
05F30:  CLRF   x93
05F32:  CLRF   x92
05F34:  CLRF   x91
05F36:  CLRF   x90
05F38:  MOVLB  0
05F3A:  CALL   561A
05F3E:  MOVFF  03,878
05F42:  MOVFF  02,877
05F46:  MOVFF  01,876
05F4A:  MOVFF  00,875
....................  
.................... 	flash_write_enable(); 
05F4E:  RCALL  57D8
.................... 	flash_wait_while_busy(); 
05F50:  RCALL  57CE
.................... 	 
.................... 	output_low(FLASH_CS); 
05F52:  BCF    F95.2
05F54:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
05F56:  MOVLW  02
05F58:  MOVLB  8
05F5A:  MOVWF  x8D
05F5C:  MOVLW  08
05F5E:  MOVWF  x8E
05F60:  MOVLB  0
05F62:  CALL   56F2
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
05F66:  MOVLB  8
05F68:  CLRF   x7B
05F6A:  CLRF   x7C
05F6C:  MOVFF  877,87D
05F70:  CLRF   x7E
05F72:  MOVFF  877,87B
05F76:  MOVFF  87E,87C
05F7A:  CLRF   x7D
05F7C:  CLRF   x7E
05F7E:  MOVFF  877,88D
05F82:  MOVLW  08
05F84:  MOVWF  x8E
05F86:  MOVLB  0
05F88:  CALL   56F2
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
05F8C:  MOVLB  8
05F8E:  CLRF   x7B
05F90:  CLRF   x7D
05F92:  CLRF   x7E
05F94:  MOVFF  876,87B
05F98:  MOVFF  87D,87C
05F9C:  MOVFF  87E,87D
05FA0:  CLRF   x7E
05FA2:  MOVFF  876,88D
05FA6:  MOVLW  08
05FA8:  MOVWF  x8E
05FAA:  MOVLB  0
05FAC:  CALL   56F2
.................... 	spi_xfer(starting_address & 0xFF); 
05FB0:  MOVLB  8
05FB2:  MOVFF  875,87B
05FB6:  CLRF   x7C
05FB8:  CLRF   x7D
05FBA:  CLRF   x7E
05FBC:  MOVFF  875,88D
05FC0:  MOVLW  08
05FC2:  MOVWF  x8E
05FC4:  MOVLB  0
05FC6:  CALL   56F2
.................... 		 
.................... 	for (value_counter = 0; value_counter < 256; value_counter++) 
05FCA:  MOVLB  8
05FCC:  CLRF   x7A
05FCE:  CLRF   x79
05FD0:  MOVF   x7A,W
05FD2:  SUBLW  00
05FD4:  BNC   5FFE
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
05FD6:  MOVF   x71,W
05FD8:  ADDWF  x79,W
05FDA:  MOVWF  FE9
05FDC:  MOVF   x72,W
05FDE:  ADDWFC x7A,W
05FE0:  MOVWF  FEA
05FE2:  MOVFF  FEF,87B
05FE6:  MOVFF  87B,88D
05FEA:  MOVLW  08
05FEC:  MOVWF  x8E
05FEE:  MOVLB  0
05FF0:  CALL   56F2
.................... 	} 
05FF4:  MOVLB  8
05FF6:  INCF   x79,F
05FF8:  BTFSC  FD8.2
05FFA:  INCF   x7A,F
05FFC:  BRA    5FD0
....................  
.................... 	output_high(FLASH_CS); 
05FFE:  BCF    F95.2
06000:  BSF    F8C.2
....................  
.................... 	flash_wait_while_busy(); 
06002:  MOVLB  0
06004:  CALL   57CE
.................... } 
06008:  RETURN 0
....................  
.................... void write_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
*
0736E:  MOVLB  8
07370:  CLRF   x6D
07372:  CLRF   x6C
07374:  MOVF   x6D,W
07376:  SUBLW  00
07378:  BNC   73BA
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
0737A:  DECFSZ x6B,W
0737C:  BRA    739A
.................... 			fputc(ptr[value_counter],USB); 
0737E:  MOVF   x69,W
07380:  ADDWF  x6C,W
07382:  MOVWF  FE9
07384:  MOVF   x6A,W
07386:  ADDWFC x6D,W
07388:  MOVWF  FEA
0738A:  MOVFF  FEF,86E
0738E:  MOVFF  86E,872
07392:  MOVLB  0
07394:  RCALL  6DBC
.................... 		} else { 
07396:  BRA    73B0
07398:  MOVLB  8
.................... 			fputc(ptr[value_counter],RS232); 
0739A:  MOVF   x69,W
0739C:  ADDWF  x6C,W
0739E:  MOVWF  FE9
073A0:  MOVF   x6A,W
073A2:  ADDWFC x6D,W
073A4:  MOVWF  FEA
073A6:  MOVFF  FEF,86E
073AA:  MOVF   x6E,W
073AC:  MOVLB  0
073AE:  RCALL  7366
.................... 		} 
.................... 	}	 
073B0:  MOVLB  8
073B2:  INCF   x6C,F
073B4:  BTFSC  FD8.2
073B6:  INCF   x6D,F
073B8:  BRA    7374
.................... } 
073BA:  MOVLB  0
073BC:  GOTO   8C20 (RETURN)
....................  
.................... void print_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
.................... 			fprintf(USB,"%x",ptr[value_counter]); 
.................... 		} else { 
.................... 			fprintf(RS232,"%x",ptr[value_counter]); 
....................  
.................... 			if((value_counter % 4) == 3) { 
.................... 				fprintf(RS232," ");	 
.................... 			} 
....................  
.................... 			if((value_counter % 32) == 31) { 
.................... 				fprintf(RS232,"\r\n");	 
.................... 			} 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void print_flash_page_buffer(int *ptr) 
.................... { 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
....................  
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... } 
....................  
....................  
....................  
.................... #include <errorlist.h> 
....................  #define ERR_START 						0x15 
....................  
....................  #define ERR_INVALID_START 				0x02 
....................  
....................  #define ERR_UNKNOWN 					0x09 
....................  
....................  #define ERR_COMMAND_TIMEOUT 			0x10 
....................  #define ERR_COMMAND_INVALID			0x13 
....................  
....................  #define ERR_END_TIMEOUT 				0x11 
....................  #define ERR_END_INVALID 				0x12 
....................  
....................   
....................  #define ERR_ADDR_TIMEOUT 				0x14 
....................  #define ERR_ADDR_INVALID 				0x16 
....................  
....................  #define ERR_DATA_TIMEOUT 				0x17 
....................  #define ERR_DATA_INVALID 				0x17 
....................  
....................  #define ERR_PHANTOM_BOOL_TIMEOUT		0x18 
....................  #define ERR_PHANTOM_BOOL_INVALID 		0x19 
....................  
....................  #define ERR_PHANTOM_CH_TIMEOUT 		0x20 
....................  #define ERR_PHANTOM_CH_INVALID 		0x21 
....................  
....................  #define ERR_VOL_CH_TIMEOUT				0x22 
....................  #define ERR_VOL_CH_INVALID				0x23 
....................  
....................  #define ERR_VOL_TIMEOUT				0x24 
....................  #define ERR_VOL_INVALID				0x25 
....................  
....................  #define ERR_RS232_CH_TIMEOUT			0x26 
....................  #define ERR_RS232_CH_INVALID			0x27 
....................  
....................  #define ERR_RS232_DATA_TIMEOUT			0x28 
....................  #define ERR_RS232_DATA_INVALID			0x29 
....................  
....................  #define ERR_DEVICE_CONFIG_INVALID		0x30 
....................  
....................  
....................  
....................  
.................... #include <dsp_comm.c> 
.................... BYTE dsp_read_buffer[8]; 
....................  
.................... void i2c_write_4byte(int32 fourBytes) { 
*
00D66:  MOVLB  8
00D68:  MOVFF  8C4,8C8
....................  
....................       int byte4 = fourBytes & 0xFF; 
....................       fourBytes = fourBytes >> 8; 
00D6C:  MOVFF  8C5,8C4
00D70:  MOVFF  8C6,8C5
00D74:  MOVFF  8C7,8C6
00D78:  CLRF   xC7
....................     
....................       int byte3 = fourBytes & 0xFF; 
00D7A:  MOVFF  8C4,8C9
....................       fourBytes = fourBytes >> 8; 
00D7E:  MOVFF  8C5,8C4
00D82:  MOVFF  8C6,8C5
00D86:  MOVFF  8C7,8C6
00D8A:  CLRF   xC7
....................     
....................       int byte2 = fourBytes & 0xFF; 
....................     
....................       int byte1 = fourBytes >> 8; 
00D8C:  MOVFF  8C4,8CA
00D90:  MOVFF  8C5,8CB
....................     
....................       i2c_write(byte1); 
00D94:  MOVFF  8CB,8CC
00D98:  MOVLB  0
00D9A:  RCALL  0CF0
....................       i2c_write(byte2);  
00D9C:  MOVFF  8CA,8CC
00DA0:  RCALL  0CF0
....................       i2c_write(byte3); 
00DA2:  MOVFF  8C9,8CC
00DA6:  RCALL  0CF0
....................       i2c_write(byte4); 
00DA8:  MOVFF  8C8,8CC
00DAC:  RCALL  0CF0
....................     
.................... } 
00DAE:  RETURN 0
....................  
.................... void reset_dsp() { 
....................  
.................... 	output_high(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_low(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_high(PIN_DSP_nRESET); 
.................... } 
....................  
....................  
.................... void send_dsp_command(int32 address, int32 command) { 
....................  
....................    i2c_start(); 
00DB0:  BSF    F94.3
00DB2:  MOVLW  03
00DB4:  MOVWF  00
00DB6:  DECFSZ 00,F
00DB8:  BRA    0DB6
00DBA:  BSF    F94.2
00DBC:  MOVLW  03
00DBE:  MOVWF  00
00DC0:  DECFSZ 00,F
00DC2:  BRA    0DC0
00DC4:  BCF    F8B.3
00DC6:  BCF    F94.3
00DC8:  MOVLW  03
00DCA:  MOVWF  00
00DCC:  DECFSZ 00,F
00DCE:  BRA    0DCC
00DD0:  BCF    F8B.2
00DD2:  BCF    F94.2
....................    i2c_write(DSP_I2C_ADDRESS); 
00DD4:  MOVLW  80
00DD6:  MOVLB  8
00DD8:  MOVWF  xCC
00DDA:  MOVLB  0
00DDC:  RCALL  0CF0
....................    i2c_write_4byte(address); 
00DDE:  MOVFF  8BF,8C7
00DE2:  MOVFF  8BE,8C6
00DE6:  MOVFF  8BD,8C5
00DEA:  MOVFF  8BC,8C4
00DEE:  RCALL  0D66
....................    i2c_write_4byte(command); 
00DF0:  MOVFF  8C3,8C7
00DF4:  MOVFF  8C2,8C6
00DF8:  MOVFF  8C1,8C5
00DFC:  MOVFF  8C0,8C4
00E00:  RCALL  0D66
....................    i2c_stop(); 
00E02:  BCF    F94.3
00E04:  NOP   
00E06:  BSF    F94.2
00E08:  BTFSS  F82.2
00E0A:  BRA    0E08
00E0C:  MOVLW  03
00E0E:  MOVWF  00
00E10:  DECFSZ 00,F
00E12:  BRA    0E10
00E14:  BRA    0E16
00E16:  NOP   
00E18:  BSF    F94.3
00E1A:  MOVLW  03
00E1C:  MOVWF  00
00E1E:  DECFSZ 00,F
00E20:  BRA    0E1E
....................  
.................... } 
00E22:  RETURN 0
....................  
....................  
.................... void send_dsp_message(int32 message) { 
....................  
....................    i2c_start(); 
....................    i2c_write(DSP_I2C_ADDRESS); 
....................    i2c_write_4byte(message); 
....................    i2c_stop(); 
.................... } 
....................  
.................... void send_prefixed_dsp_command(int16 address_prefix, int16 address_suffix, int32 command) { 
....................  
....................    i2c_start(); 
*
062A8:  BSF    F94.3
062AA:  MOVLW  03
062AC:  MOVWF  00
062AE:  DECFSZ 00,F
062B0:  BRA    62AE
062B2:  BSF    F94.2
062B4:  MOVLW  03
062B6:  MOVWF  00
062B8:  DECFSZ 00,F
062BA:  BRA    62B8
062BC:  BCF    F8B.3
062BE:  BCF    F94.3
062C0:  MOVLW  03
062C2:  MOVWF  00
062C4:  DECFSZ 00,F
062C6:  BRA    62C4
062C8:  BCF    F8B.2
062CA:  BCF    F94.2
062CC:  CLRF   19
062CE:  BTFSC  FF2.7
062D0:  BSF    19.7
062D2:  BCF    FF2.7
....................    i2c_write(DSP_I2C_ADDRESS); 
062D4:  MOVLW  80
062D6:  MOVLB  8
062D8:  MOVWF  xCC
062DA:  MOVLB  0
062DC:  CALL   0CF0
062E0:  BTFSC  19.7
062E2:  BSF    FF2.7
....................  
....................    int32 address = address_prefix; 
062E4:  MOVLB  8
062E6:  CLRF   x84
062E8:  CLRF   x83
062EA:  MOVFF  87A,882
062EE:  MOVFF  879,881
....................    address <<= 16; 
062F2:  MOVFF  882,884
062F6:  MOVFF  881,883
062FA:  CLRF   x81
062FC:  CLRF   x82
....................    address |= address_suffix; 
062FE:  MOVF   x7B,W
06300:  IORWF  x81,F
06302:  MOVF   x7C,W
06304:  IORWF  x82,F
06306:  CLRF   19
06308:  BTFSC  FF2.7
0630A:  BSF    19.7
0630C:  BCF    FF2.7
....................    i2c_write_4byte(address); 
0630E:  MOVFF  884,8C7
06312:  MOVFF  883,8C6
06316:  MOVFF  882,8C5
0631A:  MOVFF  881,8C4
0631E:  MOVLB  0
06320:  CALL   0D66
06324:  BTFSC  19.7
06326:  BSF    FF2.7
06328:  CLRF   19
0632A:  BTFSC  FF2.7
0632C:  BSF    19.7
0632E:  BCF    FF2.7
....................    i2c_write_4byte(command); 
06330:  MOVFF  880,8C7
06334:  MOVFF  87F,8C6
06338:  MOVFF  87E,8C5
0633C:  MOVFF  87D,8C4
06340:  CALL   0D66
06344:  BTFSC  19.7
06346:  BSF    FF2.7
....................    i2c_stop(); 
06348:  BCF    F94.3
0634A:  NOP   
0634C:  BSF    F94.2
0634E:  BTFSS  F82.2
06350:  BRA    634E
06352:  MOVLW  03
06354:  MOVWF  00
06356:  DECFSZ 00,F
06358:  BRA    6356
0635A:  BRA    635C
0635C:  NOP   
0635E:  BSF    F94.3
06360:  MOVLW  03
06362:  MOVWF  00
06364:  DECFSZ 00,F
06366:  BRA    6364
....................  
.................... } 
06368:  RETURN 0
....................  
.................... int read_dsp_int_prefixed(int16 address_prefix,int16 address_suffix) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	int32 address = address_prefix; 
....................    	address <<= 16; 
....................    	address |= address_suffix; 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
....................  
.................... 	return dsp_read_buffer[7]; 
.................... } 
....................  
....................  
.................... void read_dsp_and_send_to_usb(int32 address) 
.................... { 
.................... 	i2c_start(); 
*
06F16:  BSF    F94.3
06F18:  MOVLW  03
06F1A:  MOVWF  00
06F1C:  DECFSZ 00,F
06F1E:  BRA    6F1C
06F20:  BSF    F94.2
06F22:  MOVLW  03
06F24:  MOVWF  00
06F26:  DECFSZ 00,F
06F28:  BRA    6F26
06F2A:  BCF    F8B.3
06F2C:  BCF    F94.3
06F2E:  MOVLW  03
06F30:  MOVWF  00
06F32:  DECFSZ 00,F
06F34:  BRA    6F32
06F36:  BCF    F8B.2
06F38:  BCF    F94.2
06F3A:  CLRF   19
06F3C:  BTFSC  FF2.7
06F3E:  BSF    19.7
06F40:  BCF    FF2.7
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
06F42:  MOVLW  80
06F44:  MOVLB  8
06F46:  MOVWF  xCC
06F48:  MOVLB  0
06F4A:  CALL   0CF0
06F4E:  BTFSC  19.7
06F50:  BSF    FF2.7
06F52:  CLRF   19
06F54:  BTFSC  FF2.7
06F56:  BSF    19.7
06F58:  BCF    FF2.7
.................... 	i2c_write_4byte(address); 
06F5A:  MOVFF  86C,8C7
06F5E:  MOVFF  86B,8C6
06F62:  MOVFF  86A,8C5
06F66:  MOVFF  869,8C4
06F6A:  CALL   0D66
06F6E:  BTFSC  19.7
06F70:  BSF    FF2.7
.................... 	i2c_stop(); 
06F72:  BCF    F94.3
06F74:  NOP   
06F76:  BSF    F94.2
06F78:  BTFSS  F82.2
06F7A:  BRA    6F78
06F7C:  MOVLW  03
06F7E:  MOVWF  00
06F80:  DECFSZ 00,F
06F82:  BRA    6F80
06F84:  BRA    6F86
06F86:  NOP   
06F88:  BSF    F94.3
06F8A:  MOVLW  03
06F8C:  MOVWF  00
06F8E:  DECFSZ 00,F
06F90:  BRA    6F8E
....................  
.................... 	delay_ms(1); 
06F92:  MOVLW  01
06F94:  MOVLB  8
06F96:  MOVWF  x74
06F98:  MOVLB  0
06F9A:  CALL   5A08
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
06F9E:  BSF    F93.2
06FA0:  BTFSC  F81.2
06FA2:  BRA    70A4
....................  
.................... 		i2c_start(); 
06FA4:  BSF    F94.3
06FA6:  MOVLW  03
06FA8:  MOVWF  00
06FAA:  DECFSZ 00,F
06FAC:  BRA    6FAA
06FAE:  BSF    F94.2
06FB0:  MOVLW  03
06FB2:  MOVWF  00
06FB4:  DECFSZ 00,F
06FB6:  BRA    6FB4
06FB8:  BCF    F8B.3
06FBA:  BCF    F94.3
06FBC:  MOVLW  03
06FBE:  MOVWF  00
06FC0:  DECFSZ 00,F
06FC2:  BRA    6FC0
06FC4:  BCF    F8B.2
06FC6:  BCF    F94.2
06FC8:  CLRF   19
06FCA:  BTFSC  FF2.7
06FCC:  BSF    19.7
06FCE:  BCF    FF2.7
....................  
.................... 		if(i2c_write(0x81) == 0) { 
06FD0:  MOVLW  81
06FD2:  MOVLB  8
06FD4:  MOVWF  xCC
06FD6:  MOVLB  0
06FD8:  CALL   0CF0
06FDC:  BTFSC  19.7
06FDE:  BSF    FF2.7
06FE0:  MOVF   01,F
06FE2:  BNZ   7082
....................  
.................... 			for(int i = 0; i < 8; i++) { 
06FE4:  MOVLB  8
06FE6:  CLRF   x6D
06FE8:  MOVF   x6D,W
06FEA:  SUBLW  07
06FEC:  BNC   703A
.................... 				if(i == 7) { 
06FEE:  MOVF   x6D,W
06FF0:  SUBLW  07
06FF2:  BNZ   7010
.................... 					dsp_read_buffer[i] = i2c_read(0); 
06FF4:  CLRF   03
06FF6:  MOVF   x6D,W
06FF8:  ADDLW  CC
06FFA:  MOVWF  FE9
06FFC:  MOVLW  06
06FFE:  ADDWFC 03,W
07000:  MOVWF  FEA
07002:  CLRF   00
07004:  MOVLB  0
07006:  RCALL  6EAC
07008:  MOVFF  01,FEF
.................... 				} else { 
0700C:  BRA    702A
0700E:  MOVLB  8
.................... 					dsp_read_buffer[i] = i2c_read(); 
07010:  CLRF   03
07012:  MOVF   x6D,W
07014:  ADDLW  CC
07016:  MOVWF  FE9
07018:  MOVLW  06
0701A:  ADDWFC 03,W
0701C:  MOVWF  FEA
0701E:  MOVLW  01
07020:  MOVWF  00
07022:  MOVLB  0
07024:  RCALL  6EAC
07026:  MOVFF  01,FEF
.................... 				} 
....................  
.................... 				delay_us(100); 
0702A:  MOVLW  7A
0702C:  MOVWF  00
0702E:  DECFSZ 00,F
07030:  BRA    702E
07032:  NOP   
.................... 			} 
07034:  MOVLB  8
07036:  INCF   x6D,F
07038:  BRA    6FE8
.................... 	 
.................... 			fputc(0x06,USB); 
0703A:  MOVLW  06
0703C:  MOVWF  x72
0703E:  MOVLB  0
07040:  RCALL  6DBC
.................... 			//delay_ms(1); 
.................... 			for(int x = 4; x < 8; x++) { 
07042:  MOVLW  04
07044:  MOVLB  8
07046:  MOVWF  x6E
07048:  MOVF   x6E,W
0704A:  SUBLW  07
0704C:  BNC   706E
.................... 				fputc(dsp_read_buffer[x],USB); 
0704E:  CLRF   03
07050:  MOVF   x6E,W
07052:  ADDLW  CC
07054:  MOVWF  FE9
07056:  MOVLW  06
07058:  ADDWFC 03,W
0705A:  MOVWF  FEA
0705C:  MOVFF  FEF,86F
07060:  MOVFF  86F,872
07064:  MOVLB  0
07066:  RCALL  6DBC
.................... 				//delay_ms(1); 
.................... 			} 
07068:  MOVLB  8
0706A:  INCF   x6E,F
0706C:  BRA    7048
.................... 			//delay_ms(1); 
.................... 			fputc(0x03,USB); 
0706E:  MOVLW  03
07070:  MOVWF  x72
07072:  MOVLB  0
07074:  RCALL  6DBC
.................... 			delay_ms(1); 
07076:  MOVLW  01
07078:  MOVLB  8
0707A:  MOVWF  x74
0707C:  MOVLB  0
0707E:  CALL   5A08
.................... 		} 
....................  
.................... 		i2c_stop(); 
07082:  BCF    F94.3
07084:  NOP   
07086:  BSF    F94.2
07088:  BTFSS  F82.2
0708A:  BRA    7088
0708C:  MOVLW  03
0708E:  MOVWF  00
07090:  DECFSZ 00,F
07092:  BRA    7090
07094:  BRA    7096
07096:  NOP   
07098:  BSF    F94.3
0709A:  MOVLW  03
0709C:  MOVWF  00
0709E:  DECFSZ 00,F
070A0:  BRA    709E
.................... 	} else { 
070A2:  BRA    70A4
.................... 		//fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
070A4:  GOTO   89BC (RETURN)
....................  
.................... void read_dsp_and_send_to_rs232(int32 address) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 	 
.................... 			fprintf(RS232,"Read:"); 
.................... 			for(int x = 4; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
.................... void read_unsolicited_DSP_message() 
.................... { 
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_us(100); 
.................... 			} 
.................... 			for(int x = 0; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
....................  
.................... } 
....................  
.................... void load_dsp_values() { 
....................  
.................... /* 
.................... 	for(int16 i = 0; i <= num_dsp_values; i++) { 
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(i),READ_CONFIG_VALUE(i)); 
.................... 		//delay_ms(2);	 
.................... 	} 
.................... */ 
.................... } 
....................  
.................... void dsp_mute_outputs() 
.................... { 
*
0636A:  CLRF   19
0636C:  BTFSC  FF2.7
0636E:  BSF    19.7
06370:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x00000000); 
06372:  MOVLW  83
06374:  MOVLB  8
06376:  MOVWF  xBF
06378:  CLRF   xBE
0637A:  CLRF   xBD
0637C:  CLRF   xBC
0637E:  CLRF   xC3
06380:  CLRF   xC2
06382:  CLRF   xC1
06384:  CLRF   xC0
06386:  MOVLB  0
06388:  CALL   0DB0
0638C:  BTFSC  19.7
0638E:  BSF    FF2.7
.................... } 
06390:  GOTO   69B6 (RETURN)
....................  
.................... void dsp_unmute_outputs() 
.................... { 
*
066F2:  CLRF   19
066F4:  BTFSC  FF2.7
066F6:  BSF    19.7
066F8:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x08000000); 
066FA:  MOVLW  83
066FC:  MOVLB  8
066FE:  MOVWF  xBF
06700:  CLRF   xBE
06702:  CLRF   xBD
06704:  CLRF   xBC
06706:  MOVLW  08
06708:  MOVWF  xC3
0670A:  CLRF   xC2
0670C:  CLRF   xC1
0670E:  CLRF   xC0
06710:  MOVLB  0
06712:  CALL   0DB0
06716:  BTFSC  19.7
06718:  BSF    FF2.7
.................... } 
0671A:  RETURN 0
....................  
.................... void send_flash_program_to_dsp_buffered(int prog_index) 
.................... { 
*
06578:  MOVLB  8
0657A:  CLRF   x70
0657C:  CLRF   x6F
.................... 	int16 overall_counter = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
0657E:  CLRF   x71
06580:  MOVF   x71,W
06582:  SUBLW  07
06584:  BTFSS  FD8.0
06586:  BRA    66EC
....................  
.................... 		read_flash_page_into_buffer(&PAGE_BUFFER_A,prog_index,sector_counter); 
06588:  CLRF   x74
0658A:  MOVLW  CE
0658C:  MOVWF  x73
0658E:  MOVFF  86E,875
06592:  MOVFF  871,876
06596:  MOVLB  0
06598:  RCALL  5E08
....................  
.................... 		for(int i = 0; i < 64; i++) { 
0659A:  MOVLB  8
0659C:  CLRF   x72
0659E:  MOVF   x72,W
065A0:  SUBLW  3F
065A2:  BTFSS  FD8.0
065A4:  BRA    66E8
.................... 			if(PAGE_BUFFER_A[i] == 0xFFFFFFFF) { 
065A6:  MOVF   x72,W
065A8:  MULLW  04
065AA:  MOVF   FF3,W
065AC:  CLRF   03
065AE:  ADDLW  CE
065B0:  MOVWF  FE9
065B2:  MOVLW  00
065B4:  ADDWFC 03,W
065B6:  MOVWF  FEA
065B8:  MOVFF  FEF,873
065BC:  MOVFF  FEC,874
065C0:  MOVFF  FEC,875
065C4:  MOVFF  FEC,876
065C8:  INCFSZ x73,W
065CA:  BRA    65DA
065CC:  INCFSZ x74,W
065CE:  BRA    65DA
065D0:  INCFSZ x75,W
065D2:  BRA    65DA
065D4:  INCFSZ x76,W
065D6:  BRA    65DA
.................... 				break; 
065D8:  BRA    66E8
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT0) { 
065DA:  MOVFF  870,874
065DE:  MOVFF  86F,873
065E2:  MOVLB  0
065E4:  RCALL  6394
065E6:  MOVFF  02,874
065EA:  MOVFF  01,873
065EE:  MOVLB  8
065F0:  MOVF   01,W
065F2:  SUBLW  7E
065F4:  BNZ   6604
065F6:  MOVF   x74,W
065F8:  SUBLW  02
065FA:  BNZ   6604
.................... 				overall_counter++; 
065FC:  INCF   x6F,F
065FE:  BTFSC  FD8.2
06600:  INCF   x70,F
.................... 				continue;	 
06602:  BRA    66E4
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT1) { 
06604:  MOVFF  870,874
06608:  MOVFF  86F,873
0660C:  MOVLB  0
0660E:  RCALL  6394
06610:  MOVFF  02,874
06614:  MOVFF  01,873
06618:  MOVLB  8
0661A:  MOVF   01,W
0661C:  SUBLW  7F
0661E:  BNZ   662E
06620:  MOVF   x74,W
06622:  SUBLW  02
06624:  BNZ   662E
.................... 				overall_counter++; 
06626:  INCF   x6F,F
06628:  BTFSC  FD8.2
0662A:  INCF   x70,F
.................... 				continue;	 
0662C:  BRA    66E4
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT2) { 
0662E:  MOVFF  870,874
06632:  MOVFF  86F,873
06636:  MOVLB  0
06638:  RCALL  6394
0663A:  MOVFF  02,874
0663E:  MOVFF  01,873
06642:  MOVLB  8
06644:  MOVF   01,W
06646:  SUBLW  80
06648:  BNZ   6658
0664A:  MOVF   x74,W
0664C:  SUBLW  02
0664E:  BNZ   6658
.................... 				overall_counter++; 
06650:  INCF   x6F,F
06652:  BTFSC  FD8.2
06654:  INCF   x70,F
.................... 				continue;	 
06656:  BRA    66E4
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT3) { 
06658:  MOVFF  870,874
0665C:  MOVFF  86F,873
06660:  MOVLB  0
06662:  RCALL  6394
06664:  MOVFF  02,874
06668:  MOVFF  01,873
0666C:  MOVLB  8
0666E:  MOVF   01,W
06670:  SUBLW  81
06672:  BNZ   6682
06674:  MOVF   x74,W
06676:  SUBLW  02
06678:  BNZ   6682
.................... 				overall_counter++; 
0667A:  INCF   x6F,F
0667C:  BTFSC  FD8.2
0667E:  INCF   x70,F
.................... 				continue;	 
06680:  BRA    66E4
.................... 			} 
....................  
....................  
.................... 			send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(overall_counter),PAGE_BUFFER_A[i]); 
06682:  MOVFF  870,874
06686:  MOVFF  86F,873
0668A:  MOVLB  0
0668C:  RCALL  6394
0668E:  MOVFF  02,874
06692:  MOVFF  01,873
06696:  MOVLB  8
06698:  MOVF   x72,W
0669A:  MULLW  04
0669C:  MOVF   FF3,W
0669E:  CLRF   03
066A0:  ADDLW  CE
066A2:  MOVWF  FE9
066A4:  MOVLW  00
066A6:  ADDWFC 03,W
066A8:  MOVWF  FEA
066AA:  MOVFF  FEF,875
066AE:  MOVFF  FEC,876
066B2:  MOVFF  FEC,877
066B6:  MOVFF  FEC,878
066BA:  MOVLW  F0
066BC:  MOVWF  x7A
066BE:  CLRF   x79
066C0:  MOVFF  02,87C
066C4:  MOVFF  01,87B
066C8:  MOVFF  878,880
066CC:  MOVFF  877,87F
066D0:  MOVFF  876,87E
066D4:  MOVFF  875,87D
066D8:  MOVLB  0
066DA:  RCALL  62A8
.................... 			overall_counter++; 
066DC:  MOVLB  8
066DE:  INCF   x6F,F
066E0:  BTFSC  FD8.2
066E2:  INCF   x70,F
.................... 		} 
066E4:  INCF   x72,F
066E6:  BRA    659E
....................  
.................... 		 
.................... 	} 
066E8:  INCF   x71,F
066EA:  BRA    6580
.................... } 
066EC:  MOVLB  0
066EE:  GOTO   69BC (RETURN)
....................  
....................  
.................... #include <debug.c> 
.................... // file debug.c 
....................  
.................... #include <eeprom.c> 
.................... #byte INTCON=0xFF2 //Change for a 16 chip  
.................... #bit INT_GIE=INTCON.7  
....................  
....................  
.................... void write_int16_eeprom(int16 address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
05D28:  MOVLB  8
05D2A:  CLRF   x7B
05D2C:  MOVF   x7B,W
05D2E:  SUBLW  01
05D30:  BNC   5D92
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
05D32:  MOVF   x7B,W
05D34:  ADDWF  x77,W
05D36:  MOVWF  x7C
05D38:  MOVLW  00
05D3A:  ADDWFC x78,W
05D3C:  MOVWF  x7D
05D3E:  MOVLW  08
05D40:  MOVWF  x7F
05D42:  MOVLW  79
05D44:  MOVWF  x7E
05D46:  MOVF   x7B,W
05D48:  ADDWF  x7E,W
05D4A:  MOVWF  01
05D4C:  MOVLW  00
05D4E:  ADDWFC x7F,W
05D50:  MOVWF  03
05D52:  MOVF   01,W
05D54:  MOVWF  FE9
05D56:  MOVFF  03,FEA
05D5A:  MOVFF  FEF,87E
05D5E:  MOVFF  87D,FAA
05D62:  MOVFF  87C,FA9
05D66:  MOVFF  87E,FA8
05D6A:  BCF    FA6.6
05D6C:  BCF    FA6.7
05D6E:  BSF    FA6.2
05D70:  MOVF   FF2,W
05D72:  MOVWF  00
05D74:  BCF    FF2.7
05D76:  MOVLB  F
05D78:  MOVLW  55
05D7A:  MOVWF  FA7
05D7C:  MOVLW  AA
05D7E:  MOVWF  FA7
05D80:  BSF    FA6.1
05D82:  BTFSC  FA6.1
05D84:  BRA    5D82
05D86:  BCF    FA6.2
05D88:  MOVF   00,W
05D8A:  IORWF  FF2,F
....................    } 
05D8C:  MOVLB  8
05D8E:  INCF   x7B,F
05D90:  BRA    5D2C
.................... } 
05D92:  MOVLB  0
05D94:  GOTO   5DE8 (RETURN)
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(int16 address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
05C5A:  MOVLB  8
05C5C:  CLRF   x32
05C5E:  MOVF   x32,W
05C60:  SUBLW  01
05C62:  BNC   5CAC
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
05C64:  MOVLW  08
05C66:  MOVWF  x36
05C68:  MOVLW  33
05C6A:  MOVWF  x35
05C6C:  MOVF   x32,W
05C6E:  ADDWF  x35,W
05C70:  MOVWF  01
05C72:  MOVLW  00
05C74:  ADDWFC x36,W
05C76:  MOVWF  03
05C78:  MOVF   01,W
05C7A:  MOVWF  FE9
05C7C:  MOVFF  03,FEA
05C80:  MOVF   x32,W
05C82:  ADDWF  x30,W
05C84:  MOVWF  x37
05C86:  MOVLW  00
05C88:  ADDWFC x31,W
05C8A:  MOVWF  x38
05C8C:  MOVFF  FF2,839
05C90:  BCF    FF2.7
05C92:  MOVFF  838,FAA
05C96:  MOVFF  837,FA9
05C9A:  BCF    FA6.6
05C9C:  BCF    FA6.7
05C9E:  BSF    FA6.0
05CA0:  MOVF   FA8,W
05CA2:  BTFSC  x39.7
05CA4:  BSF    FF2.7
05CA6:  MOVWF  FEF
....................    } 
05CA8:  INCF   x32,F
05CAA:  BRA    5C5E
....................  
....................    return(data); 
05CAC:  MOVFF  833,01
05CB0:  MOVFF  834,02
.................... } 
05CB4:  MOVLB  0
05CB6:  GOTO   5D04 (RETURN)
....................  
....................  
.................... void INTEEPROM_GET(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
05CBA:  MOVLB  8
05CBC:  BCF    x2B.0
05CBE:  BTFSC  FF2.7
05CC0:  BSF    x2B.0
....................    for (count=0;count<num;count++)  
05CC2:  CLRF   x2A
05CC4:  CLRF   x29
05CC6:  MOVF   x2A,W
05CC8:  SUBWF  x26,W
05CCA:  BNC   5D22
05CCC:  BNZ   5CD4
05CCE:  MOVF   x25,W
05CD0:  SUBWF  x29,W
05CD2:  BC    5D22
....................    {  
....................       disable_interrupts(global);  
05CD4:  BCF    FF2.6
05CD6:  BCF    FF2.7
05CD8:  BTFSC  FF2.7
05CDA:  BRA    5CD6
....................       ptr[count]=read_int16_eeprom(addr+count);  
05CDC:  MOVF   x23,W
05CDE:  ADDWF  x29,W
05CE0:  MOVWF  01
05CE2:  MOVF   x24,W
05CE4:  ADDWFC x2A,W
05CE6:  MOVWF  03
05CE8:  MOVFF  01,82C
05CEC:  MOVWF  x2D
05CEE:  MOVF   x29,W
05CF0:  ADDWF  x27,W
05CF2:  MOVWF  x2E
05CF4:  MOVF   x2A,W
05CF6:  ADDWFC x28,W
05CF8:  MOVWF  x2F
05CFA:  MOVWF  x31
05CFC:  MOVFF  82E,830
05D00:  MOVLB  0
05D02:  BRA    5C5A
05D04:  MOVFF  82D,FEA
05D08:  MOVFF  82C,FE9
05D0C:  MOVFF  01,FEF
....................       if (int_enabled) enable_interrupts(global);  
05D10:  MOVLB  8
05D12:  BTFSS  x2B.0
05D14:  BRA    5D1A
05D16:  MOVLW  C0
05D18:  IORWF  FF2,F
....................    }  
05D1A:  INCF   x29,F
05D1C:  BTFSC  FD8.2
05D1E:  INCF   x2A,F
05D20:  BRA    5CC6
.................... }  
05D22:  MOVLB  0
05D24:  GOTO   61FC (RETURN)
....................  
.................... void INTEEPROM_PUT(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
*
05D98:  MOVLB  8
05D9A:  BCF    x73.0
05D9C:  BTFSC  FF2.7
05D9E:  BSF    x73.0
....................    for (count=0;count<num;count++)  
05DA0:  CLRF   x72
05DA2:  CLRF   x71
05DA4:  MOVF   x72,W
05DA6:  SUBWF  x6E,W
05DA8:  BNC   5E04
05DAA:  BNZ   5DB2
05DAC:  MOVF   x6D,W
05DAE:  SUBWF  x71,W
05DB0:  BC    5E04
....................    {  
....................       disable_interrupts(global);  
05DB2:  BCF    FF2.6
05DB4:  BCF    FF2.7
05DB6:  BTFSC  FF2.7
05DB8:  BRA    5DB4
....................       //WRITE_EEPROM  
.................... 		write_int16_eeprom(addr+count,ptr[count]); 
05DBA:  MOVF   x71,W
05DBC:  ADDWF  x6F,W
05DBE:  MOVWF  x74
05DC0:  MOVF   x72,W
05DC2:  ADDWFC x70,W
05DC4:  MOVWF  x75
05DC6:  MOVF   x6B,W
05DC8:  ADDWF  x71,W
05DCA:  MOVWF  FE9
05DCC:  MOVF   x6C,W
05DCE:  ADDWFC x72,W
05DD0:  MOVWF  FEA
05DD2:  MOVFF  FEF,876
05DD6:  MOVFF  875,878
05DDA:  MOVFF  874,877
05DDE:  CLRF   x7A
05DE0:  MOVFF  876,879
05DE4:  MOVLB  0
05DE6:  BRA    5D28
.................... 		delay_ms(3); 
05DE8:  MOVLW  03
05DEA:  MOVLB  8
05DEC:  MOVWF  x74
05DEE:  MOVLB  0
05DF0:  RCALL  5A08
....................       if (int_enabled) enable_interrupts(global);  
05DF2:  MOVLB  8
05DF4:  BTFSS  x73.0
05DF6:  BRA    5DFC
05DF8:  MOVLW  C0
05DFA:  IORWF  FF2,F
....................    } 
05DFC:  INCF   x71,F
05DFE:  BTFSC  FD8.2
05E00:  INCF   x72,F
05E02:  BRA    5DA4
.................... }  
05E04:  MOVLB  0
05E06:  RETURN 0
....................  
....................  
.................... void INTEEPROM_GET8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       ptr[count]=read_eeprom(addr+count);  
....................       if (int_enabled) enable_interrupts(global);  
....................    }  
.................... }  
....................  
.................... void INTEEPROM_PUT8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       //WRITE_EEPROM  
.................... 		write_eeprom(addr+count,ptr[count]); 
.................... 		delay_ms(3); 
....................       if (int_enabled) enable_interrupts(global);  
....................    } 
.................... }  
....................  
.................... void default_addr() 
.................... { 
.................... 	WRITE_CONFIG_ADDRESS(0, PREGAIN_CH1);     	// PREGAIN_CH1 
*
02C7A:  MOVLB  8
02C7C:  CLRF   x22
02C7E:  CLRF   x21
02C80:  MOVLW  03
02C82:  MOVWF  x24
02C84:  MOVLW  73
02C86:  MOVWF  x23
02C88:  MOVLB  0
02C8A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(1, PREGAIN_MUTE_CH1);  // PREGAIN_MUTE_CH1 
02C8C:  MOVLB  8
02C8E:  CLRF   x22
02C90:  MOVLW  01
02C92:  MOVWF  x21
02C94:  MOVLW  04
02C96:  MOVWF  x24
02C98:  MOVLW  43
02C9A:  MOVWF  x23
02C9C:  MOVLB  0
02C9E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(2, PREGAIN_CH2);     	// PREGAIN_CH2 
02CA0:  MOVLB  8
02CA2:  CLRF   x22
02CA4:  MOVLW  02
02CA6:  MOVWF  x21
02CA8:  MOVLW  03
02CAA:  MOVWF  x24
02CAC:  MOVLW  CF
02CAE:  MOVWF  x23
02CB0:  MOVLB  0
02CB2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(3, PREGAIN_MUTE_CH2);  // PREGAIN_MUTE_CH2 
02CB4:  MOVLB  8
02CB6:  CLRF   x22
02CB8:  MOVLW  03
02CBA:  MOVWF  x21
02CBC:  MOVLW  04
02CBE:  MOVWF  x24
02CC0:  MOVLW  41
02CC2:  MOVWF  x23
02CC4:  MOVLB  0
02CC6:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(4, PREGAIN_CH3);     	// PREGAIN_CH3 
02CC8:  MOVLB  8
02CCA:  CLRF   x22
02CCC:  MOVLW  04
02CCE:  MOVWF  x21
02CD0:  MOVLW  03
02CD2:  MOVWF  x24
02CD4:  MOVLW  CB
02CD6:  MOVWF  x23
02CD8:  MOVLB  0
02CDA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(5, PREGAIN_MUTE_CH3);  // PREGAIN_MUTE_CH3 
02CDC:  MOVLB  8
02CDE:  CLRF   x22
02CE0:  MOVLW  05
02CE2:  MOVWF  x21
02CE4:  MOVLW  04
02CE6:  MOVWF  x24
02CE8:  MOVLW  3F
02CEA:  MOVWF  x23
02CEC:  MOVLB  0
02CEE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(6, PREGAIN_CH4);     	// PREGAIN_CH4 
02CF0:  MOVLB  8
02CF2:  CLRF   x22
02CF4:  MOVLW  06
02CF6:  MOVWF  x21
02CF8:  MOVLW  03
02CFA:  MOVWF  x24
02CFC:  MOVLW  C7
02CFE:  MOVWF  x23
02D00:  MOVLB  0
02D02:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(7, PREGAIN_MUTE_CH4);  // PREGAIN_MUTE_CH4 
02D04:  MOVLB  8
02D06:  CLRF   x22
02D08:  MOVLW  07
02D0A:  MOVWF  x21
02D0C:  MOVLW  04
02D0E:  MOVWF  x24
02D10:  MOVLW  3D
02D12:  MOVWF  x23
02D14:  MOVLB  0
02D16:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(8, PREGAIN_CH5);     	// PREGAIN_CH5 
02D18:  MOVLB  8
02D1A:  CLRF   x22
02D1C:  MOVLW  08
02D1E:  MOVWF  x21
02D20:  MOVLW  03
02D22:  MOVWF  x24
02D24:  MOVLW  C3
02D26:  MOVWF  x23
02D28:  MOVLB  0
02D2A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(9, PREGAIN_MUTE_CH5);  // PREGAIN_MUTE_CH5 
02D2C:  MOVLB  8
02D2E:  CLRF   x22
02D30:  MOVLW  09
02D32:  MOVWF  x21
02D34:  MOVLW  04
02D36:  MOVWF  x24
02D38:  MOVLW  3B
02D3A:  MOVWF  x23
02D3C:  MOVLB  0
02D3E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(10, PREGAIN_CH6);     	// PREGAIN_CH6 
02D40:  MOVLB  8
02D42:  CLRF   x22
02D44:  MOVLW  0A
02D46:  MOVWF  x21
02D48:  MOVLW  03
02D4A:  MOVWF  x24
02D4C:  MOVLW  BF
02D4E:  MOVWF  x23
02D50:  MOVLB  0
02D52:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(11, PREGAIN_MUTE_CH6); // PREGAIN_MUTE_CH6 
02D54:  MOVLB  8
02D56:  CLRF   x22
02D58:  MOVLW  0B
02D5A:  MOVWF  x21
02D5C:  MOVLW  04
02D5E:  MOVWF  x24
02D60:  MOVLW  39
02D62:  MOVWF  x23
02D64:  MOVLB  0
02D66:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(12, PREGAIN_CH7);     	// PREGAIN_CH7 
02D68:  MOVLB  8
02D6A:  CLRF   x22
02D6C:  MOVLW  0C
02D6E:  MOVWF  x21
02D70:  MOVLW  03
02D72:  MOVWF  x24
02D74:  MOVLW  BB
02D76:  MOVWF  x23
02D78:  MOVLB  0
02D7A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(13, PREGAIN_MUTE_CH7); // PREGAIN_MUTE_CH7 
02D7C:  MOVLB  8
02D7E:  CLRF   x22
02D80:  MOVLW  0D
02D82:  MOVWF  x21
02D84:  MOVLW  04
02D86:  MOVWF  x24
02D88:  MOVLW  37
02D8A:  MOVWF  x23
02D8C:  MOVLB  0
02D8E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(14, PREGAIN_CH8);     	// PREGAIN_CH8 
02D90:  MOVLB  8
02D92:  CLRF   x22
02D94:  MOVLW  0E
02D96:  MOVWF  x21
02D98:  MOVLW  03
02D9A:  MOVWF  x24
02D9C:  MOVLW  B7
02D9E:  MOVWF  x23
02DA0:  MOVLB  0
02DA2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(15, PREGAIN_MUTE_CH8); // PREGAIN_MUTE_CH8 
02DA4:  MOVLB  8
02DA6:  CLRF   x22
02DA8:  MOVLW  0F
02DAA:  MOVWF  x21
02DAC:  MOVLW  04
02DAE:  MOVWF  x24
02DB0:  MOVLW  35
02DB2:  MOVWF  x23
02DB4:  MOVLB  0
02DB6:  RCALL  2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(16, PREMIX_CH1);     	// PREMIX_CH1 
02DB8:  MOVLB  8
02DBA:  CLRF   x22
02DBC:  MOVLW  10
02DBE:  MOVWF  x21
02DC0:  MOVLW  03
02DC2:  MOVWF  x24
02DC4:  MOVLW  B3
02DC6:  MOVWF  x23
02DC8:  MOVLB  0
02DCA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(17, PREMIX_MUTE_CH1);  // PREMIX_MUTE_CH1 
02DCC:  MOVLB  8
02DCE:  CLRF   x22
02DD0:  MOVLW  11
02DD2:  MOVWF  x21
02DD4:  MOVLW  04
02DD6:  MOVWF  x24
02DD8:  MOVLW  33
02DDA:  MOVWF  x23
02DDC:  MOVLB  0
02DDE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(18, PREMIX_CH2);     	// PREMIX_CH2 
02DE0:  MOVLB  8
02DE2:  CLRF   x22
02DE4:  MOVLW  12
02DE6:  MOVWF  x21
02DE8:  MOVLW  03
02DEA:  MOVWF  x24
02DEC:  MOVLW  AF
02DEE:  MOVWF  x23
02DF0:  MOVLB  0
02DF2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(19, PREMIX_MUTE_CH2);  // PREMIX_MUTE_CH2 
02DF4:  MOVLB  8
02DF6:  CLRF   x22
02DF8:  MOVLW  13
02DFA:  MOVWF  x21
02DFC:  MOVLW  04
02DFE:  MOVWF  x24
02E00:  MOVLW  31
02E02:  MOVWF  x23
02E04:  MOVLB  0
02E06:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(20, PREMIX_CH3);     	// PREMIX_CH3 
02E08:  MOVLB  8
02E0A:  CLRF   x22
02E0C:  MOVLW  14
02E0E:  MOVWF  x21
02E10:  MOVLW  03
02E12:  MOVWF  x24
02E14:  MOVLW  AB
02E16:  MOVWF  x23
02E18:  MOVLB  0
02E1A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(21, PREMIX_MUTE_CH3);  // PREMIX_MUTE_CH3 
02E1C:  MOVLB  8
02E1E:  CLRF   x22
02E20:  MOVLW  15
02E22:  MOVWF  x21
02E24:  MOVLW  04
02E26:  MOVWF  x24
02E28:  MOVLW  2F
02E2A:  MOVWF  x23
02E2C:  MOVLB  0
02E2E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(22, PREMIX_CH4);     	// PREMIX_CH4 
02E30:  MOVLB  8
02E32:  CLRF   x22
02E34:  MOVLW  16
02E36:  MOVWF  x21
02E38:  MOVLW  03
02E3A:  MOVWF  x24
02E3C:  MOVLW  A7
02E3E:  MOVWF  x23
02E40:  MOVLB  0
02E42:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(23, PREMIX_MUTE_CH4);  // PREMIX_MUTE_CH4 
02E44:  MOVLB  8
02E46:  CLRF   x22
02E48:  MOVLW  17
02E4A:  MOVWF  x21
02E4C:  MOVLW  04
02E4E:  MOVWF  x24
02E50:  MOVLW  2D
02E52:  MOVWF  x23
02E54:  MOVLB  0
02E56:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(24, PREMIX_CH5);     	// PREMIX_CH5 
02E58:  MOVLB  8
02E5A:  CLRF   x22
02E5C:  MOVLW  18
02E5E:  MOVWF  x21
02E60:  MOVLW  03
02E62:  MOVWF  x24
02E64:  MOVLW  A3
02E66:  MOVWF  x23
02E68:  MOVLB  0
02E6A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(25, PREMIX_MUTE_CH5);  // PREMIX_MUTE_CH5 
02E6C:  MOVLB  8
02E6E:  CLRF   x22
02E70:  MOVLW  19
02E72:  MOVWF  x21
02E74:  MOVLW  04
02E76:  MOVWF  x24
02E78:  MOVLW  2B
02E7A:  MOVWF  x23
02E7C:  MOVLB  0
02E7E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(26, PREMIX_CH6);     	// PREMIX_CH6 
02E80:  MOVLB  8
02E82:  CLRF   x22
02E84:  MOVLW  1A
02E86:  MOVWF  x21
02E88:  MOVLW  03
02E8A:  MOVWF  x24
02E8C:  MOVLW  9F
02E8E:  MOVWF  x23
02E90:  MOVLB  0
02E92:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(27, PREMIX_MUTE_CH6);  // PREMIX_MUTE_CH6 
02E94:  MOVLB  8
02E96:  CLRF   x22
02E98:  MOVLW  1B
02E9A:  MOVWF  x21
02E9C:  MOVLW  04
02E9E:  MOVWF  x24
02EA0:  MOVLW  29
02EA2:  MOVWF  x23
02EA4:  MOVLB  0
02EA6:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(28, PREMIX_CH7);     	// PREMIX_CH7 
02EA8:  MOVLB  8
02EAA:  CLRF   x22
02EAC:  MOVLW  1C
02EAE:  MOVWF  x21
02EB0:  MOVLW  03
02EB2:  MOVWF  x24
02EB4:  MOVLW  9B
02EB6:  MOVWF  x23
02EB8:  MOVLB  0
02EBA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(29, PREMIX_MUTE_CH7);  // PREMIX_MUTE_CH7 
02EBC:  MOVLB  8
02EBE:  CLRF   x22
02EC0:  MOVLW  1D
02EC2:  MOVWF  x21
02EC4:  MOVLW  04
02EC6:  MOVWF  x24
02EC8:  MOVLW  27
02ECA:  MOVWF  x23
02ECC:  MOVLB  0
02ECE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(30, PREMIX_CH8);     	// PREMIX_CH8 
02ED0:  MOVLB  8
02ED2:  CLRF   x22
02ED4:  MOVLW  1E
02ED6:  MOVWF  x21
02ED8:  MOVLW  03
02EDA:  MOVWF  x24
02EDC:  MOVLW  97
02EDE:  MOVWF  x23
02EE0:  MOVLB  0
02EE2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(31, PREMIX_MUTE_CH8);  // PREMIX_MUTE_CH8 
02EE4:  MOVLB  8
02EE6:  CLRF   x22
02EE8:  MOVLW  1F
02EEA:  MOVWF  x21
02EEC:  MOVLW  04
02EEE:  MOVWF  x24
02EF0:  MOVLW  25
02EF2:  MOVWF  x23
02EF4:  MOVLB  0
02EF6:  RCALL  2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(32, TRIM_CH1);     	// TRIM_CH1 
02EF8:  MOVLB  8
02EFA:  CLRF   x22
02EFC:  MOVLW  20
02EFE:  MOVWF  x21
02F00:  MOVLW  03
02F02:  MOVWF  x24
02F04:  MOVLW  93
02F06:  MOVWF  x23
02F08:  MOVLB  0
02F0A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(33, TRIM_MUTE_CH1);    // TRIM_MUTE_CH1 
02F0C:  MOVLB  8
02F0E:  CLRF   x22
02F10:  MOVLW  21
02F12:  MOVWF  x21
02F14:  MOVLW  04
02F16:  MOVWF  x24
02F18:  MOVLW  23
02F1A:  MOVWF  x23
02F1C:  MOVLB  0
02F1E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(34, TRIM_CH2);     	// TRIM_CH2 
02F20:  MOVLB  8
02F22:  CLRF   x22
02F24:  MOVLW  22
02F26:  MOVWF  x21
02F28:  MOVLW  03
02F2A:  MOVWF  x24
02F2C:  MOVLW  8F
02F2E:  MOVWF  x23
02F30:  MOVLB  0
02F32:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(35, TRIM_MUTE_CH2);    // TRIM_MUTE_CH2 
02F34:  MOVLB  8
02F36:  CLRF   x22
02F38:  MOVLW  23
02F3A:  MOVWF  x21
02F3C:  MOVLW  04
02F3E:  MOVWF  x24
02F40:  MOVLW  21
02F42:  MOVWF  x23
02F44:  MOVLB  0
02F46:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(36, TRIM_CH3);     	// TRIM_CH3 
02F48:  MOVLB  8
02F4A:  CLRF   x22
02F4C:  MOVLW  24
02F4E:  MOVWF  x21
02F50:  MOVLW  03
02F52:  MOVWF  x24
02F54:  MOVLW  8B
02F56:  MOVWF  x23
02F58:  MOVLB  0
02F5A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(37, TRIM_MUTE_CH3);    // TRIM_MUTE_CH3 
02F5C:  MOVLB  8
02F5E:  CLRF   x22
02F60:  MOVLW  25
02F62:  MOVWF  x21
02F64:  MOVLW  04
02F66:  MOVWF  x24
02F68:  MOVLW  1F
02F6A:  MOVWF  x23
02F6C:  MOVLB  0
02F6E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(38, TRIM_CH4);     	// TRIM_CH4 
02F70:  MOVLB  8
02F72:  CLRF   x22
02F74:  MOVLW  26
02F76:  MOVWF  x21
02F78:  MOVLW  03
02F7A:  MOVWF  x24
02F7C:  MOVLW  87
02F7E:  MOVWF  x23
02F80:  MOVLB  0
02F82:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(39, TRIM_MUTE_CH4);     // TRIM_MUTE_CH4 
02F84:  MOVLB  8
02F86:  CLRF   x22
02F88:  MOVLW  27
02F8A:  MOVWF  x21
02F8C:  MOVLW  04
02F8E:  MOVWF  x24
02F90:  MOVLW  1D
02F92:  MOVWF  x23
02F94:  MOVLB  0
02F96:  RCALL  2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(40, OUTPUTGAIN_CH1);     // OUTPUTGAIN_CH1 
02F98:  MOVLB  8
02F9A:  CLRF   x22
02F9C:  MOVLW  28
02F9E:  MOVWF  x21
02FA0:  MOVLW  03
02FA2:  MOVWF  x24
02FA4:  MOVLW  83
02FA6:  MOVWF  x23
02FA8:  MOVLB  0
02FAA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(41, OUTPUT_MUTE_CH1);     // OUTPUT_MUTE_CH1 
02FAC:  MOVLB  8
02FAE:  CLRF   x22
02FB0:  MOVLW  29
02FB2:  MOVWF  x21
02FB4:  MOVLW  04
02FB6:  MOVWF  x24
02FB8:  MOVLW  1B
02FBA:  MOVWF  x23
02FBC:  MOVLB  0
02FBE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(42, OUTPUTGAIN_CH2);     // OUTPUTGAIN_CH2 
02FC0:  MOVLB  8
02FC2:  CLRF   x22
02FC4:  MOVLW  2A
02FC6:  MOVWF  x21
02FC8:  MOVLW  03
02FCA:  MOVWF  x24
02FCC:  MOVLW  7F
02FCE:  MOVWF  x23
02FD0:  MOVLB  0
02FD2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(43, OUTPUT_MUTE_CH2);     // OUTPUT_MUTE_CH2 
02FD4:  MOVLB  8
02FD6:  CLRF   x22
02FD8:  MOVLW  2B
02FDA:  MOVWF  x21
02FDC:  MOVLW  04
02FDE:  MOVWF  x24
02FE0:  MOVLW  19
02FE2:  MOVWF  x23
02FE4:  MOVLB  0
02FE6:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(44, OUTPUTGAIN_CH3);     // OUTPUTGAIN_CH3 
02FE8:  MOVLB  8
02FEA:  CLRF   x22
02FEC:  MOVLW  2C
02FEE:  MOVWF  x21
02FF0:  MOVLW  03
02FF2:  MOVWF  x24
02FF4:  MOVLW  7B
02FF6:  MOVWF  x23
02FF8:  MOVLB  0
02FFA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(45, OUTPUT_MUTE_CH3);     // OUTPUT_MUTE_CH3 
02FFC:  MOVLB  8
02FFE:  CLRF   x22
03000:  MOVLW  2D
03002:  MOVWF  x21
03004:  MOVLW  04
03006:  MOVWF  x24
03008:  MOVLW  17
0300A:  MOVWF  x23
0300C:  MOVLB  0
0300E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(46, OUTPUTGAIN_CH4);     // OUTPUTGAIN_CH4 
03010:  MOVLB  8
03012:  CLRF   x22
03014:  MOVLW  2E
03016:  MOVWF  x21
03018:  MOVLW  03
0301A:  MOVWF  x24
0301C:  MOVLW  77
0301E:  MOVWF  x23
03020:  MOVLB  0
03022:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(47, OUTPUT_MUTE_CH4);     // OUTPUT_MUTE_CH4 
03024:  MOVLB  8
03026:  CLRF   x22
03028:  MOVLW  2F
0302A:  MOVWF  x21
0302C:  MOVLW  04
0302E:  MOVWF  x24
03030:  MOVLW  15
03032:  MOVWF  x23
03034:  MOVLB  0
03036:  RCALL  2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(48, INDUCKROUTER_SELECT0);     // INDUCKROUTER_SELECT0 
03038:  MOVLB  8
0303A:  CLRF   x22
0303C:  MOVLW  30
0303E:  MOVWF  x21
03040:  MOVLW  02
03042:  MOVWF  x24
03044:  MOVLW  0E
03046:  MOVWF  x23
03048:  MOVLB  0
0304A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(49, INDUCKROUTER_SELECT1);     // INDUCKROUTER_SELECT1 
0304C:  MOVLB  8
0304E:  CLRF   x22
03050:  MOVLW  31
03052:  MOVWF  x21
03054:  MOVLW  02
03056:  MOVWF  x24
03058:  MOVLW  0F
0305A:  MOVWF  x23
0305C:  MOVLB  0
0305E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(50, INDUCKROUTER_SELECT2);     // INDUCKROUTER_SELECT2 
03060:  MOVLB  8
03062:  CLRF   x22
03064:  MOVLW  32
03066:  MOVWF  x21
03068:  MOVLW  02
0306A:  MOVWF  x24
0306C:  MOVLW  10
0306E:  MOVWF  x23
03070:  MOVLB  0
03072:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(51, INDUCKROUTER_SELECT3);     // INDUCKROUTER_SELECT3 
03074:  MOVLB  8
03076:  CLRF   x22
03078:  MOVLW  33
0307A:  MOVWF  x21
0307C:  MOVLW  02
0307E:  MOVWF  x24
03080:  MOVLW  11
03082:  MOVWF  x23
03084:  MOVLB  0
03086:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(52, INDUCKROUTER_SELECT4);     // INDUCKROUTER_SELECT4 
03088:  MOVLB  8
0308A:  CLRF   x22
0308C:  MOVLW  34
0308E:  MOVWF  x21
03090:  MOVLW  02
03092:  MOVWF  x24
03094:  MOVLW  12
03096:  MOVWF  x23
03098:  MOVLB  0
0309A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(53, INDUCKROUTER_SELECT5);     // INDUCKROUTER_SELECT5 
0309C:  MOVLB  8
0309E:  CLRF   x22
030A0:  MOVLW  35
030A2:  MOVWF  x21
030A4:  MOVLW  02
030A6:  MOVWF  x24
030A8:  MOVLW  13
030AA:  MOVWF  x23
030AC:  MOVLB  0
030AE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(54, INDUCKROUTER_SELECT6);     // INDUCKROUTER_SELECT6 
030B0:  MOVLB  8
030B2:  CLRF   x22
030B4:  MOVLW  36
030B6:  MOVWF  x21
030B8:  MOVLW  02
030BA:  MOVWF  x24
030BC:  MOVLW  14
030BE:  MOVWF  x23
030C0:  MOVLB  0
030C2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(55, INDUCKROUTER_SELECT7);     // INDUCKROUTER_SELECT7 
030C4:  MOVLB  8
030C6:  CLRF   x22
030C8:  MOVLW  37
030CA:  MOVWF  x21
030CC:  MOVLW  02
030CE:  MOVWF  x24
030D0:  MOVLW  15
030D2:  MOVWF  x23
030D4:  MOVLB  0
030D6:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(56, OUTDUCKROUTER_SELECT0);     // OUTDUCKROUTER_SELECT0 
030D8:  MOVLB  8
030DA:  CLRF   x22
030DC:  MOVLW  38
030DE:  MOVWF  x21
030E0:  MOVLW  02
030E2:  MOVWF  x24
030E4:  MOVLW  05
030E6:  MOVWF  x23
030E8:  MOVLB  0
030EA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(57, OUTDUCKROUTER_SELECT1);     // OUTDUCKROUTER_SELECT1 
030EC:  MOVLB  8
030EE:  CLRF   x22
030F0:  MOVLW  39
030F2:  MOVWF  x21
030F4:  MOVLW  02
030F6:  MOVWF  x24
030F8:  MOVLW  06
030FA:  MOVWF  x23
030FC:  MOVLB  0
030FE:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(58, OUTDUCKROUTER_SELECT2);     // OUTDUCKROUTER_SELECT2 
03100:  MOVLB  8
03102:  CLRF   x22
03104:  MOVLW  3A
03106:  MOVWF  x21
03108:  MOVLW  02
0310A:  MOVWF  x24
0310C:  MOVLW  07
0310E:  MOVWF  x23
03110:  MOVLB  0
03112:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(59, OUTDUCKROUTER_SELECT3);     // OUTDUCKROUTER_SELECT3 
03114:  MOVLB  8
03116:  CLRF   x22
03118:  MOVLW  3B
0311A:  MOVWF  x21
0311C:  MOVLW  02
0311E:  MOVWF  x24
03120:  MOVLW  08
03122:  MOVWF  x23
03124:  MOVLB  0
03126:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(60, OUTDUCKROUTER_SELECT4);     // OUTDUCKROUTER_SELECT4 
03128:  MOVLB  8
0312A:  CLRF   x22
0312C:  MOVLW  3C
0312E:  MOVWF  x21
03130:  MOVLW  02
03132:  MOVWF  x24
03134:  MOVLW  09
03136:  MOVWF  x23
03138:  MOVLB  0
0313A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(61, OUTDUCKROUTER_SELECT5);     // OUTDUCKROUTER_SELECT5 
0313C:  MOVLB  8
0313E:  CLRF   x22
03140:  MOVLW  3D
03142:  MOVWF  x21
03144:  MOVLW  02
03146:  MOVWF  x24
03148:  MOVLW  0A
0314A:  MOVWF  x23
0314C:  MOVLB  0
0314E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(62, OUTDUCKROUTER_SELECT6);     // OUTDUCKROUTER_SELECT6 
03150:  MOVLB  8
03152:  CLRF   x22
03154:  MOVLW  3E
03156:  MOVWF  x21
03158:  MOVLW  02
0315A:  MOVWF  x24
0315C:  MOVLW  0B
0315E:  MOVWF  x23
03160:  MOVLB  0
03162:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(63, OUTDUCKROUTER_SELECT7);     // OUTDUCKROUTER_SELECT7 
03164:  MOVLB  8
03166:  CLRF   x22
03168:  MOVLW  3F
0316A:  MOVWF  x21
0316C:  MOVLW  02
0316E:  MOVWF  x24
03170:  MOVLW  0C
03172:  MOVWF  x23
03174:  MOVLB  0
03176:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(64, DUCKER_THRESHOLD);     // DUCKER_THRESHOLD 
03178:  MOVLB  8
0317A:  CLRF   x22
0317C:  MOVLW  40
0317E:  MOVWF  x21
03180:  MOVLW  02
03182:  MOVWF  x24
03184:  MOVLW  76
03186:  MOVWF  x23
03188:  MOVLB  0
0318A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(65, DUCKER_HOLD);     // DUCKER_HOLD 
0318C:  MOVLB  8
0318E:  CLRF   x22
03190:  MOVLW  41
03192:  MOVWF  x21
03194:  MOVLW  02
03196:  MOVWF  x24
03198:  MOVLW  77
0319A:  MOVWF  x23
0319C:  MOVLB  0
0319E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(66, DUCKER_DEPTH);     // DUCKER_DEPTH 
031A0:  MOVLB  8
031A2:  CLRF   x22
031A4:  MOVLW  42
031A6:  MOVWF  x21
031A8:  MOVLW  02
031AA:  MOVWF  x24
031AC:  MOVLW  78
031AE:  MOVWF  x23
031B0:  MOVLB  0
031B2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(67, DUCKER_ATTACK);     // DUCKER_ATTACK 
031B4:  MOVLB  8
031B6:  CLRF   x22
031B8:  MOVLW  43
031BA:  MOVWF  x21
031BC:  MOVLW  02
031BE:  MOVWF  x24
031C0:  MOVLW  79
031C2:  MOVWF  x23
031C4:  MOVLB  0
031C6:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(68, DUCKER_RELEASE);     // DUCKER_RELEASE 
031C8:  MOVLB  8
031CA:  CLRF   x22
031CC:  MOVLW  44
031CE:  MOVWF  x21
031D0:  MOVLW  02
031D2:  MOVWF  x24
031D4:  MOVLW  7A
031D6:  MOVWF  x23
031D8:  MOVLB  0
031DA:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(69, DUCKER_BYPASS);     // DUCKER_BYPASS 
031DC:  MOVLB  8
031DE:  CLRF   x22
031E0:  MOVLW  45
031E2:  MOVWF  x21
031E4:  MOVLW  02
031E6:  MOVWF  x24
031E8:  MOVLW  7B
031EA:  MOVWF  x23
031EC:  MOVLB  0
031EE:  RCALL  2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(70, IN_1_1_FILTER_B0);     // IN_1_1_FILTER_B0 
031F0:  MOVLB  8
031F2:  CLRF   x22
031F4:  MOVLW  46
031F6:  MOVWF  x21
031F8:  MOVLW  03
031FA:  MOVWF  x24
031FC:  MOVLW  6D
031FE:  MOVWF  x23
03200:  MOVLB  0
03202:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(71, IN_1_1_FILTER_B1);     // IN_1_1_FILTER_B1 
03204:  MOVLB  8
03206:  CLRF   x22
03208:  MOVLW  47
0320A:  MOVWF  x21
0320C:  MOVLW  03
0320E:  MOVWF  x24
03210:  MOVLW  6E
03212:  MOVWF  x23
03214:  MOVLB  0
03216:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(72, IN_1_1_FILTER_B2);     // IN_1_1_FILTER_B2 
03218:  MOVLB  8
0321A:  CLRF   x22
0321C:  MOVLW  48
0321E:  MOVWF  x21
03220:  MOVLW  03
03222:  MOVWF  x24
03224:  MOVLW  6F
03226:  MOVWF  x23
03228:  MOVLB  0
0322A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(73, IN_1_1_FILTER_MINUSA1);     // IN_1_1_FILTER_MINUSA1 
0322C:  MOVLB  8
0322E:  CLRF   x22
03230:  MOVLW  49
03232:  MOVWF  x21
03234:  MOVLW  03
03236:  MOVWF  x24
03238:  MOVLW  70
0323A:  MOVWF  x23
0323C:  MOVLB  0
0323E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(74, IN_1_1_FILTER_MINUSA2);     // IN_1_1_FILTER_MINUSA2 
03240:  MOVLB  8
03242:  CLRF   x22
03244:  MOVLW  4A
03246:  MOVWF  x21
03248:  MOVLW  03
0324A:  MOVWF  x24
0324C:  MOVLW  71
0324E:  MOVWF  x23
03250:  MOVLB  0
03252:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(75, IN_1_2_FILTER_B0);     // IN_1_2_FILTER_B0 
03254:  MOVLB  8
03256:  CLRF   x22
03258:  MOVLW  4B
0325A:  MOVWF  x21
0325C:  MOVLW  03
0325E:  MOVWF  x24
03260:  MOVLW  68
03262:  MOVWF  x23
03264:  MOVLB  0
03266:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(76, IN_1_2_FILTER_B1);     // IN_1_2_FILTER_B1 
03268:  MOVLB  8
0326A:  CLRF   x22
0326C:  MOVLW  4C
0326E:  MOVWF  x21
03270:  MOVLW  03
03272:  MOVWF  x24
03274:  MOVLW  69
03276:  MOVWF  x23
03278:  MOVLB  0
0327A:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(77, IN_1_2_FILTER_B2);     // IN_1_2_FILTER_B2 
0327C:  MOVLB  8
0327E:  CLRF   x22
03280:  MOVLW  4D
03282:  MOVWF  x21
03284:  MOVLW  03
03286:  MOVWF  x24
03288:  MOVLW  6A
0328A:  MOVWF  x23
0328C:  MOVLB  0
0328E:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(78, IN_1_2_FILTER_MINUSA1);     // IN_1_2_FILTER_MINUSA1 
03290:  MOVLB  8
03292:  CLRF   x22
03294:  MOVLW  4E
03296:  MOVWF  x21
03298:  MOVLW  03
0329A:  MOVWF  x24
0329C:  MOVLW  6B
0329E:  MOVWF  x23
032A0:  MOVLB  0
032A2:  RCALL  2AA8
.................... 	WRITE_CONFIG_ADDRESS(79, IN_1_2_FILTER_MINUSA2);     // IN_1_2_FILTER_MINUSA2 
032A4:  MOVLB  8
032A6:  CLRF   x22
032A8:  MOVLW  4F
032AA:  MOVWF  x21
032AC:  MOVLW  03
032AE:  MOVWF  x24
032B0:  MOVLW  6C
032B2:  MOVWF  x23
032B4:  MOVLB  0
032B6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(80, IN_1_3_FILTER_B0);     // IN_1_3_FILTER_B0 
032BA:  MOVLB  8
032BC:  CLRF   x22
032BE:  MOVLW  50
032C0:  MOVWF  x21
032C2:  MOVLW  03
032C4:  MOVWF  x24
032C6:  MOVLW  63
032C8:  MOVWF  x23
032CA:  MOVLB  0
032CC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(81, IN_1_3_FILTER_B1);     // IN_1_3_FILTER_B1 
032D0:  MOVLB  8
032D2:  CLRF   x22
032D4:  MOVLW  51
032D6:  MOVWF  x21
032D8:  MOVLW  03
032DA:  MOVWF  x24
032DC:  MOVLW  64
032DE:  MOVWF  x23
032E0:  MOVLB  0
032E2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(82, IN_1_3_FILTER_B2);     // IN_1_3_FILTER_B2 
032E6:  MOVLB  8
032E8:  CLRF   x22
032EA:  MOVLW  52
032EC:  MOVWF  x21
032EE:  MOVLW  03
032F0:  MOVWF  x24
032F2:  MOVLW  65
032F4:  MOVWF  x23
032F6:  MOVLB  0
032F8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(83, IN_1_3_FILTER_MINUSA1);     // IN_1_3_FILTER_MINUSA1 
032FC:  MOVLB  8
032FE:  CLRF   x22
03300:  MOVLW  53
03302:  MOVWF  x21
03304:  MOVLW  03
03306:  MOVWF  x24
03308:  MOVLW  66
0330A:  MOVWF  x23
0330C:  MOVLB  0
0330E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(84, IN_1_3_FILTER_MINUSA2);     // IN_1_3_FILTER_MINUSA2 
03312:  MOVLB  8
03314:  CLRF   x22
03316:  MOVLW  54
03318:  MOVWF  x21
0331A:  MOVLW  03
0331C:  MOVWF  x24
0331E:  MOVLW  67
03320:  MOVWF  x23
03322:  MOVLB  0
03324:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(85, IN_2_1_FILTER_B0);     // IN_2_1_FILTER_B0 
03328:  MOVLB  8
0332A:  CLRF   x22
0332C:  MOVLW  55
0332E:  MOVWF  x21
03330:  MOVLW  03
03332:  MOVWF  x24
03334:  MOVLW  5E
03336:  MOVWF  x23
03338:  MOVLB  0
0333A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(86, IN_2_1_FILTER_B1);     // IN_2_1_FILTER_B1 
0333E:  MOVLB  8
03340:  CLRF   x22
03342:  MOVLW  56
03344:  MOVWF  x21
03346:  MOVLW  03
03348:  MOVWF  x24
0334A:  MOVLW  5F
0334C:  MOVWF  x23
0334E:  MOVLB  0
03350:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(87, IN_2_1_FILTER_B2);     // IN_2_1_FILTER_B2 
03354:  MOVLB  8
03356:  CLRF   x22
03358:  MOVLW  57
0335A:  MOVWF  x21
0335C:  MOVLW  03
0335E:  MOVWF  x24
03360:  MOVLW  60
03362:  MOVWF  x23
03364:  MOVLB  0
03366:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(88, IN_2_1_FILTER_MINUSA1);     // IN_2_1_FILTER_MINUSA1 
0336A:  MOVLB  8
0336C:  CLRF   x22
0336E:  MOVLW  58
03370:  MOVWF  x21
03372:  MOVLW  03
03374:  MOVWF  x24
03376:  MOVLW  61
03378:  MOVWF  x23
0337A:  MOVLB  0
0337C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(89, IN_2_1_FILTER_MINUSA2);     // IN_2_1_FILTER_MINUSA2 
03380:  MOVLB  8
03382:  CLRF   x22
03384:  MOVLW  59
03386:  MOVWF  x21
03388:  MOVLW  03
0338A:  MOVWF  x24
0338C:  MOVLW  62
0338E:  MOVWF  x23
03390:  MOVLB  0
03392:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(90, IN_2_2_FILTER_B0);     // IN_2_2_FILTER_B0 
03396:  MOVLB  8
03398:  CLRF   x22
0339A:  MOVLW  5A
0339C:  MOVWF  x21
0339E:  MOVLW  03
033A0:  MOVWF  x24
033A2:  MOVLW  59
033A4:  MOVWF  x23
033A6:  MOVLB  0
033A8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(91, IN_2_2_FILTER_B1);     // IN_2_2_FILTER_B1 
033AC:  MOVLB  8
033AE:  CLRF   x22
033B0:  MOVLW  5B
033B2:  MOVWF  x21
033B4:  MOVLW  03
033B6:  MOVWF  x24
033B8:  MOVLW  5A
033BA:  MOVWF  x23
033BC:  MOVLB  0
033BE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(92, IN_2_2_FILTER_B2);     // IN_2_2_FILTER_B2 
033C2:  MOVLB  8
033C4:  CLRF   x22
033C6:  MOVLW  5C
033C8:  MOVWF  x21
033CA:  MOVLW  03
033CC:  MOVWF  x24
033CE:  MOVLW  5B
033D0:  MOVWF  x23
033D2:  MOVLB  0
033D4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(93, IN_2_2_FILTER_MINUSA1);     // IN_2_2_FILTER_MINUSA1 
033D8:  MOVLB  8
033DA:  CLRF   x22
033DC:  MOVLW  5D
033DE:  MOVWF  x21
033E0:  MOVLW  03
033E2:  MOVWF  x24
033E4:  MOVLW  5C
033E6:  MOVWF  x23
033E8:  MOVLB  0
033EA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(94, IN_2_2_FILTER_MINUSA2);     // IN_2_2_FILTER_MINUSA2 
033EE:  MOVLB  8
033F0:  CLRF   x22
033F2:  MOVLW  5E
033F4:  MOVWF  x21
033F6:  MOVLW  03
033F8:  MOVWF  x24
033FA:  MOVLW  5D
033FC:  MOVWF  x23
033FE:  MOVLB  0
03400:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(95, IN_2_3_FILTER_B0);     // IN_2_3_FILTER_B0 
03404:  MOVLB  8
03406:  CLRF   x22
03408:  MOVLW  5F
0340A:  MOVWF  x21
0340C:  MOVLW  03
0340E:  MOVWF  x24
03410:  MOVLW  54
03412:  MOVWF  x23
03414:  MOVLB  0
03416:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(96, IN_2_3_FILTER_B1);     // IN_2_3_FILTER_B1 
0341A:  MOVLB  8
0341C:  CLRF   x22
0341E:  MOVLW  60
03420:  MOVWF  x21
03422:  MOVLW  03
03424:  MOVWF  x24
03426:  MOVLW  55
03428:  MOVWF  x23
0342A:  MOVLB  0
0342C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(97, IN_2_3_FILTER_B2);     // IN_2_3_FILTER_B2 
03430:  MOVLB  8
03432:  CLRF   x22
03434:  MOVLW  61
03436:  MOVWF  x21
03438:  MOVLW  03
0343A:  MOVWF  x24
0343C:  MOVLW  56
0343E:  MOVWF  x23
03440:  MOVLB  0
03442:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(98, IN_2_3_FILTER_MINUSA1);     // IN_2_3_FILTER_MINUSA1 
03446:  MOVLB  8
03448:  CLRF   x22
0344A:  MOVLW  62
0344C:  MOVWF  x21
0344E:  MOVLW  03
03450:  MOVWF  x24
03452:  MOVLW  57
03454:  MOVWF  x23
03456:  MOVLB  0
03458:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(99, IN_2_3_FILTER_MINUSA2);     // IN_2_3_FILTER_MINUSA2 
0345C:  MOVLB  8
0345E:  CLRF   x22
03460:  MOVLW  63
03462:  MOVWF  x21
03464:  MOVLW  03
03466:  MOVWF  x24
03468:  MOVLW  58
0346A:  MOVWF  x23
0346C:  MOVLB  0
0346E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(100, IN_3_1_FILTER_B0);     // IN_3_1_FILTER_B0 
03472:  MOVLB  8
03474:  CLRF   x22
03476:  MOVLW  64
03478:  MOVWF  x21
0347A:  MOVLW  03
0347C:  MOVWF  x24
0347E:  MOVLW  4F
03480:  MOVWF  x23
03482:  MOVLB  0
03484:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(101, IN_3_1_FILTER_B1);     // IN_3_1_FILTER_B1 
03488:  MOVLB  8
0348A:  CLRF   x22
0348C:  MOVLW  65
0348E:  MOVWF  x21
03490:  MOVLW  03
03492:  MOVWF  x24
03494:  MOVLW  50
03496:  MOVWF  x23
03498:  MOVLB  0
0349A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(102, IN_3_1_FILTER_B2);     // IN_3_1_FILTER_B2 
0349E:  MOVLB  8
034A0:  CLRF   x22
034A2:  MOVLW  66
034A4:  MOVWF  x21
034A6:  MOVLW  03
034A8:  MOVWF  x24
034AA:  MOVLW  51
034AC:  MOVWF  x23
034AE:  MOVLB  0
034B0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(103, IN_3_1_FILTER_MINUSA1);     // IN_3_1_FILTER_MINUSA1 
034B4:  MOVLB  8
034B6:  CLRF   x22
034B8:  MOVLW  67
034BA:  MOVWF  x21
034BC:  MOVLW  03
034BE:  MOVWF  x24
034C0:  MOVLW  52
034C2:  MOVWF  x23
034C4:  MOVLB  0
034C6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(104, IN_3_1_FILTER_MINUSA2);     // IN_3_1_FILTER_MINUSA2 
034CA:  MOVLB  8
034CC:  CLRF   x22
034CE:  MOVLW  68
034D0:  MOVWF  x21
034D2:  MOVLW  03
034D4:  MOVWF  x24
034D6:  MOVLW  53
034D8:  MOVWF  x23
034DA:  MOVLB  0
034DC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(105, IN_3_2_FILTER_B0);     // IN_3_2_FILTER_B0 
034E0:  MOVLB  8
034E2:  CLRF   x22
034E4:  MOVLW  69
034E6:  MOVWF  x21
034E8:  MOVLW  03
034EA:  MOVWF  x24
034EC:  MOVLW  4A
034EE:  MOVWF  x23
034F0:  MOVLB  0
034F2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(106, IN_3_2_FILTER_B1);     // IN_3_2_FILTER_B1 
034F6:  MOVLB  8
034F8:  CLRF   x22
034FA:  MOVLW  6A
034FC:  MOVWF  x21
034FE:  MOVLW  03
03500:  MOVWF  x24
03502:  MOVLW  4B
03504:  MOVWF  x23
03506:  MOVLB  0
03508:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(107, IN_3_2_FILTER_B2);     // IN_3_2_FILTER_B2 
0350C:  MOVLB  8
0350E:  CLRF   x22
03510:  MOVLW  6B
03512:  MOVWF  x21
03514:  MOVLW  03
03516:  MOVWF  x24
03518:  MOVLW  4C
0351A:  MOVWF  x23
0351C:  MOVLB  0
0351E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(108, IN_3_2_FILTER_MINUSA1);     // IN_3_2_FILTER_MINUSA1 
03522:  MOVLB  8
03524:  CLRF   x22
03526:  MOVLW  6C
03528:  MOVWF  x21
0352A:  MOVLW  03
0352C:  MOVWF  x24
0352E:  MOVLW  4D
03530:  MOVWF  x23
03532:  MOVLB  0
03534:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(109, IN_3_2_FILTER_MINUSA2);     // IN_3_2_FILTER_MINUSA2 
03538:  MOVLB  8
0353A:  CLRF   x22
0353C:  MOVLW  6D
0353E:  MOVWF  x21
03540:  MOVLW  03
03542:  MOVWF  x24
03544:  MOVLW  4E
03546:  MOVWF  x23
03548:  MOVLB  0
0354A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(110, IN_3_3_FILTER_B0);     // IN_3_3_FILTER_B0 
0354E:  MOVLB  8
03550:  CLRF   x22
03552:  MOVLW  6E
03554:  MOVWF  x21
03556:  MOVLW  03
03558:  MOVWF  x24
0355A:  MOVLW  45
0355C:  MOVWF  x23
0355E:  MOVLB  0
03560:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(111, IN_3_3_FILTER_B1);     // IN_3_3_FILTER_B1 
03564:  MOVLB  8
03566:  CLRF   x22
03568:  MOVLW  6F
0356A:  MOVWF  x21
0356C:  MOVLW  03
0356E:  MOVWF  x24
03570:  MOVLW  46
03572:  MOVWF  x23
03574:  MOVLB  0
03576:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(112, IN_3_3_FILTER_B2);     // IN_3_3_FILTER_B2 
0357A:  MOVLB  8
0357C:  CLRF   x22
0357E:  MOVLW  70
03580:  MOVWF  x21
03582:  MOVLW  03
03584:  MOVWF  x24
03586:  MOVLW  47
03588:  MOVWF  x23
0358A:  MOVLB  0
0358C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(113, IN_3_3_FILTER_MINUSA1);     // IN_3_3_FILTER_MINUSA1 
03590:  MOVLB  8
03592:  CLRF   x22
03594:  MOVLW  71
03596:  MOVWF  x21
03598:  MOVLW  03
0359A:  MOVWF  x24
0359C:  MOVLW  48
0359E:  MOVWF  x23
035A0:  MOVLB  0
035A2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(114, IN_3_3_FILTER_MINUSA2);     // IN_3_3_FILTER_MINUSA2 
035A6:  MOVLB  8
035A8:  CLRF   x22
035AA:  MOVLW  72
035AC:  MOVWF  x21
035AE:  MOVLW  03
035B0:  MOVWF  x24
035B2:  MOVLW  49
035B4:  MOVWF  x23
035B6:  MOVLB  0
035B8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(115, IN_4_1_FILTER_B0);     // IN_4_1_FILTER_B0 
035BC:  MOVLB  8
035BE:  CLRF   x22
035C0:  MOVLW  73
035C2:  MOVWF  x21
035C4:  MOVLW  03
035C6:  MOVWF  x24
035C8:  MOVLW  40
035CA:  MOVWF  x23
035CC:  MOVLB  0
035CE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(116, IN_4_1_FILTER_B1);     // IN_4_1_FILTER_B1 
035D2:  MOVLB  8
035D4:  CLRF   x22
035D6:  MOVLW  74
035D8:  MOVWF  x21
035DA:  MOVLW  03
035DC:  MOVWF  x24
035DE:  MOVLW  41
035E0:  MOVWF  x23
035E2:  MOVLB  0
035E4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(117, IN_4_1_FILTER_B2);     // IN_4_1_FILTER_B2 
035E8:  MOVLB  8
035EA:  CLRF   x22
035EC:  MOVLW  75
035EE:  MOVWF  x21
035F0:  MOVLW  03
035F2:  MOVWF  x24
035F4:  MOVLW  42
035F6:  MOVWF  x23
035F8:  MOVLB  0
035FA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(118, IN_4_1_FILTER_MINUSA1);     // IN_4_1_FILTER_MINUSA1 
035FE:  MOVLB  8
03600:  CLRF   x22
03602:  MOVLW  76
03604:  MOVWF  x21
03606:  MOVLW  03
03608:  MOVWF  x24
0360A:  MOVLW  43
0360C:  MOVWF  x23
0360E:  MOVLB  0
03610:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(119, IN_4_1_FILTER_MINUSA2);     // IN_4_1_FILTER_MINUSA2 
03614:  MOVLB  8
03616:  CLRF   x22
03618:  MOVLW  77
0361A:  MOVWF  x21
0361C:  MOVLW  03
0361E:  MOVWF  x24
03620:  MOVLW  44
03622:  MOVWF  x23
03624:  MOVLB  0
03626:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(120, IN_4_2_FILTER_B0);     // IN_4_2_FILTER_B0 
0362A:  MOVLB  8
0362C:  CLRF   x22
0362E:  MOVLW  78
03630:  MOVWF  x21
03632:  MOVLW  03
03634:  MOVWF  x24
03636:  MOVLW  3B
03638:  MOVWF  x23
0363A:  MOVLB  0
0363C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(121, IN_4_2_FILTER_B1);     // IN_4_2_FILTER_B1 
03640:  MOVLB  8
03642:  CLRF   x22
03644:  MOVLW  79
03646:  MOVWF  x21
03648:  MOVLW  03
0364A:  MOVWF  x24
0364C:  MOVLW  3C
0364E:  MOVWF  x23
03650:  MOVLB  0
03652:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(122, IN_4_2_FILTER_B2);     // IN_4_2_FILTER_B2 
03656:  MOVLB  8
03658:  CLRF   x22
0365A:  MOVLW  7A
0365C:  MOVWF  x21
0365E:  MOVLW  03
03660:  MOVWF  x24
03662:  MOVLW  3D
03664:  MOVWF  x23
03666:  MOVLB  0
03668:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(123, IN_4_2_FILTER_MINUSA1);     // IN_4_2_FILTER_MINUSA1 
0366C:  MOVLB  8
0366E:  CLRF   x22
03670:  MOVLW  7B
03672:  MOVWF  x21
03674:  MOVLW  03
03676:  MOVWF  x24
03678:  MOVLW  3E
0367A:  MOVWF  x23
0367C:  MOVLB  0
0367E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(124, IN_4_2_FILTER_MINUSA2);     // IN_4_2_FILTER_MINUSA2 
03682:  MOVLB  8
03684:  CLRF   x22
03686:  MOVLW  7C
03688:  MOVWF  x21
0368A:  MOVLW  03
0368C:  MOVWF  x24
0368E:  MOVLW  3F
03690:  MOVWF  x23
03692:  MOVLB  0
03694:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(125, IN_4_3_FILTER_B0);     // IN_4_3_FILTER_B0 
03698:  MOVLB  8
0369A:  CLRF   x22
0369C:  MOVLW  7D
0369E:  MOVWF  x21
036A0:  MOVLW  03
036A2:  MOVWF  x24
036A4:  MOVLW  36
036A6:  MOVWF  x23
036A8:  MOVLB  0
036AA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(126, IN_4_3_FILTER_B1);     // IN_4_3_FILTER_B1 
036AE:  MOVLB  8
036B0:  CLRF   x22
036B2:  MOVLW  7E
036B4:  MOVWF  x21
036B6:  MOVLW  03
036B8:  MOVWF  x24
036BA:  MOVLW  37
036BC:  MOVWF  x23
036BE:  MOVLB  0
036C0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(127, IN_4_3_FILTER_B2);     // IN_4_3_FILTER_B2 
036C4:  MOVLB  8
036C6:  CLRF   x22
036C8:  MOVLW  7F
036CA:  MOVWF  x21
036CC:  MOVLW  03
036CE:  MOVWF  x24
036D0:  MOVLW  38
036D2:  MOVWF  x23
036D4:  MOVLB  0
036D6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(128, IN_4_3_FILTER_MINUSA1);     // IN_4_3_FILTER_MINUSA1 
036DA:  MOVLB  8
036DC:  CLRF   x22
036DE:  MOVLW  80
036E0:  MOVWF  x21
036E2:  MOVLW  03
036E4:  MOVWF  x24
036E6:  MOVLW  39
036E8:  MOVWF  x23
036EA:  MOVLB  0
036EC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(129, IN_4_3_FILTER_MINUSA2);     // IN_4_3_FILTER_MINUSA2 
036F0:  MOVLB  8
036F2:  CLRF   x22
036F4:  MOVLW  81
036F6:  MOVWF  x21
036F8:  MOVLW  03
036FA:  MOVWF  x24
036FC:  MOVLW  3A
036FE:  MOVWF  x23
03700:  MOVLB  0
03702:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(130, IN_5_1_FILTER_B0);     // IN_5_1_FILTER_B0 
03706:  MOVLB  8
03708:  CLRF   x22
0370A:  MOVLW  82
0370C:  MOVWF  x21
0370E:  MOVLW  03
03710:  MOVWF  x24
03712:  MOVLW  31
03714:  MOVWF  x23
03716:  MOVLB  0
03718:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(131, IN_5_1_FILTER_B1);     // IN_5_1_FILTER_B1 
0371C:  MOVLB  8
0371E:  CLRF   x22
03720:  MOVLW  83
03722:  MOVWF  x21
03724:  MOVLW  03
03726:  MOVWF  x24
03728:  MOVLW  32
0372A:  MOVWF  x23
0372C:  MOVLB  0
0372E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(132, IN_5_1_FILTER_B2);     // IN_5_1_FILTER_B2 
03732:  MOVLB  8
03734:  CLRF   x22
03736:  MOVLW  84
03738:  MOVWF  x21
0373A:  MOVLW  03
0373C:  MOVWF  x24
0373E:  MOVLW  33
03740:  MOVWF  x23
03742:  MOVLB  0
03744:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(133, IN_5_1_FILTER_MINUSA1);     // IN_5_1_FILTER_MINUSA1 
03748:  MOVLB  8
0374A:  CLRF   x22
0374C:  MOVLW  85
0374E:  MOVWF  x21
03750:  MOVLW  03
03752:  MOVWF  x24
03754:  MOVLW  34
03756:  MOVWF  x23
03758:  MOVLB  0
0375A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(134, IN_5_1_FILTER_MINUSA2);     // IN_5_1_FILTER_MINUSA2 
0375E:  MOVLB  8
03760:  CLRF   x22
03762:  MOVLW  86
03764:  MOVWF  x21
03766:  MOVLW  03
03768:  MOVWF  x24
0376A:  MOVLW  35
0376C:  MOVWF  x23
0376E:  MOVLB  0
03770:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(135, IN_5_2_FILTER_B0);     // IN_5_2_FILTER_B0 
03774:  MOVLB  8
03776:  CLRF   x22
03778:  MOVLW  87
0377A:  MOVWF  x21
0377C:  MOVLW  03
0377E:  MOVWF  x24
03780:  MOVLW  2C
03782:  MOVWF  x23
03784:  MOVLB  0
03786:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(136, IN_5_2_FILTER_B1);     // IN_5_2_FILTER_B1 
0378A:  MOVLB  8
0378C:  CLRF   x22
0378E:  MOVLW  88
03790:  MOVWF  x21
03792:  MOVLW  03
03794:  MOVWF  x24
03796:  MOVLW  2D
03798:  MOVWF  x23
0379A:  MOVLB  0
0379C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(137, IN_5_2_FILTER_B2);     // IN_5_2_FILTER_B2 
037A0:  MOVLB  8
037A2:  CLRF   x22
037A4:  MOVLW  89
037A6:  MOVWF  x21
037A8:  MOVLW  03
037AA:  MOVWF  x24
037AC:  MOVLW  2E
037AE:  MOVWF  x23
037B0:  MOVLB  0
037B2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(138, IN_5_2_FILTER_MINUSA1);     // IN_5_2_FILTER_MINUSA1 
037B6:  MOVLB  8
037B8:  CLRF   x22
037BA:  MOVLW  8A
037BC:  MOVWF  x21
037BE:  MOVLW  03
037C0:  MOVWF  x24
037C2:  MOVLW  2F
037C4:  MOVWF  x23
037C6:  MOVLB  0
037C8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(139, IN_5_2_FILTER_MINUSA2);     // IN_5_2_FILTER_MINUSA2 
037CC:  MOVLB  8
037CE:  CLRF   x22
037D0:  MOVLW  8B
037D2:  MOVWF  x21
037D4:  MOVLW  03
037D6:  MOVWF  x24
037D8:  MOVLW  30
037DA:  MOVWF  x23
037DC:  MOVLB  0
037DE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(140, IN_5_3_FILTER_B0);     // IN_5_3_FILTER_B0 
037E2:  MOVLB  8
037E4:  CLRF   x22
037E6:  MOVLW  8C
037E8:  MOVWF  x21
037EA:  MOVLW  03
037EC:  MOVWF  x24
037EE:  MOVLW  27
037F0:  MOVWF  x23
037F2:  MOVLB  0
037F4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(141, IN_5_3_FILTER_B1);     // IN_5_3_FILTER_B1 
037F8:  MOVLB  8
037FA:  CLRF   x22
037FC:  MOVLW  8D
037FE:  MOVWF  x21
03800:  MOVLW  03
03802:  MOVWF  x24
03804:  MOVLW  28
03806:  MOVWF  x23
03808:  MOVLB  0
0380A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(142, IN_5_3_FILTER_B2);     // IN_5_3_FILTER_B2 
0380E:  MOVLB  8
03810:  CLRF   x22
03812:  MOVLW  8E
03814:  MOVWF  x21
03816:  MOVLW  03
03818:  MOVWF  x24
0381A:  MOVLW  29
0381C:  MOVWF  x23
0381E:  MOVLB  0
03820:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(143, IN_5_3_FILTER_MINUSA1);     // IN_5_3_FILTER_MINUSA1 
03824:  MOVLB  8
03826:  CLRF   x22
03828:  MOVLW  8F
0382A:  MOVWF  x21
0382C:  MOVLW  03
0382E:  MOVWF  x24
03830:  MOVLW  2A
03832:  MOVWF  x23
03834:  MOVLB  0
03836:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(144, IN_5_3_FILTER_MINUSA2);     // IN_5_3_FILTER_MINUSA2 
0383A:  MOVLB  8
0383C:  CLRF   x22
0383E:  MOVLW  90
03840:  MOVWF  x21
03842:  MOVLW  03
03844:  MOVWF  x24
03846:  MOVLW  2B
03848:  MOVWF  x23
0384A:  MOVLB  0
0384C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(145, IN_6_1_FILTER_B0);     // IN_6_1_FILTER_B0 
03850:  MOVLB  8
03852:  CLRF   x22
03854:  MOVLW  91
03856:  MOVWF  x21
03858:  MOVLW  03
0385A:  MOVWF  x24
0385C:  MOVLW  22
0385E:  MOVWF  x23
03860:  MOVLB  0
03862:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(146, IN_6_1_FILTER_B1);     // IN_6_1_FILTER_B1 
03866:  MOVLB  8
03868:  CLRF   x22
0386A:  MOVLW  92
0386C:  MOVWF  x21
0386E:  MOVLW  03
03870:  MOVWF  x24
03872:  MOVLW  23
03874:  MOVWF  x23
03876:  MOVLB  0
03878:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(147, IN_6_1_FILTER_B2);     // IN_6_1_FILTER_B2 
0387C:  MOVLB  8
0387E:  CLRF   x22
03880:  MOVLW  93
03882:  MOVWF  x21
03884:  MOVLW  03
03886:  MOVWF  x24
03888:  MOVLW  24
0388A:  MOVWF  x23
0388C:  MOVLB  0
0388E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(148, IN_6_1_FILTER_MINUSA1);     // IN_6_1_FILTER_MINUSA1 
03892:  MOVLB  8
03894:  CLRF   x22
03896:  MOVLW  94
03898:  MOVWF  x21
0389A:  MOVLW  03
0389C:  MOVWF  x24
0389E:  MOVLW  25
038A0:  MOVWF  x23
038A2:  MOVLB  0
038A4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(149, IN_6_1_FILTER_MINUSA2);     // IN_6_1_FILTER_MINUSA2 
038A8:  MOVLB  8
038AA:  CLRF   x22
038AC:  MOVLW  95
038AE:  MOVWF  x21
038B0:  MOVLW  03
038B2:  MOVWF  x24
038B4:  MOVLW  26
038B6:  MOVWF  x23
038B8:  MOVLB  0
038BA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(150, IN_6_2_FILTER_B0);     // IN_6_2_FILTER_B0 
038BE:  MOVLB  8
038C0:  CLRF   x22
038C2:  MOVLW  96
038C4:  MOVWF  x21
038C6:  MOVLW  03
038C8:  MOVWF  x24
038CA:  MOVLW  1D
038CC:  MOVWF  x23
038CE:  MOVLB  0
038D0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(151, IN_6_2_FILTER_B1);     // IN_6_2_FILTER_B1 
038D4:  MOVLB  8
038D6:  CLRF   x22
038D8:  MOVLW  97
038DA:  MOVWF  x21
038DC:  MOVLW  03
038DE:  MOVWF  x24
038E0:  MOVLW  1E
038E2:  MOVWF  x23
038E4:  MOVLB  0
038E6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(152, IN_6_2_FILTER_B2);     // IN_6_2_FILTER_B2 
038EA:  MOVLB  8
038EC:  CLRF   x22
038EE:  MOVLW  98
038F0:  MOVWF  x21
038F2:  MOVLW  03
038F4:  MOVWF  x24
038F6:  MOVLW  1F
038F8:  MOVWF  x23
038FA:  MOVLB  0
038FC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(153, IN_6_2_FILTER_MINUSA1);     // IN_6_2_FILTER_MINUSA1 
03900:  MOVLB  8
03902:  CLRF   x22
03904:  MOVLW  99
03906:  MOVWF  x21
03908:  MOVLW  03
0390A:  MOVWF  x24
0390C:  MOVLW  20
0390E:  MOVWF  x23
03910:  MOVLB  0
03912:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(154, IN_6_2_FILTER_MINUSA2);     // IN_6_2_FILTER_MINUSA2 
03916:  MOVLB  8
03918:  CLRF   x22
0391A:  MOVLW  9A
0391C:  MOVWF  x21
0391E:  MOVLW  03
03920:  MOVWF  x24
03922:  MOVLW  21
03924:  MOVWF  x23
03926:  MOVLB  0
03928:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(155, IN_6_3_FILTER_B0);     // IN_6_3_FILTER_B0 
0392C:  MOVLB  8
0392E:  CLRF   x22
03930:  MOVLW  9B
03932:  MOVWF  x21
03934:  MOVLW  03
03936:  MOVWF  x24
03938:  MOVLW  18
0393A:  MOVWF  x23
0393C:  MOVLB  0
0393E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(156, IN_6_3_FILTER_B1);     // IN_6_3_FILTER_B1 
03942:  MOVLB  8
03944:  CLRF   x22
03946:  MOVLW  9C
03948:  MOVWF  x21
0394A:  MOVLW  03
0394C:  MOVWF  x24
0394E:  MOVLW  19
03950:  MOVWF  x23
03952:  MOVLB  0
03954:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(157, IN_6_3_FILTER_B2);     // IN_6_3_FILTER_B2 
03958:  MOVLB  8
0395A:  CLRF   x22
0395C:  MOVLW  9D
0395E:  MOVWF  x21
03960:  MOVLW  03
03962:  MOVWF  x24
03964:  MOVLW  1A
03966:  MOVWF  x23
03968:  MOVLB  0
0396A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(158, IN_6_3_FILTER_MINUSA1);     // IN_6_3_FILTER_MINUSA1 
0396E:  MOVLB  8
03970:  CLRF   x22
03972:  MOVLW  9E
03974:  MOVWF  x21
03976:  MOVLW  03
03978:  MOVWF  x24
0397A:  MOVLW  1B
0397C:  MOVWF  x23
0397E:  MOVLB  0
03980:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(159, IN_6_3_FILTER_MINUSA2);     // IN_6_3_FILTER_MINUSA2 
03984:  MOVLB  8
03986:  CLRF   x22
03988:  MOVLW  9F
0398A:  MOVWF  x21
0398C:  MOVLW  03
0398E:  MOVWF  x24
03990:  MOVLW  1C
03992:  MOVWF  x23
03994:  MOVLB  0
03996:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(160, IN_7_1_FILTER_B0);     // IN_7_1_FILTER_B0 
0399A:  MOVLB  8
0399C:  CLRF   x22
0399E:  MOVLW  A0
039A0:  MOVWF  x21
039A2:  MOVLW  03
039A4:  MOVWF  x24
039A6:  MOVLW  13
039A8:  MOVWF  x23
039AA:  MOVLB  0
039AC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(161, IN_7_1_FILTER_B1);     // IN_7_1_FILTER_B1 
039B0:  MOVLB  8
039B2:  CLRF   x22
039B4:  MOVLW  A1
039B6:  MOVWF  x21
039B8:  MOVLW  03
039BA:  MOVWF  x24
039BC:  MOVLW  14
039BE:  MOVWF  x23
039C0:  MOVLB  0
039C2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(162, IN_7_1_FILTER_B2);     // IN_7_1_FILTER_B2 
039C6:  MOVLB  8
039C8:  CLRF   x22
039CA:  MOVLW  A2
039CC:  MOVWF  x21
039CE:  MOVLW  03
039D0:  MOVWF  x24
039D2:  MOVLW  15
039D4:  MOVWF  x23
039D6:  MOVLB  0
039D8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(163, IN_7_1_FILTER_MINUSA1);     // IN_7_1_FILTER_MINUSA1 
039DC:  MOVLB  8
039DE:  CLRF   x22
039E0:  MOVLW  A3
039E2:  MOVWF  x21
039E4:  MOVLW  03
039E6:  MOVWF  x24
039E8:  MOVLW  16
039EA:  MOVWF  x23
039EC:  MOVLB  0
039EE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(164, IN_7_1_FILTER_MINUSA2);     // IN_7_1_FILTER_MINUSA2 
039F2:  MOVLB  8
039F4:  CLRF   x22
039F6:  MOVLW  A4
039F8:  MOVWF  x21
039FA:  MOVLW  03
039FC:  MOVWF  x24
039FE:  MOVLW  17
03A00:  MOVWF  x23
03A02:  MOVLB  0
03A04:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(165, IN_7_2_FILTER_B0);     // IN_7_2_FILTER_B0 
03A08:  MOVLB  8
03A0A:  CLRF   x22
03A0C:  MOVLW  A5
03A0E:  MOVWF  x21
03A10:  MOVLW  03
03A12:  MOVWF  x24
03A14:  MOVLW  0E
03A16:  MOVWF  x23
03A18:  MOVLB  0
03A1A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(166, IN_7_2_FILTER_B1);     // IN_7_2_FILTER_B1 
03A1E:  MOVLB  8
03A20:  CLRF   x22
03A22:  MOVLW  A6
03A24:  MOVWF  x21
03A26:  MOVLW  03
03A28:  MOVWF  x24
03A2A:  MOVLW  0F
03A2C:  MOVWF  x23
03A2E:  MOVLB  0
03A30:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(167, IN_7_2_FILTER_B2);     // IN_7_2_FILTER_B2 
03A34:  MOVLB  8
03A36:  CLRF   x22
03A38:  MOVLW  A7
03A3A:  MOVWF  x21
03A3C:  MOVLW  03
03A3E:  MOVWF  x24
03A40:  MOVLW  10
03A42:  MOVWF  x23
03A44:  MOVLB  0
03A46:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(168, IN_7_2_FILTER_MINUSA1);     // IN_7_2_FILTER_MINUSA1 
03A4A:  MOVLB  8
03A4C:  CLRF   x22
03A4E:  MOVLW  A8
03A50:  MOVWF  x21
03A52:  MOVLW  03
03A54:  MOVWF  x24
03A56:  MOVLW  11
03A58:  MOVWF  x23
03A5A:  MOVLB  0
03A5C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(169, IN_7_2_FILTER_MINUSA2);     // IN_7_2_FILTER_MINUSA2 
03A60:  MOVLB  8
03A62:  CLRF   x22
03A64:  MOVLW  A9
03A66:  MOVWF  x21
03A68:  MOVLW  03
03A6A:  MOVWF  x24
03A6C:  MOVLW  12
03A6E:  MOVWF  x23
03A70:  MOVLB  0
03A72:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(170, IN_7_3_FILTER_B0);     // IN_7_3_FILTER_B0 
03A76:  MOVLB  8
03A78:  CLRF   x22
03A7A:  MOVLW  AA
03A7C:  MOVWF  x21
03A7E:  MOVLW  03
03A80:  MOVWF  x24
03A82:  MOVLW  09
03A84:  MOVWF  x23
03A86:  MOVLB  0
03A88:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(171, IN_7_3_FILTER_B1);     // IN_7_3_FILTER_B1 
03A8C:  MOVLB  8
03A8E:  CLRF   x22
03A90:  MOVLW  AB
03A92:  MOVWF  x21
03A94:  MOVLW  03
03A96:  MOVWF  x24
03A98:  MOVLW  0A
03A9A:  MOVWF  x23
03A9C:  MOVLB  0
03A9E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(172, IN_7_3_FILTER_B2);     // IN_7_3_FILTER_B2 
03AA2:  MOVLB  8
03AA4:  CLRF   x22
03AA6:  MOVLW  AC
03AA8:  MOVWF  x21
03AAA:  MOVLW  03
03AAC:  MOVWF  x24
03AAE:  MOVLW  0B
03AB0:  MOVWF  x23
03AB2:  MOVLB  0
03AB4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(173, IN_7_3_FILTER_MINUSA1);     // IN_7_3_FILTER_MINUSA1 
03AB8:  MOVLB  8
03ABA:  CLRF   x22
03ABC:  MOVLW  AD
03ABE:  MOVWF  x21
03AC0:  MOVLW  03
03AC2:  MOVWF  x24
03AC4:  MOVLW  0C
03AC6:  MOVWF  x23
03AC8:  MOVLB  0
03ACA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(174, IN_7_3_FILTER_MINUSA2);     // IN_7_3_FILTER_MINUSA2 
03ACE:  MOVLB  8
03AD0:  CLRF   x22
03AD2:  MOVLW  AE
03AD4:  MOVWF  x21
03AD6:  MOVLW  03
03AD8:  MOVWF  x24
03ADA:  MOVLW  0D
03ADC:  MOVWF  x23
03ADE:  MOVLB  0
03AE0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(175, IN_8_1_FILTER_B0);     // IN_8_1_FILTER_B0 
03AE4:  MOVLB  8
03AE6:  CLRF   x22
03AE8:  MOVLW  AF
03AEA:  MOVWF  x21
03AEC:  MOVLW  03
03AEE:  MOVWF  x24
03AF0:  MOVLW  04
03AF2:  MOVWF  x23
03AF4:  MOVLB  0
03AF6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(176, IN_8_1_FILTER_B1);     // IN_8_1_FILTER_B1 
03AFA:  MOVLB  8
03AFC:  CLRF   x22
03AFE:  MOVLW  B0
03B00:  MOVWF  x21
03B02:  MOVLW  03
03B04:  MOVWF  x24
03B06:  MOVLW  05
03B08:  MOVWF  x23
03B0A:  MOVLB  0
03B0C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(177, IN_8_1_FILTER_B2);     // IN_8_1_FILTER_B2 
03B10:  MOVLB  8
03B12:  CLRF   x22
03B14:  MOVLW  B1
03B16:  MOVWF  x21
03B18:  MOVLW  03
03B1A:  MOVWF  x24
03B1C:  MOVLW  06
03B1E:  MOVWF  x23
03B20:  MOVLB  0
03B22:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(178, IN_8_1_FILTER_MINUSA1);     // IN_8_1_FILTER_MINUSA1 
03B26:  MOVLB  8
03B28:  CLRF   x22
03B2A:  MOVLW  B2
03B2C:  MOVWF  x21
03B2E:  MOVLW  03
03B30:  MOVWF  x24
03B32:  MOVLW  07
03B34:  MOVWF  x23
03B36:  MOVLB  0
03B38:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(179, IN_8_1_FILTER_MINUSA2);     // IN_8_1_FILTER_MINUSA2 
03B3C:  MOVLB  8
03B3E:  CLRF   x22
03B40:  MOVLW  B3
03B42:  MOVWF  x21
03B44:  MOVLW  03
03B46:  MOVWF  x24
03B48:  MOVLW  08
03B4A:  MOVWF  x23
03B4C:  MOVLB  0
03B4E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(180, IN_8_2_FILTER_B0);     // IN_8_2_FILTER_B0 
03B52:  MOVLB  8
03B54:  CLRF   x22
03B56:  MOVLW  B4
03B58:  MOVWF  x21
03B5A:  MOVLW  02
03B5C:  MOVWF  x24
03B5E:  SETF   x23
03B60:  MOVLB  0
03B62:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(181, IN_8_2_FILTER_B1);     // IN_8_2_FILTER_B1 
03B66:  MOVLB  8
03B68:  CLRF   x22
03B6A:  MOVLW  B5
03B6C:  MOVWF  x21
03B6E:  MOVLW  03
03B70:  MOVWF  x24
03B72:  CLRF   x23
03B74:  MOVLB  0
03B76:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(182, IN_8_2_FILTER_B2);     // IN_8_2_FILTER_B2 
03B7A:  MOVLB  8
03B7C:  CLRF   x22
03B7E:  MOVLW  B6
03B80:  MOVWF  x21
03B82:  MOVLW  03
03B84:  MOVWF  x24
03B86:  MOVLW  01
03B88:  MOVWF  x23
03B8A:  MOVLB  0
03B8C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(183, IN_8_2_FILTER_MINUSA1);     // IN_8_2_FILTER_MINUSA1 
03B90:  MOVLB  8
03B92:  CLRF   x22
03B94:  MOVLW  B7
03B96:  MOVWF  x21
03B98:  MOVLW  03
03B9A:  MOVWF  x24
03B9C:  MOVLW  02
03B9E:  MOVWF  x23
03BA0:  MOVLB  0
03BA2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(184, IN_8_2_FILTER_MINUSA2);     // IN_8_2_FILTER_MINUSA2 
03BA6:  MOVLB  8
03BA8:  CLRF   x22
03BAA:  MOVLW  B8
03BAC:  MOVWF  x21
03BAE:  MOVLW  03
03BB0:  MOVWF  x24
03BB2:  MOVWF  x23
03BB4:  MOVLB  0
03BB6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(185, IN_8_3_FILTER_B0);     // IN_8_3_FILTER_B0 
03BBA:  MOVLB  8
03BBC:  CLRF   x22
03BBE:  MOVLW  B9
03BC0:  MOVWF  x21
03BC2:  MOVLW  02
03BC4:  MOVWF  x24
03BC6:  MOVLW  FA
03BC8:  MOVWF  x23
03BCA:  MOVLB  0
03BCC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(186, IN_8_3_FILTER_B1);     // IN_8_3_FILTER_B1 
03BD0:  MOVLB  8
03BD2:  CLRF   x22
03BD4:  MOVLW  BA
03BD6:  MOVWF  x21
03BD8:  MOVLW  02
03BDA:  MOVWF  x24
03BDC:  MOVLW  FB
03BDE:  MOVWF  x23
03BE0:  MOVLB  0
03BE2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(187, IN_8_3_FILTER_B2);     // IN_8_3_FILTER_B2 
03BE6:  MOVLB  8
03BE8:  CLRF   x22
03BEA:  MOVLW  BB
03BEC:  MOVWF  x21
03BEE:  MOVLW  02
03BF0:  MOVWF  x24
03BF2:  MOVLW  FC
03BF4:  MOVWF  x23
03BF6:  MOVLB  0
03BF8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(188, IN_8_3_FILTER_MINUSA1);     // IN_8_3_FILTER_MINUSA1 
03BFC:  MOVLB  8
03BFE:  CLRF   x22
03C00:  MOVLW  BC
03C02:  MOVWF  x21
03C04:  MOVLW  02
03C06:  MOVWF  x24
03C08:  MOVLW  FD
03C0A:  MOVWF  x23
03C0C:  MOVLB  0
03C0E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(189, IN_8_3_FILTER_MINUSA2);     // IN_8_3_FILTER_MINUSA2 
03C12:  MOVLB  8
03C14:  CLRF   x22
03C16:  MOVLW  BD
03C18:  MOVWF  x21
03C1A:  MOVLW  02
03C1C:  MOVWF  x24
03C1E:  MOVLW  FE
03C20:  MOVWF  x23
03C22:  MOVLB  0
03C24:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(190, CH1COMP_THRESHOLD);     // CH1COMP_THRESHOLD 
03C28:  MOVLB  8
03C2A:  CLRF   x22
03C2C:  MOVLW  BE
03C2E:  MOVWF  x21
03C30:  MOVLW  02
03C32:  MOVWF  x24
03C34:  MOVLW  6E
03C36:  MOVWF  x23
03C38:  MOVLB  0
03C3A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(191, CH1COMP_KNEE);     // CH1COMP_KNEE 
03C3E:  MOVLB  8
03C40:  CLRF   x22
03C42:  MOVLW  BF
03C44:  MOVWF  x21
03C46:  MOVLW  02
03C48:  MOVWF  x24
03C4A:  MOVLW  6F
03C4C:  MOVWF  x23
03C4E:  MOVLB  0
03C50:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(192, CH1COMP_RATIO);     // CH1COMP_RATIO 
03C54:  MOVLB  8
03C56:  CLRF   x22
03C58:  MOVLW  C0
03C5A:  MOVWF  x21
03C5C:  MOVLW  02
03C5E:  MOVWF  x24
03C60:  MOVLW  70
03C62:  MOVWF  x23
03C64:  MOVLB  0
03C66:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(193, CH1COMP_ATTACK);     // CH1COMP_ATTACK 
03C6A:  MOVLB  8
03C6C:  CLRF   x22
03C6E:  MOVLW  C1
03C70:  MOVWF  x21
03C72:  MOVLW  02
03C74:  MOVWF  x24
03C76:  MOVLW  71
03C78:  MOVWF  x23
03C7A:  MOVLB  0
03C7C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(194, CH1COMP_RELEASE);     // CH1COMP_RELEASE 
03C80:  MOVLB  8
03C82:  CLRF   x22
03C84:  MOVLW  C2
03C86:  MOVWF  x21
03C88:  MOVLW  02
03C8A:  MOVWF  x24
03C8C:  MOVLW  72
03C8E:  MOVWF  x23
03C90:  MOVLB  0
03C92:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(195, CH1COMP_BYPASS);     // CH1COMP_BYPASS 
03C96:  MOVLB  8
03C98:  CLRF   x22
03C9A:  MOVLW  C3
03C9C:  MOVWF  x21
03C9E:  MOVLW  02
03CA0:  MOVWF  x24
03CA2:  MOVLW  73
03CA4:  MOVWF  x23
03CA6:  MOVLB  0
03CA8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(196, CH2COMP_THRESHOLD);     // CH2COMP_THRESHOLD 
03CAC:  MOVLB  8
03CAE:  CLRF   x22
03CB0:  MOVLW  C4
03CB2:  MOVWF  x21
03CB4:  MOVLW  02
03CB6:  MOVWF  x24
03CB8:  MOVLW  66
03CBA:  MOVWF  x23
03CBC:  MOVLB  0
03CBE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(197, CH2COMP_KNEE);     // CH2COMP_KNEE 
03CC2:  MOVLB  8
03CC4:  CLRF   x22
03CC6:  MOVLW  C5
03CC8:  MOVWF  x21
03CCA:  MOVLW  02
03CCC:  MOVWF  x24
03CCE:  MOVLW  67
03CD0:  MOVWF  x23
03CD2:  MOVLB  0
03CD4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(198, CH2COMP_RATIO);     // CH2COMP_RATIO 
03CD8:  MOVLB  8
03CDA:  CLRF   x22
03CDC:  MOVLW  C6
03CDE:  MOVWF  x21
03CE0:  MOVLW  02
03CE2:  MOVWF  x24
03CE4:  MOVLW  68
03CE6:  MOVWF  x23
03CE8:  MOVLB  0
03CEA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(199, CH2COMP_ATTACK);     // CH2COMP_ATTACK 
03CEE:  MOVLB  8
03CF0:  CLRF   x22
03CF2:  MOVLW  C7
03CF4:  MOVWF  x21
03CF6:  MOVLW  02
03CF8:  MOVWF  x24
03CFA:  MOVLW  69
03CFC:  MOVWF  x23
03CFE:  MOVLB  0
03D00:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(200, CH2COMP_RELEASE);     // CH2COMP_RELEASE 
03D04:  MOVLB  8
03D06:  CLRF   x22
03D08:  MOVLW  C8
03D0A:  MOVWF  x21
03D0C:  MOVLW  02
03D0E:  MOVWF  x24
03D10:  MOVLW  6A
03D12:  MOVWF  x23
03D14:  MOVLB  0
03D16:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(201, CH2COMP_BYPASS);     // CH2COMP_BYPASS 
03D1A:  MOVLB  8
03D1C:  CLRF   x22
03D1E:  MOVLW  C9
03D20:  MOVWF  x21
03D22:  MOVLW  02
03D24:  MOVWF  x24
03D26:  MOVLW  6B
03D28:  MOVWF  x23
03D2A:  MOVLB  0
03D2C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(202, CH3COMP_THRESHOLD);     // CH3COMP_THRESHOLD 
03D30:  MOVLB  8
03D32:  CLRF   x22
03D34:  MOVLW  CA
03D36:  MOVWF  x21
03D38:  MOVLW  02
03D3A:  MOVWF  x24
03D3C:  MOVLW  5E
03D3E:  MOVWF  x23
03D40:  MOVLB  0
03D42:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(203, CH3COMP_KNEE);     // CH3COMP_KNEE 
03D46:  MOVLB  8
03D48:  CLRF   x22
03D4A:  MOVLW  CB
03D4C:  MOVWF  x21
03D4E:  MOVLW  02
03D50:  MOVWF  x24
03D52:  MOVLW  5F
03D54:  MOVWF  x23
03D56:  MOVLB  0
03D58:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(204, CH3COMP_RATIO);     // CH3COMP_RATIO 
03D5C:  MOVLB  8
03D5E:  CLRF   x22
03D60:  MOVLW  CC
03D62:  MOVWF  x21
03D64:  MOVLW  02
03D66:  MOVWF  x24
03D68:  MOVLW  60
03D6A:  MOVWF  x23
03D6C:  MOVLB  0
03D6E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(205, CH3COMP_ATTACK);     // CH3COMP_ATTACK 
03D72:  MOVLB  8
03D74:  CLRF   x22
03D76:  MOVLW  CD
03D78:  MOVWF  x21
03D7A:  MOVLW  02
03D7C:  MOVWF  x24
03D7E:  MOVLW  61
03D80:  MOVWF  x23
03D82:  MOVLB  0
03D84:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(206, CH3COMP_RELEASE);     // CH3COMP_RELEASE 
03D88:  MOVLB  8
03D8A:  CLRF   x22
03D8C:  MOVLW  CE
03D8E:  MOVWF  x21
03D90:  MOVLW  02
03D92:  MOVWF  x24
03D94:  MOVLW  62
03D96:  MOVWF  x23
03D98:  MOVLB  0
03D9A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(207, CH3COMP_BYPASS);     // CH3COMP_BYPASS 
03D9E:  MOVLB  8
03DA0:  CLRF   x22
03DA2:  MOVLW  CF
03DA4:  MOVWF  x21
03DA6:  MOVLW  02
03DA8:  MOVWF  x24
03DAA:  MOVLW  63
03DAC:  MOVWF  x23
03DAE:  MOVLB  0
03DB0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(208, CH4COMP_THRESHOLD);     // CH4COMP_THRESHOLD 
03DB4:  MOVLB  8
03DB6:  CLRF   x22
03DB8:  MOVLW  D0
03DBA:  MOVWF  x21
03DBC:  MOVLW  02
03DBE:  MOVWF  x24
03DC0:  MOVLW  56
03DC2:  MOVWF  x23
03DC4:  MOVLB  0
03DC6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(209, CH4COMP_KNEE);     // CH4COMP_KNEE 
03DCA:  MOVLB  8
03DCC:  CLRF   x22
03DCE:  MOVLW  D1
03DD0:  MOVWF  x21
03DD2:  MOVLW  02
03DD4:  MOVWF  x24
03DD6:  MOVLW  57
03DD8:  MOVWF  x23
03DDA:  MOVLB  0
03DDC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(210, CH4COMP_RATIO);     // CH4COMP_RATIO 
03DE0:  MOVLB  8
03DE2:  CLRF   x22
03DE4:  MOVLW  D2
03DE6:  MOVWF  x21
03DE8:  MOVLW  02
03DEA:  MOVWF  x24
03DEC:  MOVLW  58
03DEE:  MOVWF  x23
03DF0:  MOVLB  0
03DF2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(211, CH4COMP_ATTACK);     // CH4COMP_ATTACK 
03DF6:  MOVLB  8
03DF8:  CLRF   x22
03DFA:  MOVLW  D3
03DFC:  MOVWF  x21
03DFE:  MOVLW  02
03E00:  MOVWF  x24
03E02:  MOVLW  59
03E04:  MOVWF  x23
03E06:  MOVLB  0
03E08:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(212, CH4COMP_RELEASE);     // CH4COMP_RELEASE 
03E0C:  MOVLB  8
03E0E:  CLRF   x22
03E10:  MOVLW  D4
03E12:  MOVWF  x21
03E14:  MOVLW  02
03E16:  MOVWF  x24
03E18:  MOVLW  5A
03E1A:  MOVWF  x23
03E1C:  MOVLB  0
03E1E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(213, CH4COMP_BYPASS);     // CH4COMP_BYPASS 
03E22:  MOVLB  8
03E24:  CLRF   x22
03E26:  MOVLW  D5
03E28:  MOVWF  x21
03E2A:  MOVLW  02
03E2C:  MOVWF  x24
03E2E:  MOVLW  5B
03E30:  MOVWF  x23
03E32:  MOVLB  0
03E34:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(214, CH5COMP_THRESHOLD);     // CH5COMP_THRESHOLD 
03E38:  MOVLB  8
03E3A:  CLRF   x22
03E3C:  MOVLW  D6
03E3E:  MOVWF  x21
03E40:  MOVLW  02
03E42:  MOVWF  x24
03E44:  MOVLW  4E
03E46:  MOVWF  x23
03E48:  MOVLB  0
03E4A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(215, CH5COMP_KNEE);     // CH5COMP_KNEE 
03E4E:  MOVLB  8
03E50:  CLRF   x22
03E52:  MOVLW  D7
03E54:  MOVWF  x21
03E56:  MOVLW  02
03E58:  MOVWF  x24
03E5A:  MOVLW  4F
03E5C:  MOVWF  x23
03E5E:  MOVLB  0
03E60:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(216, CH5COMP_RATIO);     // CH5COMP_RATIO 
03E64:  MOVLB  8
03E66:  CLRF   x22
03E68:  MOVLW  D8
03E6A:  MOVWF  x21
03E6C:  MOVLW  02
03E6E:  MOVWF  x24
03E70:  MOVLW  50
03E72:  MOVWF  x23
03E74:  MOVLB  0
03E76:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(217, CH5COMP_ATTACK);     // CH5COMP_ATTACK 
03E7A:  MOVLB  8
03E7C:  CLRF   x22
03E7E:  MOVLW  D9
03E80:  MOVWF  x21
03E82:  MOVLW  02
03E84:  MOVWF  x24
03E86:  MOVLW  51
03E88:  MOVWF  x23
03E8A:  MOVLB  0
03E8C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(218, CH5COMP_RELEASE);     // CH5COMP_RELEASE 
03E90:  MOVLB  8
03E92:  CLRF   x22
03E94:  MOVLW  DA
03E96:  MOVWF  x21
03E98:  MOVLW  02
03E9A:  MOVWF  x24
03E9C:  MOVLW  52
03E9E:  MOVWF  x23
03EA0:  MOVLB  0
03EA2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(219, CH5COMP_BYPASS);     // CH5COMP_BYPASS 
03EA6:  MOVLB  8
03EA8:  CLRF   x22
03EAA:  MOVLW  DB
03EAC:  MOVWF  x21
03EAE:  MOVLW  02
03EB0:  MOVWF  x24
03EB2:  MOVLW  53
03EB4:  MOVWF  x23
03EB6:  MOVLB  0
03EB8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(220, CH6COMP_THRESHOLD);     // CH6COMP_THRESHOLD 
03EBC:  MOVLB  8
03EBE:  CLRF   x22
03EC0:  MOVLW  DC
03EC2:  MOVWF  x21
03EC4:  MOVLW  02
03EC6:  MOVWF  x24
03EC8:  MOVLW  46
03ECA:  MOVWF  x23
03ECC:  MOVLB  0
03ECE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(221, CH6COMP_KNEE);     // CH6COMP_KNEE 
03ED2:  MOVLB  8
03ED4:  CLRF   x22
03ED6:  MOVLW  DD
03ED8:  MOVWF  x21
03EDA:  MOVLW  02
03EDC:  MOVWF  x24
03EDE:  MOVLW  47
03EE0:  MOVWF  x23
03EE2:  MOVLB  0
03EE4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(222, CH6COMP_RATIO);     // CH6COMP_RATIO 
03EE8:  MOVLB  8
03EEA:  CLRF   x22
03EEC:  MOVLW  DE
03EEE:  MOVWF  x21
03EF0:  MOVLW  02
03EF2:  MOVWF  x24
03EF4:  MOVLW  48
03EF6:  MOVWF  x23
03EF8:  MOVLB  0
03EFA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(223, CH6COMP_ATTACK);     // CH6COMP_ATTACK 
03EFE:  MOVLB  8
03F00:  CLRF   x22
03F02:  MOVLW  DF
03F04:  MOVWF  x21
03F06:  MOVLW  02
03F08:  MOVWF  x24
03F0A:  MOVLW  49
03F0C:  MOVWF  x23
03F0E:  MOVLB  0
03F10:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(224, CH6COMP_RELEASE);     // CH6COMP_RELEASE 
03F14:  MOVLB  8
03F16:  CLRF   x22
03F18:  MOVLW  E0
03F1A:  MOVWF  x21
03F1C:  MOVLW  02
03F1E:  MOVWF  x24
03F20:  MOVLW  4A
03F22:  MOVWF  x23
03F24:  MOVLB  0
03F26:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(225, CH6COMP_BYPASS);     // CH6COMP_BYPASS 
03F2A:  MOVLB  8
03F2C:  CLRF   x22
03F2E:  MOVLW  E1
03F30:  MOVWF  x21
03F32:  MOVLW  02
03F34:  MOVWF  x24
03F36:  MOVLW  4B
03F38:  MOVWF  x23
03F3A:  MOVLB  0
03F3C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(226, CH7COMP_THRESHOLD);     // CH7COMP_THRESHOLD 
03F40:  MOVLB  8
03F42:  CLRF   x22
03F44:  MOVLW  E2
03F46:  MOVWF  x21
03F48:  MOVLW  02
03F4A:  MOVWF  x24
03F4C:  MOVLW  3E
03F4E:  MOVWF  x23
03F50:  MOVLB  0
03F52:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(227, CH7COMP_KNEE);     // CH7COMP_KNEE 
03F56:  MOVLB  8
03F58:  CLRF   x22
03F5A:  MOVLW  E3
03F5C:  MOVWF  x21
03F5E:  MOVLW  02
03F60:  MOVWF  x24
03F62:  MOVLW  3F
03F64:  MOVWF  x23
03F66:  MOVLB  0
03F68:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(228, CH7COMP_RATIO);     // CH7COMP_RATIO 
03F6C:  MOVLB  8
03F6E:  CLRF   x22
03F70:  MOVLW  E4
03F72:  MOVWF  x21
03F74:  MOVLW  02
03F76:  MOVWF  x24
03F78:  MOVLW  40
03F7A:  MOVWF  x23
03F7C:  MOVLB  0
03F7E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(229, CH7COMP_ATTACK);     // CH7COMP_ATTACK 
03F82:  MOVLB  8
03F84:  CLRF   x22
03F86:  MOVLW  E5
03F88:  MOVWF  x21
03F8A:  MOVLW  02
03F8C:  MOVWF  x24
03F8E:  MOVLW  41
03F90:  MOVWF  x23
03F92:  MOVLB  0
03F94:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(230, CH7COMP_RELEASE);     // CH7COMP_RELEASE 
03F98:  MOVLB  8
03F9A:  CLRF   x22
03F9C:  MOVLW  E6
03F9E:  MOVWF  x21
03FA0:  MOVLW  02
03FA2:  MOVWF  x24
03FA4:  MOVLW  42
03FA6:  MOVWF  x23
03FA8:  MOVLB  0
03FAA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(231, CH7COMP_BYPASS);     // CH7COMP_BYPASS 
03FAE:  MOVLB  8
03FB0:  CLRF   x22
03FB2:  MOVLW  E7
03FB4:  MOVWF  x21
03FB6:  MOVLW  02
03FB8:  MOVWF  x24
03FBA:  MOVLW  43
03FBC:  MOVWF  x23
03FBE:  MOVLB  0
03FC0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(232, CH8COMP_THRESHOLD);     // CH8COMP_THRESHOLD 
03FC4:  MOVLB  8
03FC6:  CLRF   x22
03FC8:  MOVLW  E8
03FCA:  MOVWF  x21
03FCC:  MOVLW  02
03FCE:  MOVWF  x24
03FD0:  MOVLW  36
03FD2:  MOVWF  x23
03FD4:  MOVLB  0
03FD6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(233, CH8COMP_KNEE);     // CH8COMP_KNEE 
03FDA:  MOVLB  8
03FDC:  CLRF   x22
03FDE:  MOVLW  E9
03FE0:  MOVWF  x21
03FE2:  MOVLW  02
03FE4:  MOVWF  x24
03FE6:  MOVLW  37
03FE8:  MOVWF  x23
03FEA:  MOVLB  0
03FEC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(234, CH8COMP_RATIO);     // CH8COMP_RATIO 
03FF0:  MOVLB  8
03FF2:  CLRF   x22
03FF4:  MOVLW  EA
03FF6:  MOVWF  x21
03FF8:  MOVLW  02
03FFA:  MOVWF  x24
03FFC:  MOVLW  38
03FFE:  MOVWF  x23
04000:  MOVLB  0
04002:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(235, CH8COMP_ATTACK);     // CH8COMP_ATTACK 
04006:  MOVLB  8
04008:  CLRF   x22
0400A:  MOVLW  EB
0400C:  MOVWF  x21
0400E:  MOVLW  02
04010:  MOVWF  x24
04012:  MOVLW  39
04014:  MOVWF  x23
04016:  MOVLB  0
04018:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(236, CH8COMP_RELEASE);     // CH8COMP_RELEASE 
0401C:  MOVLB  8
0401E:  CLRF   x22
04020:  MOVLW  EC
04022:  MOVWF  x21
04024:  MOVLW  02
04026:  MOVWF  x24
04028:  MOVLW  3A
0402A:  MOVWF  x23
0402C:  MOVLB  0
0402E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(237, CH8COMP_BYPASS);     // CH8COMP_BYPASS 
04032:  MOVLB  8
04034:  CLRF   x22
04036:  MOVLW  ED
04038:  MOVWF  x21
0403A:  MOVLW  02
0403C:  MOVWF  x24
0403E:  MOVLW  3B
04040:  MOVWF  x23
04042:  MOVLB  0
04044:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(238, MIXER_SELECT0);     // MIXER_SELECT0 
04048:  MOVLB  8
0404A:  CLRF   x22
0404C:  MOVLW  EE
0404E:  MOVWF  x21
04050:  CLRF   x24
04052:  MOVLW  03
04054:  MOVWF  x23
04056:  MOVLB  0
04058:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(239, MIXER_SELECT1);     // MIXER_SELECT1 
0405C:  MOVLB  8
0405E:  CLRF   x22
04060:  MOVLW  EF
04062:  MOVWF  x21
04064:  CLRF   x24
04066:  MOVLW  04
04068:  MOVWF  x23
0406A:  MOVLB  0
0406C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(240, MIXER_SELECT2);     // MIXER_SELECT2 
04070:  MOVLB  8
04072:  CLRF   x22
04074:  MOVLW  F0
04076:  MOVWF  x21
04078:  CLRF   x24
0407A:  MOVLW  05
0407C:  MOVWF  x23
0407E:  MOVLB  0
04080:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(241, MIXER_SELECT3);     // MIXER_SELECT3 
04084:  MOVLB  8
04086:  CLRF   x22
04088:  MOVLW  F1
0408A:  MOVWF  x21
0408C:  CLRF   x24
0408E:  MOVLW  06
04090:  MOVWF  x23
04092:  MOVLB  0
04094:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(242, MIXER_SELECT4);     // MIXER_SELECT4 
04098:  MOVLB  8
0409A:  CLRF   x22
0409C:  MOVLW  F2
0409E:  MOVWF  x21
040A0:  CLRF   x24
040A2:  MOVLW  07
040A4:  MOVWF  x23
040A6:  MOVLB  0
040A8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(243, MIXER_SELECT5);     // MIXER_SELECT5 
040AC:  MOVLB  8
040AE:  CLRF   x22
040B0:  MOVLW  F3
040B2:  MOVWF  x21
040B4:  CLRF   x24
040B6:  MOVLW  08
040B8:  MOVWF  x23
040BA:  MOVLB  0
040BC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(244, MIXER_SELECT6);     // MIXER_SELECT6 
040C0:  MOVLB  8
040C2:  CLRF   x22
040C4:  MOVLW  F4
040C6:  MOVWF  x21
040C8:  CLRF   x24
040CA:  MOVLW  09
040CC:  MOVWF  x23
040CE:  MOVLB  0
040D0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(245, MIXER_SELECT7);     // MIXER_SELECT7 
040D4:  MOVLB  8
040D6:  CLRF   x22
040D8:  MOVLW  F5
040DA:  MOVWF  x21
040DC:  CLRF   x24
040DE:  MOVLW  0A
040E0:  MOVWF  x23
040E2:  MOVLB  0
040E4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(246, MIXER_SELECT8);     // MIXER_SELECT8 
040E8:  MOVLB  8
040EA:  CLRF   x22
040EC:  MOVLW  F6
040EE:  MOVWF  x21
040F0:  CLRF   x24
040F2:  MOVLW  0B
040F4:  MOVWF  x23
040F6:  MOVLB  0
040F8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(247, MIXER_SELECT9);     // MIXER_SELECT9 
040FC:  MOVLB  8
040FE:  CLRF   x22
04100:  MOVLW  F7
04102:  MOVWF  x21
04104:  CLRF   x24
04106:  MOVLW  0C
04108:  MOVWF  x23
0410A:  MOVLB  0
0410C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(248, MIXER_SELECT10);     // MIXER_SELECT10 
04110:  MOVLB  8
04112:  CLRF   x22
04114:  MOVLW  F8
04116:  MOVWF  x21
04118:  CLRF   x24
0411A:  MOVLW  0D
0411C:  MOVWF  x23
0411E:  MOVLB  0
04120:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(249, MIXER_SELECT11);     // MIXER_SELECT11 
04124:  MOVLB  8
04126:  CLRF   x22
04128:  MOVLW  F9
0412A:  MOVWF  x21
0412C:  CLRF   x24
0412E:  MOVLW  0E
04130:  MOVWF  x23
04132:  MOVLB  0
04134:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(250, MIXER_SELECT12);     // MIXER_SELECT12 
04138:  MOVLB  8
0413A:  CLRF   x22
0413C:  MOVLW  FA
0413E:  MOVWF  x21
04140:  CLRF   x24
04142:  MOVLW  0F
04144:  MOVWF  x23
04146:  MOVLB  0
04148:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(251, MIXER_SELECT13);     // MIXER_SELECT13 
0414C:  MOVLB  8
0414E:  CLRF   x22
04150:  MOVLW  FB
04152:  MOVWF  x21
04154:  CLRF   x24
04156:  MOVLW  10
04158:  MOVWF  x23
0415A:  MOVLB  0
0415C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(252, MIXER_SELECT14);     // MIXER_SELECT14 
04160:  MOVLB  8
04162:  CLRF   x22
04164:  MOVLW  FC
04166:  MOVWF  x21
04168:  CLRF   x24
0416A:  MOVLW  11
0416C:  MOVWF  x23
0416E:  MOVLB  0
04170:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(253, MIXER_SELECT15);     // MIXER_SELECT15 
04174:  MOVLB  8
04176:  CLRF   x22
04178:  MOVLW  FD
0417A:  MOVWF  x21
0417C:  CLRF   x24
0417E:  MOVLW  12
04180:  MOVWF  x23
04182:  MOVLB  0
04184:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(254, MIXER_SELECT16);     // MIXER_SELECT16 
04188:  MOVLB  8
0418A:  CLRF   x22
0418C:  MOVLW  FE
0418E:  MOVWF  x21
04190:  CLRF   x24
04192:  MOVLW  13
04194:  MOVWF  x23
04196:  MOVLB  0
04198:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(255, MIXER_SELECT17);     // MIXER_SELECT17 
0419C:  MOVLB  8
0419E:  CLRF   x22
041A0:  SETF   x21
041A2:  CLRF   x24
041A4:  MOVLW  14
041A6:  MOVWF  x23
041A8:  MOVLB  0
041AA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(256, MIXER_SELECT18);     // MIXER_SELECT18 
041AE:  MOVLW  01
041B0:  MOVLB  8
041B2:  MOVWF  x22
041B4:  CLRF   x21
041B6:  CLRF   x24
041B8:  MOVLW  15
041BA:  MOVWF  x23
041BC:  MOVLB  0
041BE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(257, MIXER_SELECT19);     // MIXER_SELECT19 
041C2:  MOVLW  01
041C4:  MOVLB  8
041C6:  MOVWF  x22
041C8:  MOVWF  x21
041CA:  CLRF   x24
041CC:  MOVLW  16
041CE:  MOVWF  x23
041D0:  MOVLB  0
041D2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(258, MIXER_SELECT20);     // MIXER_SELECT20 
041D6:  MOVLW  01
041D8:  MOVLB  8
041DA:  MOVWF  x22
041DC:  MOVLW  02
041DE:  MOVWF  x21
041E0:  CLRF   x24
041E2:  MOVLW  17
041E4:  MOVWF  x23
041E6:  MOVLB  0
041E8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(259, MIXER_SELECT21);     // MIXER_SELECT21 
041EC:  MOVLW  01
041EE:  MOVLB  8
041F0:  MOVWF  x22
041F2:  MOVLW  03
041F4:  MOVWF  x21
041F6:  CLRF   x24
041F8:  MOVLW  18
041FA:  MOVWF  x23
041FC:  MOVLB  0
041FE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(260, MIXER_SELECT22);     // MIXER_SELECT22 
04202:  MOVLW  01
04204:  MOVLB  8
04206:  MOVWF  x22
04208:  MOVLW  04
0420A:  MOVWF  x21
0420C:  CLRF   x24
0420E:  MOVLW  19
04210:  MOVWF  x23
04212:  MOVLB  0
04214:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(261, MIXER_SELECT23);     // MIXER_SELECT23 
04218:  MOVLW  01
0421A:  MOVLB  8
0421C:  MOVWF  x22
0421E:  MOVLW  05
04220:  MOVWF  x21
04222:  CLRF   x24
04224:  MOVLW  1A
04226:  MOVWF  x23
04228:  MOVLB  0
0422A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(262, MIXER_SELECT24);     // MIXER_SELECT24 
0422E:  MOVLW  01
04230:  MOVLB  8
04232:  MOVWF  x22
04234:  MOVLW  06
04236:  MOVWF  x21
04238:  CLRF   x24
0423A:  MOVLW  1B
0423C:  MOVWF  x23
0423E:  MOVLB  0
04240:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(263, MIXER_SELECT25);     // MIXER_SELECT25 
04244:  MOVLW  01
04246:  MOVLB  8
04248:  MOVWF  x22
0424A:  MOVLW  07
0424C:  MOVWF  x21
0424E:  CLRF   x24
04250:  MOVLW  1C
04252:  MOVWF  x23
04254:  MOVLB  0
04256:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(264, MIXER_SELECT26);     // MIXER_SELECT26 
0425A:  MOVLW  01
0425C:  MOVLB  8
0425E:  MOVWF  x22
04260:  MOVLW  08
04262:  MOVWF  x21
04264:  CLRF   x24
04266:  MOVLW  1D
04268:  MOVWF  x23
0426A:  MOVLB  0
0426C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(265, MIXER_SELECT27);     // MIXER_SELECT27 
04270:  MOVLW  01
04272:  MOVLB  8
04274:  MOVWF  x22
04276:  MOVLW  09
04278:  MOVWF  x21
0427A:  CLRF   x24
0427C:  MOVLW  1E
0427E:  MOVWF  x23
04280:  MOVLB  0
04282:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(266, MIXER_SELECT28);     // MIXER_SELECT28 
04286:  MOVLW  01
04288:  MOVLB  8
0428A:  MOVWF  x22
0428C:  MOVLW  0A
0428E:  MOVWF  x21
04290:  CLRF   x24
04292:  MOVLW  1F
04294:  MOVWF  x23
04296:  MOVLB  0
04298:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(267, MIXER_SELECT29);     // MIXER_SELECT29 
0429C:  MOVLW  01
0429E:  MOVLB  8
042A0:  MOVWF  x22
042A2:  MOVLW  0B
042A4:  MOVWF  x21
042A6:  CLRF   x24
042A8:  MOVLW  20
042AA:  MOVWF  x23
042AC:  MOVLB  0
042AE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(268, MIXER_SELECT30);     // MIXER_SELECT30 
042B2:  MOVLW  01
042B4:  MOVLB  8
042B6:  MOVWF  x22
042B8:  MOVLW  0C
042BA:  MOVWF  x21
042BC:  CLRF   x24
042BE:  MOVLW  21
042C0:  MOVWF  x23
042C2:  MOVLB  0
042C4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(269, MIXER_SELECT31);     // MIXER_SELECT31 
042C8:  MOVLW  01
042CA:  MOVLB  8
042CC:  MOVWF  x22
042CE:  MOVLW  0D
042D0:  MOVWF  x21
042D2:  CLRF   x24
042D4:  MOVLW  22
042D6:  MOVWF  x23
042D8:  MOVLB  0
042DA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(270, MIXER_SELECT32);     // MIXER_SELECT32 
042DE:  MOVLW  01
042E0:  MOVLB  8
042E2:  MOVWF  x22
042E4:  MOVLW  0E
042E6:  MOVWF  x21
042E8:  CLRF   x24
042EA:  MOVLW  23
042EC:  MOVWF  x23
042EE:  MOVLB  0
042F0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(271, MIXER_SELECT33);     // MIXER_SELECT33 
042F4:  MOVLW  01
042F6:  MOVLB  8
042F8:  MOVWF  x22
042FA:  MOVLW  0F
042FC:  MOVWF  x21
042FE:  CLRF   x24
04300:  MOVLW  24
04302:  MOVWF  x23
04304:  MOVLB  0
04306:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(272, MIXER_SELECT34);     // MIXER_SELECT34 
0430A:  MOVLW  01
0430C:  MOVLB  8
0430E:  MOVWF  x22
04310:  MOVLW  10
04312:  MOVWF  x21
04314:  CLRF   x24
04316:  MOVLW  25
04318:  MOVWF  x23
0431A:  MOVLB  0
0431C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(273, MIXER_SELECT35);     // MIXER_SELECT35 
04320:  MOVLW  01
04322:  MOVLB  8
04324:  MOVWF  x22
04326:  MOVLW  11
04328:  MOVWF  x21
0432A:  CLRF   x24
0432C:  MOVLW  26
0432E:  MOVWF  x23
04330:  MOVLB  0
04332:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(274, MIXER_SELECT36);     // MIXER_SELECT36 
04336:  MOVLW  01
04338:  MOVLB  8
0433A:  MOVWF  x22
0433C:  MOVLW  12
0433E:  MOVWF  x21
04340:  CLRF   x24
04342:  MOVLW  27
04344:  MOVWF  x23
04346:  MOVLB  0
04348:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(275, MIXER_SELECT37);     // MIXER_SELECT37 
0434C:  MOVLW  01
0434E:  MOVLB  8
04350:  MOVWF  x22
04352:  MOVLW  13
04354:  MOVWF  x21
04356:  CLRF   x24
04358:  MOVLW  28
0435A:  MOVWF  x23
0435C:  MOVLB  0
0435E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(276, MIXER_SELECT38);     // MIXER_SELECT38 
04362:  MOVLW  01
04364:  MOVLB  8
04366:  MOVWF  x22
04368:  MOVLW  14
0436A:  MOVWF  x21
0436C:  CLRF   x24
0436E:  MOVLW  29
04370:  MOVWF  x23
04372:  MOVLB  0
04374:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(277, MIXER_SELECT39);     // MIXER_SELECT39 
04378:  MOVLW  01
0437A:  MOVLB  8
0437C:  MOVWF  x22
0437E:  MOVLW  15
04380:  MOVWF  x21
04382:  CLRF   x24
04384:  MOVLW  2A
04386:  MOVWF  x23
04388:  MOVLB  0
0438A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(278, MIXER_SELECT40);     // MIXER_SELECT40 
0438E:  MOVLW  01
04390:  MOVLB  8
04392:  MOVWF  x22
04394:  MOVLW  16
04396:  MOVWF  x21
04398:  CLRF   x24
0439A:  MOVLW  2B
0439C:  MOVWF  x23
0439E:  MOVLB  0
043A0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(279, MIXER_SELECT41);     // MIXER_SELECT41 
043A4:  MOVLW  01
043A6:  MOVLB  8
043A8:  MOVWF  x22
043AA:  MOVLW  17
043AC:  MOVWF  x21
043AE:  CLRF   x24
043B0:  MOVLW  2C
043B2:  MOVWF  x23
043B4:  MOVLB  0
043B6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(280, MIXER_SELECT42);     // MIXER_SELECT42 
043BA:  MOVLW  01
043BC:  MOVLB  8
043BE:  MOVWF  x22
043C0:  MOVLW  18
043C2:  MOVWF  x21
043C4:  CLRF   x24
043C6:  MOVLW  2D
043C8:  MOVWF  x23
043CA:  MOVLB  0
043CC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(281, MIXER_SELECT43);     // MIXER_SELECT43 
043D0:  MOVLW  01
043D2:  MOVLB  8
043D4:  MOVWF  x22
043D6:  MOVLW  19
043D8:  MOVWF  x21
043DA:  CLRF   x24
043DC:  MOVLW  2E
043DE:  MOVWF  x23
043E0:  MOVLB  0
043E2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(282, MIXER_SELECT44);     // MIXER_SELECT44 
043E6:  MOVLW  01
043E8:  MOVLB  8
043EA:  MOVWF  x22
043EC:  MOVLW  1A
043EE:  MOVWF  x21
043F0:  CLRF   x24
043F2:  MOVLW  2F
043F4:  MOVWF  x23
043F6:  MOVLB  0
043F8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(283, MIXER_SELECT45);     // MIXER_SELECT45 
043FC:  MOVLW  01
043FE:  MOVLB  8
04400:  MOVWF  x22
04402:  MOVLW  1B
04404:  MOVWF  x21
04406:  CLRF   x24
04408:  MOVLW  30
0440A:  MOVWF  x23
0440C:  MOVLB  0
0440E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(284, MIXER_SELECT46);     // MIXER_SELECT46 
04412:  MOVLW  01
04414:  MOVLB  8
04416:  MOVWF  x22
04418:  MOVLW  1C
0441A:  MOVWF  x21
0441C:  CLRF   x24
0441E:  MOVLW  31
04420:  MOVWF  x23
04422:  MOVLB  0
04424:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(285, MIXER_SELECT47);     // MIXER_SELECT47 
04428:  MOVLW  01
0442A:  MOVLB  8
0442C:  MOVWF  x22
0442E:  MOVLW  1D
04430:  MOVWF  x21
04432:  CLRF   x24
04434:  MOVLW  32
04436:  MOVWF  x23
04438:  MOVLB  0
0443A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(286, MIXER_SELECT48);     // MIXER_SELECT48 
0443E:  MOVLW  01
04440:  MOVLB  8
04442:  MOVWF  x22
04444:  MOVLW  1E
04446:  MOVWF  x21
04448:  CLRF   x24
0444A:  MOVLW  33
0444C:  MOVWF  x23
0444E:  MOVLB  0
04450:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(287, MIXER_SELECT49);     // MIXER_SELECT49 
04454:  MOVLW  01
04456:  MOVLB  8
04458:  MOVWF  x22
0445A:  MOVLW  1F
0445C:  MOVWF  x21
0445E:  CLRF   x24
04460:  MOVLW  34
04462:  MOVWF  x23
04464:  MOVLB  0
04466:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(288, MIXER_SELECT50);     // MIXER_SELECT50 
0446A:  MOVLW  01
0446C:  MOVLB  8
0446E:  MOVWF  x22
04470:  MOVLW  20
04472:  MOVWF  x21
04474:  CLRF   x24
04476:  MOVLW  35
04478:  MOVWF  x23
0447A:  MOVLB  0
0447C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(289, MIXER_SELECT51);     // MIXER_SELECT51 
04480:  MOVLW  01
04482:  MOVLB  8
04484:  MOVWF  x22
04486:  MOVLW  21
04488:  MOVWF  x21
0448A:  CLRF   x24
0448C:  MOVLW  36
0448E:  MOVWF  x23
04490:  MOVLB  0
04492:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(290, MIXER_SELECT52);     // MIXER_SELECT52 
04496:  MOVLW  01
04498:  MOVLB  8
0449A:  MOVWF  x22
0449C:  MOVLW  22
0449E:  MOVWF  x21
044A0:  CLRF   x24
044A2:  MOVLW  37
044A4:  MOVWF  x23
044A6:  MOVLB  0
044A8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(291, MIXER_SELECT53);     // MIXER_SELECT53 
044AC:  MOVLW  01
044AE:  MOVLB  8
044B0:  MOVWF  x22
044B2:  MOVLW  23
044B4:  MOVWF  x21
044B6:  CLRF   x24
044B8:  MOVLW  38
044BA:  MOVWF  x23
044BC:  MOVLB  0
044BE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(292, MIXER_SELECT54);     // MIXER_SELECT54 
044C2:  MOVLW  01
044C4:  MOVLB  8
044C6:  MOVWF  x22
044C8:  MOVLW  24
044CA:  MOVWF  x21
044CC:  CLRF   x24
044CE:  MOVLW  39
044D0:  MOVWF  x23
044D2:  MOVLB  0
044D4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(293, MIXER_SELECT55);     // MIXER_SELECT55 
044D8:  MOVLW  01
044DA:  MOVLB  8
044DC:  MOVWF  x22
044DE:  MOVLW  25
044E0:  MOVWF  x21
044E2:  CLRF   x24
044E4:  MOVLW  3A
044E6:  MOVWF  x23
044E8:  MOVLB  0
044EA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(294, MIXER_SELECT56);     // MIXER_SELECT56 
044EE:  MOVLW  01
044F0:  MOVLB  8
044F2:  MOVWF  x22
044F4:  MOVLW  26
044F6:  MOVWF  x21
044F8:  CLRF   x24
044FA:  MOVLW  3B
044FC:  MOVWF  x23
044FE:  MOVLB  0
04500:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(295, MIXER_SELECT57);     // MIXER_SELECT57 
04504:  MOVLW  01
04506:  MOVLB  8
04508:  MOVWF  x22
0450A:  MOVLW  27
0450C:  MOVWF  x21
0450E:  CLRF   x24
04510:  MOVLW  3C
04512:  MOVWF  x23
04514:  MOVLB  0
04516:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(296, MIXER_SELECT58);     // MIXER_SELECT58 
0451A:  MOVLW  01
0451C:  MOVLB  8
0451E:  MOVWF  x22
04520:  MOVLW  28
04522:  MOVWF  x21
04524:  CLRF   x24
04526:  MOVLW  3D
04528:  MOVWF  x23
0452A:  MOVLB  0
0452C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(297, MIXER_SELECT59);     // MIXER_SELECT59 
04530:  MOVLW  01
04532:  MOVLB  8
04534:  MOVWF  x22
04536:  MOVLW  29
04538:  MOVWF  x21
0453A:  CLRF   x24
0453C:  MOVLW  3E
0453E:  MOVWF  x23
04540:  MOVLB  0
04542:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(298, MIXER_SELECT60);     // MIXER_SELECT60 
04546:  MOVLW  01
04548:  MOVLB  8
0454A:  MOVWF  x22
0454C:  MOVLW  2A
0454E:  MOVWF  x21
04550:  CLRF   x24
04552:  MOVLW  3F
04554:  MOVWF  x23
04556:  MOVLB  0
04558:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(299, MIXER_SELECT61);     // MIXER_SELECT61 
0455C:  MOVLW  01
0455E:  MOVLB  8
04560:  MOVWF  x22
04562:  MOVLW  2B
04564:  MOVWF  x21
04566:  CLRF   x24
04568:  MOVLW  40
0456A:  MOVWF  x23
0456C:  MOVLB  0
0456E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(300, MIXER_SELECT62);     // MIXER_SELECT62 
04572:  MOVLW  01
04574:  MOVLB  8
04576:  MOVWF  x22
04578:  MOVLW  2C
0457A:  MOVWF  x21
0457C:  CLRF   x24
0457E:  MOVLW  41
04580:  MOVWF  x23
04582:  MOVLB  0
04584:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(301, MIXER_SELECT63);     // MIXER_SELECT63 
04588:  MOVLW  01
0458A:  MOVLB  8
0458C:  MOVWF  x22
0458E:  MOVLW  2D
04590:  MOVWF  x21
04592:  CLRF   x24
04594:  MOVLW  42
04596:  MOVWF  x23
04598:  MOVLB  0
0459A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(302, MIXER_SELECT64);     // MIXER_SELECT64 
0459E:  MOVLW  01
045A0:  MOVLB  8
045A2:  MOVWF  x22
045A4:  MOVLW  2E
045A6:  MOVWF  x21
045A8:  CLRF   x24
045AA:  MOVLW  43
045AC:  MOVWF  x23
045AE:  MOVLB  0
045B0:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(303, MIXER_SELECT65);     // MIXER_SELECT65 
045B4:  MOVLW  01
045B6:  MOVLB  8
045B8:  MOVWF  x22
045BA:  MOVLW  2F
045BC:  MOVWF  x21
045BE:  CLRF   x24
045C0:  MOVLW  44
045C2:  MOVWF  x23
045C4:  MOVLB  0
045C6:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(304, MIXER_SELECT66);     // MIXER_SELECT66 
045CA:  MOVLW  01
045CC:  MOVLB  8
045CE:  MOVWF  x22
045D0:  MOVLW  30
045D2:  MOVWF  x21
045D4:  CLRF   x24
045D6:  MOVLW  45
045D8:  MOVWF  x23
045DA:  MOVLB  0
045DC:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(305, MIXER_SELECT67);     // MIXER_SELECT67 
045E0:  MOVLW  01
045E2:  MOVLB  8
045E4:  MOVWF  x22
045E6:  MOVLW  31
045E8:  MOVWF  x21
045EA:  CLRF   x24
045EC:  MOVLW  46
045EE:  MOVWF  x23
045F0:  MOVLB  0
045F2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(306, MIXER_SELECT68);     // MIXER_SELECT68 
045F6:  MOVLW  01
045F8:  MOVLB  8
045FA:  MOVWF  x22
045FC:  MOVLW  32
045FE:  MOVWF  x21
04600:  CLRF   x24
04602:  MOVLW  47
04604:  MOVWF  x23
04606:  MOVLB  0
04608:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(307, MIXER_SELECT69);     // MIXER_SELECT69 
0460C:  MOVLW  01
0460E:  MOVLB  8
04610:  MOVWF  x22
04612:  MOVLW  33
04614:  MOVWF  x21
04616:  CLRF   x24
04618:  MOVLW  48
0461A:  MOVWF  x23
0461C:  MOVLB  0
0461E:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(308, MIXER_SELECT70);     // MIXER_SELECT70 
04622:  MOVLW  01
04624:  MOVLB  8
04626:  MOVWF  x22
04628:  MOVLW  34
0462A:  MOVWF  x21
0462C:  CLRF   x24
0462E:  MOVLW  49
04630:  MOVWF  x23
04632:  MOVLB  0
04634:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(309, MIXER_SELECT71);     // MIXER_SELECT71 
04638:  MOVLW  01
0463A:  MOVLB  8
0463C:  MOVWF  x22
0463E:  MOVLW  35
04640:  MOVWF  x21
04642:  CLRF   x24
04644:  MOVLW  4A
04646:  MOVWF  x23
04648:  MOVLB  0
0464A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(310, MIXER_SELECT72);     // MIXER_SELECT72 
0464E:  MOVLW  01
04650:  MOVLB  8
04652:  MOVWF  x22
04654:  MOVLW  36
04656:  MOVWF  x21
04658:  CLRF   x24
0465A:  MOVLW  4B
0465C:  MOVWF  x23
0465E:  MOVLB  0
04660:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(311, MIXER_SELECT73);     // MIXER_SELECT73 
04664:  MOVLW  01
04666:  MOVLB  8
04668:  MOVWF  x22
0466A:  MOVLW  37
0466C:  MOVWF  x21
0466E:  CLRF   x24
04670:  MOVLW  4C
04672:  MOVWF  x23
04674:  MOVLB  0
04676:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(312, MIXER_SELECT74);     // MIXER_SELECT74 
0467A:  MOVLW  01
0467C:  MOVLB  8
0467E:  MOVWF  x22
04680:  MOVLW  38
04682:  MOVWF  x21
04684:  CLRF   x24
04686:  MOVLW  4D
04688:  MOVWF  x23
0468A:  MOVLB  0
0468C:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(313, MIXER_SELECT75);     // MIXER_SELECT75 
04690:  MOVLW  01
04692:  MOVLB  8
04694:  MOVWF  x22
04696:  MOVLW  39
04698:  MOVWF  x21
0469A:  CLRF   x24
0469C:  MOVLW  4E
0469E:  MOVWF  x23
046A0:  MOVLB  0
046A2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(314, MIXER_SELECT76);     // MIXER_SELECT76 
046A6:  MOVLW  01
046A8:  MOVLB  8
046AA:  MOVWF  x22
046AC:  MOVLW  3A
046AE:  MOVWF  x21
046B0:  CLRF   x24
046B2:  MOVLW  4F
046B4:  MOVWF  x23
046B6:  MOVLB  0
046B8:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(315, MIXER_SELECT77);     // MIXER_SELECT77 
046BC:  MOVLW  01
046BE:  MOVLB  8
046C0:  MOVWF  x22
046C2:  MOVLW  3B
046C4:  MOVWF  x21
046C6:  CLRF   x24
046C8:  MOVLW  50
046CA:  MOVWF  x23
046CC:  MOVLB  0
046CE:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(316, MIXER_SELECT78);     // MIXER_SELECT78 
046D2:  MOVLW  01
046D4:  MOVLB  8
046D6:  MOVWF  x22
046D8:  MOVLW  3C
046DA:  MOVWF  x21
046DC:  CLRF   x24
046DE:  MOVLW  51
046E0:  MOVWF  x23
046E2:  MOVLB  0
046E4:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(317, MIXER_SELECT79);     // MIXER_SELECT79 
046E8:  MOVLW  01
046EA:  MOVLB  8
046EC:  MOVWF  x22
046EE:  MOVLW  3D
046F0:  MOVWF  x21
046F2:  CLRF   x24
046F4:  MOVLW  52
046F6:  MOVWF  x23
046F8:  MOVLB  0
046FA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(318, OUT_1_1_FILTER_B0);     // OUT_1_1_FILTER_B0 
046FE:  MOVLW  01
04700:  MOVLB  8
04702:  MOVWF  x22
04704:  MOVLW  3E
04706:  MOVWF  x21
04708:  MOVLW  02
0470A:  MOVWF  x24
0470C:  MOVLW  F5
0470E:  MOVWF  x23
04710:  MOVLB  0
04712:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(319, OUT_1_1_FILTER_B1);     // OUT_1_1_FILTER_B1 
04716:  MOVLW  01
04718:  MOVLB  8
0471A:  MOVWF  x22
0471C:  MOVLW  3F
0471E:  MOVWF  x21
04720:  MOVLW  02
04722:  MOVWF  x24
04724:  MOVLW  F6
04726:  MOVWF  x23
04728:  MOVLB  0
0472A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(320, OUT_1_1_FILTER_B2);     // OUT_1_1_FILTER_B2 
0472E:  MOVLW  01
04730:  MOVLB  8
04732:  MOVWF  x22
04734:  MOVLW  40
04736:  MOVWF  x21
04738:  MOVLW  02
0473A:  MOVWF  x24
0473C:  MOVLW  F7
0473E:  MOVWF  x23
04740:  MOVLB  0
04742:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(321, OUT_1_1_FILTER_NEGATIVEA1);     // OUT_1_1_FILTER_NEGATIVEA1 
04746:  MOVLW  01
04748:  MOVLB  8
0474A:  MOVWF  x22
0474C:  MOVLW  41
0474E:  MOVWF  x21
04750:  MOVLW  02
04752:  MOVWF  x24
04754:  MOVLW  F8
04756:  MOVWF  x23
04758:  MOVLB  0
0475A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(322, OUT_1_1_FILTER_NEGATIVEA2);     // OUT_1_1_FILTER_NEGATIVEA2 
0475E:  MOVLW  01
04760:  MOVLB  8
04762:  MOVWF  x22
04764:  MOVLW  42
04766:  MOVWF  x21
04768:  MOVLW  02
0476A:  MOVWF  x24
0476C:  MOVLW  F9
0476E:  MOVWF  x23
04770:  MOVLB  0
04772:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(323, OUT_1_2_FILTER_B0);     // OUT_1_2_FILTER_B0 
04776:  MOVLW  01
04778:  MOVLB  8
0477A:  MOVWF  x22
0477C:  MOVLW  43
0477E:  MOVWF  x21
04780:  MOVLW  02
04782:  MOVWF  x24
04784:  MOVLW  F0
04786:  MOVWF  x23
04788:  MOVLB  0
0478A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(324, OUT_1_2_FILTER_B1);     // OUT_1_2_FILTER_B1 
0478E:  MOVLW  01
04790:  MOVLB  8
04792:  MOVWF  x22
04794:  MOVLW  44
04796:  MOVWF  x21
04798:  MOVLW  02
0479A:  MOVWF  x24
0479C:  MOVLW  F1
0479E:  MOVWF  x23
047A0:  MOVLB  0
047A2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(325, OUT_1_2_FILTER_B2);     // OUT_1_2_FILTER_B2 
047A6:  MOVLW  01
047A8:  MOVLB  8
047AA:  MOVWF  x22
047AC:  MOVLW  45
047AE:  MOVWF  x21
047B0:  MOVLW  02
047B2:  MOVWF  x24
047B4:  MOVLW  F2
047B6:  MOVWF  x23
047B8:  MOVLB  0
047BA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(326, OUT_1_2_FILTER_NEGATIVEA1);     // OUT_1_2_FILTER_NEGATIVEA1 
047BE:  MOVLW  01
047C0:  MOVLB  8
047C2:  MOVWF  x22
047C4:  MOVLW  46
047C6:  MOVWF  x21
047C8:  MOVLW  02
047CA:  MOVWF  x24
047CC:  MOVLW  F3
047CE:  MOVWF  x23
047D0:  MOVLB  0
047D2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(327, OUT_1_2_FILTER_NEGATIVEA2);     // OUT_1_2_FILTER_NEGATIVEA2 
047D6:  MOVLW  01
047D8:  MOVLB  8
047DA:  MOVWF  x22
047DC:  MOVLW  47
047DE:  MOVWF  x21
047E0:  MOVLW  02
047E2:  MOVWF  x24
047E4:  MOVLW  F4
047E6:  MOVWF  x23
047E8:  MOVLB  0
047EA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(328, OUT_1_3_FILTER_B0);     // OUT_1_3_FILTER_B0 
047EE:  MOVLW  01
047F0:  MOVLB  8
047F2:  MOVWF  x22
047F4:  MOVLW  48
047F6:  MOVWF  x21
047F8:  MOVLW  02
047FA:  MOVWF  x24
047FC:  MOVLW  EB
047FE:  MOVWF  x23
04800:  MOVLB  0
04802:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(329, OUT_1_3_FILTER_B1);     // OUT_1_3_FILTER_B1 
04806:  MOVLW  01
04808:  MOVLB  8
0480A:  MOVWF  x22
0480C:  MOVLW  49
0480E:  MOVWF  x21
04810:  MOVLW  02
04812:  MOVWF  x24
04814:  MOVLW  EC
04816:  MOVWF  x23
04818:  MOVLB  0
0481A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(330, OUT_1_3_FILTER_B2);     // OUT_1_3_FILTER_B2 
0481E:  MOVLW  01
04820:  MOVLB  8
04822:  MOVWF  x22
04824:  MOVLW  4A
04826:  MOVWF  x21
04828:  MOVLW  02
0482A:  MOVWF  x24
0482C:  MOVLW  ED
0482E:  MOVWF  x23
04830:  MOVLB  0
04832:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(331, OUT_1_3_FILTER_NEGATIVEA1);     // OUT_1_3_FILTER_NEGATIVEA1 
04836:  MOVLW  01
04838:  MOVLB  8
0483A:  MOVWF  x22
0483C:  MOVLW  4B
0483E:  MOVWF  x21
04840:  MOVLW  02
04842:  MOVWF  x24
04844:  MOVLW  EE
04846:  MOVWF  x23
04848:  MOVLB  0
0484A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(332, OUT_1_3_FILTER_NEGATIVEA2);     // OUT_1_3_FILTER_NEGATIVEA2 
0484E:  MOVLW  01
04850:  MOVLB  8
04852:  MOVWF  x22
04854:  MOVLW  4C
04856:  MOVWF  x21
04858:  MOVLW  02
0485A:  MOVWF  x24
0485C:  MOVLW  EF
0485E:  MOVWF  x23
04860:  MOVLB  0
04862:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(333, OUT_1_4_FILTER_B0);     // OUT_1_4_FILTER_B0 
04866:  MOVLW  01
04868:  MOVLB  8
0486A:  MOVWF  x22
0486C:  MOVLW  4D
0486E:  MOVWF  x21
04870:  MOVLW  02
04872:  MOVWF  x24
04874:  MOVLW  B9
04876:  MOVWF  x23
04878:  MOVLB  0
0487A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(334, OUT_1_4_FILTER_B1);     // OUT_1_4_FILTER_B1 
0487E:  MOVLW  01
04880:  MOVLB  8
04882:  MOVWF  x22
04884:  MOVLW  4E
04886:  MOVWF  x21
04888:  MOVLW  02
0488A:  MOVWF  x24
0488C:  MOVLW  BA
0488E:  MOVWF  x23
04890:  MOVLB  0
04892:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(335, OUT_1_4_FILTER_B2);     // OUT_1_4_FILTER_B2 
04896:  MOVLW  01
04898:  MOVLB  8
0489A:  MOVWF  x22
0489C:  MOVLW  4F
0489E:  MOVWF  x21
048A0:  MOVLW  02
048A2:  MOVWF  x24
048A4:  MOVLW  BB
048A6:  MOVWF  x23
048A8:  MOVLB  0
048AA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(336, OUT_1_4_FILTER_NEGATIVEA1);     // OUT_1_4_FILTER_NEGATIVEA1 
048AE:  MOVLW  01
048B0:  MOVLB  8
048B2:  MOVWF  x22
048B4:  MOVLW  50
048B6:  MOVWF  x21
048B8:  MOVLW  02
048BA:  MOVWF  x24
048BC:  MOVLW  BC
048BE:  MOVWF  x23
048C0:  MOVLB  0
048C2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(337, OUT_1_4_FILTER_NEGATIVEA2);     // OUT_1_4_FILTER_NEGATIVEA2 
048C6:  MOVLW  01
048C8:  MOVLB  8
048CA:  MOVWF  x22
048CC:  MOVLW  51
048CE:  MOVWF  x21
048D0:  MOVLW  02
048D2:  MOVWF  x24
048D4:  MOVLW  BD
048D6:  MOVWF  x23
048D8:  MOVLB  0
048DA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(338, OUT_1_5_FILTER_B0);     // OUT_1_5_FILTER_B0 
048DE:  MOVLW  01
048E0:  MOVLB  8
048E2:  MOVWF  x22
048E4:  MOVLW  52
048E6:  MOVWF  x21
048E8:  MOVLW  02
048EA:  MOVWF  x24
048EC:  MOVLW  B4
048EE:  MOVWF  x23
048F0:  MOVLB  0
048F2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(339, OUT_1_5_FILTER_B1);     // OUT_1_5_FILTER_B1 
048F6:  MOVLW  01
048F8:  MOVLB  8
048FA:  MOVWF  x22
048FC:  MOVLW  53
048FE:  MOVWF  x21
04900:  MOVLW  02
04902:  MOVWF  x24
04904:  MOVLW  B5
04906:  MOVWF  x23
04908:  MOVLB  0
0490A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(340, OUT_1_5_FILTER_B2);     // OUT_1_5_FILTER_B2 
0490E:  MOVLW  01
04910:  MOVLB  8
04912:  MOVWF  x22
04914:  MOVLW  54
04916:  MOVWF  x21
04918:  MOVLW  02
0491A:  MOVWF  x24
0491C:  MOVLW  B6
0491E:  MOVWF  x23
04920:  MOVLB  0
04922:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(341, OUT_1_5_FILTER_NEGATIVEA1);     // OUT_1_5_FILTER_NEGATIVEA1 
04926:  MOVLW  01
04928:  MOVLB  8
0492A:  MOVWF  x22
0492C:  MOVLW  55
0492E:  MOVWF  x21
04930:  MOVLW  02
04932:  MOVWF  x24
04934:  MOVLW  B7
04936:  MOVWF  x23
04938:  MOVLB  0
0493A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(342, OUT_1_5_FILTER_NEGATIVEA2);     // OUT_1_5_FILTER_NEGATIVEA2 
0493E:  MOVLW  01
04940:  MOVLB  8
04942:  MOVWF  x22
04944:  MOVLW  56
04946:  MOVWF  x21
04948:  MOVLW  02
0494A:  MOVWF  x24
0494C:  MOVLW  B8
0494E:  MOVWF  x23
04950:  MOVLB  0
04952:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(343, OUT_1_6_FILTER_B0);     // OUT_1_6_FILTER_B0 
04956:  MOVLW  01
04958:  MOVLB  8
0495A:  MOVWF  x22
0495C:  MOVLW  57
0495E:  MOVWF  x21
04960:  MOVLW  02
04962:  MOVWF  x24
04964:  MOVLW  AF
04966:  MOVWF  x23
04968:  MOVLB  0
0496A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(344, OUT_1_6_FILTER_B1);     // OUT_1_6_FILTER_B1 
0496E:  MOVLW  01
04970:  MOVLB  8
04972:  MOVWF  x22
04974:  MOVLW  58
04976:  MOVWF  x21
04978:  MOVLW  02
0497A:  MOVWF  x24
0497C:  MOVLW  B0
0497E:  MOVWF  x23
04980:  MOVLB  0
04982:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(345, OUT_1_6_FILTER_B2);     // OUT_1_6_FILTER_B2 
04986:  MOVLW  01
04988:  MOVLB  8
0498A:  MOVWF  x22
0498C:  MOVLW  59
0498E:  MOVWF  x21
04990:  MOVLW  02
04992:  MOVWF  x24
04994:  MOVLW  B1
04996:  MOVWF  x23
04998:  MOVLB  0
0499A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(346, OUT_1_6_FILTER_NEGATIVEA1);     // OUT_1_6_FILTER_NEGATIVEA1 
0499E:  MOVLW  01
049A0:  MOVLB  8
049A2:  MOVWF  x22
049A4:  MOVLW  5A
049A6:  MOVWF  x21
049A8:  MOVLW  02
049AA:  MOVWF  x24
049AC:  MOVLW  B2
049AE:  MOVWF  x23
049B0:  MOVLB  0
049B2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(347, OUT_1_6_FILTER_NEGATIVEA2);     // OUT_1_6_FILTER_NEGATIVEA2 
049B6:  MOVLW  01
049B8:  MOVLB  8
049BA:  MOVWF  x22
049BC:  MOVLW  5B
049BE:  MOVWF  x21
049C0:  MOVLW  02
049C2:  MOVWF  x24
049C4:  MOVLW  B3
049C6:  MOVWF  x23
049C8:  MOVLB  0
049CA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(348, OUT_2_1_FILTER_B0);     // OUT_2_1_FILTER_B0 
049CE:  MOVLW  01
049D0:  MOVLB  8
049D2:  MOVWF  x22
049D4:  MOVLW  5C
049D6:  MOVWF  x21
049D8:  MOVLW  02
049DA:  MOVWF  x24
049DC:  MOVLW  E6
049DE:  MOVWF  x23
049E0:  MOVLB  0
049E2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(349, OUT_2_1_FILTER_B1);     // OUT_2_1_FILTER_B1 
049E6:  MOVLW  01
049E8:  MOVLB  8
049EA:  MOVWF  x22
049EC:  MOVLW  5D
049EE:  MOVWF  x21
049F0:  MOVLW  02
049F2:  MOVWF  x24
049F4:  MOVLW  E7
049F6:  MOVWF  x23
049F8:  MOVLB  0
049FA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(350, OUT_2_1_FILTER_B2);     // OUT_2_1_FILTER_B2 
049FE:  MOVLW  01
04A00:  MOVLB  8
04A02:  MOVWF  x22
04A04:  MOVLW  5E
04A06:  MOVWF  x21
04A08:  MOVLW  02
04A0A:  MOVWF  x24
04A0C:  MOVLW  E8
04A0E:  MOVWF  x23
04A10:  MOVLB  0
04A12:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(351, OUT_2_1_FILTER_NEGATIVEA1);     // OUT_2_1_FILTER_NEGATIVEA1 
04A16:  MOVLW  01
04A18:  MOVLB  8
04A1A:  MOVWF  x22
04A1C:  MOVLW  5F
04A1E:  MOVWF  x21
04A20:  MOVLW  02
04A22:  MOVWF  x24
04A24:  MOVLW  E9
04A26:  MOVWF  x23
04A28:  MOVLB  0
04A2A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(352, OUT_2_1_FILTER_NEGATIVEA2);     // OUT_2_1_FILTER_NEGATIVEA2 
04A2E:  MOVLW  01
04A30:  MOVLB  8
04A32:  MOVWF  x22
04A34:  MOVLW  60
04A36:  MOVWF  x21
04A38:  MOVLW  02
04A3A:  MOVWF  x24
04A3C:  MOVLW  EA
04A3E:  MOVWF  x23
04A40:  MOVLB  0
04A42:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(353, OUT_2_2_FILTER_B0);     // OUT_2_2_FILTER_B0 
04A46:  MOVLW  01
04A48:  MOVLB  8
04A4A:  MOVWF  x22
04A4C:  MOVLW  61
04A4E:  MOVWF  x21
04A50:  MOVLW  02
04A52:  MOVWF  x24
04A54:  MOVLW  E1
04A56:  MOVWF  x23
04A58:  MOVLB  0
04A5A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(354, OUT_2_2_FILTER_B1);     // OUT_2_2_FILTER_B1 
04A5E:  MOVLW  01
04A60:  MOVLB  8
04A62:  MOVWF  x22
04A64:  MOVLW  62
04A66:  MOVWF  x21
04A68:  MOVLW  02
04A6A:  MOVWF  x24
04A6C:  MOVLW  E2
04A6E:  MOVWF  x23
04A70:  MOVLB  0
04A72:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(355, OUT_2_2_FILTER_B2);     // OUT_2_2_FILTER_B2 
04A76:  MOVLW  01
04A78:  MOVLB  8
04A7A:  MOVWF  x22
04A7C:  MOVLW  63
04A7E:  MOVWF  x21
04A80:  MOVLW  02
04A82:  MOVWF  x24
04A84:  MOVLW  E3
04A86:  MOVWF  x23
04A88:  MOVLB  0
04A8A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(356, OUT_2_2_FILTER_NEGATIVEA1);     // OUT_2_2_FILTER_NEGATIVEA1 
04A8E:  MOVLW  01
04A90:  MOVLB  8
04A92:  MOVWF  x22
04A94:  MOVLW  64
04A96:  MOVWF  x21
04A98:  MOVLW  02
04A9A:  MOVWF  x24
04A9C:  MOVLW  E4
04A9E:  MOVWF  x23
04AA0:  MOVLB  0
04AA2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(357, OUT_2_2_FILTER_NEGATIVEA2);     // OUT_2_2_FILTER_NEGATIVEA2 
04AA6:  MOVLW  01
04AA8:  MOVLB  8
04AAA:  MOVWF  x22
04AAC:  MOVLW  65
04AAE:  MOVWF  x21
04AB0:  MOVLW  02
04AB2:  MOVWF  x24
04AB4:  MOVLW  E5
04AB6:  MOVWF  x23
04AB8:  MOVLB  0
04ABA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(358, OUT_2_3_FILTER_B0);     // OUT_2_3_FILTER_B0 
04ABE:  MOVLW  01
04AC0:  MOVLB  8
04AC2:  MOVWF  x22
04AC4:  MOVLW  66
04AC6:  MOVWF  x21
04AC8:  MOVLW  02
04ACA:  MOVWF  x24
04ACC:  MOVLW  DC
04ACE:  MOVWF  x23
04AD0:  MOVLB  0
04AD2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(359, OUT_2_3_FILTER_B1);     // OUT_2_3_FILTER_B1 
04AD6:  MOVLW  01
04AD8:  MOVLB  8
04ADA:  MOVWF  x22
04ADC:  MOVLW  67
04ADE:  MOVWF  x21
04AE0:  MOVLW  02
04AE2:  MOVWF  x24
04AE4:  MOVLW  DD
04AE6:  MOVWF  x23
04AE8:  MOVLB  0
04AEA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(360, OUT_2_3_FILTER_B2);     // OUT_2_3_FILTER_B2 
04AEE:  MOVLW  01
04AF0:  MOVLB  8
04AF2:  MOVWF  x22
04AF4:  MOVLW  68
04AF6:  MOVWF  x21
04AF8:  MOVLW  02
04AFA:  MOVWF  x24
04AFC:  MOVLW  DE
04AFE:  MOVWF  x23
04B00:  MOVLB  0
04B02:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(361, OUT_2_3_FILTER_NEGATIVEA1);     // OUT_2_3_FILTER_NEGATIVEA1 
04B06:  MOVLW  01
04B08:  MOVLB  8
04B0A:  MOVWF  x22
04B0C:  MOVLW  69
04B0E:  MOVWF  x21
04B10:  MOVLW  02
04B12:  MOVWF  x24
04B14:  MOVLW  DF
04B16:  MOVWF  x23
04B18:  MOVLB  0
04B1A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(362, OUT_2_3_FILTER_NEGATIVEA2);     // OUT_2_3_FILTER_NEGATIVEA2 
04B1E:  MOVLW  01
04B20:  MOVLB  8
04B22:  MOVWF  x22
04B24:  MOVLW  6A
04B26:  MOVWF  x21
04B28:  MOVLW  02
04B2A:  MOVWF  x24
04B2C:  MOVLW  E0
04B2E:  MOVWF  x23
04B30:  MOVLB  0
04B32:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(363, OUT_2_4_FILTER_B0);     // OUT_2_4_FILTER_B0 
04B36:  MOVLW  01
04B38:  MOVLB  8
04B3A:  MOVWF  x22
04B3C:  MOVLW  6B
04B3E:  MOVWF  x21
04B40:  MOVLW  02
04B42:  MOVWF  x24
04B44:  MOVLW  AA
04B46:  MOVWF  x23
04B48:  MOVLB  0
04B4A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(364, OUT_2_4_FILTER_B1);     // OUT_2_4_FILTER_B1 
04B4E:  MOVLW  01
04B50:  MOVLB  8
04B52:  MOVWF  x22
04B54:  MOVLW  6C
04B56:  MOVWF  x21
04B58:  MOVLW  02
04B5A:  MOVWF  x24
04B5C:  MOVLW  AB
04B5E:  MOVWF  x23
04B60:  MOVLB  0
04B62:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(365, OUT_2_4_FILTER_B2);     // OUT_2_4_FILTER_B2 
04B66:  MOVLW  01
04B68:  MOVLB  8
04B6A:  MOVWF  x22
04B6C:  MOVLW  6D
04B6E:  MOVWF  x21
04B70:  MOVLW  02
04B72:  MOVWF  x24
04B74:  MOVLW  AC
04B76:  MOVWF  x23
04B78:  MOVLB  0
04B7A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(366, OUT_2_4_FILTER_NEGATIVEA1);     // OUT_2_4_FILTER_NEGATIVEA1 
04B7E:  MOVLW  01
04B80:  MOVLB  8
04B82:  MOVWF  x22
04B84:  MOVLW  6E
04B86:  MOVWF  x21
04B88:  MOVLW  02
04B8A:  MOVWF  x24
04B8C:  MOVLW  AD
04B8E:  MOVWF  x23
04B90:  MOVLB  0
04B92:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(367, OUT_2_4_FILTER_NEGATIVEA2);     // OUT_2_4_FILTER_NEGATIVEA2 
04B96:  MOVLW  01
04B98:  MOVLB  8
04B9A:  MOVWF  x22
04B9C:  MOVLW  6F
04B9E:  MOVWF  x21
04BA0:  MOVLW  02
04BA2:  MOVWF  x24
04BA4:  MOVLW  AE
04BA6:  MOVWF  x23
04BA8:  MOVLB  0
04BAA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(368, OUT_2_5_FILTER_B0);     // OUT_2_5_FILTER_B0 
04BAE:  MOVLW  01
04BB0:  MOVLB  8
04BB2:  MOVWF  x22
04BB4:  MOVLW  70
04BB6:  MOVWF  x21
04BB8:  MOVLW  02
04BBA:  MOVWF  x24
04BBC:  MOVLW  A5
04BBE:  MOVWF  x23
04BC0:  MOVLB  0
04BC2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(369, OUT_2_5_FILTER_B1);     // OUT_2_5_FILTER_B1 
04BC6:  MOVLW  01
04BC8:  MOVLB  8
04BCA:  MOVWF  x22
04BCC:  MOVLW  71
04BCE:  MOVWF  x21
04BD0:  MOVLW  02
04BD2:  MOVWF  x24
04BD4:  MOVLW  A6
04BD6:  MOVWF  x23
04BD8:  MOVLB  0
04BDA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(370, OUT_2_5_FILTER_B2);     // OUT_2_5_FILTER_B2 
04BDE:  MOVLW  01
04BE0:  MOVLB  8
04BE2:  MOVWF  x22
04BE4:  MOVLW  72
04BE6:  MOVWF  x21
04BE8:  MOVLW  02
04BEA:  MOVWF  x24
04BEC:  MOVLW  A7
04BEE:  MOVWF  x23
04BF0:  MOVLB  0
04BF2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(371, OUT_2_5_FILTER_NEGATIVEA1);     // OUT_2_5_FILTER_NEGATIVEA1 
04BF6:  MOVLW  01
04BF8:  MOVLB  8
04BFA:  MOVWF  x22
04BFC:  MOVLW  73
04BFE:  MOVWF  x21
04C00:  MOVLW  02
04C02:  MOVWF  x24
04C04:  MOVLW  A8
04C06:  MOVWF  x23
04C08:  MOVLB  0
04C0A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(372, OUT_2_5_FILTER_NEGATIVEA2);     // OUT_2_5_FILTER_NEGATIVEA2 
04C0E:  MOVLW  01
04C10:  MOVLB  8
04C12:  MOVWF  x22
04C14:  MOVLW  74
04C16:  MOVWF  x21
04C18:  MOVLW  02
04C1A:  MOVWF  x24
04C1C:  MOVLW  A9
04C1E:  MOVWF  x23
04C20:  MOVLB  0
04C22:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(373, OUT_2_6_FILTER_B0);     // OUT_2_6_FILTER_B0 
04C26:  MOVLW  01
04C28:  MOVLB  8
04C2A:  MOVWF  x22
04C2C:  MOVLW  75
04C2E:  MOVWF  x21
04C30:  MOVLW  02
04C32:  MOVWF  x24
04C34:  MOVLW  A0
04C36:  MOVWF  x23
04C38:  MOVLB  0
04C3A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(374, OUT_2_6_FILTER_B1);     // OUT_2_6_FILTER_B1 
04C3E:  MOVLW  01
04C40:  MOVLB  8
04C42:  MOVWF  x22
04C44:  MOVLW  76
04C46:  MOVWF  x21
04C48:  MOVLW  02
04C4A:  MOVWF  x24
04C4C:  MOVLW  A1
04C4E:  MOVWF  x23
04C50:  MOVLB  0
04C52:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(375, OUT_2_6_FILTER_B2);     // OUT_2_6_FILTER_B2 
04C56:  MOVLW  01
04C58:  MOVLB  8
04C5A:  MOVWF  x22
04C5C:  MOVLW  77
04C5E:  MOVWF  x21
04C60:  MOVLW  02
04C62:  MOVWF  x24
04C64:  MOVLW  A2
04C66:  MOVWF  x23
04C68:  MOVLB  0
04C6A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(376, OUT_2_6_FILTER_NEGATIVEA1);     // OUT_2_6_FILTER_NEGATIVEA1 
04C6E:  MOVLW  01
04C70:  MOVLB  8
04C72:  MOVWF  x22
04C74:  MOVLW  78
04C76:  MOVWF  x21
04C78:  MOVLW  02
04C7A:  MOVWF  x24
04C7C:  MOVLW  A3
04C7E:  MOVWF  x23
04C80:  MOVLB  0
04C82:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(377, OUT_2_6_FILTER_NEGATIVEA2);     // OUT_2_6_FILTER_NEGATIVEA2 
04C86:  MOVLW  01
04C88:  MOVLB  8
04C8A:  MOVWF  x22
04C8C:  MOVLW  79
04C8E:  MOVWF  x21
04C90:  MOVLW  02
04C92:  MOVWF  x24
04C94:  MOVLW  A4
04C96:  MOVWF  x23
04C98:  MOVLB  0
04C9A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(378, OUT_3_1_FILTER_B0);     // OUT_3_1_FILTER_B0 
04C9E:  MOVLW  01
04CA0:  MOVLB  8
04CA2:  MOVWF  x22
04CA4:  MOVLW  7A
04CA6:  MOVWF  x21
04CA8:  MOVLW  02
04CAA:  MOVWF  x24
04CAC:  MOVLW  D7
04CAE:  MOVWF  x23
04CB0:  MOVLB  0
04CB2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(379, OUT_3_1_FILTER_B1);     // OUT_3_1_FILTER_B1 
04CB6:  MOVLW  01
04CB8:  MOVLB  8
04CBA:  MOVWF  x22
04CBC:  MOVLW  7B
04CBE:  MOVWF  x21
04CC0:  MOVLW  02
04CC2:  MOVWF  x24
04CC4:  MOVLW  D8
04CC6:  MOVWF  x23
04CC8:  MOVLB  0
04CCA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(380, OUT_3_1_FILTER_B2);     // OUT_3_1_FILTER_B2 
04CCE:  MOVLW  01
04CD0:  MOVLB  8
04CD2:  MOVWF  x22
04CD4:  MOVLW  7C
04CD6:  MOVWF  x21
04CD8:  MOVLW  02
04CDA:  MOVWF  x24
04CDC:  MOVLW  D9
04CDE:  MOVWF  x23
04CE0:  MOVLB  0
04CE2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(381, OUT_3_1_FILTER_NEGATIVEA1);     // OUT_3_1_FILTER_NEGATIVEA1 
04CE6:  MOVLW  01
04CE8:  MOVLB  8
04CEA:  MOVWF  x22
04CEC:  MOVLW  7D
04CEE:  MOVWF  x21
04CF0:  MOVLW  02
04CF2:  MOVWF  x24
04CF4:  MOVLW  DA
04CF6:  MOVWF  x23
04CF8:  MOVLB  0
04CFA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(382, OUT_3_1_FILTER_NEGATIVEA2);     // OUT_3_1_FILTER_NEGATIVEA2 
04CFE:  MOVLW  01
04D00:  MOVLB  8
04D02:  MOVWF  x22
04D04:  MOVLW  7E
04D06:  MOVWF  x21
04D08:  MOVLW  02
04D0A:  MOVWF  x24
04D0C:  MOVLW  DB
04D0E:  MOVWF  x23
04D10:  MOVLB  0
04D12:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(383, OUT_3_2_FILTER_B0);     // OUT_3_2_FILTER_B0 
04D16:  MOVLW  01
04D18:  MOVLB  8
04D1A:  MOVWF  x22
04D1C:  MOVLW  7F
04D1E:  MOVWF  x21
04D20:  MOVLW  02
04D22:  MOVWF  x24
04D24:  MOVLW  D2
04D26:  MOVWF  x23
04D28:  MOVLB  0
04D2A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(384, OUT_3_2_FILTER_B1);     // OUT_3_2_FILTER_B1 
04D2E:  MOVLW  01
04D30:  MOVLB  8
04D32:  MOVWF  x22
04D34:  MOVLW  80
04D36:  MOVWF  x21
04D38:  MOVLW  02
04D3A:  MOVWF  x24
04D3C:  MOVLW  D3
04D3E:  MOVWF  x23
04D40:  MOVLB  0
04D42:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(385, OUT_3_2_FILTER_B2);     // OUT_3_2_FILTER_B2 
04D46:  MOVLW  01
04D48:  MOVLB  8
04D4A:  MOVWF  x22
04D4C:  MOVLW  81
04D4E:  MOVWF  x21
04D50:  MOVLW  02
04D52:  MOVWF  x24
04D54:  MOVLW  D4
04D56:  MOVWF  x23
04D58:  MOVLB  0
04D5A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(386, OUT_3_2_FILTER_NEGATIVEA1);     // OUT_3_2_FILTER_NEGATIVEA1 
04D5E:  MOVLW  01
04D60:  MOVLB  8
04D62:  MOVWF  x22
04D64:  MOVLW  82
04D66:  MOVWF  x21
04D68:  MOVLW  02
04D6A:  MOVWF  x24
04D6C:  MOVLW  D5
04D6E:  MOVWF  x23
04D70:  MOVLB  0
04D72:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(387, OUT_3_2_FILTER_NEGATIVEA2);     // OUT_3_2_FILTER_NEGATIVEA2 
04D76:  MOVLW  01
04D78:  MOVLB  8
04D7A:  MOVWF  x22
04D7C:  MOVLW  83
04D7E:  MOVWF  x21
04D80:  MOVLW  02
04D82:  MOVWF  x24
04D84:  MOVLW  D6
04D86:  MOVWF  x23
04D88:  MOVLB  0
04D8A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(388, OUT_3_3_FILTER_B0);     // OUT_3_3_FILTER_B0 
04D8E:  MOVLW  01
04D90:  MOVLB  8
04D92:  MOVWF  x22
04D94:  MOVLW  84
04D96:  MOVWF  x21
04D98:  MOVLW  02
04D9A:  MOVWF  x24
04D9C:  MOVLW  CD
04D9E:  MOVWF  x23
04DA0:  MOVLB  0
04DA2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(389, OUT_3_3_FILTER_B1);     // OUT_3_3_FILTER_B1 
04DA6:  MOVLW  01
04DA8:  MOVLB  8
04DAA:  MOVWF  x22
04DAC:  MOVLW  85
04DAE:  MOVWF  x21
04DB0:  MOVLW  02
04DB2:  MOVWF  x24
04DB4:  MOVLW  CE
04DB6:  MOVWF  x23
04DB8:  MOVLB  0
04DBA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(390, OUT_3_3_FILTER_B2);     // OUT_3_3_FILTER_B2 
04DBE:  MOVLW  01
04DC0:  MOVLB  8
04DC2:  MOVWF  x22
04DC4:  MOVLW  86
04DC6:  MOVWF  x21
04DC8:  MOVLW  02
04DCA:  MOVWF  x24
04DCC:  MOVLW  CF
04DCE:  MOVWF  x23
04DD0:  MOVLB  0
04DD2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(391, OUT_3_3_FILTER_NEGATIVEA1);     // OUT_3_3_FILTER_NEGATIVEA1 
04DD6:  MOVLW  01
04DD8:  MOVLB  8
04DDA:  MOVWF  x22
04DDC:  MOVLW  87
04DDE:  MOVWF  x21
04DE0:  MOVLW  02
04DE2:  MOVWF  x24
04DE4:  MOVLW  D0
04DE6:  MOVWF  x23
04DE8:  MOVLB  0
04DEA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(392, OUT_3_3_FILTER_NEGATIVEA2);     // OUT_3_3_FILTER_NEGATIVEA2 
04DEE:  MOVLW  01
04DF0:  MOVLB  8
04DF2:  MOVWF  x22
04DF4:  MOVLW  88
04DF6:  MOVWF  x21
04DF8:  MOVLW  02
04DFA:  MOVWF  x24
04DFC:  MOVLW  D1
04DFE:  MOVWF  x23
04E00:  MOVLB  0
04E02:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(393, OUT_3_4_FILTER_B0);     // OUT_3_4_FILTER_B0 
04E06:  MOVLW  01
04E08:  MOVLB  8
04E0A:  MOVWF  x22
04E0C:  MOVLW  89
04E0E:  MOVWF  x21
04E10:  MOVLW  02
04E12:  MOVWF  x24
04E14:  MOVLW  9B
04E16:  MOVWF  x23
04E18:  MOVLB  0
04E1A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(394, OUT_3_4_FILTER_B1);     // OUT_3_4_FILTER_B1 
04E1E:  MOVLW  01
04E20:  MOVLB  8
04E22:  MOVWF  x22
04E24:  MOVLW  8A
04E26:  MOVWF  x21
04E28:  MOVLW  02
04E2A:  MOVWF  x24
04E2C:  MOVLW  9C
04E2E:  MOVWF  x23
04E30:  MOVLB  0
04E32:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(395, OUT_3_4_FILTER_B2);     // OUT_3_4_FILTER_B2 
04E36:  MOVLW  01
04E38:  MOVLB  8
04E3A:  MOVWF  x22
04E3C:  MOVLW  8B
04E3E:  MOVWF  x21
04E40:  MOVLW  02
04E42:  MOVWF  x24
04E44:  MOVLW  9D
04E46:  MOVWF  x23
04E48:  MOVLB  0
04E4A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(396, OUT_3_4_FILTER_NEGATIVEA1);     // OUT_3_4_FILTER_NEGATIVEA1 
04E4E:  MOVLW  01
04E50:  MOVLB  8
04E52:  MOVWF  x22
04E54:  MOVLW  8C
04E56:  MOVWF  x21
04E58:  MOVLW  02
04E5A:  MOVWF  x24
04E5C:  MOVLW  9E
04E5E:  MOVWF  x23
04E60:  MOVLB  0
04E62:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(397, OUT_3_4_FILTER_NEGATIVEA2);     // OUT_3_4_FILTER_NEGATIVEA2 
04E66:  MOVLW  01
04E68:  MOVLB  8
04E6A:  MOVWF  x22
04E6C:  MOVLW  8D
04E6E:  MOVWF  x21
04E70:  MOVLW  02
04E72:  MOVWF  x24
04E74:  MOVLW  9F
04E76:  MOVWF  x23
04E78:  MOVLB  0
04E7A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(398, OUT_3_5_FILTER_B0);     // OUT_3_5_FILTER_B0 
04E7E:  MOVLW  01
04E80:  MOVLB  8
04E82:  MOVWF  x22
04E84:  MOVLW  8E
04E86:  MOVWF  x21
04E88:  MOVLW  02
04E8A:  MOVWF  x24
04E8C:  MOVLW  96
04E8E:  MOVWF  x23
04E90:  MOVLB  0
04E92:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(399, OUT_3_5_FILTER_B1);     // OUT_3_5_FILTER_B1 
04E96:  MOVLW  01
04E98:  MOVLB  8
04E9A:  MOVWF  x22
04E9C:  MOVLW  8F
04E9E:  MOVWF  x21
04EA0:  MOVLW  02
04EA2:  MOVWF  x24
04EA4:  MOVLW  97
04EA6:  MOVWF  x23
04EA8:  MOVLB  0
04EAA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(400, OUT_3_5_FILTER_B2);     // OUT_3_5_FILTER_B2 
04EAE:  MOVLW  01
04EB0:  MOVLB  8
04EB2:  MOVWF  x22
04EB4:  MOVLW  90
04EB6:  MOVWF  x21
04EB8:  MOVLW  02
04EBA:  MOVWF  x24
04EBC:  MOVLW  98
04EBE:  MOVWF  x23
04EC0:  MOVLB  0
04EC2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(401, OUT_3_5_FILTER_NEGATIVEA1);     // OUT_3_5_FILTER_NEGATIVEA1 
04EC6:  MOVLW  01
04EC8:  MOVLB  8
04ECA:  MOVWF  x22
04ECC:  MOVLW  91
04ECE:  MOVWF  x21
04ED0:  MOVLW  02
04ED2:  MOVWF  x24
04ED4:  MOVLW  99
04ED6:  MOVWF  x23
04ED8:  MOVLB  0
04EDA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(402, OUT_3_5_FILTER_NEGATIVEA2);     // OUT_3_5_FILTER_NEGATIVEA2 
04EDE:  MOVLW  01
04EE0:  MOVLB  8
04EE2:  MOVWF  x22
04EE4:  MOVLW  92
04EE6:  MOVWF  x21
04EE8:  MOVLW  02
04EEA:  MOVWF  x24
04EEC:  MOVLW  9A
04EEE:  MOVWF  x23
04EF0:  MOVLB  0
04EF2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(403, OUT_3_6_FILTER_B0);     // OUT_3_6_FILTER_B0 
04EF6:  MOVLW  01
04EF8:  MOVLB  8
04EFA:  MOVWF  x22
04EFC:  MOVLW  93
04EFE:  MOVWF  x21
04F00:  MOVLW  02
04F02:  MOVWF  x24
04F04:  MOVLW  91
04F06:  MOVWF  x23
04F08:  MOVLB  0
04F0A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(404, OUT_3_6_FILTER_B1);     // OUT_3_6_FILTER_B1 
04F0E:  MOVLW  01
04F10:  MOVLB  8
04F12:  MOVWF  x22
04F14:  MOVLW  94
04F16:  MOVWF  x21
04F18:  MOVLW  02
04F1A:  MOVWF  x24
04F1C:  MOVLW  92
04F1E:  MOVWF  x23
04F20:  MOVLB  0
04F22:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(405, OUT_3_6_FILTER_B2);     // OUT_3_6_FILTER_B2 
04F26:  MOVLW  01
04F28:  MOVLB  8
04F2A:  MOVWF  x22
04F2C:  MOVLW  95
04F2E:  MOVWF  x21
04F30:  MOVLW  02
04F32:  MOVWF  x24
04F34:  MOVLW  93
04F36:  MOVWF  x23
04F38:  MOVLB  0
04F3A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(406, OUT_3_6_FILTER_NEGATIVEA1);     // OUT_3_6_FILTER_NEGATIVEA1 
04F3E:  MOVLW  01
04F40:  MOVLB  8
04F42:  MOVWF  x22
04F44:  MOVLW  96
04F46:  MOVWF  x21
04F48:  MOVLW  02
04F4A:  MOVWF  x24
04F4C:  MOVLW  94
04F4E:  MOVWF  x23
04F50:  MOVLB  0
04F52:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(407, OUT_3_6_FILTER_NEGATIVEA2);     // OUT_3_6_FILTER_NEGATIVEA2 
04F56:  MOVLW  01
04F58:  MOVLB  8
04F5A:  MOVWF  x22
04F5C:  MOVLW  97
04F5E:  MOVWF  x21
04F60:  MOVLW  02
04F62:  MOVWF  x24
04F64:  MOVLW  95
04F66:  MOVWF  x23
04F68:  MOVLB  0
04F6A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(408, OUT_4_1_FILTER_B0);     // OUT_4_1_FILTER_B0 
04F6E:  MOVLW  01
04F70:  MOVLB  8
04F72:  MOVWF  x22
04F74:  MOVLW  98
04F76:  MOVWF  x21
04F78:  MOVLW  02
04F7A:  MOVWF  x24
04F7C:  MOVLW  C8
04F7E:  MOVWF  x23
04F80:  MOVLB  0
04F82:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(409, OUT_4_1_FILTER_B1);     // OUT_4_1_FILTER_B1 
04F86:  MOVLW  01
04F88:  MOVLB  8
04F8A:  MOVWF  x22
04F8C:  MOVLW  99
04F8E:  MOVWF  x21
04F90:  MOVLW  02
04F92:  MOVWF  x24
04F94:  MOVLW  C9
04F96:  MOVWF  x23
04F98:  MOVLB  0
04F9A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(410, OUT_4_1_FILTER_B2);     // OUT_4_1_FILTER_B2 
04F9E:  MOVLW  01
04FA0:  MOVLB  8
04FA2:  MOVWF  x22
04FA4:  MOVLW  9A
04FA6:  MOVWF  x21
04FA8:  MOVLW  02
04FAA:  MOVWF  x24
04FAC:  MOVLW  CA
04FAE:  MOVWF  x23
04FB0:  MOVLB  0
04FB2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(411, OUT_4_1_FILTER_NEGATIVEA1);     // OUT_4_1_FILTER_NEGATIVEA1 
04FB6:  MOVLW  01
04FB8:  MOVLB  8
04FBA:  MOVWF  x22
04FBC:  MOVLW  9B
04FBE:  MOVWF  x21
04FC0:  MOVLW  02
04FC2:  MOVWF  x24
04FC4:  MOVLW  CB
04FC6:  MOVWF  x23
04FC8:  MOVLB  0
04FCA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(412, OUT_4_1_FILTER_NEGATIVEA2);     // OUT_4_1_FILTER_NEGATIVEA2 
04FCE:  MOVLW  01
04FD0:  MOVLB  8
04FD2:  MOVWF  x22
04FD4:  MOVLW  9C
04FD6:  MOVWF  x21
04FD8:  MOVLW  02
04FDA:  MOVWF  x24
04FDC:  MOVLW  CC
04FDE:  MOVWF  x23
04FE0:  MOVLB  0
04FE2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(413, OUT_4_2_FILTER_B0);     // OUT_4_2_FILTER_B0 
04FE6:  MOVLW  01
04FE8:  MOVLB  8
04FEA:  MOVWF  x22
04FEC:  MOVLW  9D
04FEE:  MOVWF  x21
04FF0:  MOVLW  02
04FF2:  MOVWF  x24
04FF4:  MOVLW  C3
04FF6:  MOVWF  x23
04FF8:  MOVLB  0
04FFA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(414, OUT_4_2_FILTER_B1);     // OUT_4_2_FILTER_B1 
04FFE:  MOVLW  01
05000:  MOVLB  8
05002:  MOVWF  x22
05004:  MOVLW  9E
05006:  MOVWF  x21
05008:  MOVLW  02
0500A:  MOVWF  x24
0500C:  MOVLW  C4
0500E:  MOVWF  x23
05010:  MOVLB  0
05012:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(415, OUT_4_2_FILTER_B2);     // OUT_4_2_FILTER_B2 
05016:  MOVLW  01
05018:  MOVLB  8
0501A:  MOVWF  x22
0501C:  MOVLW  9F
0501E:  MOVWF  x21
05020:  MOVLW  02
05022:  MOVWF  x24
05024:  MOVLW  C5
05026:  MOVWF  x23
05028:  MOVLB  0
0502A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(416, OUT_4_2_FILTER_NEGATIVEA1);     // OUT_4_2_FILTER_NEGATIVEA1 
0502E:  MOVLW  01
05030:  MOVLB  8
05032:  MOVWF  x22
05034:  MOVLW  A0
05036:  MOVWF  x21
05038:  MOVLW  02
0503A:  MOVWF  x24
0503C:  MOVLW  C6
0503E:  MOVWF  x23
05040:  MOVLB  0
05042:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(417, OUT_4_2_FILTER_NEGATIVEA2);     // OUT_4_2_FILTER_NEGATIVEA2 
05046:  MOVLW  01
05048:  MOVLB  8
0504A:  MOVWF  x22
0504C:  MOVLW  A1
0504E:  MOVWF  x21
05050:  MOVLW  02
05052:  MOVWF  x24
05054:  MOVLW  C7
05056:  MOVWF  x23
05058:  MOVLB  0
0505A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(418, OUT_4_3_FILTER_B0);     // OUT_4_3_FILTER_B0 
0505E:  MOVLW  01
05060:  MOVLB  8
05062:  MOVWF  x22
05064:  MOVLW  A2
05066:  MOVWF  x21
05068:  MOVLW  02
0506A:  MOVWF  x24
0506C:  MOVLW  BE
0506E:  MOVWF  x23
05070:  MOVLB  0
05072:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(419, OUT_4_3_FILTER_B1);     // OUT_4_3_FILTER_B1 
05076:  MOVLW  01
05078:  MOVLB  8
0507A:  MOVWF  x22
0507C:  MOVLW  A3
0507E:  MOVWF  x21
05080:  MOVLW  02
05082:  MOVWF  x24
05084:  MOVLW  BF
05086:  MOVWF  x23
05088:  MOVLB  0
0508A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(420, OUT_4_3_FILTER_B2);     // OUT_4_3_FILTER_B2 
0508E:  MOVLW  01
05090:  MOVLB  8
05092:  MOVWF  x22
05094:  MOVLW  A4
05096:  MOVWF  x21
05098:  MOVLW  02
0509A:  MOVWF  x24
0509C:  MOVLW  C0
0509E:  MOVWF  x23
050A0:  MOVLB  0
050A2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(421, OUT_4_3_FILTER_NEGATIVEA1);     // OUT_4_3_FILTER_NEGATIVEA1 
050A6:  MOVLW  01
050A8:  MOVLB  8
050AA:  MOVWF  x22
050AC:  MOVLW  A5
050AE:  MOVWF  x21
050B0:  MOVLW  02
050B2:  MOVWF  x24
050B4:  MOVLW  C1
050B6:  MOVWF  x23
050B8:  MOVLB  0
050BA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(422, OUT_4_3_FILTER_NEGATIVEA2);     // OUT_4_3_FILTER_NEGATIVEA2 
050BE:  MOVLW  01
050C0:  MOVLB  8
050C2:  MOVWF  x22
050C4:  MOVLW  A6
050C6:  MOVWF  x21
050C8:  MOVLW  02
050CA:  MOVWF  x24
050CC:  MOVLW  C2
050CE:  MOVWF  x23
050D0:  MOVLB  0
050D2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(423, OUT_4_4_FILTER_B0);     // OUT_4_4_FILTER_B0 
050D6:  MOVLW  01
050D8:  MOVLB  8
050DA:  MOVWF  x22
050DC:  MOVLW  A7
050DE:  MOVWF  x21
050E0:  MOVLW  02
050E2:  MOVWF  x24
050E4:  MOVLW  8C
050E6:  MOVWF  x23
050E8:  MOVLB  0
050EA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(424, OUT_4_4_FILTER_B1);     // OUT_4_4_FILTER_B1 
050EE:  MOVLW  01
050F0:  MOVLB  8
050F2:  MOVWF  x22
050F4:  MOVLW  A8
050F6:  MOVWF  x21
050F8:  MOVLW  02
050FA:  MOVWF  x24
050FC:  MOVLW  8D
050FE:  MOVWF  x23
05100:  MOVLB  0
05102:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(425, OUT_4_4_FILTER_B2);     // OUT_4_4_FILTER_B2 
05106:  MOVLW  01
05108:  MOVLB  8
0510A:  MOVWF  x22
0510C:  MOVLW  A9
0510E:  MOVWF  x21
05110:  MOVLW  02
05112:  MOVWF  x24
05114:  MOVLW  8E
05116:  MOVWF  x23
05118:  MOVLB  0
0511A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(426, OUT_4_4_FILTER_NEGATIVEA1);     // OUT_4_4_FILTER_NEGATIVEA1 
0511E:  MOVLW  01
05120:  MOVLB  8
05122:  MOVWF  x22
05124:  MOVLW  AA
05126:  MOVWF  x21
05128:  MOVLW  02
0512A:  MOVWF  x24
0512C:  MOVLW  8F
0512E:  MOVWF  x23
05130:  MOVLB  0
05132:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(427, OUT_4_4_FILTER_NEGATIVEA2);     // OUT_4_4_FILTER_NEGATIVEA2 
05136:  MOVLW  01
05138:  MOVLB  8
0513A:  MOVWF  x22
0513C:  MOVLW  AB
0513E:  MOVWF  x21
05140:  MOVLW  02
05142:  MOVWF  x24
05144:  MOVLW  90
05146:  MOVWF  x23
05148:  MOVLB  0
0514A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(428, OUT_4_5_FILTER_B0);     // OUT_4_5_FILTER_B0 
0514E:  MOVLW  01
05150:  MOVLB  8
05152:  MOVWF  x22
05154:  MOVLW  AC
05156:  MOVWF  x21
05158:  MOVLW  02
0515A:  MOVWF  x24
0515C:  MOVLW  87
0515E:  MOVWF  x23
05160:  MOVLB  0
05162:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(429, OUT_4_5_FILTER_B1);     // OUT_4_5_FILTER_B1 
05166:  MOVLW  01
05168:  MOVLB  8
0516A:  MOVWF  x22
0516C:  MOVLW  AD
0516E:  MOVWF  x21
05170:  MOVLW  02
05172:  MOVWF  x24
05174:  MOVLW  88
05176:  MOVWF  x23
05178:  MOVLB  0
0517A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(430, OUT_4_5_FILTER_B2);     // OUT_4_5_FILTER_B2 
0517E:  MOVLW  01
05180:  MOVLB  8
05182:  MOVWF  x22
05184:  MOVLW  AE
05186:  MOVWF  x21
05188:  MOVLW  02
0518A:  MOVWF  x24
0518C:  MOVLW  89
0518E:  MOVWF  x23
05190:  MOVLB  0
05192:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(431, OUT_4_5_FILTER_NEGATIVEA1);     // OUT_4_5_FILTER_NEGATIVEA1 
05196:  MOVLW  01
05198:  MOVLB  8
0519A:  MOVWF  x22
0519C:  MOVLW  AF
0519E:  MOVWF  x21
051A0:  MOVLW  02
051A2:  MOVWF  x24
051A4:  MOVLW  8A
051A6:  MOVWF  x23
051A8:  MOVLB  0
051AA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(432, OUT_4_5_FILTER_NEGATIVEA2);     // OUT_4_5_FILTER_NEGATIVEA2 
051AE:  MOVLW  01
051B0:  MOVLB  8
051B2:  MOVWF  x22
051B4:  MOVLW  B0
051B6:  MOVWF  x21
051B8:  MOVLW  02
051BA:  MOVWF  x24
051BC:  MOVLW  8B
051BE:  MOVWF  x23
051C0:  MOVLB  0
051C2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(433, OUT_4_6_FILTER_B0);     // OUT_4_6_FILTER_B0 
051C6:  MOVLW  01
051C8:  MOVLB  8
051CA:  MOVWF  x22
051CC:  MOVLW  B1
051CE:  MOVWF  x21
051D0:  MOVLW  02
051D2:  MOVWF  x24
051D4:  MOVLW  82
051D6:  MOVWF  x23
051D8:  MOVLB  0
051DA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(434, OUT_4_6_FILTER_B1);     // OUT_4_6_FILTER_B1 
051DE:  MOVLW  01
051E0:  MOVLB  8
051E2:  MOVWF  x22
051E4:  MOVLW  B2
051E6:  MOVWF  x21
051E8:  MOVLW  02
051EA:  MOVWF  x24
051EC:  MOVLW  83
051EE:  MOVWF  x23
051F0:  MOVLB  0
051F2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(435, OUT_4_6_FILTER_B2);     // OUT_4_6_FILTER_B2 
051F6:  MOVLW  01
051F8:  MOVLB  8
051FA:  MOVWF  x22
051FC:  MOVLW  B3
051FE:  MOVWF  x21
05200:  MOVLW  02
05202:  MOVWF  x24
05204:  MOVLW  84
05206:  MOVWF  x23
05208:  MOVLB  0
0520A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(436, OUT_4_6_FILTER_NEGATIVEA1);     // OUT_4_6_FILTER_NEGATIVEA1 
0520E:  MOVLW  01
05210:  MOVLB  8
05212:  MOVWF  x22
05214:  MOVLW  B4
05216:  MOVWF  x21
05218:  MOVLW  02
0521A:  MOVWF  x24
0521C:  MOVLW  85
0521E:  MOVWF  x23
05220:  MOVLB  0
05222:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(437, OUT_4_6_FILTER_NEGATIVEA2);     // OUT_4_6_FILTER_NEGATIVEA2 
05226:  MOVLW  01
05228:  MOVLB  8
0522A:  MOVWF  x22
0522C:  MOVLW  B5
0522E:  MOVWF  x21
05230:  MOVLW  02
05232:  MOVWF  x24
05234:  MOVLW  86
05236:  MOVWF  x23
05238:  MOVLB  0
0523A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(438, CH1LIM_THRESHOLD);     // CH1LIM_THRESHOLD 
0523E:  MOVLW  01
05240:  MOVLB  8
05242:  MOVWF  x22
05244:  MOVLW  B6
05246:  MOVWF  x21
05248:  MOVLW  02
0524A:  MOVWF  x24
0524C:  MOVLW  2E
0524E:  MOVWF  x23
05250:  MOVLB  0
05252:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(439, CH1LIM_KNEE);     // CH1LIM_KNEE 
05256:  MOVLW  01
05258:  MOVLB  8
0525A:  MOVWF  x22
0525C:  MOVLW  B7
0525E:  MOVWF  x21
05260:  MOVLW  02
05262:  MOVWF  x24
05264:  MOVLW  2F
05266:  MOVWF  x23
05268:  MOVLB  0
0526A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(440, CH1LIM_RATIO);     // CH1LIM_RATIO 
0526E:  MOVLW  01
05270:  MOVLB  8
05272:  MOVWF  x22
05274:  MOVLW  B8
05276:  MOVWF  x21
05278:  MOVLW  02
0527A:  MOVWF  x24
0527C:  MOVLW  30
0527E:  MOVWF  x23
05280:  MOVLB  0
05282:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(441, CH1LIM_ATTACK);     // CH1LIM_ATTACK 
05286:  MOVLW  01
05288:  MOVLB  8
0528A:  MOVWF  x22
0528C:  MOVLW  B9
0528E:  MOVWF  x21
05290:  MOVLW  02
05292:  MOVWF  x24
05294:  MOVLW  31
05296:  MOVWF  x23
05298:  MOVLB  0
0529A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(442, CH1LIM_RELEASE);     // CH1LIM_RELEASE 
0529E:  MOVLW  01
052A0:  MOVLB  8
052A2:  MOVWF  x22
052A4:  MOVLW  BA
052A6:  MOVWF  x21
052A8:  MOVLW  02
052AA:  MOVWF  x24
052AC:  MOVLW  32
052AE:  MOVWF  x23
052B0:  MOVLB  0
052B2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(443, CH1LIM_BYPASS);     // CH1LIM_BYPASS 
052B6:  MOVLW  01
052B8:  MOVLB  8
052BA:  MOVWF  x22
052BC:  MOVLW  BB
052BE:  MOVWF  x21
052C0:  MOVLW  02
052C2:  MOVWF  x24
052C4:  MOVLW  33
052C6:  MOVWF  x23
052C8:  MOVLB  0
052CA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(444, CH2LIM_THRESHOLD);     // CH2LIM_THRESHOLD 
052CE:  MOVLW  01
052D0:  MOVLB  8
052D2:  MOVWF  x22
052D4:  MOVLW  BC
052D6:  MOVWF  x21
052D8:  MOVLW  02
052DA:  MOVWF  x24
052DC:  MOVLW  26
052DE:  MOVWF  x23
052E0:  MOVLB  0
052E2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(445, CH2LIM_KNEE);     // CH2LIM_KNEE 
052E6:  MOVLW  01
052E8:  MOVLB  8
052EA:  MOVWF  x22
052EC:  MOVLW  BD
052EE:  MOVWF  x21
052F0:  MOVLW  02
052F2:  MOVWF  x24
052F4:  MOVLW  27
052F6:  MOVWF  x23
052F8:  MOVLB  0
052FA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(446, CH2LIM_RATIO);     // CH2LIM_RATIO 
052FE:  MOVLW  01
05300:  MOVLB  8
05302:  MOVWF  x22
05304:  MOVLW  BE
05306:  MOVWF  x21
05308:  MOVLW  02
0530A:  MOVWF  x24
0530C:  MOVLW  28
0530E:  MOVWF  x23
05310:  MOVLB  0
05312:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(447, CH2LIM_ATTACK);     // CH2LIM_ATTACK 
05316:  MOVLW  01
05318:  MOVLB  8
0531A:  MOVWF  x22
0531C:  MOVLW  BF
0531E:  MOVWF  x21
05320:  MOVLW  02
05322:  MOVWF  x24
05324:  MOVLW  29
05326:  MOVWF  x23
05328:  MOVLB  0
0532A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(448, CH2LIM_RELEASE);     // CH2LIM_RELEASE 
0532E:  MOVLW  01
05330:  MOVLB  8
05332:  MOVWF  x22
05334:  MOVLW  C0
05336:  MOVWF  x21
05338:  MOVLW  02
0533A:  MOVWF  x24
0533C:  MOVLW  2A
0533E:  MOVWF  x23
05340:  MOVLB  0
05342:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(449, CH2LIM_BYPASS);     // CH2LIM_BYPASS 
05346:  MOVLW  01
05348:  MOVLB  8
0534A:  MOVWF  x22
0534C:  MOVLW  C1
0534E:  MOVWF  x21
05350:  MOVLW  02
05352:  MOVWF  x24
05354:  MOVLW  2B
05356:  MOVWF  x23
05358:  MOVLB  0
0535A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(450, CH3LIM_THRESHOLD);     // CH3LIM_THRESHOLD 
0535E:  MOVLW  01
05360:  MOVLB  8
05362:  MOVWF  x22
05364:  MOVLW  C2
05366:  MOVWF  x21
05368:  MOVLW  02
0536A:  MOVWF  x24
0536C:  MOVLW  1E
0536E:  MOVWF  x23
05370:  MOVLB  0
05372:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(451, CH3LIM_KNEE);     // CH3LIM_KNEE 
05376:  MOVLW  01
05378:  MOVLB  8
0537A:  MOVWF  x22
0537C:  MOVLW  C3
0537E:  MOVWF  x21
05380:  MOVLW  02
05382:  MOVWF  x24
05384:  MOVLW  1F
05386:  MOVWF  x23
05388:  MOVLB  0
0538A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(452, CH3LIM_RATIO);     // CH3LIM_RATIO 
0538E:  MOVLW  01
05390:  MOVLB  8
05392:  MOVWF  x22
05394:  MOVLW  C4
05396:  MOVWF  x21
05398:  MOVLW  02
0539A:  MOVWF  x24
0539C:  MOVLW  20
0539E:  MOVWF  x23
053A0:  MOVLB  0
053A2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(453, CH3LIM_ATTACK);     // CH3LIM_ATTACK 
053A6:  MOVLW  01
053A8:  MOVLB  8
053AA:  MOVWF  x22
053AC:  MOVLW  C5
053AE:  MOVWF  x21
053B0:  MOVLW  02
053B2:  MOVWF  x24
053B4:  MOVLW  21
053B6:  MOVWF  x23
053B8:  MOVLB  0
053BA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(454, CH3LIM_RELEASE);     // CH3LIM_RELEASE 
053BE:  MOVLW  01
053C0:  MOVLB  8
053C2:  MOVWF  x22
053C4:  MOVLW  C6
053C6:  MOVWF  x21
053C8:  MOVLW  02
053CA:  MOVWF  x24
053CC:  MOVLW  22
053CE:  MOVWF  x23
053D0:  MOVLB  0
053D2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(455, CH3LIM_BYPASS);     // CH3LIM_BYPASS 
053D6:  MOVLW  01
053D8:  MOVLB  8
053DA:  MOVWF  x22
053DC:  MOVLW  C7
053DE:  MOVWF  x21
053E0:  MOVLW  02
053E2:  MOVWF  x24
053E4:  MOVLW  23
053E6:  MOVWF  x23
053E8:  MOVLB  0
053EA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(456, CH4LIM_THRESHOLD);     // CH4LIM_THRESHOLD 
053EE:  MOVLW  01
053F0:  MOVLB  8
053F2:  MOVWF  x22
053F4:  MOVLW  C8
053F6:  MOVWF  x21
053F8:  MOVLW  02
053FA:  MOVWF  x24
053FC:  MOVLW  16
053FE:  MOVWF  x23
05400:  MOVLB  0
05402:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(457, CH4LIM_KNEE);     // CH4LIM_KNEE 
05406:  MOVLW  01
05408:  MOVLB  8
0540A:  MOVWF  x22
0540C:  MOVLW  C9
0540E:  MOVWF  x21
05410:  MOVLW  02
05412:  MOVWF  x24
05414:  MOVLW  17
05416:  MOVWF  x23
05418:  MOVLB  0
0541A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(458, CH4LIM_RATIO);     // CH4LIM_RATIO 
0541E:  MOVLW  01
05420:  MOVLB  8
05422:  MOVWF  x22
05424:  MOVLW  CA
05426:  MOVWF  x21
05428:  MOVLW  02
0542A:  MOVWF  x24
0542C:  MOVLW  18
0542E:  MOVWF  x23
05430:  MOVLB  0
05432:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(459, CH4LIM_ATTACK);     // CH4LIM_ATTACK 
05436:  MOVLW  01
05438:  MOVLB  8
0543A:  MOVWF  x22
0543C:  MOVLW  CB
0543E:  MOVWF  x21
05440:  MOVLW  02
05442:  MOVWF  x24
05444:  MOVLW  19
05446:  MOVWF  x23
05448:  MOVLB  0
0544A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(460, CH4LIM_RELEASE);     // CH4LIM_RELEASE 
0544E:  MOVLW  01
05450:  MOVLB  8
05452:  MOVWF  x22
05454:  MOVLW  CC
05456:  MOVWF  x21
05458:  MOVLW  02
0545A:  MOVWF  x24
0545C:  MOVLW  1A
0545E:  MOVWF  x23
05460:  MOVLB  0
05462:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(461, CH4LIM_BYPASS);     // CH4LIM_BYPASS 
05466:  MOVLW  01
05468:  MOVLB  8
0546A:  MOVWF  x22
0546C:  MOVLW  CD
0546E:  MOVWF  x21
05470:  MOVLW  02
05472:  MOVWF  x24
05474:  MOVLW  1B
05476:  MOVWF  x23
05478:  MOVLB  0
0547A:  CALL   2AA8
....................  
.................... 	WRITE_CONFIG_ADDRESS(462, DELAY_CH1);     // DELAY_CH1 
0547E:  MOVLW  01
05480:  MOVLB  8
05482:  MOVWF  x22
05484:  MOVLW  CE
05486:  MOVWF  x21
05488:  MOVLW  03
0548A:  MOVWF  x24
0548C:  MOVLW  DD
0548E:  MOVWF  x23
05490:  MOVLB  0
05492:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(463, DELAY_BYPASS_CH1);     // DELAY_BYPASS_CH1 
05496:  MOVLW  01
05498:  MOVLB  8
0549A:  MOVWF  x22
0549C:  MOVLW  CF
0549E:  MOVWF  x21
054A0:  MOVLW  04
054A2:  MOVWF  x24
054A4:  MOVLW  48
054A6:  MOVWF  x23
054A8:  MOVLB  0
054AA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(464, DELAY_CH2);     // DELAY_CH2 
054AE:  MOVLW  01
054B0:  MOVLB  8
054B2:  MOVWF  x22
054B4:  MOVLW  D0
054B6:  MOVWF  x21
054B8:  MOVLW  03
054BA:  MOVWF  x24
054BC:  MOVLW  DA
054BE:  MOVWF  x23
054C0:  MOVLB  0
054C2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(465, DELAY_BYPASS_CH2);     // DELAY_BYPASS_CH2 
054C6:  MOVLW  01
054C8:  MOVLB  8
054CA:  MOVWF  x22
054CC:  MOVLW  D1
054CE:  MOVWF  x21
054D0:  MOVLW  04
054D2:  MOVWF  x24
054D4:  MOVLW  47
054D6:  MOVWF  x23
054D8:  MOVLB  0
054DA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(466, DELAY_CH3);     // DELAY_CH3 
054DE:  MOVLW  01
054E0:  MOVLB  8
054E2:  MOVWF  x22
054E4:  MOVLW  D2
054E6:  MOVWF  x21
054E8:  MOVLW  03
054EA:  MOVWF  x24
054EC:  MOVLW  D7
054EE:  MOVWF  x23
054F0:  MOVLB  0
054F2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(467, DELAY_BYPASS_CH3);     // DELAY_BYPASS_CH3 
054F6:  MOVLW  01
054F8:  MOVLB  8
054FA:  MOVWF  x22
054FC:  MOVLW  D3
054FE:  MOVWF  x21
05500:  MOVLW  04
05502:  MOVWF  x24
05504:  MOVLW  46
05506:  MOVWF  x23
05508:  MOVLB  0
0550A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(468, DELAY_CH4);     // DELAY_CH4 
0550E:  MOVLW  01
05510:  MOVLB  8
05512:  MOVWF  x22
05514:  MOVLW  D4
05516:  MOVWF  x21
05518:  MOVLW  03
0551A:  MOVWF  x24
0551C:  MOVLW  D4
0551E:  MOVWF  x23
05520:  MOVLB  0
05522:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(469, DELAY_BYPASS_CH4);     // DELAY_BYPASS_CH4 
05526:  MOVLW  01
05528:  MOVLB  8
0552A:  MOVWF  x22
0552C:  MOVLW  D5
0552E:  MOVWF  x21
05530:  MOVLW  04
05532:  MOVWF  x24
05534:  MOVLW  45
05536:  MOVWF  x23
05538:  MOVLB  0
0553A:  CALL   2AA8
.................... 	 
.................... 	WRITE_CONFIG_ADDRESS(470, BRIDGEROUTER_SELECT0);     // BRIDGEROUTER_SELECT0 
0553E:  MOVLW  01
05540:  MOVLB  8
05542:  MOVWF  x22
05544:  MOVLW  D6
05546:  MOVWF  x21
05548:  MOVLW  02
0554A:  MOVWF  x24
0554C:  MOVLW  7E
0554E:  MOVWF  x23
05550:  MOVLB  0
05552:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(471, BRIDGEROUTER_SELECT1);     // BRIDGEROUTER_SELECT1 
05556:  MOVLW  01
05558:  MOVLB  8
0555A:  MOVWF  x22
0555C:  MOVLW  D7
0555E:  MOVWF  x21
05560:  MOVLW  02
05562:  MOVWF  x24
05564:  MOVLW  7F
05566:  MOVWF  x23
05568:  MOVLB  0
0556A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(472, BRIDGEROUTER_SELECT2);     // BRIDGEROUTER_SELECT2 
0556E:  MOVLW  01
05570:  MOVLB  8
05572:  MOVWF  x22
05574:  MOVLW  D8
05576:  MOVWF  x21
05578:  MOVLW  02
0557A:  MOVWF  x24
0557C:  MOVLW  80
0557E:  MOVWF  x23
05580:  MOVLB  0
05582:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(473, BRIDGEROUTER_SELECT3);     // BRIDGEROUTER_SELECT3 
05586:  MOVLW  01
05588:  MOVLB  8
0558A:  MOVWF  x22
0558C:  MOVLW  D9
0558E:  MOVWF  x21
05590:  MOVLW  02
05592:  MOVWF  x24
05594:  MOVLW  81
05596:  MOVWF  x23
05598:  MOVLB  0
0559A:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(474, GEN_PINK_GAIN);     // GEN_PINK_GAIN 
0559E:  MOVLW  01
055A0:  MOVLB  8
055A2:  MOVWF  x22
055A4:  MOVLW  DA
055A6:  MOVWF  x21
055A8:  MOVLW  04
055AA:  MOVWF  x24
055AC:  MOVLW  11
055AE:  MOVWF  x23
055B0:  MOVLB  0
055B2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(475, GEN_SINE_OMEGA);     // GEN_SINE_OMEGA 
055B6:  MOVLW  01
055B8:  MOVLB  8
055BA:  MOVWF  x22
055BC:  MOVLW  DB
055BE:  MOVWF  x21
055C0:  MOVLW  03
055C2:  MOVWF  x24
055C4:  MOVLW  EB
055C6:  MOVWF  x23
055C8:  MOVLB  0
055CA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(476, GEN_SINE_GAIN);     // GEN_SINE_GAIN 
055CE:  MOVLW  01
055D0:  MOVLB  8
055D2:  MOVWF  x22
055D4:  MOVLW  DC
055D6:  MOVWF  x21
055D8:  MOVLW  03
055DA:  MOVWF  x24
055DC:  MOVLW  EC
055DE:  MOVWF  x23
055E0:  MOVLB  0
055E2:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(477, SEVENTYVHP_BYPASS);     // 70VHP_BYPASS 
055E6:  MOVLW  01
055E8:  MOVLB  8
055EA:  MOVWF  x22
055EC:  MOVLW  DD
055EE:  MOVWF  x21
055F0:  MOVLW  04
055F2:  MOVWF  x24
055F4:  MOVLW  44
055F6:  MOVWF  x23
055F8:  MOVLB  0
055FA:  CALL   2AA8
.................... 	WRITE_CONFIG_ADDRESS(478, MUTE_OUTPUTS);     // MUTE_OUTPUTS 
055FE:  MOVLW  01
05600:  MOVLB  8
05602:  MOVWF  x22
05604:  MOVLW  DE
05606:  MOVWF  x21
05608:  MOVLW  04
0560A:  MOVWF  x24
0560C:  MOVLW  13
0560E:  MOVWF  x23
05610:  MOVLB  0
05612:  CALL   2AA8
....................  
.................... } 
05616:  GOTO   C0A0 (RETURN)
....................  
.................... #include <phantom.c> 
.................... void update_phantom_power() 
.................... { 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
*
0671C:  MOVLB  8
0671E:  CLRF   x74
06720:  MOVLW  CE
06722:  MOVWF  x73
06724:  MOVFF  CD,875
06728:  MOVLW  08
0672A:  MOVWF  x76
0672C:  MOVLB  0
0672E:  CALL   5E08
....................  
.................... 	int32 phantom_mask = PAGE_BUFFER_A[54]; 
06732:  MOVFF  1A9,871
06736:  MOVFF  1A8,870
0673A:  MOVFF  1A7,86F
0673E:  MOVFF  1A6,86E
....................  
.................... 	if((phantom_mask & 0x03) > 0) { 
06742:  MOVLB  8
06744:  MOVF   x6E,W
06746:  ANDLW  03
06748:  MOVWF  x72
0674A:  CLRF   x73
0674C:  CLRF   x74
0674E:  CLRF   x75
06750:  MOVF   x72,F
06752:  BNZ   6760
06754:  MOVF   x73,F
06756:  BNZ   6760
06758:  MOVF   x74,F
0675A:  BNZ   6760
0675C:  MOVF   x75,F
0675E:  BZ    6766
.................... 		output_high(PIN_PHANTOM_ENABLE); 
06760:  BCF    F95.5
06762:  BSF    F8C.5
.................... 	} else { 
06764:  BRA    676A
.................... 		output_low(PIN_PHANTOM_ENABLE); 
06766:  BCF    F95.5
06768:  BCF    F8C.5
.................... 	} 
....................  
....................  
.................... 	output_bit(PIN_PHANTOM_CH1,bit_test(phantom_mask,0)); 
0676A:  BTFSC  x6E.0
0676C:  BRA    6772
0676E:  BCF    F8A.4
06770:  BRA    6774
06772:  BSF    F8A.4
06774:  BCF    F93.4
.................... 	output_bit(PIN_PHANTOM_CH2,bit_test(phantom_mask,1)); 
06776:  BTFSC  x6E.1
06778:  BRA    677E
0677A:  BCF    F8A.5
0677C:  BRA    6780
0677E:  BSF    F8A.5
06780:  BCF    F93.5
....................  
.................... } 
06782:  MOVLB  0
06784:  RETURN 0
....................  
.................... #include <presets.c> 
.................... // presets.c 
....................  
.................... void softboot(); 
....................  
.................... void save_flash_program() 
.................... { 
.................... 	//FLASH_PROGRAM_WRITE(CURRENT_PRESET); 
.................... } 
*
00004:  GOTO   8AE4 (RETURN)
....................  
.................... void switch_flash_program(int new_index) 
.................... { 
.................... 	CURRENT_FLASH_PROGRAM = new_index; 
*
070A8:  MOVFF  869,CD
....................  
.................... 	softboot(); 
070AC:  CALL   6786
....................  
.................... 	write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
070B0:  CLRF   FAA
070B2:  MOVLW  10
070B4:  MOVWF  FA9
070B6:  MOVFF  CD,FA8
070BA:  BCF    FA6.6
070BC:  BCF    FA6.7
070BE:  BSF    FA6.2
070C0:  MOVF   FF2,W
070C2:  MOVWF  00
070C4:  BCF    FF2.7
070C6:  MOVLB  F
070C8:  MOVLW  55
070CA:  MOVWF  FA7
070CC:  MOVLW  AA
070CE:  MOVWF  FA7
070D0:  BSF    FA6.1
070D2:  BTFSC  FA6.1
070D4:  BRA    70D2
070D6:  BCF    FA6.2
070D8:  MOVF   00,W
070DA:  IORWF  FF2,F
....................  
.................... 	delay_ms(5); 
070DC:  MOVLW  05
070DE:  MOVLB  8
070E0:  MOVWF  x74
070E2:  MOVLB  0
070E4:  CALL   5A08
.................... } 
070E8:  RETURN 0
....................  
.................... #include <adc.c> 
.................... // ADC 
....................  
.................... double RVC_to_dsp_value(unsigned int read_value) 
.................... { 
.................... 	return pow(10.0,(-60.0+(60.0*((read_value-30.0)/225.0)))/20.0); 
*
023AE:  MOVLB  8
023B0:  CLRF   xEE
023B2:  MOVFF  8B8,8ED
023B6:  MOVLB  0
023B8:  CALL   0E24
023BC:  BSF    FD8.1
023BE:  MOVFF  03,8F0
023C2:  MOVFF  02,8EF
023C6:  MOVFF  01,8EE
023CA:  MOVFF  00,8ED
023CE:  MOVLB  8
023D0:  CLRF   xF4
023D2:  CLRF   xF3
023D4:  MOVLW  70
023D6:  MOVWF  xF2
023D8:  MOVLW  83
023DA:  MOVWF  xF1
023DC:  MOVLB  0
023DE:  CALL   0E5A
023E2:  MOVFF  00,8B9
023E6:  MOVFF  01,8BA
023EA:  MOVFF  02,8BB
023EE:  MOVFF  03,8BC
023F2:  MOVFF  03,8E5
023F6:  MOVFF  02,8E4
023FA:  MOVFF  01,8E3
023FE:  MOVFF  00,8E2
02402:  MOVLB  8
02404:  CLRF   xE9
02406:  CLRF   xE8
02408:  MOVLW  61
0240A:  MOVWF  xE7
0240C:  MOVLW  86
0240E:  MOVWF  xE6
02410:  MOVLB  0
02412:  CALL   10D2
02416:  MOVLB  8
02418:  CLRF   xEC
0241A:  CLRF   xEB
0241C:  MOVLW  70
0241E:  MOVWF  xEA
02420:  MOVLW  84
02422:  MOVWF  xE9
02424:  MOVFF  03,8F0
02428:  MOVFF  02,8EF
0242C:  MOVFF  01,8EE
02430:  MOVFF  00,8ED
02434:  MOVLB  0
02436:  CALL   1230
0243A:  BCF    FD8.1
0243C:  MOVLB  8
0243E:  CLRF   xF0
02440:  CLRF   xEF
02442:  MOVLW  F0
02444:  MOVWF  xEE
02446:  MOVLW  84
02448:  MOVWF  xED
0244A:  MOVFF  03,8F4
0244E:  MOVFF  02,8F3
02452:  MOVFF  01,8F2
02456:  MOVFF  00,8F1
0245A:  MOVLB  0
0245C:  CALL   0E5A
02460:  MOVFF  00,8B9
02464:  MOVFF  01,8BA
02468:  MOVFF  02,8BB
0246C:  MOVFF  03,8BC
02470:  MOVFF  03,8E5
02474:  MOVFF  02,8E4
02478:  MOVFF  01,8E3
0247C:  MOVFF  00,8E2
02480:  MOVLB  8
02482:  CLRF   xE9
02484:  CLRF   xE8
02486:  MOVLW  20
02488:  MOVWF  xE7
0248A:  MOVLW  83
0248C:  MOVWF  xE6
0248E:  MOVLB  0
02490:  CALL   10D2
02494:  MOVFF  00,8B9
02498:  MOVFF  01,8BA
0249C:  MOVFF  02,8BB
024A0:  MOVFF  03,8BC
024A4:  MOVLB  8
024A6:  CLRF   xC0
024A8:  CLRF   xBF
024AA:  MOVLW  20
024AC:  MOVWF  xBE
024AE:  MOVLW  82
024B0:  MOVWF  xBD
024B2:  MOVFF  03,8C4
024B6:  MOVFF  02,8C3
024BA:  MOVFF  01,8C2
024BE:  MOVFF  00,8C1
024C2:  MOVLB  0
024C4:  RCALL  20A2
....................  
.................... } 
024C6:  RETURN 0
....................  
.................... double RVC_to_decibel(unsigned int read_value) 
.................... { 
*
07EEC:  CLRF   19
07EEE:  BTFSC  FF2.7
07EF0:  BSF    19.7
07EF2:  BCF    FF2.7
.................... 	return -60.0 + (60.0*((read_value-30.0)/225.0)); 
07EF4:  MOVLB  8
07EF6:  CLRF   xEE
07EF8:  MOVFF  869,8ED
07EFC:  MOVLB  0
07EFE:  CALL   0E24
07F02:  BTFSC  19.7
07F04:  BSF    FF2.7
07F06:  BSF    FD8.1
07F08:  CLRF   19
07F0A:  BTFSC  FF2.7
07F0C:  BSF    19.7
07F0E:  BCF    FF2.7
07F10:  MOVFF  03,8F0
07F14:  MOVFF  02,8EF
07F18:  MOVFF  01,8EE
07F1C:  MOVFF  00,8ED
07F20:  MOVLB  8
07F22:  CLRF   xF4
07F24:  CLRF   xF3
07F26:  MOVLW  70
07F28:  MOVWF  xF2
07F2A:  MOVLW  83
07F2C:  MOVWF  xF1
07F2E:  MOVLB  0
07F30:  CALL   0E5A
07F34:  BTFSC  19.7
07F36:  BSF    FF2.7
07F38:  MOVFF  00,86A
07F3C:  MOVFF  01,86B
07F40:  MOVFF  02,86C
07F44:  MOVFF  03,86D
07F48:  CLRF   19
07F4A:  BTFSC  FF2.7
07F4C:  BSF    19.7
07F4E:  BCF    FF2.7
07F50:  MOVFF  03,8E5
07F54:  MOVFF  02,8E4
07F58:  MOVFF  01,8E3
07F5C:  MOVFF  00,8E2
07F60:  MOVLB  8
07F62:  CLRF   xE9
07F64:  CLRF   xE8
07F66:  MOVLW  61
07F68:  MOVWF  xE7
07F6A:  MOVLW  86
07F6C:  MOVWF  xE6
07F6E:  MOVLB  0
07F70:  CALL   10D2
07F74:  BTFSC  19.7
07F76:  BSF    FF2.7
07F78:  CLRF   19
07F7A:  BTFSC  FF2.7
07F7C:  BSF    19.7
07F7E:  BCF    FF2.7
07F80:  MOVLB  8
07F82:  CLRF   xEC
07F84:  CLRF   xEB
07F86:  MOVLW  70
07F88:  MOVWF  xEA
07F8A:  MOVLW  84
07F8C:  MOVWF  xE9
07F8E:  MOVFF  03,8F0
07F92:  MOVFF  02,8EF
07F96:  MOVFF  01,8EE
07F9A:  MOVFF  00,8ED
07F9E:  MOVLB  0
07FA0:  CALL   1230
07FA4:  BTFSC  19.7
07FA6:  BSF    FF2.7
07FA8:  BCF    FD8.1
07FAA:  CLRF   19
07FAC:  BTFSC  FF2.7
07FAE:  BSF    19.7
07FB0:  BCF    FF2.7
07FB2:  MOVLB  8
07FB4:  CLRF   xF0
07FB6:  CLRF   xEF
07FB8:  MOVLW  F0
07FBA:  MOVWF  xEE
07FBC:  MOVLW  84
07FBE:  MOVWF  xED
07FC0:  MOVFF  03,8F4
07FC4:  MOVFF  02,8F3
07FC8:  MOVFF  01,8F2
07FCC:  MOVFF  00,8F1
07FD0:  MOVLB  0
07FD2:  CALL   0E5A
07FD6:  BTFSC  19.7
07FD8:  BSF    FF2.7
.................... } 
07FDA:  GOTO   97C4 (RETURN)
....................  
....................  
.................... int ADC_calibrate_min(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
*
07CFE:  MOVLW  00
07D00:  MOVWF  01
07D02:  MOVF   FC2,W
07D04:  ANDLW  83
07D06:  IORWF  01,W
07D08:  MOVWF  FC2
.................... 	delay_us(10); 
07D0A:  MOVLW  0B
07D0C:  MOVWF  00
07D0E:  DECFSZ 00,F
07D10:  BRA    7D0E
07D12:  BRA    7D14
.................... 	int current_adc = read_adc(); 
07D14:  BSF    FC2.1
07D16:  BTFSC  FC2.1
07D18:  BRA    7D16
07D1A:  MOVFF  FC4,86A
07D1E:  MOVLB  8
07D20:  CLRF   19
07D22:  BTFSC  FF2.7
07D24:  BSF    19.7
07D26:  BCF    FF2.7
.................... 	 
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new minimum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = (double)current_adc; 
07D28:  CLRF   xEE
07D2A:  MOVFF  86A,8ED
07D2E:  MOVLB  0
07D30:  CALL   0E24
07D34:  BTFSC  19.7
07D36:  BSF    FF2.7
07D38:  MOVFF  03,38
07D3C:  MOVFF  02,37
07D40:  MOVFF  01,36
07D44:  MOVFF  00,35
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07D48:  MOVLB  8
07D4A:  CLRF   x6C
07D4C:  MOVLW  33
07D4E:  MOVWF  x6B
07D50:  CLRF   x6E
07D52:  MOVLW  28
07D54:  MOVWF  x6D
07D56:  CLRF   x70
07D58:  MOVLW  64
07D5A:  MOVWF  x6F
07D5C:  MOVLB  0
07D5E:  CALL   5D98
.................... 	delay_ms(10); 
07D62:  MOVLW  0A
07D64:  MOVLB  8
07D66:  MOVWF  x74
07D68:  MOVLB  0
07D6A:  CALL   5A08
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07D6E:  MOVLB  8
07D70:  MOVFF  86A,01
.................... } 
07D74:  MOVLB  0
07D76:  GOTO   90B6 (RETURN)
....................  
.................... int ADC_calibrate_max(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
07D7A:  MOVLW  00
07D7C:  MOVWF  01
07D7E:  MOVF   FC2,W
07D80:  ANDLW  83
07D82:  IORWF  01,W
07D84:  MOVWF  FC2
.................... 	delay_us(10); 
07D86:  MOVLW  0B
07D88:  MOVWF  00
07D8A:  DECFSZ 00,F
07D8C:  BRA    7D8A
07D8E:  BRA    7D90
.................... 	int current_adc = read_adc(); 
07D90:  BSF    FC2.1
07D92:  BTFSC  FC2.1
07D94:  BRA    7D92
07D96:  MOVFF  FC4,86A
07D9A:  MOVLB  8
07D9C:  CLRF   19
07D9E:  BTFSC  FF2.7
07DA0:  BSF    19.7
07DA2:  BCF    FF2.7
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new maximum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX= (double)current_adc; 
07DA4:  CLRF   xEE
07DA6:  MOVFF  86A,8ED
07DAA:  MOVLB  0
07DAC:  CALL   0E24
07DB0:  BTFSC  19.7
07DB2:  BSF    FF2.7
07DB4:  MOVFF  03,3C
07DB8:  MOVFF  02,3B
07DBC:  MOVFF  01,3A
07DC0:  MOVFF  00,39
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07DC4:  MOVLB  8
07DC6:  CLRF   x6C
07DC8:  MOVLW  33
07DCA:  MOVWF  x6B
07DCC:  CLRF   x6E
07DCE:  MOVLW  28
07DD0:  MOVWF  x6D
07DD2:  CLRF   x70
07DD4:  MOVLW  64
07DD6:  MOVWF  x6F
07DD8:  MOVLB  0
07DDA:  CALL   5D98
.................... 	delay_ms(10); 
07DDE:  MOVLW  0A
07DE0:  MOVLB  8
07DE2:  MOVWF  x74
07DE4:  MOVLB  0
07DE6:  CALL   5A08
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07DEA:  MOVLB  8
07DEC:  MOVFF  86A,01
.................... } 
07DF0:  MOVLB  0
07DF2:  GOTO   9100 (RETURN)
....................  
.................... #include <device_boot.c> 
.................... void softboot(); 
.................... void initialize_first_boot(); 
....................  
.................... void default_device_config() 
.................... { 
.................... 	for(int x = 0; x < 20; x++) { 
*
0600A:  MOVLB  8
0600C:  CLRF   x23
0600E:  MOVF   x23,W
06010:  SUBLW  13
06012:  BNC   6028
.................... 		DEVICE_CONFIG.SERIAL[x] = 0xFF; 
06014:  CLRF   03
06016:  MOVF   x23,W
06018:  ADDLW  47
0601A:  MOVWF  FE9
0601C:  MOVLW  00
0601E:  ADDWFC 03,W
06020:  MOVWF  FEA
06022:  SETF   FEF
.................... 	} 
06024:  INCF   x23,F
06026:  BRA    600E
....................  
.................... 	DEVICE_CONFIG.SERIAL[0] = 'N'; 
06028:  MOVLW  4E
0602A:  MOVWF  47
.................... 	DEVICE_CONFIG.SERIAL[1] = 'O'; 
0602C:  MOVLW  4F
0602E:  MOVWF  48
.................... 	DEVICE_CONFIG.SERIAL[2] = 'N'; 
06030:  MOVLW  4E
06032:  MOVWF  49
.................... 	DEVICE_CONFIG.SERIAL[3] = 'E'; 
06034:  MOVLW  45
06036:  MOVWF  4A
....................  
.................... 	DEVICE_CONFIG.AMP_MODE = 				DEFAULT_AMP_MODE; 
06038:  MOVFF  27,33
.................... 	DEVICE_CONFIG.IS_70V = 					DEFAULT_IS_70V; 
0603C:  MOVFF  28,34
....................  
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = 	DEFAULT_ADC_CALIBRATION_MIN; 
06040:  MOVFF  22,38
06044:  MOVFF  21,37
06048:  MOVFF  20,36
0604C:  MOVFF  1F,35
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX = 	DEFAULT_ADC_CALIBRATION_MAX; 
06050:  MOVFF  26,3C
06054:  MOVFF  25,3B
06058:  MOVFF  24,3A
0605C:  MOVFF  23,39
....................  
.................... 	DEVICE_CONFIG.RVC_ENABLE = 				DEFAULT_RVC_ENABLE; 
06060:  MOVFF  29,3D
.................... 	DEVICE_CONFIG.USBDETECT_ENABLE = 		DEFAULT_USBDETECT_ENABLE; 
06064:  MOVFF  2A,3E
.................... 	DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = 	DEFAULT_AMPBOOT_DELAY_ENABLE; 
06068:  MOVFF  2B,3F
.................... 	DEVICE_CONFIG.PS_PIN_ENABLE = 			DEFAULT_PS_PIN_ENABLE; 
0606C:  MOVFF  2C,40
.................... 	DEVICE_CONFIG.DSP_VALUESEND_ENABLE = 	DEFAULT_DSP_VALUESEND_ENABLE; 
06070:  MOVFF  2D,41
.................... 	 
.................... 	DEVICE_CONFIG.SLEEP_ENABLE		= 		DEFAULT_SLEEP_ENABLE; 
06074:  MOVFF  2E,42
.................... 	DEVICE_CONFIG.SLEEP_SECONDS		= 		DEFAULT_SLEEP_SECONDS; 
06078:  MOVFF  30,44
0607C:  MOVFF  2F,43
.................... 	DEVICE_CONFIG.SLEEP_HOLDTIME	= 		DEFAULT_SLEEP_HOLDTIME; 
06080:  MOVFF  32,46
06084:  MOVFF  31,45
.................... 	delay_ms(10); 
06088:  MOVLW  0A
0608A:  MOVWF  x74
0608C:  MOVLB  0
0608E:  RCALL  5A08
.................... 	 
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),IEEPROM_DEVICE_CONFIG_LOC); 
06090:  MOVLB  8
06092:  CLRF   x6C
06094:  MOVLW  33
06096:  MOVWF  x6B
06098:  CLRF   x6E
0609A:  MOVLW  28
0609C:  MOVWF  x6D
0609E:  CLRF   x70
060A0:  MOVLW  64
060A2:  MOVWF  x6F
060A4:  MOVLB  0
060A6:  RCALL  5D98
....................  
.................... 	 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
060A8:  MOVLB  8
060AA:  CLRF   x74
060AC:  MOVLW  CE
060AE:  MOVWF  x73
060B0:  MOVFF  CD,875
060B4:  MOVLW  08
060B6:  MOVWF  x76
060B8:  MOVLB  0
060BA:  RCALL  5E08
.................... 	PAGE_BUFFER_A[57] = 0; 
060BC:  MOVLB  1
060BE:  CLRF   xB5
060C0:  CLRF   xB4
060C2:  CLRF   xB3
060C4:  CLRF   xB2
.................... 	write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
060C6:  MOVLB  8
060C8:  CLRF   x72
060CA:  MOVLW  CE
060CC:  MOVWF  x71
060CE:  MOVFF  CD,873
060D2:  MOVLW  08
060D4:  MOVWF  x74
060D6:  MOVLB  0
060D8:  RCALL  5EF4
.................... 	 
.................... } 
060DA:  GOTO   6210 (RETURN)
....................  
.................... void print_device_config() 
.................... { 
.................... 	char name_buffer[20]; 
....................  
.................... 	memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
....................  
.................... 	fprintf(RS232,"[CONFIG] SERIAL = "); 
....................  
.................... 	for(int y = 0; y < 20; y++) { 
.................... 		if(name_buffer[y] == 0xFF) { 
.................... 			break; 
.................... 		} 
....................  
.................... 		fputc(name_buffer[y],RS232); 
....................  
.................... 	}  
....................  
.................... 	fprintf(RS232,"\r\n"); 
....................  
.................... 	 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 4CH\r\n"); 
.................... 	} else if(DEVICE_CONFIG.AMP_MODE == 1) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 2CH\r\n"); 
.................... 	} else { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 1CH\r\n"); 
.................... 	} 
....................  
.................... 	 
.................... 	fprintf(RS232,"[CONFIG] IS_70V = %u\r\n",DEVICE_CONFIG.IS_70V); 
....................  
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MIN = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MAX = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
....................  
.................... 	fprintf(RS232,"[CONFIG] RVC_ENABLE = %u\r\n",DEVICE_CONFIG.RVC_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] USBDETECT_ENABLE = %u\r\n",DEVICE_CONFIG.USBDETECT_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] AMPBOOT_DELAY_ENABLE = %u\r\n",DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] PS_PIN_ENABLE = %u\r\n",DEVICE_CONFIG.PS_PIN_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] DSP_VALUESEND_ENABLE = %u\r\n",DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_ENABLE = %u\r\n",DEVICE_CONFIG.SLEEP_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_SECONDS = %ld\r\n",DEVICE_CONFIG.SLEEP_SECONDS); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_HOLDTIME = %ld\r\n",DEVICE_CONFIG.SLEEP_HOLDTIME); 
....................  
.................... } 
....................  
.................... void device_boot() 
.................... { 
.................... 	/* POWER STARTUP SEQUENCE */ 
.................... 	delay_ms(POWERUP_DELAY); 
060DE:  MOVLW  C8
060E0:  MOVLB  8
060E2:  MOVWF  x74
060E4:  MOVLB  0
060E6:  RCALL  5A08
.................... 	 
.................... 	fprintf(RS232,"Booting into main application built on "); 
060E8:  MOVLW  60
060EA:  MOVWF  FF6
060EC:  MOVLW  04
060EE:  MOVWF  FF7
060F0:  RCALL  5A30
.................... 	fprintf(RS232,__DATE__); 
060F2:  MOVLW  88
060F4:  MOVWF  FF6
060F6:  MOVLW  04
060F8:  MOVWF  FF7
060FA:  RCALL  5A30
.................... 	fprintf(RS232," "); 
060FC:  MOVLW  20
060FE:  BTFSS  FA4.4
06100:  BRA    60FE
06102:  MOVWF  F73
.................... 	fprintf(RS232,__TIME__); 
06104:  MOVLW  92
06106:  MOVWF  FF6
06108:  MOVLW  04
0610A:  MOVWF  FF7
0610C:  RCALL  5A30
.................... 	fprintf(RS232,"\r"); 
0610E:  MOVLW  0D
06110:  BTFSS  FA4.4
06112:  BRA    6110
06114:  MOVWF  F73
....................  
.................... 	fprintf(RS232,"Device firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
06116:  MOVLW  9C
06118:  MOVWF  FF6
0611A:  MOVLW  04
0611C:  MOVWF  FF7
0611E:  MOVLW  14
06120:  MOVLB  8
06122:  MOVWF  x77
06124:  MOVLB  0
06126:  RCALL  5A52
06128:  MOVFF  61,877
0612C:  MOVLW  1B
0612E:  MOVLB  8
06130:  MOVWF  x78
06132:  MOVLB  0
06134:  RCALL  5AA8
06136:  MOVLW  2E
06138:  BTFSS  FA4.4
0613A:  BRA    6138
0613C:  MOVWF  F73
0613E:  MOVFF  62,877
06142:  MOVLW  1B
06144:  MOVLB  8
06146:  MOVWF  x78
06148:  MOVLB  0
0614A:  RCALL  5AA8
0614C:  CLRF   FEA
0614E:  MOVLW  63
06150:  MOVWF  FE9
06152:  RCALL  5B26
06154:  MOVLW  0D
06156:  BTFSS  FA4.4
06158:  BRA    6156
0615A:  MOVWF  F73
.................... 	delay_ms(10); 
0615C:  MOVLW  0A
0615E:  MOVLB  8
06160:  MOVWF  x74
06162:  MOVLB  0
06164:  RCALL  5A08
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Reading DSP addresses from flash into memory... "); 
.................... 	} 
....................  
.................... 	FLASH_ADDR_READ(); 
06166:  BRA    5B4C
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Checking if EEPROM is configured... "); 
.................... 	} 
....................  
.................... 	int eeprom_preset_number = read_eeprom(IEEPROM_PRESET_LOC); 
06168:  MOVFF  FF2,823
0616C:  BCF    FF2.7
0616E:  CLRF   FAA
06170:  MOVLW  10
06172:  MOVWF  FA9
06174:  BCF    FA6.6
06176:  BCF    FA6.7
06178:  BSF    FA6.0
0617A:  MOVF   FA8,W
0617C:  MOVLB  8
0617E:  BTFSC  x23.7
06180:  BSF    FF2.7
06182:  MOVWF  x21
....................  
.................... 	//TODO - Re-implement 
.................... 	if(eeprom_preset_number == 0xFF) { 
06184:  INCFSZ x21,W
06186:  BRA    61BC
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"NO PRESET IN EEPROM, GOING TO DEFAULT\r\n"); 
.................... 		} 
.................... 		//switch_flash_program(DEFAULT_PRESET); 
.................... 		CURRENT_FLASH_PROGRAM = DEFAULT_PRESET; 
06188:  MOVLB  0
0618A:  CLRF   xCD
.................... 		write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
0618C:  CLRF   FAA
0618E:  MOVLW  10
06190:  MOVWF  FA9
06192:  MOVFF  CD,FA8
06196:  BCF    FA6.6
06198:  BCF    FA6.7
0619A:  BSF    FA6.2
0619C:  MOVF   FF2,W
0619E:  MOVWF  00
061A0:  BCF    FF2.7
061A2:  MOVLB  F
061A4:  MOVLW  55
061A6:  MOVWF  FA7
061A8:  MOVLW  AA
061AA:  MOVWF  FA7
061AC:  BSF    FA6.1
061AE:  BTFSC  FA6.1
061B0:  BRA    61AE
061B2:  BCF    FA6.2
061B4:  MOVF   00,W
061B6:  IORWF  FF2,F
.................... 	} else { 
061B8:  BRA    61C0
061BA:  MOVLB  8
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"BOOTING FROM STORED PRESET - %U\r\n",eeprom_preset_number); 
.................... 		} 
.................... 		//switch_flash_program(eeprom_preset_number); 
.................... 		CURRENT_FLASH_PROGRAM = eeprom_preset_number; 
061BC:  MOVFF  821,CD
.................... 	} 
....................  
.................... 	delay_ms(10); 
061C0:  MOVLW  0A
061C2:  MOVLB  8
061C4:  MOVWF  x74
061C6:  MOVLB  0
061C8:  RCALL  5A08
....................  
.................... 	int programmed_flag = read_eeprom(IEEPROM_FLAG_LOC); 
061CA:  MOVFF  FF2,823
061CE:  BCF    FF2.7
061D0:  CLRF   FAA
061D2:  MOVLW  20
061D4:  MOVWF  FA9
061D6:  BCF    FA6.6
061D8:  BCF    FA6.7
061DA:  BSF    FA6.0
061DC:  MOVF   FA8,W
061DE:  MOVLB  8
061E0:  BTFSC  x23.7
061E2:  BSF    FF2.7
061E4:  MOVWF  x22
....................  
.................... 	INTEEPROM_GET(&DEVICE_CONFIG,sizeof(device_configuration),IEEPROM_DEVICE_CONFIG_LOC); 
061E6:  CLRF   x24
061E8:  MOVLW  33
061EA:  MOVWF  x23
061EC:  CLRF   x26
061EE:  MOVLW  28
061F0:  MOVWF  x25
061F2:  CLRF   x28
061F4:  MOVLW  64
061F6:  MOVWF  x27
061F8:  MOVLB  0
061FA:  BRA    5CBA
....................  
.................... 	delay_ms(10); 
061FC:  MOVLW  0A
061FE:  MOVLB  8
06200:  MOVWF  x74
06202:  MOVLB  0
06204:  RCALL  5A08
....................  
.................... 	if(DEBUG) { 
.................... 		print_device_config(); 
.................... 	} 
....................  
.................... 	if(programmed_flag == 0xFF) { 
06206:  MOVLB  8
06208:  INCFSZ x22,W
0620A:  BRA    6248
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting first boot routine\r\n"); 
.................... 		} 
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Saving default device properties..."); 
.................... 		} 
.................... 		default_device_config(); 
0620C:  MOVLB  0
0620E:  BRA    600A
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
....................  
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] New device config below...\r\n"); 
.................... 			print_device_config(); 
.................... 		} 
.................... 		//initialize_first_boot(); 
....................  
....................  
.................... 		write_eeprom(IEEPROM_FLAG_LOC,0x01); 
06210:  CLRF   FAA
06212:  MOVLW  20
06214:  MOVWF  FA9
06216:  MOVLW  01
06218:  MOVWF  FA8
0621A:  BCF    FA6.6
0621C:  BCF    FA6.7
0621E:  BSF    FA6.2
06220:  MOVF   FF2,W
06222:  MOVWF  00
06224:  BCF    FF2.7
06226:  MOVLB  F
06228:  MOVLW  55
0622A:  MOVWF  FA7
0622C:  MOVLW  AA
0622E:  MOVWF  FA7
06230:  BSF    FA6.1
06232:  BTFSC  FA6.1
06234:  BRA    6232
06236:  BCF    FA6.2
06238:  MOVF   00,W
0623A:  IORWF  FF2,F
.................... 		delay_ms(10); 
0623C:  MOVLW  0A
0623E:  MOVLB  8
06240:  MOVWF  x74
06242:  MOVLB  0
06244:  CALL   5A08
.................... 	}	 
.................... 	/* INIT RS232 volumes and mutes */ 
....................  
.................... 	rs232_premix_vol[0] = 1; 
06248:  MOVLB  0
0624A:  CLRF   xA4
0624C:  CLRF   xA3
0624E:  CLRF   xA2
06250:  MOVLW  7F
06252:  MOVWF  xA1
.................... 	rs232_premix_vol[1] = 1; 
06254:  CLRF   xA8
06256:  CLRF   xA7
06258:  CLRF   xA6
0625A:  MOVWF  xA5
.................... 	rs232_premix_vol[2] = 1; 
0625C:  CLRF   xAC
0625E:  CLRF   xAB
06260:  CLRF   xAA
06262:  MOVWF  xA9
.................... 	rs232_premix_vol[3] = 1; 
06264:  CLRF   xB0
06266:  CLRF   xAF
06268:  CLRF   xAE
0626A:  MOVWF  xAD
....................  
.................... 	rs232_premix_mute[0] = 0; 
0626C:  CLRF   xB1
.................... 	rs232_premix_mute[1] = 0; 
0626E:  CLRF   xB2
.................... 	rs232_premix_mute[2] = 0; 
06270:  CLRF   xB3
.................... 	rs232_premix_mute[3] = 0; 
06272:  CLRF   xB4
....................  
.................... 	rs232_output_vol[0] = 1; 
06274:  CLRF   xB8
06276:  CLRF   xB7
06278:  CLRF   xB6
0627A:  MOVWF  xB5
.................... 	rs232_output_vol[1] = 1; 
0627C:  CLRF   xBC
0627E:  CLRF   xBB
06280:  CLRF   xBA
06282:  MOVWF  xB9
.................... 	rs232_output_vol[2] = 1; 
06284:  CLRF   xC0
06286:  CLRF   xBF
06288:  CLRF   xBE
0628A:  MOVWF  xBD
.................... 	rs232_output_vol[3] = 1; 
0628C:  CLRF   xC4
0628E:  CLRF   xC3
06290:  CLRF   xC2
06292:  MOVWF  xC1
....................  
.................... 	rs232_output_mute[0] = 0; 
06294:  CLRF   xC5
.................... 	rs232_output_mute[1] = 0; 
06296:  CLRF   xC6
.................... 	rs232_output_mute[2] = 0; 
06298:  CLRF   xC7
.................... 	rs232_output_mute[3] = 0; 
0629A:  CLRF   xC8
....................  
.................... 	rs232_log_output_vol_index[0] = 0; 
0629C:  CLRF   xC9
.................... 	rs232_log_output_vol_index[1] = 0; 
0629E:  CLRF   xCA
.................... 	rs232_log_output_vol_index[2] = 0; 
062A0:  CLRF   xCB
.................... 	rs232_log_output_vol_index[3] = 0; 
062A2:  CLRF   xCC
....................  
....................  
.................... } 
062A4:  GOTO   C0B0 (RETURN)
....................  
.................... void softboot() 
.................... { 
.................... 	delay_ms(50); 
*
06786:  MOVLW  32
06788:  MOVLB  8
0678A:  MOVWF  x74
0678C:  MOVLB  0
0678E:  CALL   5A08
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP and Amp reset LOW\r\n"); 
.................... 	} 
....................  
.................... 	// TODO - Mute transistors 
....................  
.................... 	output_high(AUD_MUTE); 
06792:  BCF    F95.3
06794:  BSF    F8C.3
....................  
.................... 	output_low(PIN_DSP_nRESET); 
06796:  BCF    F92.4
06798:  BCF    F89.4
.................... 	output_low(PIN_AMP_nRESET); 
0679A:  BCF    F92.5
0679C:  BCF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.PS_PIN_ENABLE) { 
0679E:  MOVF   40,F
067A0:  BZ    67A6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling Power Supply\r\n"); 
.................... 		}	 
....................  
.................... 		output_high(PIN_PSON); 
067A2:  BCF    F93.4
067A4:  BSF    F8A.4
.................... 	} 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Muting DSP Output (NOT YET IMPLEMENTED)\r\n"); 
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
067A6:  MOVF   33,F
067A8:  BNZ   67B6
.................... 		//4CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 4 CH mode\r\n"); 
.................... 		} 
.................... 		output_low(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
067AA:  BCF    F92.1
067AC:  BCF    F89.1
.................... 		output_low(PIN_AMP_M2); // TI Chip - Mode Pin 2 
067AE:  BCF    F92.2
067B0:  BCF    F89.2
.................... 		output_high(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
067B2:  BCF    F92.3
067B4:  BSF    F89.3
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 1) { 
067B6:  DECFSZ 33,W
067B8:  BRA    67C6
.................... 		//2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 2 CH mode\r\n"); 
.................... 		} 
.................... 		output_low(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
067BA:  BCF    F92.1
067BC:  BCF    F89.1
.................... 		output_high(PIN_AMP_M2); // TI Chip - Mode Pin 2 
067BE:  BCF    F92.2
067C0:  BSF    F89.2
.................... 		output_low(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
067C2:  BCF    F92.3
067C4:  BCF    F89.3
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 2) { 
067C6:  MOVF   33,W
067C8:  SUBLW  02
067CA:  BNZ   67D8
.................... 		//1.2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 1.2 CH mode\r\n"); 
.................... 		} 
.................... 		output_high(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
067CC:  BCF    F92.1
067CE:  BSF    F89.1
.................... 		output_high(PIN_AMP_M2); // TI Chip - Mode Pin 2 
067D0:  BCF    F92.2
067D2:  BSF    F89.2
.................... 		output_low(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
067D4:  BCF    F92.3
067D6:  BCF    F89.3
.................... 	} 
....................  
.................... 	delay_ms(DELAY_AMP_MODE_SETTLE); 
067D8:  MOVLW  04
067DA:  MOVLB  8
067DC:  MOVWF  x6E
067DE:  MOVLW  FA
067E0:  MOVWF  x74
067E2:  MOVLB  0
067E4:  CALL   5A08
067E8:  MOVLB  8
067EA:  DECFSZ x6E,F
067EC:  BRA    67DE
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling AMP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_AMP_nRESET); 
067EE:  BCF    F92.5
067F0:  BSF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE) { 
067F2:  MOVF   3F,F
067F4:  BZ    67FE
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Waiting for AMP ready....\r\n"); 
.................... 		} 
.................... 		while(!input(PIN_AMP_READY)) { 
067F6:  BSF    F96.2
067F8:  BTFSC  F84.2
067FA:  BRA    67FE
.................... 	 
.................... 		} 
067FC:  BRA    67F6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] AMP is ready!\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	 
.................... 	delay_ms(50); 
067FE:  MOVLW  32
06800:  MOVWF  x74
06802:  MOVLB  0
06804:  CALL   5A08
....................  
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_DSP_nRESET);// DSP Reset 
06808:  BCF    F92.4
0680A:  BSF    F89.4
.................... 	 
.................... 	delay_ms(DELAY_DSP_RESET_SETTLE); 
0680C:  MOVLW  32
0680E:  MOVLB  8
06810:  MOVWF  x74
06812:  MOVLB  0
06814:  CALL   5A08
....................  
.................... 	if(DEVICE_CONFIG.IS_70V == 0) { 
06818:  MOVF   34,F
0681A:  BNZ   683A
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Not a 70V amp. Disabling 100Hz HP Filter\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,SEVENTYVHP_BYPASS,0x00000001); 
0681C:  MOVLW  F0
0681E:  MOVLB  8
06820:  MOVWF  x7A
06822:  CLRF   x79
06824:  MOVLW  04
06826:  MOVWF  x7C
06828:  MOVLW  44
0682A:  MOVWF  x7B
0682C:  CLRF   x80
0682E:  CLRF   x7F
06830:  CLRF   x7E
06832:  MOVLW  01
06834:  MOVWF  x7D
06836:  MOVLB  0
06838:  RCALL  62A8
.................... 	} 
.................... 		 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
0683A:  MOVF   33,F
0683C:  BNZ   68B6
.................... 		//4CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 4 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
0683E:  MOVLW  F0
06840:  MOVLB  8
06842:  MOVWF  x7A
06844:  CLRF   x79
06846:  MOVLW  02
06848:  MOVWF  x7C
0684A:  MOVLW  7E
0684C:  MOVWF  x7B
0684E:  CLRF   x80
06850:  CLRF   x7F
06852:  CLRF   x7E
06854:  MOVLW  01
06856:  MOVWF  x7D
06858:  MOVLB  0
0685A:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000002); 
0685C:  MOVLW  F0
0685E:  MOVLB  8
06860:  MOVWF  x7A
06862:  CLRF   x79
06864:  MOVLW  02
06866:  MOVWF  x7C
06868:  MOVLW  7F
0686A:  MOVWF  x7B
0686C:  CLRF   x80
0686E:  CLRF   x7F
06870:  CLRF   x7E
06872:  MOVLW  02
06874:  MOVWF  x7D
06876:  MOVLB  0
06878:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
0687A:  MOVLW  F0
0687C:  MOVLB  8
0687E:  MOVWF  x7A
06880:  CLRF   x79
06882:  MOVLW  02
06884:  MOVWF  x7C
06886:  MOVLW  80
06888:  MOVWF  x7B
0688A:  CLRF   x80
0688C:  CLRF   x7F
0688E:  CLRF   x7E
06890:  MOVLW  03
06892:  MOVWF  x7D
06894:  MOVLB  0
06896:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000004); 
06898:  MOVLW  F0
0689A:  MOVLB  8
0689C:  MOVWF  x7A
0689E:  CLRF   x79
068A0:  MOVLW  02
068A2:  MOVWF  x7C
068A4:  MOVLW  81
068A6:  MOVWF  x7B
068A8:  CLRF   x80
068AA:  CLRF   x7F
068AC:  CLRF   x7E
068AE:  MOVLW  04
068B0:  MOVWF  x7D
068B2:  MOVLB  0
068B4:  RCALL  62A8
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 1) { 
068B6:  DECFSZ 33,W
068B8:  BRA    6932
.................... 		//2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 2 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
068BA:  MOVLW  F0
068BC:  MOVLB  8
068BE:  MOVWF  x7A
068C0:  CLRF   x79
068C2:  MOVLW  02
068C4:  MOVWF  x7C
068C6:  MOVLW  7E
068C8:  MOVWF  x7B
068CA:  CLRF   x80
068CC:  CLRF   x7F
068CE:  CLRF   x7E
068D0:  MOVLW  01
068D2:  MOVWF  x7D
068D4:  MOVLB  0
068D6:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000001); 
068D8:  MOVLW  F0
068DA:  MOVLB  8
068DC:  MOVWF  x7A
068DE:  CLRF   x79
068E0:  MOVLW  02
068E2:  MOVWF  x7C
068E4:  MOVLW  7F
068E6:  MOVWF  x7B
068E8:  CLRF   x80
068EA:  CLRF   x7F
068EC:  CLRF   x7E
068EE:  MOVLW  01
068F0:  MOVWF  x7D
068F2:  MOVLB  0
068F4:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
068F6:  MOVLW  F0
068F8:  MOVLB  8
068FA:  MOVWF  x7A
068FC:  CLRF   x79
068FE:  MOVLW  02
06900:  MOVWF  x7C
06902:  MOVLW  80
06904:  MOVWF  x7B
06906:  CLRF   x80
06908:  CLRF   x7F
0690A:  CLRF   x7E
0690C:  MOVLW  03
0690E:  MOVWF  x7D
06910:  MOVLB  0
06912:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000003); 
06914:  MOVLW  F0
06916:  MOVLB  8
06918:  MOVWF  x7A
0691A:  CLRF   x79
0691C:  MOVLW  02
0691E:  MOVWF  x7C
06920:  MOVLW  81
06922:  MOVWF  x7B
06924:  CLRF   x80
06926:  CLRF   x7F
06928:  CLRF   x7E
0692A:  MOVLW  03
0692C:  MOVWF  x7D
0692E:  MOVLB  0
06930:  RCALL  62A8
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 2) { 
06932:  MOVF   33,W
06934:  SUBLW  02
06936:  BNZ   69B0
.................... 		//1.2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 1.2 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
06938:  MOVLW  F0
0693A:  MOVLB  8
0693C:  MOVWF  x7A
0693E:  CLRF   x79
06940:  MOVLW  02
06942:  MOVWF  x7C
06944:  MOVLW  7E
06946:  MOVWF  x7B
06948:  CLRF   x80
0694A:  CLRF   x7F
0694C:  CLRF   x7E
0694E:  MOVLW  01
06950:  MOVWF  x7D
06952:  MOVLB  0
06954:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000001); 
06956:  MOVLW  F0
06958:  MOVLB  8
0695A:  MOVWF  x7A
0695C:  CLRF   x79
0695E:  MOVLW  02
06960:  MOVWF  x7C
06962:  MOVLW  7F
06964:  MOVWF  x7B
06966:  CLRF   x80
06968:  CLRF   x7F
0696A:  CLRF   x7E
0696C:  MOVLW  01
0696E:  MOVWF  x7D
06970:  MOVLB  0
06972:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
06974:  MOVLW  F0
06976:  MOVLB  8
06978:  MOVWF  x7A
0697A:  CLRF   x79
0697C:  MOVLW  02
0697E:  MOVWF  x7C
06980:  MOVLW  80
06982:  MOVWF  x7B
06984:  CLRF   x80
06986:  CLRF   x7F
06988:  CLRF   x7E
0698A:  MOVLW  03
0698C:  MOVWF  x7D
0698E:  MOVLB  0
06990:  RCALL  62A8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000004); 
06992:  MOVLW  F0
06994:  MOVLB  8
06996:  MOVWF  x7A
06998:  CLRF   x79
0699A:  MOVLW  02
0699C:  MOVWF  x7C
0699E:  MOVLW  81
069A0:  MOVWF  x7B
069A2:  CLRF   x80
069A4:  CLRF   x7F
069A6:  CLRF   x7E
069A8:  MOVLW  04
069AA:  MOVWF  x7D
069AC:  MOVLB  0
069AE:  RCALL  62A8
.................... 	} 
....................  
.................... 	 
.................... 	if(DEVICE_CONFIG.DSP_VALUESEND_ENABLE) 
069B0:  MOVF   41,F
069B2:  BZ    69D2
.................... 	{ 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Sending DSP values from program %u\r\n",CURRENT_FLASH_PROGRAM); 
.................... 		} 
.................... 		 
.................... 		dsp_mute_outputs(); 
069B4:  BRA    636A
....................  
.................... 		send_flash_program_to_dsp_buffered(CURRENT_FLASH_PROGRAM); 
069B6:  MOVFF  CD,86E
069BA:  BRA    6578
....................  
.................... 		// We will have an RVC value to read. Keep this muted. We'll unmute later 
.................... 		if(DEVICE_CONFIG.RVC_ENABLE != 1) { 
069BC:  DECFSZ 3D,W
069BE:  BRA    69C2
069C0:  BRA    69C4
.................... 			dsp_unmute_outputs(); 
069C2:  RCALL  66F2
.................... 		} 
....................  
.................... 		delay_ms(100); 
069C4:  MOVLW  64
069C6:  MOVLB  8
069C8:  MOVWF  x74
069CA:  MOVLB  0
069CC:  CALL   5A08
....................  
.................... 	} else { 
069D0:  BRA    69D2
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NOT sending DSP values\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
069D2:  DECFSZ 3D,W
069D4:  BRA    6D18
....................  
.................... 		pin_in_mute_state = !input(PIN_AMP_nMUTE); 
069D6:  BSF    F94.1
069D8:  MOVLB  1
069DA:  CLRF   xD1
069DC:  BTFSS  F82.1
069DE:  INCF   xD1,F
.................... 	 
.................... 		set_adc_channel(0); 
069E0:  MOVLW  00
069E2:  MOVWF  01
069E4:  MOVF   FC2,W
069E6:  ANDLW  83
069E8:  IORWF  01,W
069EA:  MOVWF  FC2
.................... 		delay_us(10); 
069EC:  MOVLW  0B
069EE:  MOVWF  00
069F0:  DECFSZ 00,F
069F2:  BRA    69F0
069F4:  BRA    69F6
.................... 		current_adc = read_adc(); 
069F6:  BSF    FC2.1
069F8:  BTFSC  FC2.1
069FA:  BRA    69F8
069FC:  MOVFF  FC4,1CF
.................... 		 
.................... 		if(pin_in_mute_state) { 
06A00:  MOVF   xD1,F
06A02:  BZ    6AB6
.................... 			is_muted = true; 
06A04:  MOVLW  01
06A06:  MOVWF  xD0
06A08:  CLRF   19
06A0A:  BTFSC  FF2.7
06A0C:  BSF    19.7
06A0E:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
06A10:  MOVLW  83
06A12:  MOVLB  8
06A14:  MOVWF  xBF
06A16:  CLRF   xBE
06A18:  CLRF   xBD
06A1A:  MOVLW  0A
06A1C:  MOVWF  xBC
06A1E:  CLRF   xC3
06A20:  CLRF   xC2
06A22:  CLRF   xC1
06A24:  CLRF   xC0
06A26:  MOVLB  0
06A28:  CALL   0DB0
06A2C:  BTFSC  19.7
06A2E:  BSF    FF2.7
06A30:  CLRF   19
06A32:  BTFSC  FF2.7
06A34:  BSF    19.7
06A36:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
06A38:  MOVLW  83
06A3A:  MOVLB  8
06A3C:  MOVWF  xBF
06A3E:  CLRF   xBE
06A40:  CLRF   xBD
06A42:  MOVLW  0B
06A44:  MOVWF  xBC
06A46:  CLRF   xC3
06A48:  CLRF   xC2
06A4A:  CLRF   xC1
06A4C:  CLRF   xC0
06A4E:  MOVLB  0
06A50:  CALL   0DB0
06A54:  BTFSC  19.7
06A56:  BSF    FF2.7
06A58:  CLRF   19
06A5A:  BTFSC  FF2.7
06A5C:  BSF    19.7
06A5E:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
06A60:  MOVLW  83
06A62:  MOVLB  8
06A64:  MOVWF  xBF
06A66:  CLRF   xBE
06A68:  CLRF   xBD
06A6A:  MOVLW  0C
06A6C:  MOVWF  xBC
06A6E:  CLRF   xC3
06A70:  CLRF   xC2
06A72:  CLRF   xC1
06A74:  CLRF   xC0
06A76:  MOVLB  0
06A78:  CALL   0DB0
06A7C:  BTFSC  19.7
06A7E:  BSF    FF2.7
06A80:  CLRF   19
06A82:  BTFSC  FF2.7
06A84:  BSF    19.7
06A86:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
06A88:  MOVLW  83
06A8A:  MOVLB  8
06A8C:  MOVWF  xBF
06A8E:  CLRF   xBE
06A90:  CLRF   xBD
06A92:  MOVLW  0D
06A94:  MOVWF  xBC
06A96:  CLRF   xC3
06A98:  CLRF   xC2
06A9A:  CLRF   xC1
06A9C:  CLRF   xC0
06A9E:  MOVLB  0
06AA0:  CALL   0DB0
06AA4:  BTFSC  19.7
06AA6:  BSF    FF2.7
.................... 			set_timer1(15550); 
06AA8:  MOVLW  3C
06AAA:  MOVWF  FCF
06AAC:  MOVLW  BE
06AAE:  MOVWF  FCE
.................... 			clear_interrupt(INT_TIMER1); 
06AB0:  BCF    F9E.0
.................... 	 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - Muted\r\n"); 
.................... 			} 
.................... 		} else { 
06AB2:  BRA    6D14
06AB4:  MOVLB  1
06AB6:  CLRF   19
06AB8:  BTFSC  FF2.7
06ABA:  BSF    19.7
06ABC:  BCF    FF2.7
.................... 			double dsp_value = RVC_to_dsp_value(current_adc); 
06ABE:  MOVFF  1CF,8B8
06AC2:  MOVLB  0
06AC4:  CALL   23AE
06AC8:  BTFSC  19.7
06ACA:  BSF    FF2.7
06ACC:  MOVFF  03,86D
06AD0:  MOVFF  02,86C
06AD4:  MOVFF  01,86B
06AD8:  MOVFF  00,86A
06ADC:  CLRF   19
06ADE:  BTFSC  FF2.7
06AE0:  BSF    19.7
06AE2:  BCF    FF2.7
....................  
.................... 			send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
06AE4:  MOVFF  86D,8EC
06AE8:  MOVFF  86C,8EB
06AEC:  MOVFF  86B,8EA
06AF0:  MOVFF  86A,8E9
06AF4:  MOVLB  8
06AF6:  CLRF   xF0
06AF8:  CLRF   xEF
06AFA:  CLRF   xEE
06AFC:  MOVLW  9E
06AFE:  MOVWF  xED
06B00:  MOVLB  0
06B02:  CALL   1230
06B06:  BTFSC  19.7
06B08:  BSF    FF2.7
06B0A:  CLRF   19
06B0C:  BTFSC  FF2.7
06B0E:  BSF    19.7
06B10:  BCF    FF2.7
06B12:  MOVFF  03,8BB
06B16:  MOVFF  02,8BA
06B1A:  MOVFF  01,8B9
06B1E:  MOVFF  00,8B8
06B22:  CALL   24C8
06B26:  BTFSC  19.7
06B28:  BSF    FF2.7
06B2A:  MOVFF  03,871
06B2E:  MOVFF  02,870
06B32:  MOVFF  01,86F
06B36:  MOVFF  00,86E
06B3A:  CLRF   19
06B3C:  BTFSC  FF2.7
06B3E:  BSF    19.7
06B40:  BCF    FF2.7
06B42:  MOVLW  83
06B44:  MOVLB  8
06B46:  MOVWF  xBF
06B48:  CLRF   xBE
06B4A:  CLRF   xBD
06B4C:  MOVLW  0A
06B4E:  MOVWF  xBC
06B50:  MOVFF  03,8C3
06B54:  MOVFF  02,8C2
06B58:  MOVFF  01,8C1
06B5C:  MOVFF  00,8C0
06B60:  MOVLB  0
06B62:  CALL   0DB0
06B66:  BTFSC  19.7
06B68:  BSF    FF2.7
06B6A:  CLRF   19
06B6C:  BTFSC  FF2.7
06B6E:  BSF    19.7
06B70:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
06B72:  MOVFF  86D,8EC
06B76:  MOVFF  86C,8EB
06B7A:  MOVFF  86B,8EA
06B7E:  MOVFF  86A,8E9
06B82:  MOVLB  8
06B84:  CLRF   xF0
06B86:  CLRF   xEF
06B88:  CLRF   xEE
06B8A:  MOVLW  9E
06B8C:  MOVWF  xED
06B8E:  MOVLB  0
06B90:  CALL   1230
06B94:  BTFSC  19.7
06B96:  BSF    FF2.7
06B98:  CLRF   19
06B9A:  BTFSC  FF2.7
06B9C:  BSF    19.7
06B9E:  BCF    FF2.7
06BA0:  MOVFF  03,8BB
06BA4:  MOVFF  02,8BA
06BA8:  MOVFF  01,8B9
06BAC:  MOVFF  00,8B8
06BB0:  CALL   24C8
06BB4:  BTFSC  19.7
06BB6:  BSF    FF2.7
06BB8:  MOVFF  03,871
06BBC:  MOVFF  02,870
06BC0:  MOVFF  01,86F
06BC4:  MOVFF  00,86E
06BC8:  CLRF   19
06BCA:  BTFSC  FF2.7
06BCC:  BSF    19.7
06BCE:  BCF    FF2.7
06BD0:  MOVLW  83
06BD2:  MOVLB  8
06BD4:  MOVWF  xBF
06BD6:  CLRF   xBE
06BD8:  CLRF   xBD
06BDA:  MOVLW  0B
06BDC:  MOVWF  xBC
06BDE:  MOVFF  03,8C3
06BE2:  MOVFF  02,8C2
06BE6:  MOVFF  01,8C1
06BEA:  MOVFF  00,8C0
06BEE:  MOVLB  0
06BF0:  CALL   0DB0
06BF4:  BTFSC  19.7
06BF6:  BSF    FF2.7
06BF8:  CLRF   19
06BFA:  BTFSC  FF2.7
06BFC:  BSF    19.7
06BFE:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
06C00:  MOVFF  86D,8EC
06C04:  MOVFF  86C,8EB
06C08:  MOVFF  86B,8EA
06C0C:  MOVFF  86A,8E9
06C10:  MOVLB  8
06C12:  CLRF   xF0
06C14:  CLRF   xEF
06C16:  CLRF   xEE
06C18:  MOVLW  9E
06C1A:  MOVWF  xED
06C1C:  MOVLB  0
06C1E:  CALL   1230
06C22:  BTFSC  19.7
06C24:  BSF    FF2.7
06C26:  CLRF   19
06C28:  BTFSC  FF2.7
06C2A:  BSF    19.7
06C2C:  BCF    FF2.7
06C2E:  MOVFF  03,8BB
06C32:  MOVFF  02,8BA
06C36:  MOVFF  01,8B9
06C3A:  MOVFF  00,8B8
06C3E:  CALL   24C8
06C42:  BTFSC  19.7
06C44:  BSF    FF2.7
06C46:  MOVFF  03,871
06C4A:  MOVFF  02,870
06C4E:  MOVFF  01,86F
06C52:  MOVFF  00,86E
06C56:  CLRF   19
06C58:  BTFSC  FF2.7
06C5A:  BSF    19.7
06C5C:  BCF    FF2.7
06C5E:  MOVLW  83
06C60:  MOVLB  8
06C62:  MOVWF  xBF
06C64:  CLRF   xBE
06C66:  CLRF   xBD
06C68:  MOVLW  0C
06C6A:  MOVWF  xBC
06C6C:  MOVFF  03,8C3
06C70:  MOVFF  02,8C2
06C74:  MOVFF  01,8C1
06C78:  MOVFF  00,8C0
06C7C:  MOVLB  0
06C7E:  CALL   0DB0
06C82:  BTFSC  19.7
06C84:  BSF    FF2.7
06C86:  CLRF   19
06C88:  BTFSC  FF2.7
06C8A:  BSF    19.7
06C8C:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
06C8E:  MOVFF  86D,8EC
06C92:  MOVFF  86C,8EB
06C96:  MOVFF  86B,8EA
06C9A:  MOVFF  86A,8E9
06C9E:  MOVLB  8
06CA0:  CLRF   xF0
06CA2:  CLRF   xEF
06CA4:  CLRF   xEE
06CA6:  MOVLW  9E
06CA8:  MOVWF  xED
06CAA:  MOVLB  0
06CAC:  CALL   1230
06CB0:  BTFSC  19.7
06CB2:  BSF    FF2.7
06CB4:  CLRF   19
06CB6:  BTFSC  FF2.7
06CB8:  BSF    19.7
06CBA:  BCF    FF2.7
06CBC:  MOVFF  03,8BB
06CC0:  MOVFF  02,8BA
06CC4:  MOVFF  01,8B9
06CC8:  MOVFF  00,8B8
06CCC:  CALL   24C8
06CD0:  BTFSC  19.7
06CD2:  BSF    FF2.7
06CD4:  MOVFF  03,871
06CD8:  MOVFF  02,870
06CDC:  MOVFF  01,86F
06CE0:  MOVFF  00,86E
06CE4:  CLRF   19
06CE6:  BTFSC  FF2.7
06CE8:  BSF    19.7
06CEA:  BCF    FF2.7
06CEC:  MOVLW  83
06CEE:  MOVLB  8
06CF0:  MOVWF  xBF
06CF2:  CLRF   xBE
06CF4:  CLRF   xBD
06CF6:  MOVLW  0D
06CF8:  MOVWF  xBC
06CFA:  MOVFF  03,8C3
06CFE:  MOVFF  02,8C2
06D02:  MOVFF  01,8C1
06D06:  MOVFF  00,8C0
06D0A:  MOVLB  0
06D0C:  CALL   0DB0
06D10:  BTFSC  19.7
06D12:  BSF    FF2.7
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		dsp_unmute_outputs(); 
06D14:  RCALL  66F2
....................  
.................... 	} else { 
06D16:  BRA    6D18
.................... 		if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] DEVICE_CONFIG.RVC_ENABLE == 0\r\n"); 
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	output_low(AUD_MUTE); 
06D18:  BCF    F95.3
06D1A:  BCF    F8C.3
....................  
.................... 	update_phantom_power(); 
06D1C:  RCALL  671C
....................  
.................... } 
06D1E:  RETURN 0
....................  
.................... void setup_interrupts() 
.................... { 
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
*
02916:  DECFSZ 3D,W
02918:  BRA    2926
....................  
.................... 		set_timer1(15550); 
0291A:  MOVLW  3C
0291C:  MOVWF  FCF
0291E:  MOVLW  BE
02920:  MOVWF  FCE
.................... 		enable_interrupts(INT_TIMER1);  
02922:  BSF    F9D.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling RVC\r\n"); 
.................... 		} 
.................... 	} else { 
02924:  BRA    2926
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Disabling RVC\r\n"); 
.................... 		} 
.................... 	} 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG]: Enabling global interrupts\r\n"); 
.................... 	} 
.................... 	enable_interrupts(GLOBAL); 
02926:  MOVLW  C0
02928:  IORWF  FF2,F
....................  
.................... 	 
.................... 	enable_interrupts(INT_RDA2); 
0292A:  BSF    FA3.5
.................... 	 
.................... 	 
....................  
.................... 	disable_interrupts(INT_EXT);  
0292C:  BCF    FF2.4
....................  
.................... 	if(DEVICE_CONFIG.SLEEP_ENABLE == 1) { 
0292E:  DECFSZ 42,W
02930:  BRA    295E
.................... 		// Sleep timer enabled.. check initial state 
.................... 		if(DEBUG){ 
.................... 			fprintf(RS232,"[DEBUG] Sleep detect enabled... checking current state..."); 
.................... 		} 
....................  
.................... 		if(input(PIN_AUDIODETECT)) { 
02932:  BSF    F93.0
02934:  BTFSS  F81.0
02936:  BRA    2948
.................... 			// We currently have audio 
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will disable sleep timer and wait for audiodetect to go low\r\n"); 
.................... 			} 
....................  
.................... 				ext_int_edge(0,H_TO_L);  
02938:  BCF    FF1.6
.................... 				enable_interrupts(INT_EXT); 
0293A:  BSF    FF2.4
.................... 				disable_interrupts(INT_TIMER0); 
0293C:  BCF    FF2.5
.................... 				sleep_timer_active = 0; 
0293E:  MOVLB  1
02940:  CLRF   xD7
.................... 				is_in_sleep = 0; 
02942:  CLRF   xD6
.................... 		} else { 
02944:  BRA    295C
02946:  MOVLB  0
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"NO AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will start sleep timer and wait for audiodetect to go high\r\n"); 
.................... 			} 
....................  
.................... 			ext_int_edge(0,L_TO_H);  
02948:  BSF    FF1.6
.................... 			enable_interrupts(INT_EXT); 
0294A:  BSF    FF2.4
....................  
.................... 			set_timer0(7936); 
0294C:  MOVLW  1F
0294E:  MOVWF  FD7
02950:  CLRF   FD6
.................... 			enable_interrupts(INT_TIMER0); 
02952:  BSF    FF2.5
.................... 			sleep_timer_active = 1; 
02954:  MOVLW  01
02956:  MOVLB  1
02958:  MOVWF  xD7
.................... 			is_in_sleep = 0; 
0295A:  CLRF   xD6
0295C:  MOVLB  0
.................... 				 
.................... 		}				 
....................  
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.USBDETECT_ENABLE == 0) { 
0295E:  MOVF   3E,F
02960:  BNZ   296A
.................... 		IS_USB_CONNECTED = true; 
02962:  MOVLW  01
02964:  MOVWF  x78
.................... 		disable_interrupts(INT_EXT1);  
02966:  BCF    FF0.3
.................... 	} else { 
02968:  BRA    2980
.................... 		// Check initial plug state 
.................... 		if(input(PIN_B1)) { 
0296A:  BSF    F93.1
0296C:  BTFSS  F81.1
0296E:  BRA    2978
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is high. Setting IS_USB_CONNECTED to true\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = true; 
02970:  MOVLW  01
02972:  MOVWF  x78
.................... 			ext_int_edge(1,H_TO_L);  
02974:  BCF    FF1.5
.................... 		} else { 
02976:  BRA    297C
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is low. Setting IS_USB_CONNECTED to false\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = false; 
02978:  CLRF   x78
.................... 			ext_int_edge(1,L_TO_H);  
0297A:  BSF    FF1.5
.................... 		} 
....................  
.................... 		clear_interrupt(INT_EXT1);  
0297C:  BCF    FF0.0
....................    		enable_interrupts(INT_EXT1); 
0297E:  BSF    FF0.3
.................... 	 
.................... 	} 
.................... } 
02980:  RETURN 0
....................  
....................  
.................... void setup_peripherals() 
.................... { 
....................  
.................... 	setup_adc( ADC_CLOCK_INTERNAL ); 
*
02A50:  MOVF   FC0,W
02A52:  ANDLW  C0
02A54:  IORLW  07
02A56:  MOVWF  FC0
02A58:  BCF    FC0.7
02A5A:  BSF    FC2.0
....................  
.................... 	setup_adc_ports( sAN0 | sAN9 ); 
02A5C:  MOVF   FC1,W
02A5E:  ANDLW  F0
02A60:  MOVWF  FC1
02A62:  MOVLW  01
02A64:  MOVLB  F
02A66:  MOVWF  x38
02A68:  MOVLW  00
02A6A:  MOVWF  x3C
02A6C:  MOVLW  08
02A6E:  MOVWF  x39
02A70:  MOVLW  00
02A72:  MOVWF  x3A
02A74:  MOVWF  x3B
....................  
.................... 	set_adc_channel(0); 
02A76:  MOVWF  01
02A78:  MOVF   FC2,W
02A7A:  ANDLW  83
02A7C:  IORWF  01,W
02A7E:  MOVWF  FC2
....................  
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
02A80:  MOVLW  85
02A82:  MOVWF  FD5
....................  
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
02A84:  MOVLW  37
02A86:  MOVWF  FCD
02A88:  CLRF   FCC
....................  
.................... 	setup_timer_3(T3_DISABLED | T3_DIV_BY_1); 
02A8A:  CLRF   FB4
02A8C:  CLRF   FB1
....................    	setup_timer_4(T4_DISABLED,0,1); 
02A8E:  MOVLW  00
02A90:  MOVWF  x51
02A92:  MOVLW  00
02A94:  MOVWF  x52
....................    	setup_timer_5(T5_DISABLED | T5_DIV_BY_1); 
02A96:  CLRF   x4D
02A98:  CLRF   x4E
....................    	setup_timer_6(T6_DISABLED,0,1); 
02A9A:  MOVWF  x4A
02A9C:  MOVLW  00
02A9E:  MOVWF  x4B
....................  
.................... 	setup_wdt(WDT_OFF);  
02AA0:  BCF    FD1.0
....................  
.................... } 
02AA2:  MOVLB  0
02AA4:  GOTO   C09C (RETURN)
....................  
....................  
....................  
.................... #include <remote_volume.c> 
.................... int32 get_AM_trim_channel(int ch) 
.................... { 
.................... 	switch(ch) { 
*
07692:  MOVLB  8
07694:  MOVF   x6D,W
07696:  XORLW  00
07698:  MOVLB  0
0769A:  BZ    76AA
0769C:  XORLW  01
0769E:  BZ    76BA
076A0:  XORLW  03
076A2:  BZ    76CA
076A4:  XORLW  01
076A6:  BZ    76DA
076A8:  BRA    76EA
.................... 		case 0 : 
.................... 			return AM_ANALOG1_TRIM; 
076AA:  MOVLW  0A
076AC:  MOVWF  00
076AE:  CLRF   01
076B0:  CLRF   02
076B2:  MOVLW  83
076B4:  MOVWF  03
076B6:  BRA    76F6
.................... 		break; 
076B8:  BRA    76F6
....................  
.................... 		case 1 : 
.................... 			return AM_ANALOG2_TRIM; 
076BA:  MOVLW  0B
076BC:  MOVWF  00
076BE:  CLRF   01
076C0:  CLRF   02
076C2:  MOVLW  83
076C4:  MOVWF  03
076C6:  BRA    76F6
.................... 		break; 
076C8:  BRA    76F6
....................  
.................... 		case 2 :  
.................... 			return AM_ANALOG3_TRIM; 
076CA:  MOVLW  0C
076CC:  MOVWF  00
076CE:  CLRF   01
076D0:  CLRF   02
076D2:  MOVLW  83
076D4:  MOVWF  03
076D6:  BRA    76F6
.................... 		break; 
076D8:  BRA    76F6
.................... 		 
.................... 		case 3 : 
.................... 			return AM_ANALOG4_TRIM; 
076DA:  MOVLW  0D
076DC:  MOVWF  00
076DE:  CLRF   01
076E0:  CLRF   02
076E2:  MOVLW  83
076E4:  MOVWF  03
076E6:  BRA    76F6
.................... 		break; 
076E8:  BRA    76F6
....................  
.................... 		default : 
.................... 			return 0; 
076EA:  CLRF   00
076EC:  CLRF   01
076EE:  CLRF   02
076F0:  CLRF   03
076F2:  BRA    76F6
.................... 		break; 
076F4:  BRA    76F6
.................... 	} 
.................... } 
076F6:  RETURN 0
....................  
.................... double discrete_vol_output(int ch,int new_vol) 
.................... { 
.................... 	 
....................  
.................... 	if(ch == 0) { 
*
079F8:  MOVLB  8
079FA:  MOVF   x69,F
079FC:  BTFSS  FD8.2
079FE:  BRA    7B74
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
07A00:  CLRF   x6B
07A02:  MOVF   x6B,W
07A04:  SUBLW  03
07A06:  BTFSS  FD8.0
07A08:  BRA    7B60
.................... 			rs232_output_mute[i] = 0; 
07A0A:  CLRF   03
07A0C:  MOVF   x6B,W
07A0E:  ADDLW  C5
07A10:  MOVWF  FE9
07A12:  MOVLW  00
07A14:  ADDWFC 03,W
07A16:  MOVWF  FEA
07A18:  CLRF   FEF
.................... 			rs232_output_vol[i] = ((double)new_vol/100.0); 
07A1A:  MOVF   x6B,W
07A1C:  MULLW  04
07A1E:  MOVF   FF3,W
07A20:  CLRF   03
07A22:  ADDLW  B5
07A24:  MOVWF  FE9
07A26:  MOVLW  00
07A28:  ADDWFC 03,W
07A2A:  MOVWF  FEA
07A2C:  CLRF   19
07A2E:  BTFSC  FF2.7
07A30:  BSF    19.7
07A32:  BCF    FF2.7
07A34:  CLRF   xEE
07A36:  MOVFF  86A,8ED
07A3A:  MOVLB  0
07A3C:  CALL   0E24
07A40:  BTFSC  19.7
07A42:  BSF    FF2.7
07A44:  MOVFF  00,86E
07A48:  MOVFF  01,86F
07A4C:  MOVFF  02,870
07A50:  MOVFF  03,871
07A54:  CLRF   19
07A56:  BTFSC  FF2.7
07A58:  BSF    19.7
07A5A:  BCF    FF2.7
07A5C:  MOVFF  03,8E5
07A60:  MOVFF  02,8E4
07A64:  MOVFF  01,8E3
07A68:  MOVFF  00,8E2
07A6C:  MOVLB  8
07A6E:  CLRF   xE9
07A70:  CLRF   xE8
07A72:  MOVLW  48
07A74:  MOVWF  xE7
07A76:  MOVLW  85
07A78:  MOVWF  xE6
07A7A:  MOVLB  0
07A7C:  CALL   10D2
07A80:  BTFSC  19.7
07A82:  BSF    FF2.7
07A84:  MOVFF  00,FEF
07A88:  MOVFF  01,FEC
07A8C:  MOVFF  02,FEC
07A90:  MOVFF  03,FEC
.................... 		 
.................... 			 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
07A94:  MOVFF  86B,86D
07A98:  RCALL  7692
07A9A:  MOVFF  03,86F
07A9E:  MOVFF  02,86E
07AA2:  MOVFF  01,86D
07AA6:  MOVFF  00,86C
07AAA:  MOVLB  8
07AAC:  MOVF   x6B,W
07AAE:  MULLW  04
07AB0:  MOVF   FF3,W
07AB2:  CLRF   03
07AB4:  ADDLW  B5
07AB6:  MOVWF  FE9
07AB8:  MOVLW  00
07ABA:  ADDWFC 03,W
07ABC:  MOVWF  FEA
07ABE:  MOVFF  FEF,870
07AC2:  MOVFF  FEC,871
07AC6:  MOVFF  FEC,872
07ACA:  MOVFF  FEC,873
07ACE:  CLRF   19
07AD0:  BTFSC  FF2.7
07AD2:  BSF    19.7
07AD4:  BCF    FF2.7
07AD6:  MOVFF  873,8EC
07ADA:  MOVFF  872,8EB
07ADE:  MOVFF  871,8EA
07AE2:  MOVFF  870,8E9
07AE6:  CLRF   xF0
07AE8:  CLRF   xEF
07AEA:  CLRF   xEE
07AEC:  MOVLW  9E
07AEE:  MOVWF  xED
07AF0:  MOVLB  0
07AF2:  CALL   1230
07AF6:  BTFSC  19.7
07AF8:  BSF    FF2.7
07AFA:  CLRF   19
07AFC:  BTFSC  FF2.7
07AFE:  BSF    19.7
07B00:  BCF    FF2.7
07B02:  MOVFF  03,8BB
07B06:  MOVFF  02,8BA
07B0A:  MOVFF  01,8B9
07B0E:  MOVFF  00,8B8
07B12:  CALL   24C8
07B16:  BTFSC  19.7
07B18:  BSF    FF2.7
07B1A:  MOVFF  03,873
07B1E:  MOVFF  02,872
07B22:  MOVFF  01,871
07B26:  MOVFF  00,870
07B2A:  CLRF   19
07B2C:  BTFSC  FF2.7
07B2E:  BSF    19.7
07B30:  BCF    FF2.7
07B32:  MOVFF  86F,8BF
07B36:  MOVFF  86E,8BE
07B3A:  MOVFF  86D,8BD
07B3E:  MOVFF  86C,8BC
07B42:  MOVFF  03,8C3
07B46:  MOVFF  02,8C2
07B4A:  MOVFF  01,8C1
07B4E:  MOVFF  00,8C0
07B52:  CALL   0DB0
07B56:  BTFSC  19.7
07B58:  BSF    FF2.7
.................... 		} 
07B5A:  MOVLB  8
07B5C:  INCF   x6B,F
07B5E:  BRA    7A02
....................  
.................... 		return rs232_output_vol[0]; // They will all be the same. So just return the volume of CH1 
07B60:  MOVFF  B5,00
07B64:  MOVFF  B6,01
07B68:  MOVFF  B7,02
07B6C:  MOVFF  B8,03
07B70:  BRA    7CFA
.................... 	} else { 
07B72:  BRA    7CFA
....................  
.................... 		rs232_output_mute[ch-1] = 0; 
07B74:  MOVLW  01
07B76:  SUBWF  x69,W
07B78:  CLRF   03
07B7A:  ADDLW  C5
07B7C:  MOVWF  FE9
07B7E:  MOVLW  00
07B80:  ADDWFC 03,W
07B82:  MOVWF  FEA
07B84:  CLRF   FEF
.................... 		rs232_output_vol[ch-1] = ((double)new_vol/100.0); 
07B86:  MOVLW  01
07B88:  SUBWF  x69,W
07B8A:  MULLW  04
07B8C:  MOVF   FF3,W
07B8E:  CLRF   03
07B90:  ADDLW  B5
07B92:  MOVWF  FE9
07B94:  MOVLW  00
07B96:  ADDWFC 03,W
07B98:  MOVWF  FEA
07B9A:  CLRF   19
07B9C:  BTFSC  FF2.7
07B9E:  BSF    19.7
07BA0:  BCF    FF2.7
07BA2:  CLRF   xEE
07BA4:  MOVFF  86A,8ED
07BA8:  MOVLB  0
07BAA:  CALL   0E24
07BAE:  BTFSC  19.7
07BB0:  BSF    FF2.7
07BB2:  MOVFF  00,86E
07BB6:  MOVFF  01,86F
07BBA:  MOVFF  02,870
07BBE:  MOVFF  03,871
07BC2:  CLRF   19
07BC4:  BTFSC  FF2.7
07BC6:  BSF    19.7
07BC8:  BCF    FF2.7
07BCA:  MOVFF  03,8E5
07BCE:  MOVFF  02,8E4
07BD2:  MOVFF  01,8E3
07BD6:  MOVFF  00,8E2
07BDA:  MOVLB  8
07BDC:  CLRF   xE9
07BDE:  CLRF   xE8
07BE0:  MOVLW  48
07BE2:  MOVWF  xE7
07BE4:  MOVLW  85
07BE6:  MOVWF  xE6
07BE8:  MOVLB  0
07BEA:  CALL   10D2
07BEE:  BTFSC  19.7
07BF0:  BSF    FF2.7
07BF2:  MOVFF  00,FEF
07BF6:  MOVFF  01,FEC
07BFA:  MOVFF  02,FEC
07BFE:  MOVFF  03,FEC
.................... 	 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
07C02:  MOVLW  01
07C04:  MOVLB  8
07C06:  SUBWF  x69,W
07C08:  MOVWF  x6C
07C0A:  MOVWF  x6D
07C0C:  MOVLB  0
07C0E:  RCALL  7692
07C10:  MOVFF  03,86F
07C14:  MOVFF  02,86E
07C18:  MOVFF  01,86D
07C1C:  MOVFF  00,86C
07C20:  MOVLW  01
07C22:  MOVLB  8
07C24:  SUBWF  x69,W
07C26:  MULLW  04
07C28:  MOVF   FF3,W
07C2A:  CLRF   03
07C2C:  ADDLW  B5
07C2E:  MOVWF  FE9
07C30:  MOVLW  00
07C32:  ADDWFC 03,W
07C34:  MOVWF  FEA
07C36:  MOVFF  FEF,870
07C3A:  MOVFF  FEC,871
07C3E:  MOVFF  FEC,872
07C42:  MOVFF  FEC,873
07C46:  CLRF   19
07C48:  BTFSC  FF2.7
07C4A:  BSF    19.7
07C4C:  BCF    FF2.7
07C4E:  MOVFF  873,8EC
07C52:  MOVFF  872,8EB
07C56:  MOVFF  871,8EA
07C5A:  MOVFF  870,8E9
07C5E:  CLRF   xF0
07C60:  CLRF   xEF
07C62:  CLRF   xEE
07C64:  MOVLW  9E
07C66:  MOVWF  xED
07C68:  MOVLB  0
07C6A:  CALL   1230
07C6E:  BTFSC  19.7
07C70:  BSF    FF2.7
07C72:  CLRF   19
07C74:  BTFSC  FF2.7
07C76:  BSF    19.7
07C78:  BCF    FF2.7
07C7A:  MOVFF  03,8BB
07C7E:  MOVFF  02,8BA
07C82:  MOVFF  01,8B9
07C86:  MOVFF  00,8B8
07C8A:  CALL   24C8
07C8E:  BTFSC  19.7
07C90:  BSF    FF2.7
07C92:  MOVFF  03,873
07C96:  MOVFF  02,872
07C9A:  MOVFF  01,871
07C9E:  MOVFF  00,870
07CA2:  CLRF   19
07CA4:  BTFSC  FF2.7
07CA6:  BSF    19.7
07CA8:  BCF    FF2.7
07CAA:  MOVFF  86F,8BF
07CAE:  MOVFF  86E,8BE
07CB2:  MOVFF  86D,8BD
07CB6:  MOVFF  86C,8BC
07CBA:  MOVFF  03,8C3
07CBE:  MOVFF  02,8C2
07CC2:  MOVFF  01,8C1
07CC6:  MOVFF  00,8C0
07CCA:  CALL   0DB0
07CCE:  BTFSC  19.7
07CD0:  BSF    FF2.7
....................  
.................... 		return rs232_output_vol[ch-1]; // They will all be the same. So just return the volume of CH1 
07CD2:  MOVLW  01
07CD4:  MOVLB  8
07CD6:  SUBWF  x69,W
07CD8:  MULLW  04
07CDA:  MOVF   FF3,W
07CDC:  CLRF   03
07CDE:  ADDLW  B5
07CE0:  MOVWF  FE9
07CE2:  MOVLW  00
07CE4:  ADDWFC 03,W
07CE6:  MOVWF  FEA
07CE8:  MOVFF  FEF,00
07CEC:  MOVFF  FEC,01
07CF0:  MOVFF  FEC,02
07CF4:  MOVFF  FEC,03
07CF8:  BRA    7CFA
.................... 	} 
.................... 	 
.................... } 
07CFA:  MOVLB  0
07CFC:  RETURN 0
....................  
.................... int log_volume_up(int ch, int amount) 
.................... { 
*
0AAA6:  MOVLB  8
0AAA8:  CLRF   x2A
0AAAA:  CLRF   x29
0AAAC:  CLRF   x28
0AAAE:  CLRF   x27
....................  
.................... 	double new_log_value = 0; 
....................  
.................... 	if(ch == 0) { 
0AAB0:  MOVF   x25,F
0AAB2:  BTFSS  FD8.2
0AAB4:  BRA    AC04
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0AAB6:  CLRF   x2B
0AAB8:  MOVF   x2B,W
0AABA:  SUBLW  03
0AABC:  BTFSS  FD8.0
0AABE:  BRA    ABF8
.................... 			rs232_output_mute[i] = 0; 
0AAC0:  CLRF   03
0AAC2:  MOVF   x2B,W
0AAC4:  ADDLW  C5
0AAC6:  MOVWF  FE9
0AAC8:  MOVLW  00
0AACA:  ADDWFC 03,W
0AACC:  MOVWF  FEA
0AACE:  CLRF   FEF
.................... 			rs232_log_output_vol_index[i] += amount; 
0AAD0:  CLRF   03
0AAD2:  MOVF   x2B,W
0AAD4:  ADDLW  C9
0AAD6:  MOVWF  FE9
0AAD8:  MOVLW  00
0AADA:  ADDWFC 03,W
0AADC:  MOVWF  FEA
0AADE:  MOVF   x26,W
0AAE0:  ADDWF  FEF,W
0AAE2:  MOVWF  FEF
....................  
.................... 			if(rs232_log_output_vol_index[i] > 60) { 
0AAE4:  CLRF   03
0AAE6:  MOVF   x2B,W
0AAE8:  ADDLW  C9
0AAEA:  MOVWF  FE9
0AAEC:  MOVLW  00
0AAEE:  ADDWFC 03,W
0AAF0:  MOVWF  FEA
0AAF2:  MOVF   FEF,W
0AAF4:  SUBLW  3C
0AAF6:  BC    AB0A
.................... 				rs232_log_output_vol_index[i] = 60; 
0AAF8:  CLRF   03
0AAFA:  MOVF   x2B,W
0AAFC:  ADDLW  C9
0AAFE:  MOVWF  FE9
0AB00:  MOVLW  00
0AB02:  ADDWFC 03,W
0AB04:  MOVWF  FEA
0AB06:  MOVLW  3C
0AB08:  MOVWF  FEF
.................... 			} 
.................... 			 
.................... 			new_log_value = log_values[rs232_log_output_vol_index[i]]; 
0AB0A:  CLRF   03
0AB0C:  MOVF   x2B,W
0AB0E:  ADDLW  C9
0AB10:  MOVWF  FE9
0AB12:  MOVLW  00
0AB14:  ADDWFC 03,W
0AB16:  MOVWF  FEA
0AB18:  MOVF   FEF,W
0AB1A:  MULLW  04
0AB1C:  MOVF   FF3,W
0AB1E:  CLRF   03
0AB20:  ADDLW  D8
0AB22:  MOVWF  FE9
0AB24:  MOVLW  01
0AB26:  ADDWFC 03,W
0AB28:  MOVWF  FEA
0AB2A:  MOVFF  FEF,00
0AB2E:  MOVFF  FEC,01
0AB32:  MOVFF  FEC,02
0AB36:  MOVFF  FEC,03
0AB3A:  MOVFF  03,82A
0AB3E:  MOVFF  02,829
0AB42:  MOVFF  01,828
0AB46:  MOVFF  00,827
....................  
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(new_log_value*2147483648.0)); 
0AB4A:  MOVFF  82B,86D
0AB4E:  MOVLB  0
0AB50:  CALL   7692
0AB54:  MOVFF  03,82F
0AB58:  MOVFF  02,82E
0AB5C:  MOVFF  01,82D
0AB60:  MOVFF  00,82C
0AB64:  CLRF   19
0AB66:  BTFSC  FF2.7
0AB68:  BSF    19.7
0AB6A:  BCF    FF2.7
0AB6C:  MOVFF  82A,8EC
0AB70:  MOVFF  829,8EB
0AB74:  MOVFF  828,8EA
0AB78:  MOVFF  827,8E9
0AB7C:  MOVLB  8
0AB7E:  CLRF   xF0
0AB80:  CLRF   xEF
0AB82:  CLRF   xEE
0AB84:  MOVLW  9E
0AB86:  MOVWF  xED
0AB88:  MOVLB  0
0AB8A:  CALL   1230
0AB8E:  BTFSC  19.7
0AB90:  BSF    FF2.7
0AB92:  CLRF   19
0AB94:  BTFSC  FF2.7
0AB96:  BSF    19.7
0AB98:  BCF    FF2.7
0AB9A:  MOVFF  03,8BB
0AB9E:  MOVFF  02,8BA
0ABA2:  MOVFF  01,8B9
0ABA6:  MOVFF  00,8B8
0ABAA:  CALL   24C8
0ABAE:  BTFSC  19.7
0ABB0:  BSF    FF2.7
0ABB2:  MOVFF  03,833
0ABB6:  MOVFF  02,832
0ABBA:  MOVFF  01,831
0ABBE:  MOVFF  00,830
0ABC2:  CLRF   19
0ABC4:  BTFSC  FF2.7
0ABC6:  BSF    19.7
0ABC8:  BCF    FF2.7
0ABCA:  MOVFF  82F,8BF
0ABCE:  MOVFF  82E,8BE
0ABD2:  MOVFF  82D,8BD
0ABD6:  MOVFF  82C,8BC
0ABDA:  MOVFF  03,8C3
0ABDE:  MOVFF  02,8C2
0ABE2:  MOVFF  01,8C1
0ABE6:  MOVFF  00,8C0
0ABEA:  CALL   0DB0
0ABEE:  BTFSC  19.7
0ABF0:  BSF    FF2.7
....................  
.................... 		} 
0ABF2:  MOVLB  8
0ABF4:  INCF   x2B,F
0ABF6:  BRA    AAB8
....................  
.................... 		return rs232_log_output_vol_index[0]; // They will all be the same. So just return the volume of CH1 
0ABF8:  MOVLB  0
0ABFA:  MOVFF  C9,01
0ABFE:  BRA    AD5E
....................  
.................... 	} else { 
0AC00:  BRA    AD5E
0AC02:  MOVLB  8
....................  
.................... 		rs232_output_mute[ch-1] = 0; 
0AC04:  MOVLW  01
0AC06:  SUBWF  x25,W
0AC08:  CLRF   03
0AC0A:  ADDLW  C5
0AC0C:  MOVWF  FE9
0AC0E:  MOVLW  00
0AC10:  ADDWFC 03,W
0AC12:  MOVWF  FEA
0AC14:  CLRF   FEF
.................... 		 
.................... 		rs232_log_output_vol_index[ch-1] += amount; 
0AC16:  MOVLW  01
0AC18:  SUBWF  x25,W
0AC1A:  CLRF   03
0AC1C:  ADDLW  C9
0AC1E:  MOVWF  FE9
0AC20:  MOVLW  00
0AC22:  ADDWFC 03,W
0AC24:  MOVWF  FEA
0AC26:  MOVF   x26,W
0AC28:  ADDWF  FEF,W
0AC2A:  MOVWF  FEF
....................  
.................... 		if(rs232_log_output_vol_index[ch-1] > 60) { 
0AC2C:  MOVLW  01
0AC2E:  SUBWF  x25,W
0AC30:  CLRF   03
0AC32:  ADDLW  C9
0AC34:  MOVWF  FE9
0AC36:  MOVLW  00
0AC38:  ADDWFC 03,W
0AC3A:  MOVWF  FEA
0AC3C:  MOVF   FEF,W
0AC3E:  SUBLW  3C
0AC40:  BC    AC56
.................... 			rs232_log_output_vol_index[ch-1] = 60; 
0AC42:  MOVLW  01
0AC44:  SUBWF  x25,W
0AC46:  CLRF   03
0AC48:  ADDLW  C9
0AC4A:  MOVWF  FE9
0AC4C:  MOVLW  00
0AC4E:  ADDWFC 03,W
0AC50:  MOVWF  FEA
0AC52:  MOVLW  3C
0AC54:  MOVWF  FEF
.................... 		} 
....................  
.................... 	 
.................... 		if(DEBUG) { 
.................... 			//fprintf(RS232,"Setting log volume for %u to %u which is %.4f\r\n",ch-1,rs232_log_output_vol_index[ch-1],log_values[rs232_log_output_vol_index[ch-1]]); 
.................... 		} 
....................  
.................... 		new_log_value = log_values[rs232_log_output_vol_index[ch-1]]; 
0AC56:  MOVLW  01
0AC58:  SUBWF  x25,W
0AC5A:  CLRF   03
0AC5C:  ADDLW  C9
0AC5E:  MOVWF  FE9
0AC60:  MOVLW  00
0AC62:  ADDWFC 03,W
0AC64:  MOVWF  FEA
0AC66:  MOVF   FEF,W
0AC68:  MULLW  04
0AC6A:  MOVF   FF3,W
0AC6C:  CLRF   03
0AC6E:  ADDLW  D8
0AC70:  MOVWF  FE9
0AC72:  MOVLW  01
0AC74:  ADDWFC 03,W
0AC76:  MOVWF  FEA
0AC78:  MOVFF  FEF,00
0AC7C:  MOVFF  FEC,01
0AC80:  MOVFF  FEC,02
0AC84:  MOVFF  FEC,03
0AC88:  MOVFF  03,82A
0AC8C:  MOVFF  02,829
0AC90:  MOVFF  01,828
0AC94:  MOVFF  00,827
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(new_log_value*2147483648.0)); 
0AC98:  MOVLW  01
0AC9A:  SUBWF  x25,W
0AC9C:  MOVWF  x2C
0AC9E:  MOVWF  x6D
0ACA0:  MOVLB  0
0ACA2:  CALL   7692
0ACA6:  MOVFF  03,82F
0ACAA:  MOVFF  02,82E
0ACAE:  MOVFF  01,82D
0ACB2:  MOVFF  00,82C
0ACB6:  CLRF   19
0ACB8:  BTFSC  FF2.7
0ACBA:  BSF    19.7
0ACBC:  BCF    FF2.7
0ACBE:  MOVFF  82A,8EC
0ACC2:  MOVFF  829,8EB
0ACC6:  MOVFF  828,8EA
0ACCA:  MOVFF  827,8E9
0ACCE:  MOVLB  8
0ACD0:  CLRF   xF0
0ACD2:  CLRF   xEF
0ACD4:  CLRF   xEE
0ACD6:  MOVLW  9E
0ACD8:  MOVWF  xED
0ACDA:  MOVLB  0
0ACDC:  CALL   1230
0ACE0:  BTFSC  19.7
0ACE2:  BSF    FF2.7
0ACE4:  CLRF   19
0ACE6:  BTFSC  FF2.7
0ACE8:  BSF    19.7
0ACEA:  BCF    FF2.7
0ACEC:  MOVFF  03,8BB
0ACF0:  MOVFF  02,8BA
0ACF4:  MOVFF  01,8B9
0ACF8:  MOVFF  00,8B8
0ACFC:  CALL   24C8
0AD00:  BTFSC  19.7
0AD02:  BSF    FF2.7
0AD04:  MOVFF  03,833
0AD08:  MOVFF  02,832
0AD0C:  MOVFF  01,831
0AD10:  MOVFF  00,830
0AD14:  CLRF   19
0AD16:  BTFSC  FF2.7
0AD18:  BSF    19.7
0AD1A:  BCF    FF2.7
0AD1C:  MOVFF  82F,8BF
0AD20:  MOVFF  82E,8BE
0AD24:  MOVFF  82D,8BD
0AD28:  MOVFF  82C,8BC
0AD2C:  MOVFF  03,8C3
0AD30:  MOVFF  02,8C2
0AD34:  MOVFF  01,8C1
0AD38:  MOVFF  00,8C0
0AD3C:  CALL   0DB0
0AD40:  BTFSC  19.7
0AD42:  BSF    FF2.7
....................  
.................... 		return rs232_log_output_vol_index[ch-1]; // They will all be the same. So just return the volume of CH1 
0AD44:  MOVLW  01
0AD46:  MOVLB  8
0AD48:  SUBWF  x25,W
0AD4A:  CLRF   03
0AD4C:  ADDLW  C9
0AD4E:  MOVWF  FE9
0AD50:  MOVLW  00
0AD52:  ADDWFC 03,W
0AD54:  MOVWF  FEA
0AD56:  MOVFF  FEF,01
0AD5A:  MOVLB  0
0AD5C:  BRA    AD5E
.................... 	} 
....................  
.................... } 
0AD5E:  GOTO   BB2A (RETURN)
....................  
.................... int log_volume_down(int ch, int amount) 
.................... { 
0AD62:  MOVLB  8
0AD64:  CLRF   x2A
0AD66:  CLRF   x29
0AD68:  CLRF   x28
0AD6A:  CLRF   x27
....................  
.................... 	double new_log_value = 0; 
....................  
.................... 	if(ch == 0) { 
0AD6C:  MOVF   x25,F
0AD6E:  BTFSS  FD8.2
0AD70:  BRA    AEC0
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0AD72:  CLRF   x2B
0AD74:  MOVF   x2B,W
0AD76:  SUBLW  03
0AD78:  BTFSS  FD8.0
0AD7A:  BRA    AEB4
.................... 			rs232_output_mute[i] = 0; 
0AD7C:  CLRF   03
0AD7E:  MOVF   x2B,W
0AD80:  ADDLW  C5
0AD82:  MOVWF  FE9
0AD84:  MOVLW  00
0AD86:  ADDWFC 03,W
0AD88:  MOVWF  FEA
0AD8A:  CLRF   FEF
....................  
.................... 			if(rs232_log_output_vol_index[i] >= amount) { 
0AD8C:  CLRF   03
0AD8E:  MOVF   x2B,W
0AD90:  ADDLW  C9
0AD92:  MOVWF  FE9
0AD94:  MOVLW  00
0AD96:  ADDWFC 03,W
0AD98:  MOVWF  FEA
0AD9A:  MOVF   x26,W
0AD9C:  SUBWF  FEF,W
0AD9E:  BNC   ADB6
.................... 				rs232_log_output_vol_index[i] -= amount; 
0ADA0:  CLRF   03
0ADA2:  MOVF   x2B,W
0ADA4:  ADDLW  C9
0ADA6:  MOVWF  FE9
0ADA8:  MOVLW  00
0ADAA:  ADDWFC 03,W
0ADAC:  MOVWF  FEA
0ADAE:  MOVF   x26,W
0ADB0:  SUBWF  FEF,W
0ADB2:  MOVWF  FEF
.................... 			} else { 
0ADB4:  BRA    ADC6
.................... 				rs232_log_output_vol_index[i] = 0; 
0ADB6:  CLRF   03
0ADB8:  MOVF   x2B,W
0ADBA:  ADDLW  C9
0ADBC:  MOVWF  FE9
0ADBE:  MOVLW  00
0ADC0:  ADDWFC 03,W
0ADC2:  MOVWF  FEA
0ADC4:  CLRF   FEF
.................... 			} 
.................... 			 
.................... 			 new_log_value = log_values[rs232_log_output_vol_index[i]]; 
0ADC6:  CLRF   03
0ADC8:  MOVF   x2B,W
0ADCA:  ADDLW  C9
0ADCC:  MOVWF  FE9
0ADCE:  MOVLW  00
0ADD0:  ADDWFC 03,W
0ADD2:  MOVWF  FEA
0ADD4:  MOVF   FEF,W
0ADD6:  MULLW  04
0ADD8:  MOVF   FF3,W
0ADDA:  CLRF   03
0ADDC:  ADDLW  D8
0ADDE:  MOVWF  FE9
0ADE0:  MOVLW  01
0ADE2:  ADDWFC 03,W
0ADE4:  MOVWF  FEA
0ADE6:  MOVFF  FEF,00
0ADEA:  MOVFF  FEC,01
0ADEE:  MOVFF  FEC,02
0ADF2:  MOVFF  FEC,03
0ADF6:  MOVFF  03,82A
0ADFA:  MOVFF  02,829
0ADFE:  MOVFF  01,828
0AE02:  MOVFF  00,827
....................  
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(new_log_value*2147483648.0)); 
0AE06:  MOVFF  82B,86D
0AE0A:  MOVLB  0
0AE0C:  CALL   7692
0AE10:  MOVFF  03,82F
0AE14:  MOVFF  02,82E
0AE18:  MOVFF  01,82D
0AE1C:  MOVFF  00,82C
0AE20:  CLRF   19
0AE22:  BTFSC  FF2.7
0AE24:  BSF    19.7
0AE26:  BCF    FF2.7
0AE28:  MOVFF  82A,8EC
0AE2C:  MOVFF  829,8EB
0AE30:  MOVFF  828,8EA
0AE34:  MOVFF  827,8E9
0AE38:  MOVLB  8
0AE3A:  CLRF   xF0
0AE3C:  CLRF   xEF
0AE3E:  CLRF   xEE
0AE40:  MOVLW  9E
0AE42:  MOVWF  xED
0AE44:  MOVLB  0
0AE46:  CALL   1230
0AE4A:  BTFSC  19.7
0AE4C:  BSF    FF2.7
0AE4E:  CLRF   19
0AE50:  BTFSC  FF2.7
0AE52:  BSF    19.7
0AE54:  BCF    FF2.7
0AE56:  MOVFF  03,8BB
0AE5A:  MOVFF  02,8BA
0AE5E:  MOVFF  01,8B9
0AE62:  MOVFF  00,8B8
0AE66:  CALL   24C8
0AE6A:  BTFSC  19.7
0AE6C:  BSF    FF2.7
0AE6E:  MOVFF  03,833
0AE72:  MOVFF  02,832
0AE76:  MOVFF  01,831
0AE7A:  MOVFF  00,830
0AE7E:  CLRF   19
0AE80:  BTFSC  FF2.7
0AE82:  BSF    19.7
0AE84:  BCF    FF2.7
0AE86:  MOVFF  82F,8BF
0AE8A:  MOVFF  82E,8BE
0AE8E:  MOVFF  82D,8BD
0AE92:  MOVFF  82C,8BC
0AE96:  MOVFF  03,8C3
0AE9A:  MOVFF  02,8C2
0AE9E:  MOVFF  01,8C1
0AEA2:  MOVFF  00,8C0
0AEA6:  CALL   0DB0
0AEAA:  BTFSC  19.7
0AEAC:  BSF    FF2.7
.................... 		} 
0AEAE:  MOVLB  8
0AEB0:  INCF   x2B,F
0AEB2:  BRA    AD74
....................  
.................... 		return rs232_log_output_vol_index[0]; // They will all be the same. So just return the volume of CH1 
0AEB4:  MOVLB  0
0AEB6:  MOVFF  C9,01
0AEBA:  BRA    B01A
....................  
.................... 	} else { 
0AEBC:  BRA    B01A
0AEBE:  MOVLB  8
....................  
.................... 		rs232_output_mute[ch-1] = 0; 
0AEC0:  MOVLW  01
0AEC2:  SUBWF  x25,W
0AEC4:  CLRF   03
0AEC6:  ADDLW  C5
0AEC8:  MOVWF  FE9
0AECA:  MOVLW  00
0AECC:  ADDWFC 03,W
0AECE:  MOVWF  FEA
0AED0:  CLRF   FEF
.................... 		 
.................... 		if(rs232_log_output_vol_index[ch-1] >= amount) { 
0AED2:  MOVLW  01
0AED4:  SUBWF  x25,W
0AED6:  CLRF   03
0AED8:  ADDLW  C9
0AEDA:  MOVWF  FE9
0AEDC:  MOVLW  00
0AEDE:  ADDWFC 03,W
0AEE0:  MOVWF  FEA
0AEE2:  MOVF   x26,W
0AEE4:  SUBWF  FEF,W
0AEE6:  BNC   AF00
.................... 			rs232_log_output_vol_index[ch-1] -= amount; 
0AEE8:  MOVLW  01
0AEEA:  SUBWF  x25,W
0AEEC:  CLRF   03
0AEEE:  ADDLW  C9
0AEF0:  MOVWF  FE9
0AEF2:  MOVLW  00
0AEF4:  ADDWFC 03,W
0AEF6:  MOVWF  FEA
0AEF8:  MOVF   x26,W
0AEFA:  SUBWF  FEF,W
0AEFC:  MOVWF  FEF
.................... 		} else { 
0AEFE:  BRA    AF12
.................... 			rs232_log_output_vol_index[ch-1] = 0; 
0AF00:  MOVLW  01
0AF02:  SUBWF  x25,W
0AF04:  CLRF   03
0AF06:  ADDLW  C9
0AF08:  MOVWF  FE9
0AF0A:  MOVLW  00
0AF0C:  ADDWFC 03,W
0AF0E:  MOVWF  FEA
0AF10:  CLRF   FEF
.................... 		} 
....................  
.................... 	 
.................... 		if(DEBUG) { 
.................... 			//fprintf(RS232,"Setting log volume for %u to %u which is %.4f\r\n",ch-1,rs232_log_output_vol_index[ch-1],log_values[rs232_log_output_vol_index[ch-1]]); 
.................... 		} 
....................  
....................  
.................... 		new_log_value = log_values[rs232_log_output_vol_index[ch-1]]; 
0AF12:  MOVLW  01
0AF14:  SUBWF  x25,W
0AF16:  CLRF   03
0AF18:  ADDLW  C9
0AF1A:  MOVWF  FE9
0AF1C:  MOVLW  00
0AF1E:  ADDWFC 03,W
0AF20:  MOVWF  FEA
0AF22:  MOVF   FEF,W
0AF24:  MULLW  04
0AF26:  MOVF   FF3,W
0AF28:  CLRF   03
0AF2A:  ADDLW  D8
0AF2C:  MOVWF  FE9
0AF2E:  MOVLW  01
0AF30:  ADDWFC 03,W
0AF32:  MOVWF  FEA
0AF34:  MOVFF  FEF,00
0AF38:  MOVFF  FEC,01
0AF3C:  MOVFF  FEC,02
0AF40:  MOVFF  FEC,03
0AF44:  MOVFF  03,82A
0AF48:  MOVFF  02,829
0AF4C:  MOVFF  01,828
0AF50:  MOVFF  00,827
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(new_log_value*2147483648.0)); 
0AF54:  MOVLW  01
0AF56:  SUBWF  x25,W
0AF58:  MOVWF  x2C
0AF5A:  MOVWF  x6D
0AF5C:  MOVLB  0
0AF5E:  CALL   7692
0AF62:  MOVFF  03,82F
0AF66:  MOVFF  02,82E
0AF6A:  MOVFF  01,82D
0AF6E:  MOVFF  00,82C
0AF72:  CLRF   19
0AF74:  BTFSC  FF2.7
0AF76:  BSF    19.7
0AF78:  BCF    FF2.7
0AF7A:  MOVFF  82A,8EC
0AF7E:  MOVFF  829,8EB
0AF82:  MOVFF  828,8EA
0AF86:  MOVFF  827,8E9
0AF8A:  MOVLB  8
0AF8C:  CLRF   xF0
0AF8E:  CLRF   xEF
0AF90:  CLRF   xEE
0AF92:  MOVLW  9E
0AF94:  MOVWF  xED
0AF96:  MOVLB  0
0AF98:  CALL   1230
0AF9C:  BTFSC  19.7
0AF9E:  BSF    FF2.7
0AFA0:  CLRF   19
0AFA2:  BTFSC  FF2.7
0AFA4:  BSF    19.7
0AFA6:  BCF    FF2.7
0AFA8:  MOVFF  03,8BB
0AFAC:  MOVFF  02,8BA
0AFB0:  MOVFF  01,8B9
0AFB4:  MOVFF  00,8B8
0AFB8:  CALL   24C8
0AFBC:  BTFSC  19.7
0AFBE:  BSF    FF2.7
0AFC0:  MOVFF  03,833
0AFC4:  MOVFF  02,832
0AFC8:  MOVFF  01,831
0AFCC:  MOVFF  00,830
0AFD0:  CLRF   19
0AFD2:  BTFSC  FF2.7
0AFD4:  BSF    19.7
0AFD6:  BCF    FF2.7
0AFD8:  MOVFF  82F,8BF
0AFDC:  MOVFF  82E,8BE
0AFE0:  MOVFF  82D,8BD
0AFE4:  MOVFF  82C,8BC
0AFE8:  MOVFF  03,8C3
0AFEC:  MOVFF  02,8C2
0AFF0:  MOVFF  01,8C1
0AFF4:  MOVFF  00,8C0
0AFF8:  CALL   0DB0
0AFFC:  BTFSC  19.7
0AFFE:  BSF    FF2.7
....................  
.................... 		return rs232_log_output_vol_index[ch-1]; // They will all be the same. So just return the volume of CH1 
0B000:  MOVLW  01
0B002:  MOVLB  8
0B004:  SUBWF  x25,W
0B006:  CLRF   03
0B008:  ADDLW  C9
0B00A:  MOVWF  FE9
0B00C:  MOVLW  00
0B00E:  ADDWFC 03,W
0B010:  MOVWF  FEA
0B012:  MOVFF  FEF,01
0B016:  MOVLB  0
0B018:  BRA    B01A
.................... 	} 
....................  
.................... } 
0B01A:  GOTO   BB5C (RETURN)
....................  
....................  
.................... double discrete_log_volume(int ch,unsigned int new_vol) 
.................... { 
0B01E:  MOVLB  8
0B020:  CLRF   x2A
0B022:  CLRF   x29
0B024:  CLRF   x28
0B026:  CLRF   x27
.................... 	 
.................... 	// Data has already been checked. 
.................... 	double new_log_value = 0; 
....................  
.................... 	if(ch == 0) { 
0B028:  MOVF   x25,F
0B02A:  BTFSS  FD8.2
0B02C:  BRA    B160
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0B02E:  CLRF   x2B
0B030:  MOVF   x2B,W
0B032:  SUBLW  03
0B034:  BTFSS  FD8.0
0B036:  BRA    B14C
....................  
.................... 			rs232_output_mute[i] = 0; 
0B038:  CLRF   03
0B03A:  MOVF   x2B,W
0B03C:  ADDLW  C5
0B03E:  MOVWF  FE9
0B040:  MOVLW  00
0B042:  ADDWFC 03,W
0B044:  MOVWF  FEA
0B046:  CLRF   FEF
.................... 			rs232_log_output_vol_index[i] = (60 - new_vol); 
0B048:  CLRF   03
0B04A:  MOVF   x2B,W
0B04C:  ADDLW  C9
0B04E:  MOVWF  FE9
0B050:  MOVLW  00
0B052:  ADDWFC 03,W
0B054:  MOVWF  FEA
0B056:  MOVLW  3C
0B058:  BSF    FD8.0
0B05A:  SUBFWB x26,W
0B05C:  MOVWF  FEF
....................  
.................... 			new_log_value = log_values[rs232_log_output_vol_index[i]]; 
0B05E:  CLRF   03
0B060:  MOVF   x2B,W
0B062:  ADDLW  C9
0B064:  MOVWF  FE9
0B066:  MOVLW  00
0B068:  ADDWFC 03,W
0B06A:  MOVWF  FEA
0B06C:  MOVF   FEF,W
0B06E:  MULLW  04
0B070:  MOVF   FF3,W
0B072:  CLRF   03
0B074:  ADDLW  D8
0B076:  MOVWF  FE9
0B078:  MOVLW  01
0B07A:  ADDWFC 03,W
0B07C:  MOVWF  FEA
0B07E:  MOVFF  FEF,00
0B082:  MOVFF  FEC,01
0B086:  MOVFF  FEC,02
0B08A:  MOVFF  FEC,03
0B08E:  MOVFF  03,82A
0B092:  MOVFF  02,829
0B096:  MOVFF  01,828
0B09A:  MOVFF  00,827
....................  
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(new_log_value*2147483648.0)); 
0B09E:  MOVFF  82B,86D
0B0A2:  MOVLB  0
0B0A4:  CALL   7692
0B0A8:  MOVFF  03,82F
0B0AC:  MOVFF  02,82E
0B0B0:  MOVFF  01,82D
0B0B4:  MOVFF  00,82C
0B0B8:  CLRF   19
0B0BA:  BTFSC  FF2.7
0B0BC:  BSF    19.7
0B0BE:  BCF    FF2.7
0B0C0:  MOVFF  82A,8EC
0B0C4:  MOVFF  829,8EB
0B0C8:  MOVFF  828,8EA
0B0CC:  MOVFF  827,8E9
0B0D0:  MOVLB  8
0B0D2:  CLRF   xF0
0B0D4:  CLRF   xEF
0B0D6:  CLRF   xEE
0B0D8:  MOVLW  9E
0B0DA:  MOVWF  xED
0B0DC:  MOVLB  0
0B0DE:  CALL   1230
0B0E2:  BTFSC  19.7
0B0E4:  BSF    FF2.7
0B0E6:  CLRF   19
0B0E8:  BTFSC  FF2.7
0B0EA:  BSF    19.7
0B0EC:  BCF    FF2.7
0B0EE:  MOVFF  03,8BB
0B0F2:  MOVFF  02,8BA
0B0F6:  MOVFF  01,8B9
0B0FA:  MOVFF  00,8B8
0B0FE:  CALL   24C8
0B102:  BTFSC  19.7
0B104:  BSF    FF2.7
0B106:  MOVFF  03,833
0B10A:  MOVFF  02,832
0B10E:  MOVFF  01,831
0B112:  MOVFF  00,830
0B116:  CLRF   19
0B118:  BTFSC  FF2.7
0B11A:  BSF    19.7
0B11C:  BCF    FF2.7
0B11E:  MOVFF  82F,8BF
0B122:  MOVFF  82E,8BE
0B126:  MOVFF  82D,8BD
0B12A:  MOVFF  82C,8BC
0B12E:  MOVFF  03,8C3
0B132:  MOVFF  02,8C2
0B136:  MOVFF  01,8C1
0B13A:  MOVFF  00,8C0
0B13E:  CALL   0DB0
0B142:  BTFSC  19.7
0B144:  BSF    FF2.7
.................... 		} 
0B146:  MOVLB  8
0B148:  INCF   x2B,F
0B14A:  BRA    B030
....................  
.................... 		return rs232_output_vol[0]; // They will all be the same. So just return the volume of CH1 
0B14C:  MOVFF  B5,00
0B150:  MOVFF  B6,01
0B154:  MOVFF  B7,02
0B158:  MOVFF  B8,03
0B15C:  BRA    B34E
.................... 	} else { 
0B15E:  BRA    B34E
....................  
.................... 			rs232_output_mute[ch-1] = 0; 
0B160:  MOVLW  01
0B162:  SUBWF  x25,W
0B164:  CLRF   03
0B166:  ADDLW  C5
0B168:  MOVWF  FE9
0B16A:  MOVLW  00
0B16C:  ADDWFC 03,W
0B16E:  MOVWF  FEA
0B170:  CLRF   FEF
.................... 			rs232_log_output_vol_index[ch-1] = (60 - new_vol); 
0B172:  MOVLW  01
0B174:  SUBWF  x25,W
0B176:  CLRF   03
0B178:  ADDLW  C9
0B17A:  MOVWF  FE9
0B17C:  MOVLW  00
0B17E:  ADDWFC 03,W
0B180:  MOVWF  FEA
0B182:  MOVLW  3C
0B184:  BSF    FD8.0
0B186:  SUBFWB x26,W
0B188:  MOVWF  FEF
....................  
.................... 			new_log_value = log_values[rs232_log_output_vol_index[ch-1]]; 
0B18A:  MOVLW  01
0B18C:  SUBWF  x25,W
0B18E:  CLRF   03
0B190:  ADDLW  C9
0B192:  MOVWF  FE9
0B194:  MOVLW  00
0B196:  ADDWFC 03,W
0B198:  MOVWF  FEA
0B19A:  MOVF   FEF,W
0B19C:  MULLW  04
0B19E:  MOVF   FF3,W
0B1A0:  CLRF   03
0B1A2:  ADDLW  D8
0B1A4:  MOVWF  FE9
0B1A6:  MOVLW  01
0B1A8:  ADDWFC 03,W
0B1AA:  MOVWF  FEA
0B1AC:  MOVFF  FEF,00
0B1B0:  MOVFF  FEC,01
0B1B4:  MOVFF  FEC,02
0B1B8:  MOVFF  FEC,03
0B1BC:  MOVFF  03,82A
0B1C0:  MOVFF  02,829
0B1C4:  MOVFF  01,828
0B1C8:  MOVFF  00,827
....................  
.................... 			send_dsp_command(get_AM_trim_channel(ch-1),(int32)(new_log_value*2147483648.0)); 
0B1CC:  MOVLW  01
0B1CE:  SUBWF  x25,W
0B1D0:  MOVWF  x2C
0B1D2:  MOVWF  x6D
0B1D4:  MOVLB  0
0B1D6:  CALL   7692
0B1DA:  MOVFF  03,82F
0B1DE:  MOVFF  02,82E
0B1E2:  MOVFF  01,82D
0B1E6:  MOVFF  00,82C
0B1EA:  CLRF   19
0B1EC:  BTFSC  FF2.7
0B1EE:  BSF    19.7
0B1F0:  BCF    FF2.7
0B1F2:  MOVFF  82A,8EC
0B1F6:  MOVFF  829,8EB
0B1FA:  MOVFF  828,8EA
0B1FE:  MOVFF  827,8E9
0B202:  MOVLB  8
0B204:  CLRF   xF0
0B206:  CLRF   xEF
0B208:  CLRF   xEE
0B20A:  MOVLW  9E
0B20C:  MOVWF  xED
0B20E:  MOVLB  0
0B210:  CALL   1230
0B214:  BTFSC  19.7
0B216:  BSF    FF2.7
0B218:  CLRF   19
0B21A:  BTFSC  FF2.7
0B21C:  BSF    19.7
0B21E:  BCF    FF2.7
0B220:  MOVFF  03,8BB
0B224:  MOVFF  02,8BA
0B228:  MOVFF  01,8B9
0B22C:  MOVFF  00,8B8
0B230:  CALL   24C8
0B234:  BTFSC  19.7
0B236:  BSF    FF2.7
0B238:  MOVFF  03,833
0B23C:  MOVFF  02,832
0B240:  MOVFF  01,831
0B244:  MOVFF  00,830
0B248:  CLRF   19
0B24A:  BTFSC  FF2.7
0B24C:  BSF    19.7
0B24E:  BCF    FF2.7
0B250:  MOVFF  82F,8BF
0B254:  MOVFF  82E,8BE
0B258:  MOVFF  82D,8BD
0B25C:  MOVFF  82C,8BC
0B260:  MOVFF  03,8C3
0B264:  MOVFF  02,8C2
0B268:  MOVFF  01,8C1
0B26C:  MOVFF  00,8C0
0B270:  CALL   0DB0
0B274:  BTFSC  19.7
0B276:  BSF    FF2.7
.................... 	 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete log volume for %u to %u which is %.4f\r\n",ch-1,rs232_log_output_vol_index[ch-1],log_values[rs232_log_output_vol_index[ch-1]]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(new_log_value*2147483648.0)); 
0B278:  MOVLW  01
0B27A:  MOVLB  8
0B27C:  SUBWF  x25,W
0B27E:  MOVWF  x2C
0B280:  MOVWF  x6D
0B282:  MOVLB  0
0B284:  CALL   7692
0B288:  MOVFF  03,82F
0B28C:  MOVFF  02,82E
0B290:  MOVFF  01,82D
0B294:  MOVFF  00,82C
0B298:  CLRF   19
0B29A:  BTFSC  FF2.7
0B29C:  BSF    19.7
0B29E:  BCF    FF2.7
0B2A0:  MOVFF  82A,8EC
0B2A4:  MOVFF  829,8EB
0B2A8:  MOVFF  828,8EA
0B2AC:  MOVFF  827,8E9
0B2B0:  MOVLB  8
0B2B2:  CLRF   xF0
0B2B4:  CLRF   xEF
0B2B6:  CLRF   xEE
0B2B8:  MOVLW  9E
0B2BA:  MOVWF  xED
0B2BC:  MOVLB  0
0B2BE:  CALL   1230
0B2C2:  BTFSC  19.7
0B2C4:  BSF    FF2.7
0B2C6:  CLRF   19
0B2C8:  BTFSC  FF2.7
0B2CA:  BSF    19.7
0B2CC:  BCF    FF2.7
0B2CE:  MOVFF  03,8BB
0B2D2:  MOVFF  02,8BA
0B2D6:  MOVFF  01,8B9
0B2DA:  MOVFF  00,8B8
0B2DE:  CALL   24C8
0B2E2:  BTFSC  19.7
0B2E4:  BSF    FF2.7
0B2E6:  MOVFF  03,833
0B2EA:  MOVFF  02,832
0B2EE:  MOVFF  01,831
0B2F2:  MOVFF  00,830
0B2F6:  CLRF   19
0B2F8:  BTFSC  FF2.7
0B2FA:  BSF    19.7
0B2FC:  BCF    FF2.7
0B2FE:  MOVFF  82F,8BF
0B302:  MOVFF  82E,8BE
0B306:  MOVFF  82D,8BD
0B30A:  MOVFF  82C,8BC
0B30E:  MOVFF  03,8C3
0B312:  MOVFF  02,8C2
0B316:  MOVFF  01,8C1
0B31A:  MOVFF  00,8C0
0B31E:  CALL   0DB0
0B322:  BTFSC  19.7
0B324:  BSF    FF2.7
....................  
.................... 		return rs232_output_vol[ch-1]; // They will all be the same. So just return the volume of CH1 
0B326:  MOVLW  01
0B328:  MOVLB  8
0B32A:  SUBWF  x25,W
0B32C:  MULLW  04
0B32E:  MOVF   FF3,W
0B330:  CLRF   03
0B332:  ADDLW  B5
0B334:  MOVWF  FE9
0B336:  MOVLW  00
0B338:  ADDWFC 03,W
0B33A:  MOVWF  FEA
0B33C:  MOVFF  FEF,00
0B340:  MOVFF  FEC,01
0B344:  MOVFF  FEC,02
0B348:  MOVFF  FEC,03
0B34C:  BRA    B34E
.................... 	} 
.................... 	 
.................... } 
0B34E:  MOVLB  0
0B350:  GOTO   BBC2 (RETURN)
....................  
....................  
....................  
.................... double vol_big_up_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
*
098B8:  MOVLB  8
098BA:  MOVF   x25,F
098BC:  BTFSS  FD8.2
098BE:  BRA    9A94
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
098C0:  CLRF   x26
098C2:  MOVF   x26,W
098C4:  SUBLW  03
098C6:  BTFSS  FD8.0
098C8:  BRA    9A80
.................... 			rs232_output_mute[i] = 0; 
098CA:  CLRF   03
098CC:  MOVF   x26,W
098CE:  ADDLW  C5
098D0:  MOVWF  FE9
098D2:  MOVLW  00
098D4:  ADDWFC 03,W
098D6:  MOVWF  FEA
098D8:  CLRF   FEF
.................... 			rs232_output_vol[i] += 0.1; 
098DA:  MOVF   x26,W
098DC:  MULLW  04
098DE:  MOVF   FF3,W
098E0:  CLRF   03
098E2:  ADDLW  B5
098E4:  MOVWF  FE9
098E6:  MOVLW  00
098E8:  ADDWFC 03,W
098EA:  MOVWF  FEA
098EC:  MOVFF  FEA,82E
098F0:  MOVFF  FE9,82D
098F4:  BCF    FD8.1
098F6:  CLRF   19
098F8:  BTFSC  FF2.7
098FA:  BSF    19.7
098FC:  BCF    FF2.7
098FE:  MOVFF  FEF,8ED
09902:  MOVFF  FEC,8EE
09906:  MOVFF  FEC,8EF
0990A:  MOVFF  FEC,8F0
0990E:  MOVLW  CD
09910:  MOVWF  xF4
09912:  MOVLW  CC
09914:  MOVWF  xF3
09916:  MOVLW  4C
09918:  MOVWF  xF2
0991A:  MOVLW  7B
0991C:  MOVWF  xF1
0991E:  MOVLB  0
09920:  CALL   0E5A
09924:  BTFSC  19.7
09926:  BSF    FF2.7
09928:  MOVFF  82E,FEA
0992C:  MOVFF  82D,FE9
09930:  MOVFF  00,FEF
09934:  MOVFF  01,FEC
09938:  MOVFF  02,FEC
0993C:  MOVFF  03,FEC
.................... 			if(rs232_output_vol[i] > 1) { 
09940:  MOVLB  8
09942:  MOVF   x26,W
09944:  MULLW  04
09946:  MOVF   FF3,W
09948:  CLRF   03
0994A:  ADDLW  B5
0994C:  MOVWF  FE9
0994E:  MOVLW  00
09950:  ADDWFC 03,W
09952:  MOVWF  FEA
09954:  MOVFF  FEF,827
09958:  MOVFF  FEC,828
0995C:  MOVFF  FEC,829
09960:  MOVFF  FEC,82A
09964:  CLRF   19
09966:  BTFSC  FF2.7
09968:  BSF    19.7
0996A:  BCF    FF2.7
0996C:  CLRF   xEC
0996E:  CLRF   xEB
09970:  CLRF   xEA
09972:  MOVLW  7F
09974:  MOVWF  xE9
09976:  MOVFF  82A,8F0
0997A:  MOVFF  829,8EF
0997E:  MOVFF  828,8EE
09982:  MOVFF  827,8ED
09986:  MOVLB  0
09988:  CALL   1326
0998C:  BTFSC  19.7
0998E:  BSF    FF2.7
09990:  BNC   99B2
.................... 				rs232_output_vol[i] = 1; 
09992:  MOVLB  8
09994:  MOVF   x26,W
09996:  MULLW  04
09998:  MOVF   FF3,W
0999A:  CLRF   03
0999C:  ADDLW  B5
0999E:  MOVWF  FE9
099A0:  MOVLW  00
099A2:  ADDWFC 03,W
099A4:  MOVWF  FEA
099A6:  MOVLW  7F
099A8:  MOVWF  FEF
099AA:  CLRF   FEC
099AC:  CLRF   FEC
099AE:  CLRF   FEC
099B0:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
099B2:  MOVFF  826,86D
099B6:  CALL   7692
099BA:  MOVFF  03,82A
099BE:  MOVFF  02,829
099C2:  MOVFF  01,828
099C6:  MOVFF  00,827
099CA:  MOVLB  8
099CC:  MOVF   x26,W
099CE:  MULLW  04
099D0:  MOVF   FF3,W
099D2:  CLRF   03
099D4:  ADDLW  B5
099D6:  MOVWF  FE9
099D8:  MOVLW  00
099DA:  ADDWFC 03,W
099DC:  MOVWF  FEA
099DE:  MOVFF  FEF,82B
099E2:  MOVFF  FEC,82C
099E6:  MOVFF  FEC,82D
099EA:  MOVFF  FEC,82E
099EE:  CLRF   19
099F0:  BTFSC  FF2.7
099F2:  BSF    19.7
099F4:  BCF    FF2.7
099F6:  MOVFF  82E,8EC
099FA:  MOVFF  82D,8EB
099FE:  MOVFF  82C,8EA
09A02:  MOVFF  82B,8E9
09A06:  CLRF   xF0
09A08:  CLRF   xEF
09A0A:  CLRF   xEE
09A0C:  MOVLW  9E
09A0E:  MOVWF  xED
09A10:  MOVLB  0
09A12:  CALL   1230
09A16:  BTFSC  19.7
09A18:  BSF    FF2.7
09A1A:  CLRF   19
09A1C:  BTFSC  FF2.7
09A1E:  BSF    19.7
09A20:  BCF    FF2.7
09A22:  MOVFF  03,8BB
09A26:  MOVFF  02,8BA
09A2A:  MOVFF  01,8B9
09A2E:  MOVFF  00,8B8
09A32:  CALL   24C8
09A36:  BTFSC  19.7
09A38:  BSF    FF2.7
09A3A:  MOVFF  03,82E
09A3E:  MOVFF  02,82D
09A42:  MOVFF  01,82C
09A46:  MOVFF  00,82B
09A4A:  CLRF   19
09A4C:  BTFSC  FF2.7
09A4E:  BSF    19.7
09A50:  BCF    FF2.7
09A52:  MOVFF  82A,8BF
09A56:  MOVFF  829,8BE
09A5A:  MOVFF  828,8BD
09A5E:  MOVFF  827,8BC
09A62:  MOVFF  03,8C3
09A66:  MOVFF  02,8C2
09A6A:  MOVFF  01,8C1
09A6E:  MOVFF  00,8C0
09A72:  CALL   0DB0
09A76:  BTFSC  19.7
09A78:  BSF    FF2.7
.................... 		} 
09A7A:  MOVLB  8
09A7C:  INCF   x26,F
09A7E:  BRA    98C2
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
09A80:  MOVFF  B5,00
09A84:  MOVFF  B6,01
09A88:  MOVFF  B7,02
09A8C:  MOVFF  B8,03
09A90:  BRA    9C7E
....................  
.................... 	} else { 
09A92:  BRA    9C7E
.................... 		rs232_output_mute[(ch-1)] = 0; 
09A94:  MOVLW  01
09A96:  SUBWF  x25,W
09A98:  CLRF   03
09A9A:  ADDLW  C5
09A9C:  MOVWF  FE9
09A9E:  MOVLW  00
09AA0:  ADDWFC 03,W
09AA2:  MOVWF  FEA
09AA4:  CLRF   FEF
.................... 		rs232_output_vol[(ch-1)] += 0.1; // TODO - Change this to be a variable 
09AA6:  MOVLW  01
09AA8:  SUBWF  x25,W
09AAA:  MULLW  04
09AAC:  MOVF   FF3,W
09AAE:  CLRF   03
09AB0:  ADDLW  B5
09AB2:  MOVWF  FE9
09AB4:  MOVLW  00
09AB6:  ADDWFC 03,W
09AB8:  MOVWF  FEA
09ABA:  MOVFF  FEA,82E
09ABE:  MOVFF  FE9,82D
09AC2:  BCF    FD8.1
09AC4:  CLRF   19
09AC6:  BTFSC  FF2.7
09AC8:  BSF    19.7
09ACA:  BCF    FF2.7
09ACC:  MOVFF  FEF,8ED
09AD0:  MOVFF  FEC,8EE
09AD4:  MOVFF  FEC,8EF
09AD8:  MOVFF  FEC,8F0
09ADC:  MOVLW  CD
09ADE:  MOVWF  xF4
09AE0:  MOVLW  CC
09AE2:  MOVWF  xF3
09AE4:  MOVLW  4C
09AE6:  MOVWF  xF2
09AE8:  MOVLW  7B
09AEA:  MOVWF  xF1
09AEC:  MOVLB  0
09AEE:  CALL   0E5A
09AF2:  BTFSC  19.7
09AF4:  BSF    FF2.7
09AF6:  MOVFF  82E,FEA
09AFA:  MOVFF  82D,FE9
09AFE:  MOVFF  00,FEF
09B02:  MOVFF  01,FEC
09B06:  MOVFF  02,FEC
09B0A:  MOVFF  03,FEC
.................... 		if(rs232_output_vol[(ch-1)] > 1) { 
09B0E:  MOVLW  01
09B10:  MOVLB  8
09B12:  SUBWF  x25,W
09B14:  MULLW  04
09B16:  MOVF   FF3,W
09B18:  CLRF   03
09B1A:  ADDLW  B5
09B1C:  MOVWF  FE9
09B1E:  MOVLW  00
09B20:  ADDWFC 03,W
09B22:  MOVWF  FEA
09B24:  MOVFF  FEF,827
09B28:  MOVFF  FEC,828
09B2C:  MOVFF  FEC,829
09B30:  MOVFF  FEC,82A
09B34:  CLRF   19
09B36:  BTFSC  FF2.7
09B38:  BSF    19.7
09B3A:  BCF    FF2.7
09B3C:  CLRF   xEC
09B3E:  CLRF   xEB
09B40:  CLRF   xEA
09B42:  MOVLW  7F
09B44:  MOVWF  xE9
09B46:  MOVFF  82A,8F0
09B4A:  MOVFF  829,8EF
09B4E:  MOVFF  828,8EE
09B52:  MOVFF  827,8ED
09B56:  MOVLB  0
09B58:  CALL   1326
09B5C:  BTFSC  19.7
09B5E:  BSF    FF2.7
09B60:  BNC   9B84
.................... 			rs232_output_vol[(ch-1)] = 1; 
09B62:  MOVLW  01
09B64:  MOVLB  8
09B66:  SUBWF  x25,W
09B68:  MULLW  04
09B6A:  MOVF   FF3,W
09B6C:  CLRF   03
09B6E:  ADDLW  B5
09B70:  MOVWF  FE9
09B72:  MOVLW  00
09B74:  ADDWFC 03,W
09B76:  MOVWF  FEA
09B78:  MOVLW  7F
09B7A:  MOVWF  FEF
09B7C:  CLRF   FEC
09B7E:  CLRF   FEC
09B80:  CLRF   FEC
09B82:  MOVLB  0
.................... 		} 
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
09B84:  MOVLW  01
09B86:  MOVLB  8
09B88:  SUBWF  x25,W
09B8A:  MOVWF  x27
09B8C:  MOVWF  x6D
09B8E:  MOVLB  0
09B90:  CALL   7692
09B94:  MOVFF  03,82A
09B98:  MOVFF  02,829
09B9C:  MOVFF  01,828
09BA0:  MOVFF  00,827
09BA4:  MOVLW  01
09BA6:  MOVLB  8
09BA8:  SUBWF  x25,W
09BAA:  MULLW  04
09BAC:  MOVF   FF3,W
09BAE:  CLRF   03
09BB0:  ADDLW  B5
09BB2:  MOVWF  FE9
09BB4:  MOVLW  00
09BB6:  ADDWFC 03,W
09BB8:  MOVWF  FEA
09BBA:  MOVFF  FEF,82B
09BBE:  MOVFF  FEC,82C
09BC2:  MOVFF  FEC,82D
09BC6:  MOVFF  FEC,82E
09BCA:  CLRF   19
09BCC:  BTFSC  FF2.7
09BCE:  BSF    19.7
09BD0:  BCF    FF2.7
09BD2:  MOVFF  82E,8EC
09BD6:  MOVFF  82D,8EB
09BDA:  MOVFF  82C,8EA
09BDE:  MOVFF  82B,8E9
09BE2:  CLRF   xF0
09BE4:  CLRF   xEF
09BE6:  CLRF   xEE
09BE8:  MOVLW  9E
09BEA:  MOVWF  xED
09BEC:  MOVLB  0
09BEE:  CALL   1230
09BF2:  BTFSC  19.7
09BF4:  BSF    FF2.7
09BF6:  CLRF   19
09BF8:  BTFSC  FF2.7
09BFA:  BSF    19.7
09BFC:  BCF    FF2.7
09BFE:  MOVFF  03,8BB
09C02:  MOVFF  02,8BA
09C06:  MOVFF  01,8B9
09C0A:  MOVFF  00,8B8
09C0E:  CALL   24C8
09C12:  BTFSC  19.7
09C14:  BSF    FF2.7
09C16:  MOVFF  03,82E
09C1A:  MOVFF  02,82D
09C1E:  MOVFF  01,82C
09C22:  MOVFF  00,82B
09C26:  CLRF   19
09C28:  BTFSC  FF2.7
09C2A:  BSF    19.7
09C2C:  BCF    FF2.7
09C2E:  MOVFF  82A,8BF
09C32:  MOVFF  829,8BE
09C36:  MOVFF  828,8BD
09C3A:  MOVFF  827,8BC
09C3E:  MOVFF  03,8C3
09C42:  MOVFF  02,8C2
09C46:  MOVFF  01,8C1
09C4A:  MOVFF  00,8C0
09C4E:  CALL   0DB0
09C52:  BTFSC  19.7
09C54:  BSF    FF2.7
....................  
.................... 		return rs232_output_vol[(ch-1)]; 
09C56:  MOVLW  01
09C58:  MOVLB  8
09C5A:  SUBWF  x25,W
09C5C:  MULLW  04
09C5E:  MOVF   FF3,W
09C60:  CLRF   03
09C62:  ADDLW  B5
09C64:  MOVWF  FE9
09C66:  MOVLW  00
09C68:  ADDWFC 03,W
09C6A:  MOVWF  FEA
09C6C:  MOVFF  FEF,00
09C70:  MOVFF  FEC,01
09C74:  MOVFF  FEC,02
09C78:  MOVFF  FEC,03
09C7C:  BRA    9C7E
.................... 	} 
.................... } 
09C7E:  MOVLB  0
09C80:  GOTO   B46C (RETURN)
....................  
.................... double vol_small_up_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
09C84:  MOVLB  8
09C86:  MOVF   x25,F
09C88:  BTFSS  FD8.2
09C8A:  BRA    9E60
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
09C8C:  CLRF   x26
09C8E:  MOVF   x26,W
09C90:  SUBLW  03
09C92:  BTFSS  FD8.0
09C94:  BRA    9E4C
.................... 			rs232_output_mute[i] = 0; 
09C96:  CLRF   03
09C98:  MOVF   x26,W
09C9A:  ADDLW  C5
09C9C:  MOVWF  FE9
09C9E:  MOVLW  00
09CA0:  ADDWFC 03,W
09CA2:  MOVWF  FEA
09CA4:  CLRF   FEF
.................... 			rs232_output_vol[i] += 0.05; // TODO - Change this to be a variable 
09CA6:  MOVF   x26,W
09CA8:  MULLW  04
09CAA:  MOVF   FF3,W
09CAC:  CLRF   03
09CAE:  ADDLW  B5
09CB0:  MOVWF  FE9
09CB2:  MOVLW  00
09CB4:  ADDWFC 03,W
09CB6:  MOVWF  FEA
09CB8:  MOVFF  FEA,82E
09CBC:  MOVFF  FE9,82D
09CC0:  BCF    FD8.1
09CC2:  CLRF   19
09CC4:  BTFSC  FF2.7
09CC6:  BSF    19.7
09CC8:  BCF    FF2.7
09CCA:  MOVFF  FEF,8ED
09CCE:  MOVFF  FEC,8EE
09CD2:  MOVFF  FEC,8EF
09CD6:  MOVFF  FEC,8F0
09CDA:  MOVLW  CD
09CDC:  MOVWF  xF4
09CDE:  MOVLW  CC
09CE0:  MOVWF  xF3
09CE2:  MOVLW  4C
09CE4:  MOVWF  xF2
09CE6:  MOVLW  7A
09CE8:  MOVWF  xF1
09CEA:  MOVLB  0
09CEC:  CALL   0E5A
09CF0:  BTFSC  19.7
09CF2:  BSF    FF2.7
09CF4:  MOVFF  82E,FEA
09CF8:  MOVFF  82D,FE9
09CFC:  MOVFF  00,FEF
09D00:  MOVFF  01,FEC
09D04:  MOVFF  02,FEC
09D08:  MOVFF  03,FEC
.................... 			if(rs232_output_vol[i] > 1) { 
09D0C:  MOVLB  8
09D0E:  MOVF   x26,W
09D10:  MULLW  04
09D12:  MOVF   FF3,W
09D14:  CLRF   03
09D16:  ADDLW  B5
09D18:  MOVWF  FE9
09D1A:  MOVLW  00
09D1C:  ADDWFC 03,W
09D1E:  MOVWF  FEA
09D20:  MOVFF  FEF,827
09D24:  MOVFF  FEC,828
09D28:  MOVFF  FEC,829
09D2C:  MOVFF  FEC,82A
09D30:  CLRF   19
09D32:  BTFSC  FF2.7
09D34:  BSF    19.7
09D36:  BCF    FF2.7
09D38:  CLRF   xEC
09D3A:  CLRF   xEB
09D3C:  CLRF   xEA
09D3E:  MOVLW  7F
09D40:  MOVWF  xE9
09D42:  MOVFF  82A,8F0
09D46:  MOVFF  829,8EF
09D4A:  MOVFF  828,8EE
09D4E:  MOVFF  827,8ED
09D52:  MOVLB  0
09D54:  CALL   1326
09D58:  BTFSC  19.7
09D5A:  BSF    FF2.7
09D5C:  BNC   9D7E
.................... 				rs232_output_vol[i] = 1; 
09D5E:  MOVLB  8
09D60:  MOVF   x26,W
09D62:  MULLW  04
09D64:  MOVF   FF3,W
09D66:  CLRF   03
09D68:  ADDLW  B5
09D6A:  MOVWF  FE9
09D6C:  MOVLW  00
09D6E:  ADDWFC 03,W
09D70:  MOVWF  FEA
09D72:  MOVLW  7F
09D74:  MOVWF  FEF
09D76:  CLRF   FEC
09D78:  CLRF   FEC
09D7A:  CLRF   FEC
09D7C:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
09D7E:  MOVFF  826,86D
09D82:  CALL   7692
09D86:  MOVFF  03,82A
09D8A:  MOVFF  02,829
09D8E:  MOVFF  01,828
09D92:  MOVFF  00,827
09D96:  MOVLB  8
09D98:  MOVF   x26,W
09D9A:  MULLW  04
09D9C:  MOVF   FF3,W
09D9E:  CLRF   03
09DA0:  ADDLW  B5
09DA2:  MOVWF  FE9
09DA4:  MOVLW  00
09DA6:  ADDWFC 03,W
09DA8:  MOVWF  FEA
09DAA:  MOVFF  FEF,82B
09DAE:  MOVFF  FEC,82C
09DB2:  MOVFF  FEC,82D
09DB6:  MOVFF  FEC,82E
09DBA:  CLRF   19
09DBC:  BTFSC  FF2.7
09DBE:  BSF    19.7
09DC0:  BCF    FF2.7
09DC2:  MOVFF  82E,8EC
09DC6:  MOVFF  82D,8EB
09DCA:  MOVFF  82C,8EA
09DCE:  MOVFF  82B,8E9
09DD2:  CLRF   xF0
09DD4:  CLRF   xEF
09DD6:  CLRF   xEE
09DD8:  MOVLW  9E
09DDA:  MOVWF  xED
09DDC:  MOVLB  0
09DDE:  CALL   1230
09DE2:  BTFSC  19.7
09DE4:  BSF    FF2.7
09DE6:  CLRF   19
09DE8:  BTFSC  FF2.7
09DEA:  BSF    19.7
09DEC:  BCF    FF2.7
09DEE:  MOVFF  03,8BB
09DF2:  MOVFF  02,8BA
09DF6:  MOVFF  01,8B9
09DFA:  MOVFF  00,8B8
09DFE:  CALL   24C8
09E02:  BTFSC  19.7
09E04:  BSF    FF2.7
09E06:  MOVFF  03,82E
09E0A:  MOVFF  02,82D
09E0E:  MOVFF  01,82C
09E12:  MOVFF  00,82B
09E16:  CLRF   19
09E18:  BTFSC  FF2.7
09E1A:  BSF    19.7
09E1C:  BCF    FF2.7
09E1E:  MOVFF  82A,8BF
09E22:  MOVFF  829,8BE
09E26:  MOVFF  828,8BD
09E2A:  MOVFF  827,8BC
09E2E:  MOVFF  03,8C3
09E32:  MOVFF  02,8C2
09E36:  MOVFF  01,8C1
09E3A:  MOVFF  00,8C0
09E3E:  CALL   0DB0
09E42:  BTFSC  19.7
09E44:  BSF    FF2.7
.................... 		} 
09E46:  MOVLB  8
09E48:  INCF   x26,F
09E4A:  BRA    9C8E
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
09E4C:  MOVFF  B5,00
09E50:  MOVFF  B6,01
09E54:  MOVFF  B7,02
09E58:  MOVFF  B8,03
09E5C:  BRA    A048
....................  
.................... 	} else { 
09E5E:  BRA    A048
.................... 		 
.................... 		rs232_output_mute[(ch-1)] = 0; 
09E60:  MOVLW  01
09E62:  SUBWF  x25,W
09E64:  CLRF   03
09E66:  ADDLW  C5
09E68:  MOVWF  FE9
09E6A:  MOVLW  00
09E6C:  ADDWFC 03,W
09E6E:  MOVWF  FEA
09E70:  CLRF   FEF
.................... 		rs232_output_vol[(ch-1)] += 0.05; 
09E72:  MOVLW  01
09E74:  SUBWF  x25,W
09E76:  MULLW  04
09E78:  MOVF   FF3,W
09E7A:  CLRF   03
09E7C:  ADDLW  B5
09E7E:  MOVWF  FE9
09E80:  MOVLW  00
09E82:  ADDWFC 03,W
09E84:  MOVWF  FEA
09E86:  MOVFF  FEA,82E
09E8A:  MOVFF  FE9,82D
09E8E:  BCF    FD8.1
09E90:  CLRF   19
09E92:  BTFSC  FF2.7
09E94:  BSF    19.7
09E96:  BCF    FF2.7
09E98:  MOVFF  FEF,8ED
09E9C:  MOVFF  FEC,8EE
09EA0:  MOVFF  FEC,8EF
09EA4:  MOVFF  FEC,8F0
09EA8:  MOVLW  CD
09EAA:  MOVWF  xF4
09EAC:  MOVLW  CC
09EAE:  MOVWF  xF3
09EB0:  MOVLW  4C
09EB2:  MOVWF  xF2
09EB4:  MOVLW  7A
09EB6:  MOVWF  xF1
09EB8:  MOVLB  0
09EBA:  CALL   0E5A
09EBE:  BTFSC  19.7
09EC0:  BSF    FF2.7
09EC2:  MOVFF  82E,FEA
09EC6:  MOVFF  82D,FE9
09ECA:  MOVFF  00,FEF
09ECE:  MOVFF  01,FEC
09ED2:  MOVFF  02,FEC
09ED6:  MOVFF  03,FEC
.................... 		if(rs232_output_vol[(ch-1)] > 1) { 
09EDA:  MOVLW  01
09EDC:  MOVLB  8
09EDE:  SUBWF  x25,W
09EE0:  MULLW  04
09EE2:  MOVF   FF3,W
09EE4:  CLRF   03
09EE6:  ADDLW  B5
09EE8:  MOVWF  FE9
09EEA:  MOVLW  00
09EEC:  ADDWFC 03,W
09EEE:  MOVWF  FEA
09EF0:  MOVFF  FEF,827
09EF4:  MOVFF  FEC,828
09EF8:  MOVFF  FEC,829
09EFC:  MOVFF  FEC,82A
09F00:  CLRF   19
09F02:  BTFSC  FF2.7
09F04:  BSF    19.7
09F06:  BCF    FF2.7
09F08:  CLRF   xEC
09F0A:  CLRF   xEB
09F0C:  CLRF   xEA
09F0E:  MOVLW  7F
09F10:  MOVWF  xE9
09F12:  MOVFF  82A,8F0
09F16:  MOVFF  829,8EF
09F1A:  MOVFF  828,8EE
09F1E:  MOVFF  827,8ED
09F22:  MOVLB  0
09F24:  CALL   1326
09F28:  BTFSC  19.7
09F2A:  BSF    FF2.7
09F2C:  BNC   9F4E
.................... 			rs232_output_vol[(ch-1)] = 1; 
09F2E:  MOVLW  01
09F30:  MOVLB  8
09F32:  SUBWF  x25,W
09F34:  MULLW  04
09F36:  MOVF   FF3,W
09F38:  CLRF   03
09F3A:  ADDLW  B5
09F3C:  MOVWF  FE9
09F3E:  MOVLW  00
09F40:  ADDWFC 03,W
09F42:  MOVWF  FEA
09F44:  MOVLW  7F
09F46:  MOVWF  FEF
09F48:  CLRF   FEC
09F4A:  CLRF   FEC
09F4C:  CLRF   FEC
.................... 		} 
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
09F4E:  MOVLW  01
09F50:  MOVLB  8
09F52:  SUBWF  x25,W
09F54:  MOVWF  x27
09F56:  MOVWF  x6D
09F58:  MOVLB  0
09F5A:  CALL   7692
09F5E:  MOVFF  03,82A
09F62:  MOVFF  02,829
09F66:  MOVFF  01,828
09F6A:  MOVFF  00,827
09F6E:  MOVLW  01
09F70:  MOVLB  8
09F72:  SUBWF  x25,W
09F74:  MULLW  04
09F76:  MOVF   FF3,W
09F78:  CLRF   03
09F7A:  ADDLW  B5
09F7C:  MOVWF  FE9
09F7E:  MOVLW  00
09F80:  ADDWFC 03,W
09F82:  MOVWF  FEA
09F84:  MOVFF  FEF,82B
09F88:  MOVFF  FEC,82C
09F8C:  MOVFF  FEC,82D
09F90:  MOVFF  FEC,82E
09F94:  CLRF   19
09F96:  BTFSC  FF2.7
09F98:  BSF    19.7
09F9A:  BCF    FF2.7
09F9C:  MOVFF  82E,8EC
09FA0:  MOVFF  82D,8EB
09FA4:  MOVFF  82C,8EA
09FA8:  MOVFF  82B,8E9
09FAC:  CLRF   xF0
09FAE:  CLRF   xEF
09FB0:  CLRF   xEE
09FB2:  MOVLW  9E
09FB4:  MOVWF  xED
09FB6:  MOVLB  0
09FB8:  CALL   1230
09FBC:  BTFSC  19.7
09FBE:  BSF    FF2.7
09FC0:  CLRF   19
09FC2:  BTFSC  FF2.7
09FC4:  BSF    19.7
09FC6:  BCF    FF2.7
09FC8:  MOVFF  03,8BB
09FCC:  MOVFF  02,8BA
09FD0:  MOVFF  01,8B9
09FD4:  MOVFF  00,8B8
09FD8:  CALL   24C8
09FDC:  BTFSC  19.7
09FDE:  BSF    FF2.7
09FE0:  MOVFF  03,82E
09FE4:  MOVFF  02,82D
09FE8:  MOVFF  01,82C
09FEC:  MOVFF  00,82B
09FF0:  CLRF   19
09FF2:  BTFSC  FF2.7
09FF4:  BSF    19.7
09FF6:  BCF    FF2.7
09FF8:  MOVFF  82A,8BF
09FFC:  MOVFF  829,8BE
0A000:  MOVFF  828,8BD
0A004:  MOVFF  827,8BC
0A008:  MOVFF  03,8C3
0A00C:  MOVFF  02,8C2
0A010:  MOVFF  01,8C1
0A014:  MOVFF  00,8C0
0A018:  CALL   0DB0
0A01C:  BTFSC  19.7
0A01E:  BSF    FF2.7
.................... 		return rs232_output_vol[(ch-1)]; 
0A020:  MOVLW  01
0A022:  MOVLB  8
0A024:  SUBWF  x25,W
0A026:  MULLW  04
0A028:  MOVF   FF3,W
0A02A:  CLRF   03
0A02C:  ADDLW  B5
0A02E:  MOVWF  FE9
0A030:  MOVLW  00
0A032:  ADDWFC 03,W
0A034:  MOVWF  FEA
0A036:  MOVFF  FEF,00
0A03A:  MOVFF  FEC,01
0A03E:  MOVFF  FEC,02
0A042:  MOVFF  FEC,03
0A046:  BRA    A048
.................... 	} 
.................... } 
0A048:  MOVLB  0
0A04A:  GOTO   B570 (RETURN)
....................  
.................... double vol_big_down_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
0A04E:  MOVLB  8
0A050:  MOVF   x25,F
0A052:  BTFSS  FD8.2
0A054:  BRA    A230
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0A056:  CLRF   x26
0A058:  MOVF   x26,W
0A05A:  SUBLW  03
0A05C:  BTFSS  FD8.0
0A05E:  BRA    A21C
.................... 			rs232_output_mute[i] = 0; 
0A060:  CLRF   03
0A062:  MOVF   x26,W
0A064:  ADDLW  C5
0A066:  MOVWF  FE9
0A068:  MOVLW  00
0A06A:  ADDWFC 03,W
0A06C:  MOVWF  FEA
0A06E:  CLRF   FEF
.................... 			if(rs232_output_vol[i] > 0.1) { // TODO - Change this to be a variable 
0A070:  MOVF   x26,W
0A072:  MULLW  04
0A074:  MOVF   FF3,W
0A076:  CLRF   03
0A078:  ADDLW  B5
0A07A:  MOVWF  FE9
0A07C:  MOVLW  00
0A07E:  ADDWFC 03,W
0A080:  MOVWF  FEA
0A082:  MOVFF  FEF,827
0A086:  MOVFF  FEC,828
0A08A:  MOVFF  FEC,829
0A08E:  MOVFF  FEC,82A
0A092:  CLRF   19
0A094:  BTFSC  FF2.7
0A096:  BSF    19.7
0A098:  BCF    FF2.7
0A09A:  MOVLW  CD
0A09C:  MOVWF  xEC
0A09E:  MOVLW  CC
0A0A0:  MOVWF  xEB
0A0A2:  MOVLW  4C
0A0A4:  MOVWF  xEA
0A0A6:  MOVLW  7B
0A0A8:  MOVWF  xE9
0A0AA:  MOVFF  82A,8F0
0A0AE:  MOVFF  829,8EF
0A0B2:  MOVFF  828,8EE
0A0B6:  MOVFF  827,8ED
0A0BA:  MOVLB  0
0A0BC:  CALL   1326
0A0C0:  BTFSC  19.7
0A0C2:  BSF    FF2.7
0A0C4:  BNC   A130
.................... 				rs232_output_vol[i] -= 0.1; // TODO - Change this to be a variable 
0A0C6:  MOVLB  8
0A0C8:  MOVF   x26,W
0A0CA:  MULLW  04
0A0CC:  MOVF   FF3,W
0A0CE:  CLRF   03
0A0D0:  ADDLW  B5
0A0D2:  MOVWF  FE9
0A0D4:  MOVLW  00
0A0D6:  ADDWFC 03,W
0A0D8:  MOVWF  FEA
0A0DA:  MOVFF  FEA,82E
0A0DE:  MOVFF  FE9,82D
0A0E2:  BSF    FD8.1
0A0E4:  CLRF   19
0A0E6:  BTFSC  FF2.7
0A0E8:  BSF    19.7
0A0EA:  BCF    FF2.7
0A0EC:  MOVFF  FEF,8ED
0A0F0:  MOVFF  FEC,8EE
0A0F4:  MOVFF  FEC,8EF
0A0F8:  MOVFF  FEC,8F0
0A0FC:  MOVLW  CD
0A0FE:  MOVWF  xF4
0A100:  MOVLW  CC
0A102:  MOVWF  xF3
0A104:  MOVLW  4C
0A106:  MOVWF  xF2
0A108:  MOVLW  7B
0A10A:  MOVWF  xF1
0A10C:  MOVLB  0
0A10E:  CALL   0E5A
0A112:  BTFSC  19.7
0A114:  BSF    FF2.7
0A116:  MOVFF  82E,FEA
0A11A:  MOVFF  82D,FE9
0A11E:  MOVFF  00,FEF
0A122:  MOVFF  01,FEC
0A126:  MOVFF  02,FEC
0A12A:  MOVFF  03,FEC
.................... 			} else { 
0A12E:  BRA    A14E
.................... 				rs232_output_vol[i] = 0; 
0A130:  MOVLB  8
0A132:  MOVF   x26,W
0A134:  MULLW  04
0A136:  MOVF   FF3,W
0A138:  CLRF   03
0A13A:  ADDLW  B5
0A13C:  MOVWF  FE9
0A13E:  MOVLW  00
0A140:  ADDWFC 03,W
0A142:  MOVWF  FEA
0A144:  CLRF   FEF
0A146:  CLRF   FEC
0A148:  CLRF   FEC
0A14A:  CLRF   FEC
0A14C:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
0A14E:  MOVFF  826,86D
0A152:  CALL   7692
0A156:  MOVFF  03,82A
0A15A:  MOVFF  02,829
0A15E:  MOVFF  01,828
0A162:  MOVFF  00,827
0A166:  MOVLB  8
0A168:  MOVF   x26,W
0A16A:  MULLW  04
0A16C:  MOVF   FF3,W
0A16E:  CLRF   03
0A170:  ADDLW  B5
0A172:  MOVWF  FE9
0A174:  MOVLW  00
0A176:  ADDWFC 03,W
0A178:  MOVWF  FEA
0A17A:  MOVFF  FEF,82B
0A17E:  MOVFF  FEC,82C
0A182:  MOVFF  FEC,82D
0A186:  MOVFF  FEC,82E
0A18A:  CLRF   19
0A18C:  BTFSC  FF2.7
0A18E:  BSF    19.7
0A190:  BCF    FF2.7
0A192:  MOVFF  82E,8EC
0A196:  MOVFF  82D,8EB
0A19A:  MOVFF  82C,8EA
0A19E:  MOVFF  82B,8E9
0A1A2:  CLRF   xF0
0A1A4:  CLRF   xEF
0A1A6:  CLRF   xEE
0A1A8:  MOVLW  9E
0A1AA:  MOVWF  xED
0A1AC:  MOVLB  0
0A1AE:  CALL   1230
0A1B2:  BTFSC  19.7
0A1B4:  BSF    FF2.7
0A1B6:  CLRF   19
0A1B8:  BTFSC  FF2.7
0A1BA:  BSF    19.7
0A1BC:  BCF    FF2.7
0A1BE:  MOVFF  03,8BB
0A1C2:  MOVFF  02,8BA
0A1C6:  MOVFF  01,8B9
0A1CA:  MOVFF  00,8B8
0A1CE:  CALL   24C8
0A1D2:  BTFSC  19.7
0A1D4:  BSF    FF2.7
0A1D6:  MOVFF  03,82E
0A1DA:  MOVFF  02,82D
0A1DE:  MOVFF  01,82C
0A1E2:  MOVFF  00,82B
0A1E6:  CLRF   19
0A1E8:  BTFSC  FF2.7
0A1EA:  BSF    19.7
0A1EC:  BCF    FF2.7
0A1EE:  MOVFF  82A,8BF
0A1F2:  MOVFF  829,8BE
0A1F6:  MOVFF  828,8BD
0A1FA:  MOVFF  827,8BC
0A1FE:  MOVFF  03,8C3
0A202:  MOVFF  02,8C2
0A206:  MOVFF  01,8C1
0A20A:  MOVFF  00,8C0
0A20E:  CALL   0DB0
0A212:  BTFSC  19.7
0A214:  BSF    FF2.7
.................... 		} 
0A216:  MOVLB  8
0A218:  INCF   x26,F
0A21A:  BRA    A058
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
0A21C:  MOVFF  B5,00
0A220:  MOVFF  B6,01
0A224:  MOVFF  B7,02
0A228:  MOVFF  B8,03
0A22C:  BRA    A420
....................  
.................... 	} else { 
0A22E:  BRA    A420
.................... 		rs232_output_mute[(ch-1)] = 0; 
0A230:  MOVLW  01
0A232:  SUBWF  x25,W
0A234:  CLRF   03
0A236:  ADDLW  C5
0A238:  MOVWF  FE9
0A23A:  MOVLW  00
0A23C:  ADDWFC 03,W
0A23E:  MOVWF  FEA
0A240:  CLRF   FEF
.................... 		if(rs232_output_vol[(ch-1)] > 0.1) { 
0A242:  MOVLW  01
0A244:  SUBWF  x25,W
0A246:  MULLW  04
0A248:  MOVF   FF3,W
0A24A:  CLRF   03
0A24C:  ADDLW  B5
0A24E:  MOVWF  FE9
0A250:  MOVLW  00
0A252:  ADDWFC 03,W
0A254:  MOVWF  FEA
0A256:  MOVFF  FEF,827
0A25A:  MOVFF  FEC,828
0A25E:  MOVFF  FEC,829
0A262:  MOVFF  FEC,82A
0A266:  CLRF   19
0A268:  BTFSC  FF2.7
0A26A:  BSF    19.7
0A26C:  BCF    FF2.7
0A26E:  MOVLW  CD
0A270:  MOVWF  xEC
0A272:  MOVLW  CC
0A274:  MOVWF  xEB
0A276:  MOVLW  4C
0A278:  MOVWF  xEA
0A27A:  MOVLW  7B
0A27C:  MOVWF  xE9
0A27E:  MOVFF  82A,8F0
0A282:  MOVFF  829,8EF
0A286:  MOVFF  828,8EE
0A28A:  MOVFF  827,8ED
0A28E:  MOVLB  0
0A290:  CALL   1326
0A294:  BTFSC  19.7
0A296:  BSF    FF2.7
0A298:  BNC   A306
.................... 			rs232_output_vol[(ch-1)] -= 0.1; 
0A29A:  MOVLW  01
0A29C:  MOVLB  8
0A29E:  SUBWF  x25,W
0A2A0:  MULLW  04
0A2A2:  MOVF   FF3,W
0A2A4:  CLRF   03
0A2A6:  ADDLW  B5
0A2A8:  MOVWF  FE9
0A2AA:  MOVLW  00
0A2AC:  ADDWFC 03,W
0A2AE:  MOVWF  FEA
0A2B0:  MOVFF  FEA,82E
0A2B4:  MOVFF  FE9,82D
0A2B8:  BSF    FD8.1
0A2BA:  CLRF   19
0A2BC:  BTFSC  FF2.7
0A2BE:  BSF    19.7
0A2C0:  BCF    FF2.7
0A2C2:  MOVFF  FEF,8ED
0A2C6:  MOVFF  FEC,8EE
0A2CA:  MOVFF  FEC,8EF
0A2CE:  MOVFF  FEC,8F0
0A2D2:  MOVLW  CD
0A2D4:  MOVWF  xF4
0A2D6:  MOVLW  CC
0A2D8:  MOVWF  xF3
0A2DA:  MOVLW  4C
0A2DC:  MOVWF  xF2
0A2DE:  MOVLW  7B
0A2E0:  MOVWF  xF1
0A2E2:  MOVLB  0
0A2E4:  CALL   0E5A
0A2E8:  BTFSC  19.7
0A2EA:  BSF    FF2.7
0A2EC:  MOVFF  82E,FEA
0A2F0:  MOVFF  82D,FE9
0A2F4:  MOVFF  00,FEF
0A2F8:  MOVFF  01,FEC
0A2FC:  MOVFF  02,FEC
0A300:  MOVFF  03,FEC
.................... 		} else { 
0A304:  BRA    A326
.................... 			rs232_output_vol[(ch-1)] = 0; 
0A306:  MOVLW  01
0A308:  MOVLB  8
0A30A:  SUBWF  x25,W
0A30C:  MULLW  04
0A30E:  MOVF   FF3,W
0A310:  CLRF   03
0A312:  ADDLW  B5
0A314:  MOVWF  FE9
0A316:  MOVLW  00
0A318:  ADDWFC 03,W
0A31A:  MOVWF  FEA
0A31C:  CLRF   FEF
0A31E:  CLRF   FEC
0A320:  CLRF   FEC
0A322:  CLRF   FEC
0A324:  MOVLB  0
.................... 		} 
.................... 	 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
0A326:  MOVLW  01
0A328:  MOVLB  8
0A32A:  SUBWF  x25,W
0A32C:  MOVWF  x27
0A32E:  MOVWF  x6D
0A330:  MOVLB  0
0A332:  CALL   7692
0A336:  MOVFF  03,82A
0A33A:  MOVFF  02,829
0A33E:  MOVFF  01,828
0A342:  MOVFF  00,827
0A346:  MOVLW  01
0A348:  MOVLB  8
0A34A:  SUBWF  x25,W
0A34C:  MULLW  04
0A34E:  MOVF   FF3,W
0A350:  CLRF   03
0A352:  ADDLW  B5
0A354:  MOVWF  FE9
0A356:  MOVLW  00
0A358:  ADDWFC 03,W
0A35A:  MOVWF  FEA
0A35C:  MOVFF  FEF,82B
0A360:  MOVFF  FEC,82C
0A364:  MOVFF  FEC,82D
0A368:  MOVFF  FEC,82E
0A36C:  CLRF   19
0A36E:  BTFSC  FF2.7
0A370:  BSF    19.7
0A372:  BCF    FF2.7
0A374:  MOVFF  82E,8EC
0A378:  MOVFF  82D,8EB
0A37C:  MOVFF  82C,8EA
0A380:  MOVFF  82B,8E9
0A384:  CLRF   xF0
0A386:  CLRF   xEF
0A388:  CLRF   xEE
0A38A:  MOVLW  9E
0A38C:  MOVWF  xED
0A38E:  MOVLB  0
0A390:  CALL   1230
0A394:  BTFSC  19.7
0A396:  BSF    FF2.7
0A398:  CLRF   19
0A39A:  BTFSC  FF2.7
0A39C:  BSF    19.7
0A39E:  BCF    FF2.7
0A3A0:  MOVFF  03,8BB
0A3A4:  MOVFF  02,8BA
0A3A8:  MOVFF  01,8B9
0A3AC:  MOVFF  00,8B8
0A3B0:  CALL   24C8
0A3B4:  BTFSC  19.7
0A3B6:  BSF    FF2.7
0A3B8:  MOVFF  03,82E
0A3BC:  MOVFF  02,82D
0A3C0:  MOVFF  01,82C
0A3C4:  MOVFF  00,82B
0A3C8:  CLRF   19
0A3CA:  BTFSC  FF2.7
0A3CC:  BSF    19.7
0A3CE:  BCF    FF2.7
0A3D0:  MOVFF  82A,8BF
0A3D4:  MOVFF  829,8BE
0A3D8:  MOVFF  828,8BD
0A3DC:  MOVFF  827,8BC
0A3E0:  MOVFF  03,8C3
0A3E4:  MOVFF  02,8C2
0A3E8:  MOVFF  01,8C1
0A3EC:  MOVFF  00,8C0
0A3F0:  CALL   0DB0
0A3F4:  BTFSC  19.7
0A3F6:  BSF    FF2.7
....................  
.................... 		return rs232_output_vol[(ch-1)]; 
0A3F8:  MOVLW  01
0A3FA:  MOVLB  8
0A3FC:  SUBWF  x25,W
0A3FE:  MULLW  04
0A400:  MOVF   FF3,W
0A402:  CLRF   03
0A404:  ADDLW  B5
0A406:  MOVWF  FE9
0A408:  MOVLW  00
0A40A:  ADDWFC 03,W
0A40C:  MOVWF  FEA
0A40E:  MOVFF  FEF,00
0A412:  MOVFF  FEC,01
0A416:  MOVFF  FEC,02
0A41A:  MOVFF  FEC,03
0A41E:  BRA    A420
.................... 	} 
.................... } 
0A420:  MOVLB  0
0A422:  GOTO   B674 (RETURN)
....................  
.................... double vol_small_down_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
0A426:  MOVLB  8
0A428:  MOVF   x25,F
0A42A:  BTFSS  FD8.2
0A42C:  BRA    A608
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0A42E:  CLRF   x26
0A430:  MOVF   x26,W
0A432:  SUBLW  03
0A434:  BTFSS  FD8.0
0A436:  BRA    A5F4
.................... 			rs232_output_mute[i] = 0; 
0A438:  CLRF   03
0A43A:  MOVF   x26,W
0A43C:  ADDLW  C5
0A43E:  MOVWF  FE9
0A440:  MOVLW  00
0A442:  ADDWFC 03,W
0A444:  MOVWF  FEA
0A446:  CLRF   FEF
.................... 			if(rs232_output_vol[i] > 0.05) { // TODO - Change this to be a variable 
0A448:  MOVF   x26,W
0A44A:  MULLW  04
0A44C:  MOVF   FF3,W
0A44E:  CLRF   03
0A450:  ADDLW  B5
0A452:  MOVWF  FE9
0A454:  MOVLW  00
0A456:  ADDWFC 03,W
0A458:  MOVWF  FEA
0A45A:  MOVFF  FEF,827
0A45E:  MOVFF  FEC,828
0A462:  MOVFF  FEC,829
0A466:  MOVFF  FEC,82A
0A46A:  CLRF   19
0A46C:  BTFSC  FF2.7
0A46E:  BSF    19.7
0A470:  BCF    FF2.7
0A472:  MOVLW  CD
0A474:  MOVWF  xEC
0A476:  MOVLW  CC
0A478:  MOVWF  xEB
0A47A:  MOVLW  4C
0A47C:  MOVWF  xEA
0A47E:  MOVLW  7A
0A480:  MOVWF  xE9
0A482:  MOVFF  82A,8F0
0A486:  MOVFF  829,8EF
0A48A:  MOVFF  828,8EE
0A48E:  MOVFF  827,8ED
0A492:  MOVLB  0
0A494:  CALL   1326
0A498:  BTFSC  19.7
0A49A:  BSF    FF2.7
0A49C:  BNC   A508
.................... 				rs232_output_vol[i] -= 0.05; // TODO - Change this to be a variable 
0A49E:  MOVLB  8
0A4A0:  MOVF   x26,W
0A4A2:  MULLW  04
0A4A4:  MOVF   FF3,W
0A4A6:  CLRF   03
0A4A8:  ADDLW  B5
0A4AA:  MOVWF  FE9
0A4AC:  MOVLW  00
0A4AE:  ADDWFC 03,W
0A4B0:  MOVWF  FEA
0A4B2:  MOVFF  FEA,82E
0A4B6:  MOVFF  FE9,82D
0A4BA:  BSF    FD8.1
0A4BC:  CLRF   19
0A4BE:  BTFSC  FF2.7
0A4C0:  BSF    19.7
0A4C2:  BCF    FF2.7
0A4C4:  MOVFF  FEF,8ED
0A4C8:  MOVFF  FEC,8EE
0A4CC:  MOVFF  FEC,8EF
0A4D0:  MOVFF  FEC,8F0
0A4D4:  MOVLW  CD
0A4D6:  MOVWF  xF4
0A4D8:  MOVLW  CC
0A4DA:  MOVWF  xF3
0A4DC:  MOVLW  4C
0A4DE:  MOVWF  xF2
0A4E0:  MOVLW  7A
0A4E2:  MOVWF  xF1
0A4E4:  MOVLB  0
0A4E6:  CALL   0E5A
0A4EA:  BTFSC  19.7
0A4EC:  BSF    FF2.7
0A4EE:  MOVFF  82E,FEA
0A4F2:  MOVFF  82D,FE9
0A4F6:  MOVFF  00,FEF
0A4FA:  MOVFF  01,FEC
0A4FE:  MOVFF  02,FEC
0A502:  MOVFF  03,FEC
.................... 			} else { 
0A506:  BRA    A526
.................... 				rs232_output_vol[i] = 0; 
0A508:  MOVLB  8
0A50A:  MOVF   x26,W
0A50C:  MULLW  04
0A50E:  MOVF   FF3,W
0A510:  CLRF   03
0A512:  ADDLW  B5
0A514:  MOVWF  FE9
0A516:  MOVLW  00
0A518:  ADDWFC 03,W
0A51A:  MOVWF  FEA
0A51C:  CLRF   FEF
0A51E:  CLRF   FEC
0A520:  CLRF   FEC
0A522:  CLRF   FEC
0A524:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
0A526:  MOVFF  826,86D
0A52A:  CALL   7692
0A52E:  MOVFF  03,82A
0A532:  MOVFF  02,829
0A536:  MOVFF  01,828
0A53A:  MOVFF  00,827
0A53E:  MOVLB  8
0A540:  MOVF   x26,W
0A542:  MULLW  04
0A544:  MOVF   FF3,W
0A546:  CLRF   03
0A548:  ADDLW  B5
0A54A:  MOVWF  FE9
0A54C:  MOVLW  00
0A54E:  ADDWFC 03,W
0A550:  MOVWF  FEA
0A552:  MOVFF  FEF,82B
0A556:  MOVFF  FEC,82C
0A55A:  MOVFF  FEC,82D
0A55E:  MOVFF  FEC,82E
0A562:  CLRF   19
0A564:  BTFSC  FF2.7
0A566:  BSF    19.7
0A568:  BCF    FF2.7
0A56A:  MOVFF  82E,8EC
0A56E:  MOVFF  82D,8EB
0A572:  MOVFF  82C,8EA
0A576:  MOVFF  82B,8E9
0A57A:  CLRF   xF0
0A57C:  CLRF   xEF
0A57E:  CLRF   xEE
0A580:  MOVLW  9E
0A582:  MOVWF  xED
0A584:  MOVLB  0
0A586:  CALL   1230
0A58A:  BTFSC  19.7
0A58C:  BSF    FF2.7
0A58E:  CLRF   19
0A590:  BTFSC  FF2.7
0A592:  BSF    19.7
0A594:  BCF    FF2.7
0A596:  MOVFF  03,8BB
0A59A:  MOVFF  02,8BA
0A59E:  MOVFF  01,8B9
0A5A2:  MOVFF  00,8B8
0A5A6:  CALL   24C8
0A5AA:  BTFSC  19.7
0A5AC:  BSF    FF2.7
0A5AE:  MOVFF  03,82E
0A5B2:  MOVFF  02,82D
0A5B6:  MOVFF  01,82C
0A5BA:  MOVFF  00,82B
0A5BE:  CLRF   19
0A5C0:  BTFSC  FF2.7
0A5C2:  BSF    19.7
0A5C4:  BCF    FF2.7
0A5C6:  MOVFF  82A,8BF
0A5CA:  MOVFF  829,8BE
0A5CE:  MOVFF  828,8BD
0A5D2:  MOVFF  827,8BC
0A5D6:  MOVFF  03,8C3
0A5DA:  MOVFF  02,8C2
0A5DE:  MOVFF  01,8C1
0A5E2:  MOVFF  00,8C0
0A5E6:  CALL   0DB0
0A5EA:  BTFSC  19.7
0A5EC:  BSF    FF2.7
.................... 		} 
0A5EE:  MOVLB  8
0A5F0:  INCF   x26,F
0A5F2:  BRA    A430
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
0A5F4:  MOVFF  B5,00
0A5F8:  MOVFF  B6,01
0A5FC:  MOVFF  B7,02
0A600:  MOVFF  B8,03
0A604:  BRA    A7F4
....................  
.................... 	} else { 
0A606:  BRA    A7F4
.................... 		 
.................... 		rs232_output_mute[(ch-1)] = 0; 
0A608:  MOVLW  01
0A60A:  SUBWF  x25,W
0A60C:  CLRF   03
0A60E:  ADDLW  C5
0A610:  MOVWF  FE9
0A612:  MOVLW  00
0A614:  ADDWFC 03,W
0A616:  MOVWF  FEA
0A618:  CLRF   FEF
.................... 		if(rs232_output_vol[(ch-1)] > 0.05) { 
0A61A:  MOVLW  01
0A61C:  SUBWF  x25,W
0A61E:  MULLW  04
0A620:  MOVF   FF3,W
0A622:  CLRF   03
0A624:  ADDLW  B5
0A626:  MOVWF  FE9
0A628:  MOVLW  00
0A62A:  ADDWFC 03,W
0A62C:  MOVWF  FEA
0A62E:  MOVFF  FEF,827
0A632:  MOVFF  FEC,828
0A636:  MOVFF  FEC,829
0A63A:  MOVFF  FEC,82A
0A63E:  CLRF   19
0A640:  BTFSC  FF2.7
0A642:  BSF    19.7
0A644:  BCF    FF2.7
0A646:  MOVLW  CD
0A648:  MOVWF  xEC
0A64A:  MOVLW  CC
0A64C:  MOVWF  xEB
0A64E:  MOVLW  4C
0A650:  MOVWF  xEA
0A652:  MOVLW  7A
0A654:  MOVWF  xE9
0A656:  MOVFF  82A,8F0
0A65A:  MOVFF  829,8EF
0A65E:  MOVFF  828,8EE
0A662:  MOVFF  827,8ED
0A666:  MOVLB  0
0A668:  CALL   1326
0A66C:  BTFSC  19.7
0A66E:  BSF    FF2.7
0A670:  BNC   A6DE
.................... 			rs232_output_vol[(ch-1)] -= 0.05; 
0A672:  MOVLW  01
0A674:  MOVLB  8
0A676:  SUBWF  x25,W
0A678:  MULLW  04
0A67A:  MOVF   FF3,W
0A67C:  CLRF   03
0A67E:  ADDLW  B5
0A680:  MOVWF  FE9
0A682:  MOVLW  00
0A684:  ADDWFC 03,W
0A686:  MOVWF  FEA
0A688:  MOVFF  FEA,82E
0A68C:  MOVFF  FE9,82D
0A690:  BSF    FD8.1
0A692:  CLRF   19
0A694:  BTFSC  FF2.7
0A696:  BSF    19.7
0A698:  BCF    FF2.7
0A69A:  MOVFF  FEF,8ED
0A69E:  MOVFF  FEC,8EE
0A6A2:  MOVFF  FEC,8EF
0A6A6:  MOVFF  FEC,8F0
0A6AA:  MOVLW  CD
0A6AC:  MOVWF  xF4
0A6AE:  MOVLW  CC
0A6B0:  MOVWF  xF3
0A6B2:  MOVLW  4C
0A6B4:  MOVWF  xF2
0A6B6:  MOVLW  7A
0A6B8:  MOVWF  xF1
0A6BA:  MOVLB  0
0A6BC:  CALL   0E5A
0A6C0:  BTFSC  19.7
0A6C2:  BSF    FF2.7
0A6C4:  MOVFF  82E,FEA
0A6C8:  MOVFF  82D,FE9
0A6CC:  MOVFF  00,FEF
0A6D0:  MOVFF  01,FEC
0A6D4:  MOVFF  02,FEC
0A6D8:  MOVFF  03,FEC
.................... 		} else { 
0A6DC:  BRA    A6FC
.................... 			rs232_output_vol[(ch-1)] = 0; 
0A6DE:  MOVLW  01
0A6E0:  MOVLB  8
0A6E2:  SUBWF  x25,W
0A6E4:  MULLW  04
0A6E6:  MOVF   FF3,W
0A6E8:  CLRF   03
0A6EA:  ADDLW  B5
0A6EC:  MOVWF  FE9
0A6EE:  MOVLW  00
0A6F0:  ADDWFC 03,W
0A6F2:  MOVWF  FEA
0A6F4:  CLRF   FEF
0A6F6:  CLRF   FEC
0A6F8:  CLRF   FEC
0A6FA:  CLRF   FEC
.................... 		} 
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
0A6FC:  MOVLW  01
0A6FE:  MOVLB  8
0A700:  SUBWF  x25,W
0A702:  MOVWF  x27
0A704:  MOVWF  x6D
0A706:  MOVLB  0
0A708:  CALL   7692
0A70C:  MOVFF  03,82A
0A710:  MOVFF  02,829
0A714:  MOVFF  01,828
0A718:  MOVFF  00,827
0A71C:  MOVLW  01
0A71E:  MOVLB  8
0A720:  SUBWF  x25,W
0A722:  MULLW  04
0A724:  MOVF   FF3,W
0A726:  CLRF   03
0A728:  ADDLW  B5
0A72A:  MOVWF  FE9
0A72C:  MOVLW  00
0A72E:  ADDWFC 03,W
0A730:  MOVWF  FEA
0A732:  MOVFF  FEF,82B
0A736:  MOVFF  FEC,82C
0A73A:  MOVFF  FEC,82D
0A73E:  MOVFF  FEC,82E
0A742:  CLRF   19
0A744:  BTFSC  FF2.7
0A746:  BSF    19.7
0A748:  BCF    FF2.7
0A74A:  MOVFF  82E,8EC
0A74E:  MOVFF  82D,8EB
0A752:  MOVFF  82C,8EA
0A756:  MOVFF  82B,8E9
0A75A:  CLRF   xF0
0A75C:  CLRF   xEF
0A75E:  CLRF   xEE
0A760:  MOVLW  9E
0A762:  MOVWF  xED
0A764:  MOVLB  0
0A766:  CALL   1230
0A76A:  BTFSC  19.7
0A76C:  BSF    FF2.7
0A76E:  CLRF   19
0A770:  BTFSC  FF2.7
0A772:  BSF    19.7
0A774:  BCF    FF2.7
0A776:  MOVFF  03,8BB
0A77A:  MOVFF  02,8BA
0A77E:  MOVFF  01,8B9
0A782:  MOVFF  00,8B8
0A786:  CALL   24C8
0A78A:  BTFSC  19.7
0A78C:  BSF    FF2.7
0A78E:  MOVFF  03,82E
0A792:  MOVFF  02,82D
0A796:  MOVFF  01,82C
0A79A:  MOVFF  00,82B
0A79E:  CLRF   19
0A7A0:  BTFSC  FF2.7
0A7A2:  BSF    19.7
0A7A4:  BCF    FF2.7
0A7A6:  MOVFF  82A,8BF
0A7AA:  MOVFF  829,8BE
0A7AE:  MOVFF  828,8BD
0A7B2:  MOVFF  827,8BC
0A7B6:  MOVFF  03,8C3
0A7BA:  MOVFF  02,8C2
0A7BE:  MOVFF  01,8C1
0A7C2:  MOVFF  00,8C0
0A7C6:  CALL   0DB0
0A7CA:  BTFSC  19.7
0A7CC:  BSF    FF2.7
....................  
.................... 		return rs232_output_vol[ch]; 
0A7CE:  MOVLB  8
0A7D0:  MOVF   x25,W
0A7D2:  MULLW  04
0A7D4:  MOVF   FF3,W
0A7D6:  CLRF   03
0A7D8:  ADDLW  B5
0A7DA:  MOVWF  FE9
0A7DC:  MOVLW  00
0A7DE:  ADDWFC 03,W
0A7E0:  MOVWF  FEA
0A7E2:  MOVFF  FEF,00
0A7E6:  MOVFF  FEC,01
0A7EA:  MOVFF  FEC,02
0A7EE:  MOVFF  FEC,03
0A7F2:  BRA    A7F4
.................... 	} 
.................... } 
0A7F4:  MOVLB  0
0A7F6:  GOTO   B778 (RETURN)
....................  
.................... void mute_on_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
0A7FA:  MOVLB  8
0A7FC:  MOVF   x25,F
0A7FE:  BNZ   A868
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0A800:  CLRF   x26
0A802:  MOVF   x26,W
0A804:  SUBLW  03
0A806:  BNC   A866
.................... 			rs232_output_mute[i] = 1; 
0A808:  CLRF   03
0A80A:  MOVF   x26,W
0A80C:  ADDLW  C5
0A80E:  MOVWF  FE9
0A810:  MOVLW  00
0A812:  ADDWFC 03,W
0A814:  MOVWF  FEA
0A816:  MOVLW  01
0A818:  MOVWF  FEF
....................  
.................... 			send_dsp_command(get_AM_trim_channel(i),0x00000000); 
0A81A:  MOVFF  826,86D
0A81E:  MOVLB  0
0A820:  CALL   7692
0A824:  MOVFF  03,82A
0A828:  MOVFF  02,829
0A82C:  MOVFF  01,828
0A830:  MOVFF  00,827
0A834:  CLRF   19
0A836:  BTFSC  FF2.7
0A838:  BSF    19.7
0A83A:  BCF    FF2.7
0A83C:  MOVFF  03,8BF
0A840:  MOVFF  02,8BE
0A844:  MOVFF  01,8BD
0A848:  MOVFF  00,8BC
0A84C:  MOVLB  8
0A84E:  CLRF   xC3
0A850:  CLRF   xC2
0A852:  CLRF   xC1
0A854:  CLRF   xC0
0A856:  MOVLB  0
0A858:  CALL   0DB0
0A85C:  BTFSC  19.7
0A85E:  BSF    FF2.7
.................... 		} 
0A860:  MOVLB  8
0A862:  INCF   x26,F
0A864:  BRA    A802
.................... 	} else { 
0A866:  BRA    A8C6
.................... 		rs232_output_mute[(ch-1)] = 1; 
0A868:  MOVLW  01
0A86A:  SUBWF  x25,W
0A86C:  CLRF   03
0A86E:  ADDLW  C5
0A870:  MOVWF  FE9
0A872:  MOVLW  00
0A874:  ADDWFC 03,W
0A876:  MOVWF  FEA
0A878:  MOVLW  01
0A87A:  MOVWF  FEF
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),0x00000000); 
0A87C:  SUBWF  x25,W
0A87E:  MOVWF  x27
0A880:  MOVWF  x6D
0A882:  MOVLB  0
0A884:  CALL   7692
0A888:  MOVFF  03,82A
0A88C:  MOVFF  02,829
0A890:  MOVFF  01,828
0A894:  MOVFF  00,827
0A898:  CLRF   19
0A89A:  BTFSC  FF2.7
0A89C:  BSF    19.7
0A89E:  BCF    FF2.7
0A8A0:  MOVFF  03,8BF
0A8A4:  MOVFF  02,8BE
0A8A8:  MOVFF  01,8BD
0A8AC:  MOVFF  00,8BC
0A8B0:  MOVLB  8
0A8B2:  CLRF   xC3
0A8B4:  CLRF   xC2
0A8B6:  CLRF   xC1
0A8B8:  CLRF   xC0
0A8BA:  MOVLB  0
0A8BC:  CALL   0DB0
0A8C0:  BTFSC  19.7
0A8C2:  BSF    FF2.7
0A8C4:  MOVLB  8
.................... 	}		 
.................... } 
0A8C6:  MOVLB  0
0A8C8:  GOTO   BA1C (RETURN)
....................  
.................... void mute_off_output(int ch) 
.................... { 
....................  
.................... 	if(ch == 0) { 
0A8CC:  MOVLB  8
0A8CE:  MOVF   x25,F
0A8D0:  BNZ   A9BC
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0A8D2:  CLRF   x26
0A8D4:  MOVF   x26,W
0A8D6:  SUBLW  03
0A8D8:  BNC   A9BA
.................... 			rs232_output_mute[i] = 0; 
0A8DA:  CLRF   03
0A8DC:  MOVF   x26,W
0A8DE:  ADDLW  C5
0A8E0:  MOVWF  FE9
0A8E2:  MOVLW  00
0A8E4:  ADDWFC 03,W
0A8E6:  MOVWF  FEA
0A8E8:  CLRF   FEF
.................... 	 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
0A8EA:  MOVFF  826,86D
0A8EE:  MOVLB  0
0A8F0:  CALL   7692
0A8F4:  MOVFF  03,82A
0A8F8:  MOVFF  02,829
0A8FC:  MOVFF  01,828
0A900:  MOVFF  00,827
0A904:  MOVLB  8
0A906:  MOVF   x26,W
0A908:  MULLW  04
0A90A:  MOVF   FF3,W
0A90C:  CLRF   03
0A90E:  ADDLW  B5
0A910:  MOVWF  FE9
0A912:  MOVLW  00
0A914:  ADDWFC 03,W
0A916:  MOVWF  FEA
0A918:  MOVFF  FEF,82B
0A91C:  MOVFF  FEC,82C
0A920:  MOVFF  FEC,82D
0A924:  MOVFF  FEC,82E
0A928:  CLRF   19
0A92A:  BTFSC  FF2.7
0A92C:  BSF    19.7
0A92E:  BCF    FF2.7
0A930:  MOVFF  82E,8EC
0A934:  MOVFF  82D,8EB
0A938:  MOVFF  82C,8EA
0A93C:  MOVFF  82B,8E9
0A940:  CLRF   xF0
0A942:  CLRF   xEF
0A944:  CLRF   xEE
0A946:  MOVLW  9E
0A948:  MOVWF  xED
0A94A:  MOVLB  0
0A94C:  CALL   1230
0A950:  BTFSC  19.7
0A952:  BSF    FF2.7
0A954:  CLRF   19
0A956:  BTFSC  FF2.7
0A958:  BSF    19.7
0A95A:  BCF    FF2.7
0A95C:  MOVFF  03,8BB
0A960:  MOVFF  02,8BA
0A964:  MOVFF  01,8B9
0A968:  MOVFF  00,8B8
0A96C:  CALL   24C8
0A970:  BTFSC  19.7
0A972:  BSF    FF2.7
0A974:  MOVFF  03,82E
0A978:  MOVFF  02,82D
0A97C:  MOVFF  01,82C
0A980:  MOVFF  00,82B
0A984:  CLRF   19
0A986:  BTFSC  FF2.7
0A988:  BSF    19.7
0A98A:  BCF    FF2.7
0A98C:  MOVFF  82A,8BF
0A990:  MOVFF  829,8BE
0A994:  MOVFF  828,8BD
0A998:  MOVFF  827,8BC
0A99C:  MOVFF  03,8C3
0A9A0:  MOVFF  02,8C2
0A9A4:  MOVFF  01,8C1
0A9A8:  MOVFF  00,8C0
0A9AC:  CALL   0DB0
0A9B0:  BTFSC  19.7
0A9B2:  BSF    FF2.7
.................... 		} 
0A9B4:  MOVLB  8
0A9B6:  INCF   x26,F
0A9B8:  BRA    A8D4
.................... 	} else { 
0A9BA:  BRA    AAA0
.................... 		rs232_output_mute[(ch-1)] = 0; 
0A9BC:  MOVLW  01
0A9BE:  SUBWF  x25,W
0A9C0:  CLRF   03
0A9C2:  ADDLW  C5
0A9C4:  MOVWF  FE9
0A9C6:  MOVLW  00
0A9C8:  ADDWFC 03,W
0A9CA:  MOVWF  FEA
0A9CC:  CLRF   FEF
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
0A9CE:  MOVLW  01
0A9D0:  SUBWF  x25,W
0A9D2:  MOVWF  x27
0A9D4:  MOVWF  x6D
0A9D6:  MOVLB  0
0A9D8:  CALL   7692
0A9DC:  MOVFF  03,82A
0A9E0:  MOVFF  02,829
0A9E4:  MOVFF  01,828
0A9E8:  MOVFF  00,827
0A9EC:  MOVLW  01
0A9EE:  MOVLB  8
0A9F0:  SUBWF  x25,W
0A9F2:  MULLW  04
0A9F4:  MOVF   FF3,W
0A9F6:  CLRF   03
0A9F8:  ADDLW  B5
0A9FA:  MOVWF  FE9
0A9FC:  MOVLW  00
0A9FE:  ADDWFC 03,W
0AA00:  MOVWF  FEA
0AA02:  MOVFF  FEF,82B
0AA06:  MOVFF  FEC,82C
0AA0A:  MOVFF  FEC,82D
0AA0E:  MOVFF  FEC,82E
0AA12:  CLRF   19
0AA14:  BTFSC  FF2.7
0AA16:  BSF    19.7
0AA18:  BCF    FF2.7
0AA1A:  MOVFF  82E,8EC
0AA1E:  MOVFF  82D,8EB
0AA22:  MOVFF  82C,8EA
0AA26:  MOVFF  82B,8E9
0AA2A:  CLRF   xF0
0AA2C:  CLRF   xEF
0AA2E:  CLRF   xEE
0AA30:  MOVLW  9E
0AA32:  MOVWF  xED
0AA34:  MOVLB  0
0AA36:  CALL   1230
0AA3A:  BTFSC  19.7
0AA3C:  BSF    FF2.7
0AA3E:  CLRF   19
0AA40:  BTFSC  FF2.7
0AA42:  BSF    19.7
0AA44:  BCF    FF2.7
0AA46:  MOVFF  03,8BB
0AA4A:  MOVFF  02,8BA
0AA4E:  MOVFF  01,8B9
0AA52:  MOVFF  00,8B8
0AA56:  CALL   24C8
0AA5A:  BTFSC  19.7
0AA5C:  BSF    FF2.7
0AA5E:  MOVFF  03,82E
0AA62:  MOVFF  02,82D
0AA66:  MOVFF  01,82C
0AA6A:  MOVFF  00,82B
0AA6E:  CLRF   19
0AA70:  BTFSC  FF2.7
0AA72:  BSF    19.7
0AA74:  BCF    FF2.7
0AA76:  MOVFF  82A,8BF
0AA7A:  MOVFF  829,8BE
0AA7E:  MOVFF  828,8BD
0AA82:  MOVFF  827,8BC
0AA86:  MOVFF  03,8C3
0AA8A:  MOVFF  02,8C2
0AA8E:  MOVFF  01,8C1
0AA92:  MOVFF  00,8C0
0AA96:  CALL   0DB0
0AA9A:  BTFSC  19.7
0AA9C:  BSF    FF2.7
0AA9E:  MOVLB  8
.................... 	}		 
.................... } 
0AAA0:  MOVLB  0
0AAA2:  GOTO   BA3A (RETURN)
....................  
.................... int mute_toggle_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
*
076F8:  MOVLB  8
076FA:  MOVF   x69,F
076FC:  BTFSS  FD8.2
076FE:  BRA    7874
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
07700:  CLRF   x6A
07702:  MOVF   x6A,W
07704:  SUBLW  03
07706:  BTFSS  FD8.0
07708:  BRA    7868
.................... 			rs232_output_mute[i] = !rs232_output_mute[i]; 
0770A:  CLRF   03
0770C:  MOVF   x6A,W
0770E:  ADDLW  C5
07710:  MOVWF  01
07712:  MOVLW  00
07714:  ADDWFC 03,F
07716:  MOVFF  01,86B
0771A:  MOVFF  03,86C
0771E:  CLRF   03
07720:  MOVF   x6A,W
07722:  ADDLW  C5
07724:  MOVWF  FE9
07726:  MOVLW  00
07728:  ADDWFC 03,W
0772A:  MOVWF  FEA
0772C:  MOVF   FEF,F
0772E:  BZ    7734
07730:  MOVLW  00
07732:  BRA    7736
07734:  MOVLW  01
07736:  MOVFF  86C,FEA
0773A:  MOVFF  86B,FE9
0773E:  MOVWF  FEF
....................  
.................... 			if(rs232_output_mute[i]) { 
07740:  CLRF   03
07742:  MOVF   x6A,W
07744:  ADDLW  C5
07746:  MOVWF  FE9
07748:  MOVLW  00
0774A:  ADDWFC 03,W
0774C:  MOVWF  FEA
0774E:  MOVF   FEF,F
07750:  BZ    779A
.................... 				send_dsp_command(get_AM_trim_channel(i),0x00000000); 
07752:  MOVFF  86A,86D
07756:  MOVLB  0
07758:  RCALL  7692
0775A:  MOVFF  03,86E
0775E:  MOVFF  02,86D
07762:  MOVFF  01,86C
07766:  MOVFF  00,86B
0776A:  CLRF   19
0776C:  BTFSC  FF2.7
0776E:  BSF    19.7
07770:  BCF    FF2.7
07772:  MOVFF  03,8BF
07776:  MOVFF  02,8BE
0777A:  MOVFF  01,8BD
0777E:  MOVFF  00,8BC
07782:  MOVLB  8
07784:  CLRF   xC3
07786:  CLRF   xC2
07788:  CLRF   xC1
0778A:  CLRF   xC0
0778C:  MOVLB  0
0778E:  CALL   0DB0
07792:  BTFSC  19.7
07794:  BSF    FF2.7
.................... 			} else { 
07796:  BRA    7862
07798:  MOVLB  8
.................... 				send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
0779A:  MOVFF  86A,86D
0779E:  MOVLB  0
077A0:  RCALL  7692
077A2:  MOVFF  03,86E
077A6:  MOVFF  02,86D
077AA:  MOVFF  01,86C
077AE:  MOVFF  00,86B
077B2:  MOVLB  8
077B4:  MOVF   x6A,W
077B6:  MULLW  04
077B8:  MOVF   FF3,W
077BA:  CLRF   03
077BC:  ADDLW  B5
077BE:  MOVWF  FE9
077C0:  MOVLW  00
077C2:  ADDWFC 03,W
077C4:  MOVWF  FEA
077C6:  MOVFF  FEF,86F
077CA:  MOVFF  FEC,870
077CE:  MOVFF  FEC,871
077D2:  MOVFF  FEC,872
077D6:  CLRF   19
077D8:  BTFSC  FF2.7
077DA:  BSF    19.7
077DC:  BCF    FF2.7
077DE:  MOVFF  872,8EC
077E2:  MOVFF  871,8EB
077E6:  MOVFF  870,8EA
077EA:  MOVFF  86F,8E9
077EE:  CLRF   xF0
077F0:  CLRF   xEF
077F2:  CLRF   xEE
077F4:  MOVLW  9E
077F6:  MOVWF  xED
077F8:  MOVLB  0
077FA:  CALL   1230
077FE:  BTFSC  19.7
07800:  BSF    FF2.7
07802:  CLRF   19
07804:  BTFSC  FF2.7
07806:  BSF    19.7
07808:  BCF    FF2.7
0780A:  MOVFF  03,8BB
0780E:  MOVFF  02,8BA
07812:  MOVFF  01,8B9
07816:  MOVFF  00,8B8
0781A:  CALL   24C8
0781E:  BTFSC  19.7
07820:  BSF    FF2.7
07822:  MOVFF  03,872
07826:  MOVFF  02,871
0782A:  MOVFF  01,870
0782E:  MOVFF  00,86F
07832:  CLRF   19
07834:  BTFSC  FF2.7
07836:  BSF    19.7
07838:  BCF    FF2.7
0783A:  MOVFF  86E,8BF
0783E:  MOVFF  86D,8BE
07842:  MOVFF  86C,8BD
07846:  MOVFF  86B,8BC
0784A:  MOVFF  03,8C3
0784E:  MOVFF  02,8C2
07852:  MOVFF  01,8C1
07856:  MOVFF  00,8C0
0785A:  CALL   0DB0
0785E:  BTFSC  19.7
07860:  BSF    FF2.7
.................... 			} 
.................... 		 
.................... 			 
.................... 		} 
07862:  MOVLB  8
07864:  INCF   x6A,F
07866:  BRA    7702
....................  
.................... 		return rs232_output_mute[0]; 
07868:  MOVLB  0
0786A:  MOVFF  C5,01
0786E:  BRA    79F6
....................  
.................... 	} else { 
07870:  BRA    79F6
07872:  MOVLB  8
.................... 		rs232_output_mute[(ch-1)] = !rs232_output_mute[(ch-1)]; 
07874:  MOVLW  01
07876:  SUBWF  x69,W
07878:  CLRF   03
0787A:  ADDLW  C5
0787C:  MOVWF  01
0787E:  MOVLW  00
07880:  ADDWFC 03,F
07882:  MOVFF  01,86B
07886:  MOVFF  03,86C
0788A:  MOVLW  01
0788C:  SUBWF  x69,W
0788E:  CLRF   03
07890:  ADDLW  C5
07892:  MOVWF  FE9
07894:  MOVLW  00
07896:  ADDWFC 03,W
07898:  MOVWF  FEA
0789A:  MOVF   FEF,F
0789C:  BZ    78A2
0789E:  MOVLW  00
078A0:  BRA    78A4
078A2:  MOVLW  01
078A4:  MOVFF  86C,FEA
078A8:  MOVFF  86B,FE9
078AC:  MOVWF  FEF
....................  
.................... 		if(rs232_output_mute[(ch-1)]) { 
078AE:  MOVLW  01
078B0:  SUBWF  x69,W
078B2:  CLRF   03
078B4:  ADDLW  C5
078B6:  MOVWF  FE9
078B8:  MOVLW  00
078BA:  ADDWFC 03,W
078BC:  MOVWF  FEA
078BE:  MOVF   FEF,F
078C0:  BZ    790E
.................... 			send_dsp_command(get_AM_trim_channel(ch-1),0x00000000);	 
078C2:  MOVLW  01
078C4:  SUBWF  x69,W
078C6:  MOVWF  x6B
078C8:  MOVWF  x6D
078CA:  MOVLB  0
078CC:  RCALL  7692
078CE:  MOVFF  03,86E
078D2:  MOVFF  02,86D
078D6:  MOVFF  01,86C
078DA:  MOVFF  00,86B
078DE:  CLRF   19
078E0:  BTFSC  FF2.7
078E2:  BSF    19.7
078E4:  BCF    FF2.7
078E6:  MOVFF  03,8BF
078EA:  MOVFF  02,8BE
078EE:  MOVFF  01,8BD
078F2:  MOVFF  00,8BC
078F6:  MOVLB  8
078F8:  CLRF   xC3
078FA:  CLRF   xC2
078FC:  CLRF   xC1
078FE:  CLRF   xC0
07900:  MOVLB  0
07902:  CALL   0DB0
07906:  BTFSC  19.7
07908:  BSF    FF2.7
.................... 		} else { 
0790A:  BRA    79DC
0790C:  MOVLB  8
.................... 			send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
0790E:  MOVLW  01
07910:  SUBWF  x69,W
07912:  MOVWF  x6B
07914:  MOVWF  x6D
07916:  MOVLB  0
07918:  RCALL  7692
0791A:  MOVFF  03,86E
0791E:  MOVFF  02,86D
07922:  MOVFF  01,86C
07926:  MOVFF  00,86B
0792A:  MOVLW  01
0792C:  MOVLB  8
0792E:  SUBWF  x69,W
07930:  MULLW  04
07932:  MOVF   FF3,W
07934:  CLRF   03
07936:  ADDLW  B5
07938:  MOVWF  FE9
0793A:  MOVLW  00
0793C:  ADDWFC 03,W
0793E:  MOVWF  FEA
07940:  MOVFF  FEF,86F
07944:  MOVFF  FEC,870
07948:  MOVFF  FEC,871
0794C:  MOVFF  FEC,872
07950:  CLRF   19
07952:  BTFSC  FF2.7
07954:  BSF    19.7
07956:  BCF    FF2.7
07958:  MOVFF  872,8EC
0795C:  MOVFF  871,8EB
07960:  MOVFF  870,8EA
07964:  MOVFF  86F,8E9
07968:  CLRF   xF0
0796A:  CLRF   xEF
0796C:  CLRF   xEE
0796E:  MOVLW  9E
07970:  MOVWF  xED
07972:  MOVLB  0
07974:  CALL   1230
07978:  BTFSC  19.7
0797A:  BSF    FF2.7
0797C:  CLRF   19
0797E:  BTFSC  FF2.7
07980:  BSF    19.7
07982:  BCF    FF2.7
07984:  MOVFF  03,8BB
07988:  MOVFF  02,8BA
0798C:  MOVFF  01,8B9
07990:  MOVFF  00,8B8
07994:  CALL   24C8
07998:  BTFSC  19.7
0799A:  BSF    FF2.7
0799C:  MOVFF  03,872
079A0:  MOVFF  02,871
079A4:  MOVFF  01,870
079A8:  MOVFF  00,86F
079AC:  CLRF   19
079AE:  BTFSC  FF2.7
079B0:  BSF    19.7
079B2:  BCF    FF2.7
079B4:  MOVFF  86E,8BF
079B8:  MOVFF  86D,8BE
079BC:  MOVFF  86C,8BD
079C0:  MOVFF  86B,8BC
079C4:  MOVFF  03,8C3
079C8:  MOVFF  02,8C2
079CC:  MOVFF  01,8C1
079D0:  MOVFF  00,8C0
079D4:  CALL   0DB0
079D8:  BTFSC  19.7
079DA:  BSF    FF2.7
.................... 		} 
.................... 	 
.................... 		return rs232_output_mute[(ch-1)]; 
079DC:  MOVLW  01
079DE:  MOVLB  8
079E0:  SUBWF  x69,W
079E2:  CLRF   03
079E4:  ADDLW  C5
079E6:  MOVWF  FE9
079E8:  MOVLW  00
079EA:  ADDWFC 03,W
079EC:  MOVWF  FEA
079EE:  MOVFF  FEF,01
079F2:  MOVLB  0
079F4:  BRA    79F6
.................... 	} 
.................... } 
079F6:  RETURN 0
....................  
.................... #include <timed_getc.c> 
.................... //timed_getc.c 
.................... int timeout_error; 
....................  
.................... short data_available_usb() 
.................... { 
.................... 	return kbhit(USB); 
....................  
....................  
.................... } 
.................... char timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
06E1E:  MOVLB  6
06E20:  CLRF   xD4
.................... 	timeout = 0; 
06E22:  MOVLB  8
06E24:  CLRF   x72
06E26:  CLRF   x71
....................  
.................... 	while(!kbhit(USB)&&(++timeout<50000)) { // half a second 
06E28:  BTFSS  F82.4
06E2A:  BRA    6E4C
06E2C:  INCF   x71,F
06E2E:  BTFSC  FD8.2
06E30:  INCF   x72,F
06E32:  MOVF   x72,W
06E34:  SUBLW  C3
06E36:  BNC   6E4C
06E38:  BNZ   6E40
06E3A:  MOVF   x71,W
06E3C:  SUBLW  4F
06E3E:  BNC   6E4C
.................... 		delay_us(5); // this polls at 10x the 9600 baud rate 
06E40:  MOVLW  05
06E42:  MOVWF  00
06E44:  DECFSZ 00,F
06E46:  BRA    6E44
06E48:  BRA    6E4A
.................... 	} 
06E4A:  BRA    6E28
....................  
.................... 	if(kbhit()) { 
06E4C:  BTFSC  F82.4
06E4E:  BRA    6E60
.................... 		timeout_error = FALSE; 
06E50:  MOVLB  6
06E52:  CLRF   xD4
.................... 		return(fgetc(USB)); 
06E54:  MOVLB  0
06E56:  RCALL  6D20
06E58:  MOVF   01,W
06E5A:  BRA    6E6E
.................... 	} else { 
06E5C:  BRA    6E6E
06E5E:  MOVLB  8
.................... 		timeout_error = TRUE; 
06E60:  MOVLW  01
06E62:  MOVLB  6
06E64:  MOVWF  xD4
.................... 		return(0); 
06E66:  MOVLW  00
06E68:  MOVWF  01
06E6A:  MOVLB  0
06E6C:  BRA    6E6E
.................... 	} 
.................... } 
06E6E:  RETURN 0
....................  
.................... char fast_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
06D6A:  MOVLB  6
06D6C:  CLRF   xD4
.................... 	timeout = 0; 
06D6E:  MOVLB  8
06D70:  CLRF   x6A
06D72:  CLRF   x69
....................  
.................... 	while(!kbhit(USB)&&(++timeout<10000)) { // tenth of a second 
06D74:  BTFSS  F82.4
06D76:  BRA    6D98
06D78:  INCF   x69,F
06D7A:  BTFSC  FD8.2
06D7C:  INCF   x6A,F
06D7E:  MOVF   x6A,W
06D80:  SUBLW  27
06D82:  BNC   6D98
06D84:  BNZ   6D8C
06D86:  MOVF   x69,W
06D88:  SUBLW  0F
06D8A:  BNC   6D98
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
06D8C:  MOVLW  0B
06D8E:  MOVWF  00
06D90:  DECFSZ 00,F
06D92:  BRA    6D90
06D94:  BRA    6D96
.................... 	} 
06D96:  BRA    6D74
....................  
.................... 	if(kbhit()) { 
06D98:  BTFSC  F82.4
06D9A:  BRA    6DAC
.................... 		timeout_error = FALSE; 
06D9C:  MOVLB  6
06D9E:  CLRF   xD4
.................... 		return(getc()); 
06DA0:  MOVLB  0
06DA2:  RCALL  6D20
06DA4:  MOVF   01,W
06DA6:  BRA    6DBA
.................... 	} else { 
06DA8:  BRA    6DBA
06DAA:  MOVLB  8
.................... 		timeout_error = TRUE; 
06DAC:  MOVLW  01
06DAE:  MOVLB  6
06DB0:  MOVWF  xD4
.................... 		return(0); 
06DB2:  MOVLW  00
06DB4:  MOVWF  01
06DB6:  MOVLB  0
06DB8:  BRA    6DBA
.................... 	} 
.................... } 
06DBA:  RETURN 0
....................  
.................... char slow_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
.................... 	timeout = 0; 
....................  
.................... 	while(!kbhit(USB)&&(++timeout<20000)) { // fifth of a second 
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
.................... 	} 
....................  
.................... 	if(kbhit()) { 
.................... 		timeout_error = FALSE; 
.................... 		return(getc()); 
.................... 	} else { 
.................... 		timeout_error = TRUE; 
.................... 		return(0); 
.................... 	} 
.................... } 
....................  
.................... #include <streaming.c> 
.................... // streaming.c 
....................  
.................... #define NIBBLE_SIZE 32 
....................  
.................... /* VARIABLES FOR STREAMING */ 
.................... byte STREAMING_BUFFER[256]; 
....................  
.................... byte STREAM_NIBBLE_BUFFER[32]; 
....................  
.................... int16 streaming_buffer_index = 0; 
.................... int16 bytes_in_stream = 0; 
....................  
.................... int16 num_bytes_added = 0; 
....................  
.................... int stream_target_program = 0; 
.................... int stream_target_page = 0; 
....................  
.................... short is_streaming = 0; 
....................  
.................... int16 total_bytes_so_far = 0; 
....................  
.................... unsigned int nibble_crc = 0; 
....................  
.................... unsigned int verified_bytes = 0; 
.................... int nibble_index = 0; // 0-31 (local in STREAM_NIBBLE_BUFFER) 
....................  
....................  
.................... void flush_nibble_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
074FE:  MOVLB  7
07500:  CLRF   xF6
07502:  CLRF   xF5
.................... 	for(int j = 0; j < 32; j++) { 
07504:  MOVLB  8
07506:  CLRF   x71
07508:  MOVF   x71,W
0750A:  SUBLW  1F
0750C:  BNC   7522
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
0750E:  CLRF   03
07510:  MOVF   x71,W
07512:  ADDLW  D5
07514:  MOVWF  FE9
07516:  MOVLW  07
07518:  ADDWFC 03,W
0751A:  MOVWF  FEA
0751C:  SETF   FEF
.................... 	} 
0751E:  INCF   x71,F
07520:  BRA    7508
....................  
.................... } 
07522:  MOVLB  0
07524:  GOTO   763E (RETURN)
....................  
....................  
.................... void flush_stream_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
073C0:  MOVLB  7
073C2:  CLRF   xF6
073C4:  CLRF   xF5
....................  
.................... 	for(int16 i = 0; i < 256; i++) { 
073C6:  MOVLB  8
073C8:  CLRF   x72
073CA:  CLRF   x71
073CC:  MOVF   x72,W
073CE:  SUBLW  00
073D0:  BNC   73E8
.................... 		STREAMING_BUFFER[i] = 0xFF; 
073D2:  MOVLW  D5
073D4:  ADDWF  x71,W
073D6:  MOVWF  FE9
073D8:  MOVLW  06
073DA:  ADDWFC x72,W
073DC:  MOVWF  FEA
073DE:  SETF   FEF
.................... 	} 
073E0:  INCF   x71,F
073E2:  BTFSC  FD8.2
073E4:  INCF   x72,F
073E6:  BRA    73CC
....................  
.................... 	for(int j = 0; j < 32; j++) { 
073E8:  CLRF   x73
073EA:  MOVF   x73,W
073EC:  SUBLW  1F
073EE:  BNC   7404
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
073F0:  CLRF   03
073F2:  MOVF   x73,W
073F4:  ADDLW  D5
073F6:  MOVWF  FE9
073F8:  MOVLW  07
073FA:  ADDWFC 03,W
073FC:  MOVWF  FEA
073FE:  SETF   FEF
.................... 	} 
07400:  INCF   x73,F
07402:  BRA    73EA
....................  
.................... } 
07404:  MOVLB  0
07406:  RETURN 0
....................  
....................  
....................  
....................  
.................... int calc_crc_int(int *Buffer, int16 Len)  
.................... {  
*
07454:  MOVLB  8
07456:  SETF   x78
07458:  SETF   x77
0745A:  CLRF   x79
....................    int16 x;  
....................    int16 crc = 0xFFFF;  
....................    int return_int = 0; 
....................  
....................    while(Len--)  
....................    {  
0745C:  MOVFF  874,03
07460:  MOVF   x73,W
07462:  BTFSC  FD8.2
07464:  DECF   x74,F
07466:  DECF   x73,F
07468:  IORWF  03,W
0746A:  BZ    74F0
....................       x = make8(crc,1) ^ *Buffer++;  
0746C:  MOVFF  872,03
07470:  MOVF   x71,W
07472:  INCF   x71,F
07474:  BTFSC  FD8.2
07476:  INCF   x72,F
07478:  MOVWF  FE9
0747A:  MOVFF  03,FEA
0747E:  MOVF   FEF,W
07480:  XORWF  x78,W
07482:  MOVWF  x75
07484:  CLRF   x76
....................       x ^= x>>4;  
07486:  RRCF   x76,W
07488:  MOVWF  03
0748A:  RRCF   x75,W
0748C:  MOVWF  02
0748E:  RRCF   03,F
07490:  RRCF   02,F
07492:  RRCF   03,F
07494:  RRCF   02,F
07496:  RRCF   03,F
07498:  RRCF   02,F
0749A:  MOVLW  0F
0749C:  ANDWF  03,F
0749E:  MOVF   02,W
074A0:  XORWF  x75,F
074A2:  MOVF   03,W
074A4:  XORWF  x76,F
....................        
....................       crc = (crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
074A6:  MOVFF  877,87B
074AA:  CLRF   x7A
074AC:  SWAPF  x75,W
074AE:  MOVWF  03
074B0:  CLRF   02
074B2:  MOVLW  F0
074B4:  ANDWF  03,F
074B6:  MOVF   02,W
074B8:  XORWF  x7A,F
074BA:  MOVF   03,W
074BC:  XORWF  x7B,F
074BE:  RLCF   x75,W
074C0:  MOVWF  02
074C2:  RLCF   x76,W
074C4:  MOVWF  03
074C6:  RLCF   02,F
074C8:  RLCF   03,F
074CA:  RLCF   02,F
074CC:  RLCF   03,F
074CE:  RLCF   02,F
074D0:  RLCF   03,F
074D2:  RLCF   02,F
074D4:  RLCF   03,F
074D6:  MOVLW  E0
074D8:  ANDWF  02,F
074DA:  MOVF   02,W
074DC:  XORWF  x7A,F
074DE:  MOVF   03,W
074E0:  XORWF  x7B,F
074E2:  MOVF   x7A,W
074E4:  XORWF  x75,W
074E6:  MOVWF  x77
074E8:  MOVF   x7B,W
074EA:  XORWF  x76,W
074EC:  MOVWF  x78
....................    }  
074EE:  BRA    745C
....................  
.................... 	return_int = crc & 0xFF; 
074F0:  MOVFF  877,879
....................  
....................    	return return_int;  
074F4:  MOVFF  879,01
.................... }  
074F8:  MOVLB  0
074FA:  GOTO   75DE (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... void clear_nibble() 
.................... { 
.................... 	for(int n = 0; n < NIBBLE_SIZE; n++) { 
*
07408:  MOVLB  8
0740A:  CLRF   x71
0740C:  MOVF   x71,W
0740E:  SUBLW  1F
07410:  BNC   7426
.................... 		STREAM_NIBBLE_BUFFER[n] = 0xFF; 
07412:  CLRF   03
07414:  MOVF   x71,W
07416:  ADDLW  D5
07418:  MOVWF  FE9
0741A:  MOVLW  07
0741C:  ADDWFC 03,W
0741E:  MOVWF  FEA
07420:  SETF   FEF
.................... 	} 
07422:  INCF   x71,F
07424:  BRA    740C
....................  
.................... 	nibble_index = 0; 
07426:  CLRF   x02
.................... } 
07428:  MOVLB  0
0742A:  GOTO   7436 (RETURN)
....................  
.................... void add_nibble_to_buffer() 
.................... { 
.................... 	for(int m = 0; m < NIBBLE_SIZE; m++) { 
.................... 		STREAMING_BUFFER[verified_bytes++] = STREAM_NIBBLE_BUFFER[m]; 
.................... 	} 
....................  
.................... 	nibble_index = 0; 
.................... } 
....................  
.................... void kill_stream() 
.................... { 
.................... 	is_streaming = false; 
0742E:  MOVLB  7
07430:  BCF    xFD.0
.................... 	clear_nibble(); 
07432:  MOVLB  0
07434:  BRA    7408
.................... 	flush_stream_buffer(); 
07436:  RCALL  73C0
.................... 	streaming_buffer_index = 0; 
07438:  MOVLB  7
0743A:  CLRF   xF6
0743C:  CLRF   xF5
.................... 	streaming_buffer_index = 0; 
0743E:  CLRF   xF6
07440:  CLRF   xF5
.................... 	nibble_index = 0; 
07442:  MOVLB  8
07444:  CLRF   x02
.................... 	verified_bytes = 0; 
07446:  CLRF   x01
.................... 	total_bytes_so_far = 0; 
07448:  MOVLB  7
0744A:  CLRF   xFF
0744C:  CLRF   xFE
....................  
.................... } 
0744E:  MOVLB  0
07450:  GOTO   75C4 (RETURN)
....................  
.................... void print_stream_to_rs232() 
.................... { 
.................... 	for(int i = 0; i < 32; i++) { 
.................... 		fprintf(RS232,"%u ",STREAM_NIBBLE_BUFFER[i]); 
.................... 	} 
....................  
.................... 	char nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
....................  
.................... 	fprintf(RS232,"CRC = %u\r\n",nibble_crc); 
....................  
.................... 	 
....................  
.................... } 
....................  
.................... void perform_stream(int target_program, int target_page, int16 num_bytes) 
.................... { 
.................... 	 
....................  
.................... 	char streamed_char; 
....................  
.................... 	stream_target_program = target_program; 
*
07528:  MOVFF  869,7FB
.................... 	stream_target_page = target_page; 
0752C:  MOVFF  86A,7FC
.................... 	bytes_in_stream = num_bytes; 
07530:  MOVFF  86C,7F8
07534:  MOVFF  86B,7F7
....................  
.................... 	streaming_buffer_index = 0; 
07538:  MOVLB  7
0753A:  CLRF   xF6
0753C:  CLRF   xF5
.................... 	streaming_buffer_index = 0; 
0753E:  CLRF   xF6
07540:  CLRF   xF5
.................... 	nibble_index = 0; 
07542:  MOVLB  8
07544:  CLRF   x02
.................... 	verified_bytes = 0; 
07546:  CLRF   x01
.................... 	total_bytes_so_far = 0; 
07548:  MOVLB  7
0754A:  CLRF   xFF
0754C:  CLRF   xFE
....................  
.................... 	num_bytes_added = 0; 
0754E:  CLRF   xFA
07550:  CLRF   xF9
.................... 	total_bytes_so_far = 0; 
07552:  CLRF   xFF
07554:  CLRF   xFE
....................  
....................  
.................... 	is_streaming = true; 
07556:  BSF    xFD.0
.................... 	flush_stream_buffer(); 
07558:  MOVLB  0
0755A:  RCALL  73C0
....................  
.................... 	fputc(0x06,USB); 
0755C:  MOVLW  06
0755E:  MOVLB  8
07560:  MOVWF  x72
07562:  MOVLB  0
07564:  RCALL  6DBC
.................... 	fputc(target_program,USB); 
07566:  MOVFF  869,872
0756A:  RCALL  6DBC
.................... 	fputc(target_page,USB); 
0756C:  MOVFF  86A,872
07570:  RCALL  6DBC
.................... 	fputc(0x03,USB); 
07572:  MOVLW  03
07574:  MOVLB  8
07576:  MOVWF  x72
07578:  MOVLB  0
0757A:  RCALL  6DBC
....................  
.................... 	int nibble_byte_counter = 0; 
0757C:  MOVLB  8
0757E:  CLRF   x6E
....................  
.................... 	for(int nibble_counter = 0; nibble_counter <8; nibble_counter++) 
07580:  CLRF   x6F
07582:  MOVF   x6F,W
07584:  SUBLW  07
07586:  BNC   7644
.................... 	{ 
.................... 		nibble_index = 0; 
07588:  CLRF   x02
....................  
.................... 		for(nibble_byte_counter = 0; nibble_byte_counter < 32; nibble_byte_counter++) { 
0758A:  CLRF   x6E
0758C:  MOVF   x6E,W
0758E:  SUBLW  1F
07590:  BNC   75BA
....................  
.................... 			streamed_char = timed_getc(); 
07592:  MOVLB  0
07594:  RCALL  6E1E
07596:  MOVFF  01,86D
.................... 	 
.................... 			total_bytes_so_far++; 
0759A:  MOVLB  7
0759C:  INCF   xFE,F
0759E:  BTFSC  FD8.2
075A0:  INCF   xFF,F
....................  
.................... 			STREAM_NIBBLE_BUFFER[nibble_byte_counter] = streamed_char;	 
075A2:  CLRF   03
075A4:  MOVLB  8
075A6:  MOVF   x6E,W
075A8:  ADDLW  D5
075AA:  MOVWF  FE9
075AC:  MOVLW  07
075AE:  ADDWFC 03,W
075B0:  MOVWF  FEA
075B2:  MOVFF  86D,FEF
.................... 		} 
075B6:  INCF   x6E,F
075B8:  BRA    758C
.................... 	 
.................... 		if(TIMEOUT_ERROR == true) { 
075BA:  MOVLB  6
075BC:  DECFSZ xD4,W
075BE:  BRA    75CA
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"Timed out after having read %lu bytes\r\n",total_bytes_so_far); 
.................... 				fprintf(RS232,"So far we have received: "); 
.................... 				print_stream_to_rs232(); 
.................... 			} 
.................... 			//send_error(ERR_COMMAND_TIMEOUT); 
.................... 			kill_stream(); 
075C0:  MOVLB  0
075C2:  BRA    742E
.................... 			return; 
075C4:  BRA    768E
.................... 		} else { 
075C6:  BRA    763E
075C8:  MOVLB  6
.................... 			 
.................... 			nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
075CA:  MOVLW  07
075CC:  MOVLB  8
075CE:  MOVWF  x72
075D0:  MOVLW  D5
075D2:  MOVWF  x71
075D4:  CLRF   x74
075D6:  MOVLW  20
075D8:  MOVWF  x73
075DA:  MOVLB  0
075DC:  BRA    7454
075DE:  MOVFF  01,800
.................... 			//fprintf(RS232,"GOT FULL NIBBLE. So far %lu. Sending %u CRC\r\n",total_bytes_so_far,nibble_crc); 
.................... 			fputc(nibble_crc,USB); 
075E2:  MOVFF  800,872
075E6:  CALL   6DBC
....................  
.................... 			for(int x = 0; x < 32; x++) { 
075EA:  MOVLB  8
075EC:  CLRF   x70
075EE:  MOVF   x70,W
075F0:  SUBLW  1F
075F2:  BNC   763A
.................... 				STREAMING_BUFFER[num_bytes_added++] = STREAM_NIBBLE_BUFFER[x]; 
075F4:  MOVLB  7
075F6:  MOVFF  7FA,03
075FA:  MOVF   xF9,W
075FC:  INCF   xF9,F
075FE:  BTFSC  FD8.2
07600:  INCF   xFA,F
07602:  MOVLB  8
07604:  MOVWF  x71
07606:  MOVFF  03,872
0760A:  MOVLW  D5
0760C:  ADDWF  x71,W
0760E:  MOVWF  01
07610:  MOVLW  06
07612:  ADDWFC 03,W
07614:  MOVWF  03
07616:  MOVWF  x74
07618:  CLRF   03
0761A:  MOVF   x70,W
0761C:  ADDLW  D5
0761E:  MOVWF  FE9
07620:  MOVLW  07
07622:  ADDWFC 03,W
07624:  MOVWF  FEA
07626:  MOVFF  FEF,875
0762A:  MOVFF  874,FEA
0762E:  MOVFF  01,FE9
07632:  MOVFF  875,FEF
.................... 			} 
07636:  INCF   x70,F
07638:  BRA    75EE
....................  
.................... 			flush_nibble_buffer(); 
0763A:  MOVLB  0
0763C:  BRA    74FE
.................... 		} 
.................... 	} 
0763E:  MOVLB  8
07640:  INCF   x6F,F
07642:  BRA    7582
....................  
.................... 	write_buffer_to_flash_page(&STREAMING_BUFFER,target_program, target_page); 
07644:  MOVLW  06
07646:  MOVWF  x72
07648:  MOVLW  D5
0764A:  MOVWF  x71
0764C:  MOVFF  869,873
07650:  MOVFF  86A,874
07654:  MOVLB  0
07656:  CALL   5EF4
....................  
.................... 	fputc(0x06,USB); 
0765A:  MOVLW  06
0765C:  MOVLB  8
0765E:  MOVWF  x72
07660:  MOVLB  0
07662:  CALL   6DBC
.................... 	fputc(0x01,USB); 
07666:  MOVLW  01
07668:  MOVLB  8
0766A:  MOVWF  x72
0766C:  MOVLB  0
0766E:  CALL   6DBC
.................... 	fputc(target_program,USB); 
07672:  MOVFF  869,872
07676:  CALL   6DBC
.................... 	fputc(target_page,USB); 
0767A:  MOVFF  86A,872
0767E:  CALL   6DBC
.................... 	fputc(0x03,USB); 
07682:  MOVLW  03
07684:  MOVLB  8
07686:  MOVWF  x72
07688:  MOVLB  0
0768A:  CALL   6DBC
....................  
.................... } 
0768E:  GOTO   8C5E (RETURN)
....................  
.................... #include <sa_usb.c> 
.................... char last_byte1,last_byte2,last_byte3,last_byte4,last_address; 
.................... int finished; 
.................... int temp_byte; 
.................... char name_buffer[20]; 
.................... int x, y; 
....................  
.................... void send_error(char error_code) 
.................... { 
.................... 	fputc(ERR_START,USB); 
*
06E02:  MOVLW  15
06E04:  MOVLB  8
06E06:  MOVWF  x72
06E08:  MOVLB  0
06E0A:  RCALL  6DBC
.................... 	fputc(error_code,USB); 
06E0C:  MOVFF  869,872
06E10:  RCALL  6DBC
.................... 	fputc(0x03,USB); 
06E12:  MOVLW  03
06E14:  MOVLB  8
06E16:  MOVWF  x72
06E18:  MOVLB  0
06E1A:  RCALL  6DBC
.................... } 
06E1C:  RETURN 0
....................  
.................... void process_usb_data()  { 
....................  
.................... 	char start_char,command_char,dummy_char,byte1,byte2,byte3,byte4,channel; 
.................... 	int16 addr_lsb, addr_msb; 
.................... 	int16 final_address, last_address; 
....................  
....................  
.................... 	/*if(is_streaming) { 
.................... 		process_stream_byte(); 
.................... 		return; 
.................... 	} 
.................... */ 
.................... 	// Wait until we get a starting char. Escapes after timeout to allow program to continue processing 
....................  
.................... 	start_char = fast_timed_getc(); 
*
07FDE:  CALL   6D6A
07FE2:  MOVFF  01,821
....................  
.................... 	if(TIMEOUT_ERROR == true) { 
07FE6:  MOVLB  6
07FE8:  DECFSZ xD4,W
07FEA:  BRA    7FF0
.................... 		return; 
07FEC:  GOTO   986A
.................... 	} 
.................... 	 
.................... 	/* THIS LIST MUST BE UPDATED WHENEVER WE ADD A NEW START CHARACTER */ 
.................... 	if( 
.................... 		(start_char != 0x02) && // GENERAL 
.................... 		(start_char != 0x04) && // WRITE_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x05) && // GET_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x07) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x08) && // READ_DSP_VALUE 
.................... 		(start_char != 0x09) && // UTILITY 
.................... 		(start_char != 0x10) && // FLASH_PROGRAM_ACTIONS 
.................... 		(start_char != 0x12) && // READ_RS232_VALUE 
.................... 		(start_char != 0x13) && // SET_RS232_VALUE 
.................... 		(start_char != 0x14) && // SET_DEVICE_PROPERTY 
.................... 		(start_char != 0x17) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x15)    // GET_DEVICE_PROPERTY 
.................... 		) 
07FF0:  MOVLB  8
07FF2:  MOVF   x21,W
07FF4:  SUBLW  02
07FF6:  BZ    804C
07FF8:  MOVF   x21,W
07FFA:  SUBLW  04
07FFC:  BZ    804C
07FFE:  MOVF   x21,W
08000:  SUBLW  05
08002:  BZ    804C
08004:  MOVF   x21,W
08006:  SUBLW  07
08008:  BZ    804C
0800A:  MOVF   x21,W
0800C:  SUBLW  08
0800E:  BZ    804C
08010:  MOVF   x21,W
08012:  SUBLW  09
08014:  BZ    804C
08016:  MOVF   x21,W
08018:  SUBLW  10
0801A:  BZ    804C
0801C:  MOVF   x21,W
0801E:  SUBLW  12
08020:  BZ    804C
08022:  MOVF   x21,W
08024:  SUBLW  13
08026:  BZ    804C
08028:  MOVF   x21,W
0802A:  SUBLW  14
0802C:  BZ    804C
0802E:  MOVF   x21,W
08030:  SUBLW  17
08032:  BZ    804C
08034:  MOVF   x21,W
08036:  SUBLW  15
08038:  BZ    804C
.................... 	{ 
.................... 		send_error(ERR_INVALID_START); 
0803A:  MOVLW  02
0803C:  MOVWF  x69
0803E:  MOVLB  0
08040:  CALL   6E02
.................... 		return; 
08044:  MOVLB  6
08046:  GOTO   986A
0804A:  MOVLB  8
.................... 	} 
....................  
....................  
.................... 	if(start_char == 0x02) { 
0804C:  MOVF   x21,W
0804E:  SUBLW  02
08050:  BNZ   8054
.................... 		goto GENERAL; 
08052:  BRA    80A8
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x04) { 
08054:  MOVF   x21,W
08056:  SUBLW  04
08058:  BNZ   805C
.................... 		goto WRITE_DSP_CONFIG_VALUE; 
0805A:  BRA    8312
.................... 	} 
....................  
.................... 	if(start_char == 0x05) { 
0805C:  MOVF   x21,W
0805E:  SUBLW  05
08060:  BNZ   8064
.................... 		goto GET_DSP_CONFIG_VALUE; 
08062:  BRA    859A
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x07) { 
08064:  MOVF   x21,W
08066:  SUBLW  07
08068:  BNZ   806C
.................... 		goto SEND_DSP_VALUE; 
0806A:  BRA    86EE
.................... 	} 
....................  
.................... 	if(start_char == 0x08) { 
0806C:  MOVF   x21,W
0806E:  SUBLW  08
08070:  BNZ   8076
.................... 		goto READ_DSP_VALUE; 
08072:  GOTO   88A8
.................... 	} 
....................  
.................... 	//if(start_char == 0x09) { 
.................... 		//goto UTILITY; 
.................... 	//} 
....................  
.................... 	if(start_char == 0x10) { 
08076:  MOVF   x21,W
08078:  SUBLW  10
0807A:  BNZ   8080
.................... 		goto FLASH_PROGRAM_ACTIONS; 
0807C:  GOTO   89C2
.................... 	} 
.................... /* 
.................... 	if(start_char == 0x11) { 
.................... 		goto PHANTOM_POWER_ACTIONS; 
.................... 	} 
.................... */ 
....................  
.................... 	if(start_char == 0x12) { 
08080:  MOVF   x21,W
08082:  SUBLW  12
08084:  BNZ   808A
.................... 		goto READ_RS232_VALUE; 
08086:  GOTO   8C7A
.................... 	} 
....................  
.................... 	if(start_char == 0x13) { 
0808A:  MOVF   x21,W
0808C:  SUBLW  13
0808E:  BNZ   8094
.................... 		goto SET_RS232_VALUE; 
08090:  GOTO   8DB4
.................... 	} 
....................  
.................... 	if(start_char == 0x14) { 
08094:  MOVF   x21,W
08096:  SUBLW  14
08098:  BNZ   809E
.................... 		goto SET_DEVICE_PROPERTY; 
0809A:  GOTO   8F7C
.................... 	} 
....................  
.................... 	if(start_char == 0x15) { 
0809E:  MOVF   x21,W
080A0:  SUBLW  15
080A2:  BNZ   80A8
.................... 		goto GET_DEVICE_PROPERTY; 
080A4:  GOTO   93E8
.................... 	} 
.................... 	 
....................  
.................... 	/* IF YOU ADD A NEW START CHARACTER, UPDATE THE VALID LIST ABOVE */ 
....................  
....................  
.................... GENERAL: 
.................... 	 
.................... 		command_char = timed_getc(); 
080A8:  MOVLB  0
080AA:  CALL   6E1E
080AE:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
080B2:  MOVLB  6
080B4:  DECFSZ xD4,W
080B6:  BRA    80CA
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
080B8:  MOVLW  10
080BA:  MOVLB  8
080BC:  MOVWF  x69
080BE:  MOVLB  0
080C0:  CALL   6E02
.................... 			return; 
080C4:  MOVLB  6
080C6:  GOTO   986A
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
080CA:  MOVLB  0
080CC:  CALL   6E1E
080D0:  MOVFF  01,823
.................... 	 
.................... 		if(timeout_error == true) { 
080D4:  MOVLB  6
080D6:  DECFSZ xD4,W
080D8:  BRA    80EC
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
080DA:  MOVLW  11
080DC:  MOVLB  8
080DE:  MOVWF  x69
080E0:  MOVLB  0
080E2:  CALL   6E02
.................... 			return; 
080E6:  MOVLB  6
080E8:  GOTO   986A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
080EC:  MOVLB  8
080EE:  MOVF   x23,W
080F0:  SUBLW  03
080F2:  BZ    8106
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
080F4:  MOVLW  12
080F6:  MOVWF  x69
080F8:  MOVLB  0
080FA:  CALL   6E02
.................... 			return; 
080FE:  MOVLB  6
08100:  GOTO   986A
08104:  MOVLB  8
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
08106:  MOVF   x22,W
08108:  XORLW  01
0810A:  MOVLB  0
0810C:  BZ    813A
0810E:  XORLW  05
08110:  BZ    8166
08112:  XORLW  01
08114:  BZ    81A8
08116:  XORLW  02
08118:  BZ    81D8
0811A:  XORLW  0F
0811C:  BTFSC  FD8.2
0811E:  BRA    8214
08120:  XORLW  01
08122:  BTFSC  FD8.2
08124:  BRA    823C
08126:  XORLW  19
08128:  BTFSC  FD8.2
0812A:  BRA    8268
0812C:  XORLW  01
0812E:  BTFSC  FD8.2
08130:  BRA    829A
08132:  XORLW  31
08134:  BTFSC  FD8.2
08136:  BRA    82D4
08138:  BRA    82FE
.................... 			case 0x01 : 
.................... 				// RTS 
.................... 				fputc(0x06,USB); 
0813A:  MOVLW  06
0813C:  MOVLB  8
0813E:  MOVWF  x72
08140:  MOVLB  0
08142:  CALL   6DBC
.................... 				fputc(0x01,USB); 
08146:  MOVLW  01
08148:  MOVLB  8
0814A:  MOVWF  x72
0814C:  MOVLB  0
0814E:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08152:  MOVLW  03
08154:  MOVLB  8
08156:  MOVWF  x72
08158:  MOVLB  0
0815A:  CALL   6DBC
.................... 				return; 
0815E:  MOVLB  6
08160:  GOTO   986A
.................... 			break; 
08164:  BRA    8312
....................  
.................... 			case 0x04 : 
.................... 				// DEVICE ID 
.................... 				fputc(0x06,USB); 
08166:  MOVLW  06
08168:  MOVLB  8
0816A:  MOVWF  x72
0816C:  MOVLB  0
0816E:  CALL   6DBC
.................... 				fputc(0x04,USB); 
08172:  MOVLW  04
08174:  MOVLB  8
08176:  MOVWF  x72
08178:  MOVLB  0
0817A:  CALL   6DBC
.................... 				fputc(DEVICE_ID_MSB,USB); 
0817E:  MOVLB  8
08180:  CLRF   x72
08182:  MOVLB  0
08184:  CALL   6DBC
.................... 				fputc(DEVICE_ID_LSB,USB); 
08188:  MOVLW  0A
0818A:  MOVLB  8
0818C:  MOVWF  x72
0818E:  MOVLB  0
08190:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08194:  MOVLW  03
08196:  MOVLB  8
08198:  MOVWF  x72
0819A:  MOVLB  0
0819C:  CALL   6DBC
.................... 				return; 
081A0:  MOVLB  6
081A2:  GOTO   986A
.................... 			break; 
081A6:  BRA    8312
....................  
.................... 			case 0x05 : 
.................... 				// SOFT REBOOT 
.................... 				softboot(); 
081A8:  CALL   6786
.................... 				fputc(0x06,USB); 
081AC:  MOVLW  06
081AE:  MOVLB  8
081B0:  MOVWF  x72
081B2:  MOVLB  0
081B4:  CALL   6DBC
.................... 				fputc(0x05,USB); 
081B8:  MOVLW  05
081BA:  MOVLB  8
081BC:  MOVWF  x72
081BE:  MOVLB  0
081C0:  CALL   6DBC
.................... 				fputc(0x03,USB); 
081C4:  MOVLW  03
081C6:  MOVLB  8
081C8:  MOVWF  x72
081CA:  MOVLB  0
081CC:  CALL   6DBC
.................... 				return; 
081D0:  MOVLB  6
081D2:  GOTO   986A
.................... 			break; 
081D6:  BRA    8312
....................  
.................... 			case 0x07 : 
.................... 				// Firmware Version 
....................  
.................... 				fputc(0x06,USB); 
081D8:  MOVLW  06
081DA:  MOVLB  8
081DC:  MOVWF  x72
081DE:  MOVLB  0
081E0:  CALL   6DBC
.................... 				fputc(0x07,USB); 
081E4:  MOVLW  07
081E6:  MOVLB  8
081E8:  MOVWF  x72
081EA:  MOVLB  0
081EC:  CALL   6DBC
.................... 				fputc(MAJOR_REVISION,USB); 
081F0:  MOVFF  61,872
081F4:  CALL   6DBC
.................... 				fputc(MINOR_REVISION,USB); 
081F8:  MOVFF  62,872
081FC:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08200:  MOVLW  03
08202:  MOVLB  8
08204:  MOVWF  x72
08206:  MOVLB  0
08208:  CALL   6DBC
.................... 				return; 
0820C:  MOVLB  6
0820E:  GOTO   986A
.................... 			break; 
08212:  BRA    8312
....................  
.................... 			case 0x08 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				fputc(0x06,USB); 
08214:  MOVLW  06
08216:  MOVLB  8
08218:  MOVWF  x72
0821A:  MOVLB  0
0821C:  CALL   6DBC
.................... 				fputc(0x08,USB); 
08220:  MOVLW  08
08222:  MOVLB  8
08224:  MOVWF  x72
08226:  MOVLB  0
08228:  CALL   6DBC
.................... 				fputc(0x03,USB); 
0822C:  MOVLW  03
0822E:  MOVLB  8
08230:  MOVWF  x72
08232:  MOVLB  0
08234:  CALL   6DBC
.................... 			break; 
08238:  MOVLB  6
0823A:  BRA    8312
....................  
.................... 			case 0x09 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				update_phantom_power(); 
0823C:  CALL   671C
....................  
.................... 				fputc(0x06,USB); 
08240:  MOVLW  06
08242:  MOVLB  8
08244:  MOVWF  x72
08246:  MOVLB  0
08248:  CALL   6DBC
.................... 				fputc(0x09,USB); 
0824C:  MOVLW  09
0824E:  MOVLB  8
08250:  MOVWF  x72
08252:  MOVLB  0
08254:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08258:  MOVLW  03
0825A:  MOVLB  8
0825C:  MOVWF  x72
0825E:  MOVLB  0
08260:  CALL   6DBC
.................... 			break; 
08264:  MOVLB  6
08266:  BRA    8312
....................  
....................  
.................... 			case 0x10 : 
.................... 				// DISABLE TIMERS 
....................  
.................... 				SETUP_TIMER_0(RTCC_OFF); 
08268:  CLRF   FD5
.................... 				setup_timer_1(T1_DISABLED); 
0826A:  CLRF   FCD
0826C:  CLRF   FCC
....................  
.................... 				fputc(0x06,USB); 
0826E:  MOVLW  06
08270:  MOVLB  8
08272:  MOVWF  x72
08274:  MOVLB  0
08276:  CALL   6DBC
.................... 				fputc(0x10,USB); 
0827A:  MOVLW  10
0827C:  MOVLB  8
0827E:  MOVWF  x72
08280:  MOVLB  0
08282:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08286:  MOVLW  03
08288:  MOVLB  8
0828A:  MOVWF  x72
0828C:  MOVLB  0
0828E:  CALL   6DBC
.................... 				return; 
08292:  MOVLB  6
08294:  GOTO   986A
.................... 			break; 
08298:  BRA    8312
....................  
.................... 			case 0x11 : 
.................... 				// ENABLE TIMERS 
....................  
.................... 				setup_timer_0(T0_INTERNAL|T0_DIV_64); 
0829A:  MOVLW  85
0829C:  MOVWF  FD5
.................... 				setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0829E:  MOVLW  37
082A0:  MOVWF  FCD
082A2:  CLRF   FCC
....................  
.................... 				setup_interrupts(); 
082A4:  CALL   2916
....................  
.................... 				fputc(0x06,USB); 
082A8:  MOVLW  06
082AA:  MOVLB  8
082AC:  MOVWF  x72
082AE:  MOVLB  0
082B0:  CALL   6DBC
.................... 				fputc(0x11,USB); 
082B4:  MOVLW  11
082B6:  MOVLB  8
082B8:  MOVWF  x72
082BA:  MOVLB  0
082BC:  CALL   6DBC
.................... 				fputc(0x03,USB); 
082C0:  MOVLW  03
082C2:  MOVLB  8
082C4:  MOVWF  x72
082C6:  MOVLB  0
082C8:  CALL   6DBC
.................... 				return; 
082CC:  MOVLB  6
082CE:  GOTO   986A
.................... 			break; 
082D2:  BRA    8312
....................  
....................  
.................... 			case 0x20 : 
.................... 				// Reboot for firmware update 
.................... 				fputc(0x06,USB); 
082D4:  MOVLW  06
082D6:  MOVLB  8
082D8:  MOVWF  x72
082DA:  MOVLB  0
082DC:  CALL   6DBC
.................... 				fputc(0x20,USB); 
082E0:  MOVLW  20
082E2:  MOVLB  8
082E4:  MOVWF  x72
082E6:  MOVLB  0
082E8:  CALL   6DBC
.................... 				fputc(0x03,USB); 
082EC:  MOVLW  03
082EE:  MOVLB  8
082F0:  MOVWF  x72
082F2:  MOVLB  0
082F4:  CALL   6DBC
.................... 				reset_cpu(); 
082F8:  RESET
....................  
.................... 			break; 
082FA:  MOVLB  6
082FC:  BRA    8312
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
082FE:  MOVLW  13
08300:  MOVLB  8
08302:  MOVWF  x69
08304:  MOVLB  0
08306:  CALL   6E02
.................... 				return; 
0830A:  MOVLB  6
0830C:  GOTO   986A
.................... 			break; 
08310:  BRA    8312
.................... 		} 
....................  
.................... WRITE_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
08312:  MOVLB  0
08314:  CALL   6E1E
08318:  MOVLB  8
0831A:  CLRF   x2C
0831C:  MOVFF  01,82B
....................  
.................... 		if(timeout_error == true) { 
08320:  MOVLB  6
08322:  DECFSZ xD4,W
08324:  BRA    8338
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
08326:  MOVLW  14
08328:  MOVLB  8
0832A:  MOVWF  x69
0832C:  MOVLB  0
0832E:  CALL   6E02
.................... 			return; 
08332:  MOVLB  6
08334:  GOTO   986A
.................... 		} 
....................  
.................... 		addr_lsb = timed_getc(); 
08338:  MOVLB  0
0833A:  CALL   6E1E
0833E:  MOVLB  8
08340:  CLRF   x2A
08342:  MOVFF  01,829
....................  
.................... 		if(timeout_error == true) { 
08346:  MOVLB  6
08348:  DECFSZ xD4,W
0834A:  BRA    835E
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
0834C:  MOVLW  14
0834E:  MOVLB  8
08350:  MOVWF  x69
08352:  MOVLB  0
08354:  CALL   6E02
.................... 			return; 
08358:  MOVLB  6
0835A:  GOTO   986A
.................... 		} 
....................  
....................  
.................... 		if(addr_msb > 0) { 
0835E:  MOVLB  8
08360:  MOVF   x2B,F
08362:  BNZ   8368
08364:  MOVF   x2C,F
08366:  BZ    8384
.................... 			final_address = 0; 
08368:  CLRF   x2E
0836A:  CLRF   x2D
.................... 			final_address = addr_msb; 
0836C:  MOVFF  82C,82E
08370:  MOVFF  82B,82D
.................... 			final_address <<= 8; 
08374:  MOVFF  82D,82E
08378:  CLRF   x2D
.................... 			final_address |= addr_lsb; 
0837A:  MOVF   x29,W
0837C:  IORWF  x2D,F
0837E:  MOVF   x2A,W
08380:  IORWF  x2E,F
.................... 		} else { 
08382:  BRA    838C
.................... 			final_address = addr_lsb; 
08384:  MOVFF  82A,82E
08388:  MOVFF  829,82D
.................... 		} 
....................  
.................... 		//if((final_address >= 0) && (final_address <= num_dsp_values)) { 
....................  
.................... 			// byte1 is MSB 
.................... 			byte1 = fast_timed_getc(); 
0838C:  MOVLB  0
0838E:  CALL   6D6A
08392:  MOVFF  01,824
.................... 			byte2 = fast_timed_getc(); 
08396:  CALL   6D6A
0839A:  MOVFF  01,825
.................... 			byte3 = fast_timed_getc(); 
0839E:  CALL   6D6A
083A2:  MOVFF  01,826
.................... 			byte4 = fast_timed_getc(); 
083A6:  CALL   6D6A
083AA:  MOVFF  01,827
....................  
.................... 			if(timeout_error == true) { 
083AE:  MOVLB  6
083B0:  DECFSZ xD4,W
083B2:  BRA    83DE
.................... 				// Timed out on one of the bytes 
.................... 				fputc(0x15,USB); 
083B4:  MOVLW  15
083B6:  MOVLB  8
083B8:  MOVWF  x72
083BA:  MOVLB  0
083BC:  CALL   6DBC
.................... 				fputc(ERR_DATA_TIMEOUT,USB); 
083C0:  MOVLW  17
083C2:  MOVLB  8
083C4:  MOVWF  x72
083C6:  MOVLB  0
083C8:  CALL   6DBC
.................... 				fputc(0x03,USB); 
083CC:  MOVLW  03
083CE:  MOVLB  8
083D0:  MOVWF  x72
083D2:  MOVLB  0
083D4:  CALL   6DBC
.................... 				return; 
083D8:  MOVLB  6
083DA:  GOTO   986A
.................... 			}	 
.................... 			 
.................... 			dummy_char = timed_getc(); 
083DE:  MOVLB  0
083E0:  CALL   6E1E
083E4:  MOVFF  01,823
.................... 	 
.................... 			if(timeout_error == true) { 
083E8:  MOVLB  6
083EA:  DECFSZ xD4,W
083EC:  BRA    8418
.................... 				// Timed out. No command. Start over. 
.................... 				fputc(0x15,USB); 
083EE:  MOVLW  15
083F0:  MOVLB  8
083F2:  MOVWF  x72
083F4:  MOVLB  0
083F6:  CALL   6DBC
.................... 				fputc(ERR_END_TIMEOUT,USB); 
083FA:  MOVLW  11
083FC:  MOVLB  8
083FE:  MOVWF  x72
08400:  MOVLB  0
08402:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08406:  MOVLW  03
08408:  MOVLB  8
0840A:  MOVWF  x72
0840C:  MOVLB  0
0840E:  CALL   6DBC
.................... 				return; 
08412:  MOVLB  6
08414:  GOTO   986A
.................... 			} 
.................... 	 
.................... 			if(dummy_char != 0x03) { 
08418:  MOVLB  8
0841A:  MOVF   x23,W
0841C:  SUBLW  03
0841E:  BZ    844A
.................... 				// Ending char not 0x03 
.................... 				fputc(0x15,USB); 
08420:  MOVLW  15
08422:  MOVWF  x72
08424:  MOVLB  0
08426:  CALL   6DBC
.................... 				fputc(ERR_END_INVALID,USB); 
0842A:  MOVLW  12
0842C:  MOVLB  8
0842E:  MOVWF  x72
08430:  MOVLB  0
08432:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08436:  MOVLW  03
08438:  MOVLB  8
0843A:  MOVWF  x72
0843C:  MOVLB  0
0843E:  CALL   6DBC
.................... 				return; 
08442:  MOVLB  6
08444:  GOTO   986A
08448:  MOVLB  8
.................... 			} 
.................... 			 
.................... 			last_address = final_address; 
0844A:  MOVFF  82E,830
0844E:  MOVFF  82D,82F
.................... 			last_byte1 = byte1; 
08452:  MOVFF  824,803
.................... 			last_byte2 = byte2; 
08456:  MOVFF  825,804
.................... 			last_byte3 = byte3; 
0845A:  MOVFF  826,805
.................... 			last_byte4 = byte4; 
0845E:  MOVFF  827,806
....................  
.................... 			read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
08462:  MOVFF  82E,86A
08466:  MOVFF  82D,869
0846A:  MOVLB  0
0846C:  CALL   6E70
08470:  MOVFF  01,869
08474:  MOVLB  8
08476:  CLRF   x74
08478:  MOVLW  CE
0847A:  MOVWF  x73
0847C:  MOVFF  CD,875
08480:  MOVFF  01,876
08484:  MOVLB  0
08486:  CALL   5E08
....................  
.................... 			int32 new_dsp_value = 0x00000000 | byte1; 
0848A:  MOVLB  8
0848C:  MOVFF  824,831
08490:  CLRF   x32
08492:  CLRF   x33
08494:  CLRF   x34
.................... 			new_dsp_value = new_dsp_value << 8; 
08496:  MOVFF  833,834
0849A:  MOVFF  832,833
0849E:  MOVFF  831,832
084A2:  CLRF   x31
.................... 			new_dsp_value = new_dsp_value | byte2; 
084A4:  MOVF   x25,W
084A6:  IORWF  x31,F
.................... 			new_dsp_value = new_dsp_value << 8; 
084A8:  MOVFF  833,834
084AC:  MOVFF  832,833
084B0:  MOVFF  831,832
084B4:  CLRF   x31
.................... 			new_dsp_value = new_dsp_value | byte3; 
084B6:  MOVF   x26,W
084B8:  IORWF  x31,F
.................... 			new_dsp_value = new_dsp_value << 8; 
084BA:  MOVFF  833,834
084BE:  MOVFF  832,833
084C2:  MOVFF  831,832
084C6:  CLRF   x31
.................... 			new_dsp_value = new_dsp_value | byte4; 
084C8:  MOVF   x27,W
084CA:  IORWF  x31,F
....................  
....................  
.................... 			if(final_address < num_dsp_values) { 
084CC:  MOVF   x2E,W
084CE:  SUBWF  1B,W
084D0:  BNC   8516
084D2:  BNZ   84DA
084D4:  MOVF   1A,W
084D6:  SUBWF  x2D,W
084D8:  BC    8516
.................... 				send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(final_address),new_dsp_value); 
084DA:  MOVFF  82E,874
084DE:  MOVFF  82D,873
084E2:  MOVLB  0
084E4:  CALL   6394
084E8:  MOVFF  02,86A
084EC:  MOVFF  01,869
084F0:  MOVLW  F0
084F2:  MOVLB  8
084F4:  MOVWF  x7A
084F6:  CLRF   x79
084F8:  MOVFF  02,87C
084FC:  MOVFF  01,87B
08500:  MOVFF  834,880
08504:  MOVFF  833,87F
08508:  MOVFF  832,87E
0850C:  MOVFF  831,87D
08510:  MOVLB  0
08512:  CALL   62A8
.................... 			} 
.................... 			PAGE_BUFFER_A[addr_index_to_buffer_index(final_address)] = new_dsp_value; 
08516:  MOVFF  82E,86A
0851A:  MOVFF  82D,869
0851E:  MOVLB  0
08520:  GOTO   6E9A
08524:  MOVF   01,W
08526:  MULLW  04
08528:  MOVF   FF3,W
0852A:  CLRF   03
0852C:  ADDLW  CE
0852E:  MOVWF  FE9
08530:  MOVLW  00
08532:  ADDWFC 03,W
08534:  MOVWF  FEA
08536:  MOVFF  831,FEF
0853A:  MOVFF  832,FEC
0853E:  MOVFF  833,FEC
08542:  MOVFF  834,FEC
....................  
.................... 			write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
08546:  MOVFF  82E,86A
0854A:  MOVFF  82D,869
0854E:  CALL   6E70
08552:  MOVFF  01,869
08556:  MOVLB  8
08558:  CLRF   x72
0855A:  MOVLW  CE
0855C:  MOVWF  x71
0855E:  MOVFF  CD,873
08562:  MOVFF  01,874
08566:  MOVLB  0
08568:  CALL   5EF4
....................  
.................... 			// Send ACK 
.................... 			fputc(0x06,USB); 
0856C:  MOVLW  06
0856E:  MOVLB  8
08570:  MOVWF  x72
08572:  MOVLB  0
08574:  CALL   6DBC
.................... 			fputc(addr_msb,USB); 
08578:  MOVFF  82B,872
0857C:  CALL   6DBC
.................... 			fputc(addr_lsb,USB); 
08580:  MOVFF  829,872
08584:  CALL   6DBC
.................... 			fputc(0x03,USB);	 
08588:  MOVLW  03
0858A:  MOVLB  8
0858C:  MOVWF  x72
0858E:  MOVLB  0
08590:  CALL   6DBC
.................... 			return; 
08594:  MOVLB  6
08596:  GOTO   986A
....................  
.................... 		//} else { 
.................... 		//	// Invalid address 
.................... 		//	send_error(ERR_ADDR_INVALID); 
.................... 		//	return; 
.................... 		//} 
....................  
.................... GET_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
0859A:  MOVLB  0
0859C:  CALL   6E1E
085A0:  MOVLB  8
085A2:  CLRF   x2C
085A4:  MOVFF  01,82B
....................  
.................... 		if(timeout_error == true) { 
085A8:  MOVLB  6
085AA:  DECFSZ xD4,W
085AC:  BRA    85C0
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
085AE:  MOVLW  14
085B0:  MOVLB  8
085B2:  MOVWF  x69
085B4:  MOVLB  0
085B6:  CALL   6E02
.................... 			return; 
085BA:  MOVLB  6
085BC:  GOTO   986A
.................... 		} 
....................  
.................... 		//printf("Got address 1 %u\r\n",addr_index); 
....................  
.................... 		addr_lsb = timed_getc(); 
085C0:  MOVLB  0
085C2:  CALL   6E1E
085C6:  MOVLB  8
085C8:  CLRF   x2A
085CA:  MOVFF  01,829
....................  
.................... 		if(timeout_error == true) { 
085CE:  MOVLB  6
085D0:  DECFSZ xD4,W
085D2:  BRA    85E6
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
085D4:  MOVLW  14
085D6:  MOVLB  8
085D8:  MOVWF  x69
085DA:  MOVLB  0
085DC:  CALL   6E02
.................... 			return; 
085E0:  MOVLB  6
085E2:  GOTO   986A
.................... 		} 
....................  
.................... 		//printf("Got address 2 %u\r\n",addr_index); 
....................  
.................... 		if(addr_lsb == 255) { 
085E6:  MOVLB  8
085E8:  INCFSZ x29,W
085EA:  BRA    8606
085EC:  MOVF   x2A,F
085EE:  BNZ   8606
.................... 			final_address = 0; 
085F0:  CLRF   x2E
085F2:  CLRF   x2D
.................... 			final_address += addr_msb; 
085F4:  MOVF   x2B,W
085F6:  ADDWF  x2D,F
085F8:  MOVF   x2C,W
085FA:  ADDWFC x2E,F
.................... 			final_address += addr_lsb; 
085FC:  MOVF   x29,W
085FE:  ADDWF  x2D,F
08600:  MOVF   x2A,W
08602:  ADDWFC x2E,F
.................... 		} else { 
08604:  BRA    860E
.................... 			final_address = addr_lsb; 
08606:  MOVFF  82A,82E
0860A:  MOVFF  829,82D
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
0860E:  MOVLB  0
08610:  CALL   6E1E
08614:  MOVFF  01,823
....................  
....................  
.................... 		if(timeout_error == true) { 
08618:  MOVLB  6
0861A:  DECFSZ xD4,W
0861C:  BRA    8630
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
0861E:  MOVLW  11
08620:  MOVLB  8
08622:  MOVWF  x69
08624:  MOVLB  0
08626:  CALL   6E02
.................... 			return; 
0862A:  MOVLB  6
0862C:  GOTO   986A
.................... 		} 
.................... 		 
.................... 		if(dummy_char != 0x03) { 
08630:  MOVLB  8
08632:  MOVF   x23,W
08634:  SUBLW  03
08636:  BZ    864A
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
08638:  MOVLW  12
0863A:  MOVWF  x69
0863C:  MOVLB  0
0863E:  CALL   6E02
.................... 			return; 
08642:  MOVLB  6
08644:  GOTO   986A
08648:  MOVLB  8
.................... 		} 
....................  
.................... 		if((final_address >= 0) && (final_address <= num_dsp_values)) { 
0864A:  MOVF   x2E,W
0864C:  SUBWF  1B,W
0864E:  BNC   86DC
08650:  BNZ   8658
08652:  MOVF   x2D,W
08654:  SUBWF  1A,W
08656:  BNC   86DC
....................  
.................... 			// TODO - Re-implement 
.................... 			//int32 value = READ_CONFIG_VALUE(final_address); 
.................... 	 
.................... 			int32 value = 0; 
....................  
.................... 			char byte4 = value & 0xFF; 
08658:  CLRF   x38
0865A:  CLRF   x37
0865C:  CLRF   x36
0865E:  CLRF   x35
08660:  MOVFF  835,839
.................... 			value = value >> 8; 
08664:  MOVFF  836,835
08668:  MOVFF  837,836
0866C:  MOVFF  838,837
08670:  CLRF   x38
.................... 		 
.................... 			char byte3 = value & 0xFF; 
08672:  MOVFF  835,83A
.................... 			value = value >> 8; 
08676:  MOVFF  836,835
0867A:  MOVFF  837,836
0867E:  MOVFF  838,837
08682:  CLRF   x38
.................... 			 
.................... 			char byte2 = value & 0xFF; 
.................... 			char byte1 = value >> 8; 
08684:  MOVFF  835,83B
08688:  MOVFF  836,83C
.................... 		 
.................... 			fputc(0x06,USB); 
0868C:  MOVLW  06
0868E:  MOVWF  x72
08690:  MOVLB  0
08692:  CALL   6DBC
.................... 			fputc(addr_msb,USB); 
08696:  MOVFF  82B,872
0869A:  CALL   6DBC
.................... 			fputc(addr_lsb,USB); 
0869E:  MOVFF  829,872
086A2:  CALL   6DBC
.................... 			fputc(byte1,USB); 
086A6:  MOVFF  83C,872
086AA:  CALL   6DBC
.................... 			fputc(byte2,USB); 
086AE:  MOVFF  83B,872
086B2:  CALL   6DBC
.................... 			fputc(byte3,USB); 
086B6:  MOVFF  83A,872
086BA:  CALL   6DBC
.................... 			fputc(byte4,USB); 
086BE:  MOVFF  839,872
086C2:  CALL   6DBC
.................... 			fputc(0x03,USB); 
086C6:  MOVLW  03
086C8:  MOVLB  8
086CA:  MOVWF  x72
086CC:  MOVLB  0
086CE:  CALL   6DBC
.................... 			return; 
086D2:  MOVLB  6
086D4:  GOTO   986A
.................... 	 
.................... 		} else { 
086D8:  BRA    86EC
086DA:  MOVLB  8
.................... 			// Invalid address 
.................... 			send_error(ERR_ADDR_INVALID); 
086DC:  MOVLW  16
086DE:  MOVWF  x69
086E0:  MOVLB  0
086E2:  CALL   6E02
.................... 			return; 
086E6:  MOVLB  6
086E8:  GOTO   986A
086EC:  MOVLB  8
.................... 		} 
....................  
.................... 	// END GET_VALUE label 
....................  
.................... SEND_DSP_VALUE: 
....................  
.................... 		byte addr_byte1,addr_byte2,addr_byte3,addr_byte4; 
.................... 		byte val_byte1,val_byte2,val_byte3,val_byte4; 
....................  
.................... 		addr_byte1 = fast_timed_getc(); 
086EE:  MOVLB  0
086F0:  CALL   6D6A
086F4:  MOVFF  01,83D
.................... 		addr_byte2 = fast_timed_getc(); 
086F8:  CALL   6D6A
086FC:  MOVFF  01,83E
.................... 		addr_byte3 = fast_timed_getc(); 
08700:  CALL   6D6A
08704:  MOVFF  01,83F
.................... 		addr_byte4 = fast_timed_getc(); 
08708:  CALL   6D6A
0870C:  MOVFF  01,840
....................  
.................... 		val_byte1 = fast_timed_getc(); 
08710:  CALL   6D6A
08714:  MOVFF  01,841
.................... 		val_byte2 = fast_timed_getc(); 
08718:  CALL   6D6A
0871C:  MOVFF  01,842
.................... 		val_byte3 = fast_timed_getc(); 
08720:  CALL   6D6A
08724:  MOVFF  01,843
.................... 		val_byte4 = fast_timed_getc(); 
08728:  CALL   6D6A
0872C:  MOVFF  01,844
....................  
.................... 		if(timeout_error == true) { 
08730:  MOVLB  6
08732:  DECFSZ xD4,W
08734:  BRA    8760
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
08736:  MOVLW  15
08738:  MOVLB  8
0873A:  MOVWF  x72
0873C:  MOVLB  0
0873E:  CALL   6DBC
.................... 			fputc(0x17,USB); 
08742:  MOVLW  17
08744:  MOVLB  8
08746:  MOVWF  x72
08748:  MOVLB  0
0874A:  CALL   6DBC
.................... 			fputc(0x03,USB); 
0874E:  MOVLW  03
08750:  MOVLB  8
08752:  MOVWF  x72
08754:  MOVLB  0
08756:  CALL   6DBC
.................... 			return; 
0875A:  MOVLB  6
0875C:  GOTO   986A
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08760:  MOVLB  0
08762:  CALL   6E1E
08766:  MOVFF  01,823
....................  
.................... 		if(timeout_error == true) { 
0876A:  MOVLB  6
0876C:  DECFSZ xD4,W
0876E:  BRA    879A
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
08770:  MOVLW  15
08772:  MOVLB  8
08774:  MOVWF  x72
08776:  MOVLB  0
08778:  CALL   6DBC
.................... 			fputc(ERR_END_TIMEOUT,USB); 
0877C:  MOVLW  11
0877E:  MOVLB  8
08780:  MOVWF  x72
08782:  MOVLB  0
08784:  CALL   6DBC
.................... 			fputc(0x03,USB); 
08788:  MOVLW  03
0878A:  MOVLB  8
0878C:  MOVWF  x72
0878E:  MOVLB  0
08790:  CALL   6DBC
.................... 			return; 
08794:  MOVLB  6
08796:  GOTO   986A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
0879A:  MOVLB  8
0879C:  MOVF   x23,W
0879E:  SUBLW  03
087A0:  BZ    87CC
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
087A2:  MOVLW  15
087A4:  MOVWF  x72
087A6:  MOVLB  0
087A8:  CALL   6DBC
.................... 			fputc(0x13,USB); 
087AC:  MOVLW  13
087AE:  MOVLB  8
087B0:  MOVWF  x72
087B2:  MOVLB  0
087B4:  CALL   6DBC
.................... 			fputc(0x03,USB); 
087B8:  MOVLW  03
087BA:  MOVLB  8
087BC:  MOVWF  x72
087BE:  MOVLB  0
087C0:  CALL   6DBC
.................... 			return; 
087C4:  MOVLB  6
087C6:  GOTO   986A
087CA:  MOVLB  8
.................... 		} 
....................  
.................... 		 
....................  
.................... 		int32 debug_address = 0x00000000 | addr_byte1; 
087CC:  MOVFF  83D,845
087D0:  CLRF   x46
087D2:  CLRF   x47
087D4:  CLRF   x48
.................... 		debug_address = debug_address << 8; 
087D6:  MOVFF  847,848
087DA:  MOVFF  846,847
087DE:  MOVFF  845,846
087E2:  CLRF   x45
.................... 		debug_address = debug_address | addr_byte2; 
087E4:  MOVF   x3E,W
087E6:  IORWF  x45,F
.................... 		debug_address = debug_address << 8; 
087E8:  MOVFF  847,848
087EC:  MOVFF  846,847
087F0:  MOVFF  845,846
087F4:  CLRF   x45
.................... 		debug_address = debug_address | addr_byte3; 
087F6:  MOVF   x3F,W
087F8:  IORWF  x45,F
.................... 		debug_address = debug_address << 8; 
087FA:  MOVFF  847,848
087FE:  MOVFF  846,847
08802:  MOVFF  845,846
08806:  CLRF   x45
.................... 		debug_address = debug_address | addr_byte4; 
08808:  MOVF   x40,W
0880A:  IORWF  x45,F
....................  
.................... 		int32 debug_value = 0x00000000 | val_byte1; 
0880C:  MOVFF  841,849
08810:  CLRF   x4A
08812:  CLRF   x4B
08814:  CLRF   x4C
.................... 		debug_value = debug_value << 8; 
08816:  MOVFF  84B,84C
0881A:  MOVFF  84A,84B
0881E:  MOVFF  849,84A
08822:  CLRF   x49
.................... 		debug_value = debug_value | val_byte2; 
08824:  MOVF   x42,W
08826:  IORWF  x49,F
.................... 		debug_value = debug_value << 8; 
08828:  MOVFF  84B,84C
0882C:  MOVFF  84A,84B
08830:  MOVFF  849,84A
08834:  CLRF   x49
.................... 		debug_value = debug_value | val_byte3; 
08836:  MOVF   x43,W
08838:  IORWF  x49,F
.................... 		debug_value = debug_value << 8; 
0883A:  MOVFF  84B,84C
0883E:  MOVFF  84A,84B
08842:  MOVFF  849,84A
08846:  CLRF   x49
.................... 		debug_value = debug_value | val_byte4; 
08848:  MOVF   x44,W
0884A:  IORWF  x49,F
0884C:  CLRF   19
0884E:  BTFSC  FF2.7
08850:  BSF    19.7
08852:  BCF    FF2.7
.................... 			 
.................... 		send_dsp_command(debug_address,debug_value); 
08854:  MOVFF  848,8BF
08858:  MOVFF  847,8BE
0885C:  MOVFF  846,8BD
08860:  MOVFF  845,8BC
08864:  MOVFF  84C,8C3
08868:  MOVFF  84B,8C2
0886C:  MOVFF  84A,8C1
08870:  MOVFF  849,8C0
08874:  MOVLB  0
08876:  CALL   0DB0
0887A:  BTFSC  19.7
0887C:  BSF    FF2.7
....................  
.................... 		fputc(0x06); 
0887E:  MOVLW  06
08880:  MOVLB  8
08882:  MOVWF  x72
08884:  MOVLB  0
08886:  CALL   6DBC
.................... 		fputc(0x07); 
0888A:  MOVLW  07
0888C:  MOVLB  8
0888E:  MOVWF  x72
08890:  MOVLB  0
08892:  CALL   6DBC
.................... 		fputc(0x03); 
08896:  MOVLW  03
08898:  MOVLB  8
0889A:  MOVWF  x72
0889C:  MOVLB  0
0889E:  CALL   6DBC
....................  
....................  
.................... 		return; 
088A2:  MOVLB  6
088A4:  GOTO   986A
....................  
.................... READ_DSP_VALUE: 
....................  
.................... 		byte1 = fast_timed_getc(); 
088A8:  MOVLB  0
088AA:  CALL   6D6A
088AE:  MOVFF  01,824
.................... 		byte2 = fast_timed_getc(); 
088B2:  CALL   6D6A
088B6:  MOVFF  01,825
.................... 		byte3 = fast_timed_getc(); 
088BA:  CALL   6D6A
088BE:  MOVFF  01,826
.................... 		byte4 = fast_timed_getc(); 
088C2:  CALL   6D6A
088C6:  MOVFF  01,827
....................  
.................... 		if(timeout_error == true) { 
088CA:  MOVLB  6
088CC:  DECFSZ xD4,W
088CE:  BRA    88FA
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
088D0:  MOVLW  15
088D2:  MOVLB  8
088D4:  MOVWF  x72
088D6:  MOVLB  0
088D8:  CALL   6DBC
.................... 			fputc(0x17,USB); 
088DC:  MOVLW  17
088DE:  MOVLB  8
088E0:  MOVWF  x72
088E2:  MOVLB  0
088E4:  CALL   6DBC
.................... 			fputc(0x03,USB); 
088E8:  MOVLW  03
088EA:  MOVLB  8
088EC:  MOVWF  x72
088EE:  MOVLB  0
088F0:  CALL   6DBC
.................... 			return; 
088F4:  MOVLB  6
088F6:  GOTO   986A
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
088FA:  MOVLB  0
088FC:  CALL   6E1E
08900:  MOVFF  01,823
....................  
.................... 		if(timeout_error == true) { 
08904:  MOVLB  6
08906:  DECFSZ xD4,W
08908:  BRA    8934
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
0890A:  MOVLW  15
0890C:  MOVLB  8
0890E:  MOVWF  x72
08910:  MOVLB  0
08912:  CALL   6DBC
.................... 			fputc(ERR_END_TIMEOUT,USB); 
08916:  MOVLW  11
08918:  MOVLB  8
0891A:  MOVWF  x72
0891C:  MOVLB  0
0891E:  CALL   6DBC
.................... 			fputc(0x03,USB); 
08922:  MOVLW  03
08924:  MOVLB  8
08926:  MOVWF  x72
08928:  MOVLB  0
0892A:  CALL   6DBC
.................... 			return; 
0892E:  MOVLB  6
08930:  GOTO   986A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08934:  MOVLB  8
08936:  MOVF   x23,W
08938:  SUBLW  03
0893A:  BZ    8966
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
0893C:  MOVLW  15
0893E:  MOVWF  x72
08940:  MOVLB  0
08942:  CALL   6DBC
.................... 			fputc(0x13,USB); 
08946:  MOVLW  13
08948:  MOVLB  8
0894A:  MOVWF  x72
0894C:  MOVLB  0
0894E:  CALL   6DBC
.................... 			fputc(0x03,USB); 
08952:  MOVLW  03
08954:  MOVLB  8
08956:  MOVWF  x72
08958:  MOVLB  0
0895A:  CALL   6DBC
.................... 			return; 
0895E:  MOVLB  6
08960:  GOTO   986A
08964:  MOVLB  8
.................... 		} 
....................  
.................... 		int32 address = 0x00000000 | byte1; 
08966:  MOVFF  824,84D
0896A:  CLRF   x4E
0896C:  CLRF   x4F
0896E:  CLRF   x50
.................... 		address = address << 8; 
08970:  MOVFF  84F,850
08974:  MOVFF  84E,84F
08978:  MOVFF  84D,84E
0897C:  CLRF   x4D
.................... 		address = address | byte2; 
0897E:  MOVF   x25,W
08980:  IORWF  x4D,F
.................... 		address = address << 8; 
08982:  MOVFF  84F,850
08986:  MOVFF  84E,84F
0898A:  MOVFF  84D,84E
0898E:  CLRF   x4D
.................... 		address = address | byte3; 
08990:  MOVF   x26,W
08992:  IORWF  x4D,F
.................... 		address = address << 8; 
08994:  MOVFF  84F,850
08998:  MOVFF  84E,84F
0899C:  MOVFF  84D,84E
089A0:  CLRF   x4D
.................... 		address = address | byte4; 
089A2:  MOVF   x27,W
089A4:  IORWF  x4D,F
.................... 			 
.................... 		read_dsp_and_send_to_usb(address); 
089A6:  MOVFF  850,86C
089AA:  MOVFF  84F,86B
089AE:  MOVFF  84E,86A
089B2:  MOVFF  84D,869
089B6:  MOVLB  0
089B8:  GOTO   6F16
....................  
.................... 		return; 
089BC:  MOVLB  6
089BE:  GOTO   986A
....................  
....................  
....................  
.................... FLASH_PROGRAM_ACTIONS: 
....................  
.................... 		command_char = timed_getc(); 
089C2:  MOVLB  0
089C4:  CALL   6E1E
089C8:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
089CC:  MOVLB  6
089CE:  DECFSZ xD4,W
089D0:  BRA    89E4
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
089D2:  MOVLW  10
089D4:  MOVLB  8
089D6:  MOVWF  x69
089D8:  MOVLB  0
089DA:  CALL   6E02
.................... 			return; 
089DE:  MOVLB  6
089E0:  GOTO   986A
.................... 		} 
....................  
.................... 		if(command_char == 0x04 || command_char == 0x05 || command_char == 0x09 || command_char == 0x11) { 
089E4:  MOVLB  8
089E6:  MOVF   x22,W
089E8:  SUBLW  04
089EA:  BZ    89FE
089EC:  MOVF   x22,W
089EE:  SUBLW  05
089F0:  BZ    89FE
089F2:  MOVF   x22,W
089F4:  SUBLW  09
089F6:  BZ    89FE
089F8:  MOVF   x22,W
089FA:  SUBLW  11
089FC:  BNZ   8A1C
.................... 			addr_msb = timed_getc(); 
089FE:  MOVLB  0
08A00:  CALL   6E1E
08A04:  MOVLB  8
08A06:  CLRF   x2C
08A08:  MOVFF  01,82B
.................... 			addr_lsb = timed_getc(); 
08A0C:  MOVLB  0
08A0E:  CALL   6E1E
08A12:  MOVLB  8
08A14:  CLRF   x2A
08A16:  MOVFF  01,829
.................... 		} else { 
08A1A:  BRA    8A26
.................... 			temp_byte = timed_getc(); 
08A1C:  MOVLB  0
08A1E:  CALL   6E1E
08A22:  MOVFF  01,809
....................  
.................... 		} 
.................... 	 
.................... 		if(timeout_error == true) { 
08A26:  MOVLB  6
08A28:  DECFSZ xD4,W
08A2A:  BRA    8A3E
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08A2C:  MOVLW  17
08A2E:  MOVLB  8
08A30:  MOVWF  x69
08A32:  MOVLB  0
08A34:  CALL   6E02
.................... 			return; 
08A38:  MOVLB  6
08A3A:  GOTO   986A
.................... 		} 
.................... 		 
.................... 	 
.................... 		 
....................  
.................... 		char stream_size_msb,stream_size_lsb; 
....................  
.................... 		if(command_char == 0x11) { 
08A3E:  MOVLB  8
08A40:  MOVF   x22,W
08A42:  SUBLW  11
08A44:  BNZ   8A58
.................... 			stream_size_msb = timed_getc(); 
08A46:  MOVLB  0
08A48:  CALL   6E1E
08A4C:  MOVFF  01,851
.................... 			stream_size_lsb = timed_getc(); 
08A50:  CALL   6E1E
08A54:  MOVFF  01,852
.................... 		}	 
....................  
.................... 		dummy_char = timed_getc(); 
08A58:  MOVLB  0
08A5A:  CALL   6E1E
08A5E:  MOVFF  01,823
....................  
.................... 		if(timeout_error == true) { 
08A62:  MOVLB  6
08A64:  DECFSZ xD4,W
08A66:  BRA    8A7A
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08A68:  MOVLW  11
08A6A:  MOVLB  8
08A6C:  MOVWF  x69
08A6E:  MOVLB  0
08A70:  CALL   6E02
.................... 			return; 
08A74:  MOVLB  6
08A76:  GOTO   986A
.................... 		} 
....................  
.................... 		switch(command_char) { 
08A7A:  MOVLB  8
08A7C:  MOVF   x22,W
08A7E:  XORLW  01
08A80:  MOVLB  0
08A82:  BZ    8AA4
08A84:  XORLW  03
08A86:  BZ    8AE0
08A88:  XORLW  06
08A8A:  BZ    8B18
08A8C:  XORLW  01
08A8E:  BZ    8B54
08A90:  XORLW  0D
08A92:  BTFSC  FD8.2
08A94:  BRA    8B9C
08A96:  XORLW  01
08A98:  BTFSC  FD8.2
08A9A:  BRA    8BD0
08A9C:  XORLW  18
08A9E:  BTFSC  FD8.2
08AA0:  BRA    8C34
08AA2:  BRA    8C66
....................  
.................... 			case 0x01 : 
.................... 				// SWITCH ACTIVE PROGRAM 
.................... 				switch_flash_program(temp_byte); 
08AA4:  MOVFF  809,869
08AA8:  CALL   70A8
.................... 				fputc(0x06,USB); 
08AAC:  MOVLW  06
08AAE:  MOVLB  8
08AB0:  MOVWF  x72
08AB2:  MOVLB  0
08AB4:  CALL   6DBC
.................... 				fputc(0x01,USB); 
08AB8:  MOVLW  01
08ABA:  MOVLB  8
08ABC:  MOVWF  x72
08ABE:  MOVLB  0
08AC0:  CALL   6DBC
.................... 				fputc(temp_byte,USB); 
08AC4:  MOVFF  809,872
08AC8:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08ACC:  MOVLW  03
08ACE:  MOVLB  8
08AD0:  MOVWF  x72
08AD2:  MOVLB  0
08AD4:  CALL   6DBC
.................... 				return; 
08AD8:  MOVLB  6
08ADA:  GOTO   986A
.................... 			break; 
08ADE:  BRA    8C7A
....................  
.................... 			case 0x02 : 
.................... 				// SAVE ACTIVE PROGRAM 
....................  
.................... 				save_flash_program(); 
08AE0:  GOTO   0004
....................  
.................... 				fputc(0x06,USB); 
08AE4:  MOVLW  06
08AE6:  MOVLB  8
08AE8:  MOVWF  x72
08AEA:  MOVLB  0
08AEC:  CALL   6DBC
.................... 				fputc(0x02,USB); 
08AF0:  MOVLW  02
08AF2:  MOVLB  8
08AF4:  MOVWF  x72
08AF6:  MOVLB  0
08AF8:  CALL   6DBC
.................... 				fputc(temp_byte,USB); 
08AFC:  MOVFF  809,872
08B00:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08B04:  MOVLW  03
08B06:  MOVLB  8
08B08:  MOVWF  x72
08B0A:  MOVLB  0
08B0C:  CALL   6DBC
.................... 				return; 
08B10:  MOVLB  6
08B12:  GOTO   986A
.................... 			break; 
08B16:  BRA    8C7A
....................  
.................... 			case 0x04 : 
....................  
.................... 				// SAVE ACTIVE SECTOR 
....................  
.................... 				fputc(0x06,USB); 
08B18:  MOVLW  06
08B1A:  MOVLB  8
08B1C:  MOVWF  x72
08B1E:  MOVLB  0
08B20:  CALL   6DBC
.................... 				fputc(0x05,USB); 
08B24:  MOVLW  05
08B26:  MOVLB  8
08B28:  MOVWF  x72
08B2A:  MOVLB  0
08B2C:  CALL   6DBC
.................... 				fputc(addr_msb,USB); 
08B30:  MOVFF  82B,872
08B34:  CALL   6DBC
.................... 				fputc(addr_lsb,USB); 
08B38:  MOVFF  829,872
08B3C:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08B40:  MOVLW  03
08B42:  MOVLB  8
08B44:  MOVWF  x72
08B46:  MOVLB  0
08B48:  CALL   6DBC
.................... 				return; 
08B4C:  MOVLB  6
08B4E:  GOTO   986A
.................... 			break; 
08B52:  BRA    8C7A
....................  
.................... 			case 0x05 : 
....................  
.................... 				FLASH_COPY_PROGRAM(addr_msb,addr_lsb); 
08B54:  MOVFF  82B,869
08B58:  MOVFF  829,86A
08B5C:  GOTO   70EA
....................  
.................... 				fputc(0x06,USB); 
08B60:  MOVLW  06
08B62:  MOVLB  8
08B64:  MOVWF  x72
08B66:  MOVLB  0
08B68:  CALL   6DBC
.................... 				fputc(0x05,USB); 
08B6C:  MOVLW  05
08B6E:  MOVLB  8
08B70:  MOVWF  x72
08B72:  MOVLB  0
08B74:  CALL   6DBC
.................... 				fputc(addr_msb,USB); 
08B78:  MOVFF  82B,872
08B7C:  CALL   6DBC
.................... 				fputc(addr_lsb,USB); 
08B80:  MOVFF  829,872
08B84:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08B88:  MOVLW  03
08B8A:  MOVLB  8
08B8C:  MOVWF  x72
08B8E:  MOVLB  0
08B90:  CALL   6DBC
.................... 				return; 
08B94:  MOVLB  6
08B96:  GOTO   986A
.................... 			break; 
08B9A:  BRA    8C7A
....................  
....................  
.................... 			case 0x08 : 
....................  
.................... 				// GET ACTIVE PROGRAM INDEX 
....................  
.................... 				fputc(0x06,USB); 
08B9C:  MOVLW  06
08B9E:  MOVLB  8
08BA0:  MOVWF  x72
08BA2:  MOVLB  0
08BA4:  CALL   6DBC
.................... 				fputc(0x08,USB); 
08BA8:  MOVLW  08
08BAA:  MOVLB  8
08BAC:  MOVWF  x72
08BAE:  MOVLB  0
08BB0:  CALL   6DBC
.................... 				fputc(CURRENT_FLASH_PROGRAM,USB); 
08BB4:  MOVFF  CD,872
08BB8:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08BBC:  MOVLW  03
08BBE:  MOVLB  8
08BC0:  MOVWF  x72
08BC2:  MOVLB  0
08BC4:  CALL   6DBC
.................... 				return; 
08BC8:  MOVLB  6
08BCA:  GOTO   986A
.................... 			break; 
08BCE:  BRA    8C7A
....................  
.................... 			case 0x09 : 
....................  
.................... 				// STREAM PROGRAM BLOCK TO USB 
....................  
.................... 				read_flash_page_into_buffer(&PAGE_BUFFER_A,addr_msb,addr_lsb); 
08BD0:  MOVLB  8
08BD2:  CLRF   x74
08BD4:  MOVLW  CE
08BD6:  MOVWF  x73
08BD8:  MOVFF  82B,875
08BDC:  MOVFF  829,876
08BE0:  MOVLB  0
08BE2:  CALL   5E08
....................  
.................... 				fputc(0x06,USB); 
08BE6:  MOVLW  06
08BE8:  MOVLB  8
08BEA:  MOVWF  x72
08BEC:  MOVLB  0
08BEE:  CALL   6DBC
.................... 				fputc(0x09,USB); 
08BF2:  MOVLW  09
08BF4:  MOVLB  8
08BF6:  MOVWF  x72
08BF8:  MOVLB  0
08BFA:  CALL   6DBC
.................... 				fputc(addr_msb,USB); 
08BFE:  MOVFF  82B,872
08C02:  CALL   6DBC
.................... 				fputc(addr_lsb,USB); 
08C06:  MOVFF  829,872
08C0A:  CALL   6DBC
....................  
.................... 				write_buffer_to_stream(&PAGE_BUFFER_A); 
08C0E:  MOVLB  8
08C10:  CLRF   x6A
08C12:  MOVLW  CE
08C14:  MOVWF  x69
08C16:  MOVLW  01
08C18:  MOVWF  x6B
08C1A:  MOVLB  0
08C1C:  GOTO   736E
....................  
.................... 				fputc(0x03,USB); 
08C20:  MOVLW  03
08C22:  MOVLB  8
08C24:  MOVWF  x72
08C26:  MOVLB  0
08C28:  CALL   6DBC
.................... 				return; 
08C2C:  MOVLB  6
08C2E:  GOTO   986A
.................... 			break; 
08C32:  BRA    8C7A
....................  
.................... 			case 0x11 : 
.................... 				 
.................... 				 
.................... 				int16 stream_size = 0; 
08C34:  MOVLB  8
08C36:  CLRF   x54
08C38:  CLRF   x53
.................... 		 
.................... 				//fprintf(RS232,"Stream size MSB = %x, Stream size LSB = %x\r\n",stream_size_msb,stream_size_lsb); 
.................... 				stream_size = stream_size | stream_size_msb; 
08C3A:  MOVF   x51,W
08C3C:  IORWF  x53,F
.................... 				stream_size <<= 8; 
08C3E:  MOVFF  853,854
08C42:  CLRF   x53
.................... 				stream_size = stream_size | stream_size_lsb; 
08C44:  MOVF   x52,W
08C46:  IORWF  x53,F
....................  
.................... 				/*if(data_available_usb()) { 
.................... 					fprintf(RS232,"Data still available on USB...\r\n"); 
.................... 				} else { 
.................... 					fprintf(RS232,"NO data available on USB...\r\n"); 
.................... 				} 
.................... */ 
.................... 				// initiate_stream(int target_program, int target_page, int16 num_bytes) 
.................... 				//initiate_stream(addr_msb,addr_lsb,stream_size); 
.................... 				perform_stream(addr_msb,addr_lsb,stream_size); 
08C48:  MOVFF  82B,869
08C4C:  MOVFF  829,86A
08C50:  MOVFF  854,86C
08C54:  MOVFF  853,86B
08C58:  MOVLB  0
08C5A:  GOTO   7528
.................... 				return; 
08C5E:  MOVLB  6
08C60:  GOTO   986A
.................... 				 
....................  
.................... 			break; 
08C64:  BRA    8C7A
....................  
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
08C66:  MOVLW  13
08C68:  MOVLB  8
08C6A:  MOVWF  x69
08C6C:  MOVLB  0
08C6E:  CALL   6E02
.................... 				return; 
08C72:  MOVLB  6
08C74:  GOTO   986A
.................... 			break; 
08C78:  BRA    8C7A
....................  
.................... 		} 
....................  
.................... READ_RS232_VALUE: 
.................... 	 
.................... 		command_char = timed_getc(); 
08C7A:  MOVLB  0
08C7C:  CALL   6E1E
08C80:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
08C84:  MOVLB  6
08C86:  DECFSZ xD4,W
08C88:  BRA    8C9C
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08C8A:  MOVLW  10
08C8C:  MOVLB  8
08C8E:  MOVWF  x69
08C90:  MOVLB  0
08C92:  CALL   6E02
.................... 			return; 
08C96:  MOVLB  6
08C98:  GOTO   986A
.................... 		} 
....................  
.................... 		channel = timed_getc(); 
08C9C:  MOVLB  0
08C9E:  CALL   6E1E
08CA2:  MOVFF  01,828
....................  
.................... 		if(timeout_error == true) { 
08CA6:  MOVLB  6
08CA8:  DECFSZ xD4,W
08CAA:  BRA    8CBE
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_RS232_CH_TIMEOUT); 
08CAC:  MOVLW  26
08CAE:  MOVLB  8
08CB0:  MOVWF  x69
08CB2:  MOVLB  0
08CB4:  CALL   6E02
.................... 			return; 
08CB8:  MOVLB  6
08CBA:  GOTO   986A
.................... 		} 
....................  
.................... 		// TODO - this is zero based but use NUM_CHANNELS later 
.................... 		if(channel > 4) { 
08CBE:  MOVLB  8
08CC0:  MOVF   x28,W
08CC2:  SUBLW  04
08CC4:  BC    8CD6
.................... 			send_error(ERR_RS232_CH_INVALID); 
08CC6:  MOVLW  27
08CC8:  MOVWF  x69
08CCA:  MOVLB  0
08CCC:  CALL   6E02
.................... 			return; 
08CD0:  MOVLB  6
08CD2:  GOTO   986A
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
08CD6:  MOVLB  0
08CD8:  CALL   6E1E
08CDC:  MOVFF  01,823
.................... 	 
.................... 		if(timeout_error == true) { 
08CE0:  MOVLB  6
08CE2:  DECFSZ xD4,W
08CE4:  BRA    8CF8
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08CE6:  MOVLW  11
08CE8:  MOVLB  8
08CEA:  MOVWF  x69
08CEC:  MOVLB  0
08CEE:  CALL   6E02
.................... 			return; 
08CF2:  MOVLB  6
08CF4:  GOTO   986A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08CF8:  MOVLB  8
08CFA:  MOVF   x23,W
08CFC:  SUBLW  03
08CFE:  BZ    8D12
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
08D00:  MOVLW  12
08D02:  MOVWF  x69
08D04:  MOVLB  0
08D06:  CALL   6E02
.................... 			return; 
08D0A:  MOVLB  6
08D0C:  GOTO   986A
08D10:  MOVLB  8
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
08D12:  MOVF   x22,W
08D14:  XORLW  01
08D16:  MOVLB  0
08D18:  BZ    8D20
08D1A:  XORLW  03
08D1C:  BZ    8D60
08D1E:  BRA    8DA0
.................... 			case 0x01 : 
.................... 				// MUTE STATUS 
.................... 				fputc(0x06,USB); 
08D20:  MOVLW  06
08D22:  MOVLB  8
08D24:  MOVWF  x72
08D26:  MOVLB  0
08D28:  CALL   6DBC
.................... 				fputc(rs232_log_output_vol_index[channel-1],USB); 
08D2C:  MOVLW  01
08D2E:  MOVLB  8
08D30:  SUBWF  x28,W
08D32:  CLRF   03
08D34:  ADDLW  C9
08D36:  MOVWF  FE9
08D38:  MOVLW  00
08D3A:  ADDWFC 03,W
08D3C:  MOVWF  FEA
08D3E:  MOVFF  FEF,869
08D42:  MOVFF  869,872
08D46:  MOVLB  0
08D48:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08D4C:  MOVLW  03
08D4E:  MOVLB  8
08D50:  MOVWF  x72
08D52:  MOVLB  0
08D54:  CALL   6DBC
.................... 				return; 
08D58:  MOVLB  6
08D5A:  GOTO   986A
.................... 			break; 
08D5E:  BRA    8DB4
....................  
.................... 			case 0x02 : 
.................... 				// VOL STATUS 
.................... 				fputc(0x06,USB); 
08D60:  MOVLW  06
08D62:  MOVLB  8
08D64:  MOVWF  x72
08D66:  MOVLB  0
08D68:  CALL   6DBC
.................... 				fputc(((int)(rs232_log_output_vol_index[channel-1])),USB); 
08D6C:  MOVLW  01
08D6E:  MOVLB  8
08D70:  SUBWF  x28,W
08D72:  CLRF   03
08D74:  ADDLW  C9
08D76:  MOVWF  FE9
08D78:  MOVLW  00
08D7A:  ADDWFC 03,W
08D7C:  MOVWF  FEA
08D7E:  MOVFF  FEF,869
08D82:  MOVFF  869,872
08D86:  MOVLB  0
08D88:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08D8C:  MOVLW  03
08D8E:  MOVLB  8
08D90:  MOVWF  x72
08D92:  MOVLB  0
08D94:  CALL   6DBC
.................... 				return; 
08D98:  MOVLB  6
08D9A:  GOTO   986A
.................... 			break; 
08D9E:  BRA    8DB4
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
08DA0:  MOVLW  13
08DA2:  MOVLB  8
08DA4:  MOVWF  x69
08DA6:  MOVLB  0
08DA8:  CALL   6E02
.................... 				return; 
08DAC:  MOVLB  6
08DAE:  GOTO   986A
.................... 			break; 
08DB2:  BRA    8DB4
.................... 		} 
....................  
.................... SET_RS232_VALUE: 
....................  
....................  
.................... 		command_char = timed_getc(); 
08DB4:  MOVLB  0
08DB6:  CALL   6E1E
08DBA:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
08DBE:  MOVLB  6
08DC0:  DECFSZ xD4,W
08DC2:  BRA    8DD6
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08DC4:  MOVLW  10
08DC6:  MOVLB  8
08DC8:  MOVWF  x69
08DCA:  MOVLB  0
08DCC:  CALL   6E02
.................... 			return; 
08DD0:  MOVLB  6
08DD2:  GOTO   986A
.................... 		} 
....................  
.................... 		channel = timed_getc(); 
08DD6:  MOVLB  0
08DD8:  CALL   6E1E
08DDC:  MOVFF  01,828
....................  
.................... 		if(timeout_error == true) { 
08DE0:  MOVLB  6
08DE2:  DECFSZ xD4,W
08DE4:  BRA    8DF8
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_RS232_CH_TIMEOUT); 
08DE6:  MOVLW  26
08DE8:  MOVLB  8
08DEA:  MOVWF  x69
08DEC:  MOVLB  0
08DEE:  CALL   6E02
.................... 			return; 
08DF2:  MOVLB  6
08DF4:  GOTO   986A
.................... 		} 
....................  
.................... 		// TODO - this is zero based but use NUM_CHANNELS later 
.................... 		if(channel > 4) { 
08DF8:  MOVLB  8
08DFA:  MOVF   x28,W
08DFC:  SUBLW  04
08DFE:  BC    8E10
.................... 			send_error(ERR_RS232_CH_INVALID); 
08E00:  MOVLW  27
08E02:  MOVWF  x69
08E04:  MOVLB  0
08E06:  CALL   6E02
.................... 			return; 
08E0A:  MOVLB  6
08E0C:  GOTO   986A
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
08E10:  MOVLB  0
08E12:  CALL   6E1E
08E16:  MOVFF  01,823
.................... 	 
.................... 		if(timeout_error == true) { 
08E1A:  MOVLB  6
08E1C:  DECFSZ xD4,W
08E1E:  BRA    8E32
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08E20:  MOVLW  11
08E22:  MOVLB  8
08E24:  MOVWF  x69
08E26:  MOVLB  0
08E28:  CALL   6E02
.................... 			return; 
08E2C:  MOVLB  6
08E2E:  GOTO   986A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08E32:  MOVLB  8
08E34:  MOVF   x23,W
08E36:  SUBLW  03
08E38:  BZ    8E4C
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
08E3A:  MOVLW  12
08E3C:  MOVWF  x69
08E3E:  MOVLB  0
08E40:  CALL   6E02
.................... 			return; 
08E44:  MOVLB  6
08E46:  GOTO   986A
08E4A:  MOVLB  8
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
08E4C:  MOVF   x22,W
08E4E:  XORLW  00
08E50:  MOVLB  0
08E52:  BZ    8E62
08E54:  XORLW  01
08E56:  BZ    8EAC
08E58:  XORLW  03
08E5A:  BZ    8EF8
08E5C:  XORLW  01
08E5E:  BZ    8F2C
08E60:  BRA    8F68
.................... 			case 0x00 : 
.................... 				// SET MUTE OFF 
.................... 				 
.................... 				if(rs232_output_mute[channel-1] == 1) { 
08E62:  MOVLW  01
08E64:  MOVLB  8
08E66:  SUBWF  x28,W
08E68:  CLRF   03
08E6A:  ADDLW  C5
08E6C:  MOVWF  FE9
08E6E:  MOVLW  00
08E70:  ADDWFC 03,W
08E72:  MOVWF  FEA
08E74:  DECFSZ FEF,W
08E76:  BRA    8E84
.................... 					mute_toggle_output(channel); 
08E78:  MOVFF  828,869
08E7C:  MOVLB  0
08E7E:  CALL   76F8
08E82:  MOVLB  8
.................... 				} 
....................  
.................... 				fputc(0x06,USB); 
08E84:  MOVLW  06
08E86:  MOVWF  x72
08E88:  MOVLB  0
08E8A:  CALL   6DBC
.................... 				fputc(0x00,USB); 
08E8E:  MOVLB  8
08E90:  CLRF   x72
08E92:  MOVLB  0
08E94:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08E98:  MOVLW  03
08E9A:  MOVLB  8
08E9C:  MOVWF  x72
08E9E:  MOVLB  0
08EA0:  CALL   6DBC
.................... 				return; 
08EA4:  MOVLB  6
08EA6:  GOTO   986A
.................... 			break; 
08EAA:  BRA    8F7C
....................  
.................... 				case 0x01 : 
.................... 				// SET MUTE ON 
.................... 				 
.................... 				if(rs232_output_mute[channel-1] == 0) { 
08EAC:  MOVLW  01
08EAE:  MOVLB  8
08EB0:  SUBWF  x28,W
08EB2:  CLRF   03
08EB4:  ADDLW  C5
08EB6:  MOVWF  FE9
08EB8:  MOVLW  00
08EBA:  ADDWFC 03,W
08EBC:  MOVWF  FEA
08EBE:  MOVF   FEF,F
08EC0:  BNZ   8ECE
.................... 					mute_toggle_output(channel); 
08EC2:  MOVFF  828,869
08EC6:  MOVLB  0
08EC8:  CALL   76F8
08ECC:  MOVLB  8
.................... 				} 
....................  
.................... 				fputc(0x06,USB); 
08ECE:  MOVLW  06
08ED0:  MOVWF  x72
08ED2:  MOVLB  0
08ED4:  CALL   6DBC
.................... 				fputc(0x01,USB); 
08ED8:  MOVLW  01
08EDA:  MOVLB  8
08EDC:  MOVWF  x72
08EDE:  MOVLB  0
08EE0:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08EE4:  MOVLW  03
08EE6:  MOVLB  8
08EE8:  MOVWF  x72
08EEA:  MOVLB  0
08EEC:  CALL   6DBC
.................... 				return; 
08EF0:  MOVLB  6
08EF2:  GOTO   986A
.................... 			break; 
08EF6:  BRA    8F7C
....................  
.................... 		 
.................... 			case 0x02 : 
.................... 				// SET MUTE TOGGLE 
.................... 				 
.................... 				mute_toggle_output(channel); 
08EF8:  MOVFF  828,869
08EFC:  CALL   76F8
.................... 				fputc(0x06,USB); 
08F00:  MOVLW  06
08F02:  MOVLB  8
08F04:  MOVWF  x72
08F06:  MOVLB  0
08F08:  CALL   6DBC
.................... 				fputc(0x02,USB); 
08F0C:  MOVLW  02
08F0E:  MOVLB  8
08F10:  MOVWF  x72
08F12:  MOVLB  0
08F14:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08F18:  MOVLW  03
08F1A:  MOVLB  8
08F1C:  MOVWF  x72
08F1E:  MOVLB  0
08F20:  CALL   6DBC
.................... 				return; 
08F24:  MOVLB  6
08F26:  GOTO   986A
.................... 			break; 
08F2A:  BRA    8F7C
....................  
.................... 			case 0x03 : 
.................... 				// RESET VOLUME 
.................... 				 
.................... 				discrete_vol_output(channel,100); 
08F2C:  MOVFF  828,869
08F30:  MOVLW  64
08F32:  MOVLB  8
08F34:  MOVWF  x6A
08F36:  MOVLB  0
08F38:  CALL   79F8
.................... 				fputc(0x06,USB); 
08F3C:  MOVLW  06
08F3E:  MOVLB  8
08F40:  MOVWF  x72
08F42:  MOVLB  0
08F44:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08F48:  MOVLW  03
08F4A:  MOVLB  8
08F4C:  MOVWF  x72
08F4E:  MOVLB  0
08F50:  CALL   6DBC
.................... 				fputc(0x03,USB); 
08F54:  MOVLW  03
08F56:  MOVLB  8
08F58:  MOVWF  x72
08F5A:  MOVLB  0
08F5C:  CALL   6DBC
.................... 				return; 
08F60:  MOVLB  6
08F62:  GOTO   986A
.................... 			break; 
08F66:  BRA    8F7C
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
08F68:  MOVLW  13
08F6A:  MOVLB  8
08F6C:  MOVWF  x69
08F6E:  MOVLB  0
08F70:  CALL   6E02
.................... 				return; 
08F74:  MOVLB  6
08F76:  GOTO   986A
.................... 			break; 
08F7A:  BRA    8F7C
.................... 		} 
....................  
.................... SET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
08F7C:  MOVLB  0
08F7E:  CALL   6E1E
08F82:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
08F86:  MOVLB  6
08F88:  DECFSZ xD4,W
08F8A:  BRA    8F9E
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08F8C:  MOVLW  10
08F8E:  MOVLB  8
08F90:  MOVWF  x69
08F92:  MOVLB  0
08F94:  CALL   6E02
.................... 			return; 
08F98:  MOVLB  6
08F9A:  GOTO   986A
.................... 		} 
....................  
.................... 		unsigned int new_value = timed_getc(); 
08F9E:  MOVLB  0
08FA0:  CALL   6E1E
08FA4:  MOVFF  01,855
.................... 	 
.................... 		if(timeout_error == true) { 
08FA8:  MOVLB  6
08FAA:  DECFSZ xD4,W
08FAC:  BRA    8FC0
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08FAE:  MOVLW  17
08FB0:  MOVLB  8
08FB2:  MOVWF  x69
08FB4:  MOVLB  0
08FB6:  CALL   6E02
.................... 			return; 
08FBA:  MOVLB  6
08FBC:  GOTO   986A
.................... 		} 
.................... 	 
.................... 		unsigned int new_value2; 
....................  
.................... 		if(command_char == 0x11 || command_char == 0x12) { 
08FC0:  MOVLB  8
08FC2:  MOVF   x22,W
08FC4:  SUBLW  11
08FC6:  BZ    8FCE
08FC8:  MOVF   x22,W
08FCA:  SUBLW  12
08FCC:  BNZ   8FF0
....................  
.................... 			// SETTING SLEEP_SECONDS OR SLEEP_HOLDTIME 
.................... 			// THESE ARE 16 BIT SO WE NEED TWO CHARS 
.................... 			 
.................... 			new_value2 = timed_getc(); 
08FCE:  MOVLB  0
08FD0:  CALL   6E1E
08FD4:  MOVFF  01,856
....................  
.................... 			if(timeout_error == true) { 
08FD8:  MOVLB  6
08FDA:  DECFSZ xD4,W
08FDC:  BRA    8FF0
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 				send_error(ERR_DATA_TIMEOUT); 
08FDE:  MOVLW  17
08FE0:  MOVLB  8
08FE2:  MOVWF  x69
08FE4:  MOVLB  0
08FE6:  CALL   6E02
.................... 				return; 
08FEA:  MOVLB  6
08FEC:  GOTO   986A
.................... 			} 
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08FF0:  MOVLB  0
08FF2:  CALL   6E1E
08FF6:  MOVFF  01,823
.................... 		 
.................... 		if(timeout_error == true) { 
08FFA:  MOVLB  6
08FFC:  DECFSZ xD4,W
08FFE:  BRA    9012
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
09000:  MOVLW  11
09002:  MOVLB  8
09004:  MOVWF  x69
09006:  MOVLB  0
09008:  CALL   6E02
.................... 			return; 
0900C:  MOVLB  6
0900E:  GOTO   986A
.................... 		} 
.................... 		 
.................... 		int perform_eeprom_save = 0; 
.................... 		 
.................... 		int16 lsb,msb; 
09012:  MOVLB  8
09014:  CLRF   x57
....................  
.................... 		switch(command_char) { 
09016:  MOVF   x22,W
09018:  XORLW  01
0901A:  MOVLB  0
0901C:  BZ    9062
0901E:  XORLW  03
09020:  BZ    9086
09022:  XORLW  01
09024:  BZ    90AA
09026:  XORLW  07
09028:  BZ    90F4
0902A:  XORLW  01
0902C:  BTFSC  FD8.2
0902E:  BRA    913E
09030:  XORLW  03
09032:  BTFSC  FD8.2
09034:  BRA    9162
09036:  XORLW  01
09038:  BTFSC  FD8.2
0903A:  BRA    9184
0903C:  XORLW  0F
0903E:  BTFSC  FD8.2
09040:  BRA    91A6
09042:  XORLW  01
09044:  BTFSC  FD8.2
09046:  BRA    91C8
09048:  XORLW  19
0904A:  BTFSC  FD8.2
0904C:  BRA    91EA
0904E:  XORLW  01
09050:  BTFSC  FD8.2
09052:  BRA    920C
09054:  XORLW  03
09056:  BTFSC  FD8.2
09058:  BRA    9254
0905A:  XORLW  01
0905C:  BTFSC  FD8.2
0905E:  BRA    929C
09060:  BRA    937E
....................  
.................... 			case 0x01 : 
.................... 				// SETTING AMP MODE 
.................... 				 
.................... 				if(new_value>2) { 
09062:  MOVLB  8
09064:  MOVF   x55,W
09066:  SUBLW  02
09068:  BC    907C
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
0906A:  MOVLW  30
0906C:  MOVWF  x69
0906E:  MOVLB  0
09070:  CALL   6E02
.................... 					return; 
09074:  MOVLB  6
09076:  GOTO   986A
0907A:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMP_MODE = new_value; 
0907C:  MOVFF  855,33
.................... 				perform_eeprom_save = 1; 
09080:  MOVLW  01
09082:  MOVWF  x57
.................... 			break; 
09084:  BRA    9392
.................... 			 
.................... 			case 0x02 : 
.................... 				// SETTING 70V MODE 
.................... 				 
.................... 				if(new_value>1) { 
09086:  MOVLB  8
09088:  MOVF   x55,W
0908A:  SUBLW  01
0908C:  BC    90A0
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
0908E:  MOVLW  30
09090:  MOVWF  x69
09092:  MOVLB  0
09094:  CALL   6E02
.................... 					return; 
09098:  MOVLB  6
0909A:  GOTO   986A
0909E:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.IS_70V = new_value; 
090A0:  MOVFF  855,34
.................... 				perform_eeprom_save = 1; 
090A4:  MOVLW  01
090A6:  MOVWF  x57
.................... 			break; 
090A8:  BRA    9392
.................... 			 
.................... 			case 0x03 : 
.................... 				// CALIBRATING ADC_MIN 
.................... 				 
.................... 				int new_min = ADC_calibrate_min(1); 
090AA:  MOVLW  01
090AC:  MOVLB  8
090AE:  MOVWF  x69
090B0:  MOVLB  0
090B2:  GOTO   7CFE
090B6:  MOVFF  01,85C
.................... 				fputc(0x06,USB); 
090BA:  MOVLW  06
090BC:  MOVLB  8
090BE:  MOVWF  x72
090C0:  MOVLB  0
090C2:  CALL   6DBC
.................... 				fputc(0x03,USB); 
090C6:  MOVLW  03
090C8:  MOVLB  8
090CA:  MOVWF  x72
090CC:  MOVLB  0
090CE:  CALL   6DBC
.................... 				fputc(new_min,USB); 
090D2:  MOVFF  85C,872
090D6:  CALL   6DBC
.................... 				fputc(0x03,USB); 
090DA:  MOVLW  03
090DC:  MOVLB  8
090DE:  MOVWF  x72
090E0:  MOVLB  0
090E2:  CALL   6DBC
.................... 				perform_eeprom_save = 0; 
090E6:  MOVLB  8
090E8:  CLRF   x57
.................... 				return; 
090EA:  MOVLB  6
090EC:  GOTO   986A
.................... 			break; 
090F0:  MOVLB  8
090F2:  BRA    9392
.................... 			 
.................... 			case 0x04 : 
.................... 				// CALIBRATING ADC_MAX 
.................... 				 
.................... 				int new_max = ADC_calibrate_max(1); 
090F4:  MOVLW  01
090F6:  MOVLB  8
090F8:  MOVWF  x69
090FA:  MOVLB  0
090FC:  GOTO   7D7A
09100:  MOVFF  01,85D
....................  
.................... 				fputc(0x06,USB); 
09104:  MOVLW  06
09106:  MOVLB  8
09108:  MOVWF  x72
0910A:  MOVLB  0
0910C:  CALL   6DBC
.................... 				fputc(0x04,USB); 
09110:  MOVLW  04
09112:  MOVLB  8
09114:  MOVWF  x72
09116:  MOVLB  0
09118:  CALL   6DBC
.................... 				fputc(new_max,USB); 
0911C:  MOVFF  85D,872
09120:  CALL   6DBC
.................... 				fputc(0x03,USB); 
09124:  MOVLW  03
09126:  MOVLB  8
09128:  MOVWF  x72
0912A:  MOVLB  0
0912C:  CALL   6DBC
.................... 				perform_eeprom_save = 0; 
09130:  MOVLB  8
09132:  CLRF   x57
.................... 				return; 
09134:  MOVLB  6
09136:  GOTO   986A
.................... 			break; 
0913A:  MOVLB  8
0913C:  BRA    9392
.................... 			 
.................... 			case 0x05 : 
.................... 				// SETTING RVC_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
0913E:  MOVLB  8
09140:  MOVF   x55,W
09142:  SUBLW  01
09144:  BC    9158
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
09146:  MOVLW  30
09148:  MOVWF  x69
0914A:  MOVLB  0
0914C:  CALL   6E02
.................... 					return; 
09150:  MOVLB  6
09152:  GOTO   986A
09156:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.RVC_ENABLE = new_value; 
09158:  MOVFF  855,3D
.................... 				perform_eeprom_save = 1; 
0915C:  MOVLW  01
0915E:  MOVWF  x57
.................... 			break; 
09160:  BRA    9392
.................... 			 
.................... 			case 0x06 : 
.................... 				// SETTING USBDETECT_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
09162:  MOVLB  8
09164:  MOVF   x55,W
09166:  SUBLW  01
09168:  BC    917A
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
0916A:  MOVLW  30
0916C:  MOVWF  x69
0916E:  MOVLB  0
09170:  CALL   6E02
.................... 					return; 
09174:  MOVLB  6
09176:  BRA    986A
09178:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.USBDETECT_ENABLE = new_value; 
0917A:  MOVFF  855,3E
.................... 				perform_eeprom_save = 1; 
0917E:  MOVLW  01
09180:  MOVWF  x57
.................... 			break; 
09182:  BRA    9392
.................... 			 
.................... 			case 0x07 : 
.................... 				// SETTING AMPBOOT_DELAY_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
09184:  MOVLB  8
09186:  MOVF   x55,W
09188:  SUBLW  01
0918A:  BC    919C
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
0918C:  MOVLW  30
0918E:  MOVWF  x69
09190:  MOVLB  0
09192:  CALL   6E02
.................... 					return; 
09196:  MOVLB  6
09198:  BRA    986A
0919A:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = new_value; 
0919C:  MOVFF  855,3F
.................... 				perform_eeprom_save = 1; 
091A0:  MOVLW  01
091A2:  MOVWF  x57
.................... 			break; 
091A4:  BRA    9392
.................... 			 
.................... 			case 0x08 : 
.................... 				// SETTING PS_PIN_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
091A6:  MOVLB  8
091A8:  MOVF   x55,W
091AA:  SUBLW  01
091AC:  BC    91BE
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
091AE:  MOVLW  30
091B0:  MOVWF  x69
091B2:  MOVLB  0
091B4:  CALL   6E02
.................... 					return; 
091B8:  MOVLB  6
091BA:  BRA    986A
091BC:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.PS_PIN_ENABLE = new_value; 
091BE:  MOVFF  855,40
.................... 				perform_eeprom_save = 1; 
091C2:  MOVLW  01
091C4:  MOVWF  x57
.................... 			break; 
091C6:  BRA    9392
.................... 			 
.................... 			case 0x09 : 
.................... 				// SETTING DSP_VALUESEND_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
091C8:  MOVLB  8
091CA:  MOVF   x55,W
091CC:  SUBLW  01
091CE:  BC    91E0
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
091D0:  MOVLW  30
091D2:  MOVWF  x69
091D4:  MOVLB  0
091D6:  CALL   6E02
.................... 					return; 
091DA:  MOVLB  6
091DC:  BRA    986A
091DE:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.DSP_VALUESEND_ENABLE = new_value; 
091E0:  MOVFF  855,41
.................... 				perform_eeprom_save = 1; 
091E4:  MOVLW  01
091E6:  MOVWF  x57
.................... 			break; 
091E8:  BRA    9392
....................  
.................... 			case 0x10 : 
.................... 				// SETTING SLEEP_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
091EA:  MOVLB  8
091EC:  MOVF   x55,W
091EE:  SUBLW  01
091F0:  BC    9202
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
091F2:  MOVLW  30
091F4:  MOVWF  x69
091F6:  MOVLB  0
091F8:  CALL   6E02
.................... 					return; 
091FC:  MOVLB  6
091FE:  BRA    986A
09200:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_ENABLE = new_value; 
09202:  MOVFF  855,42
.................... 				perform_eeprom_save = 1; 
09206:  MOVLW  01
09208:  MOVWF  x57
.................... 			break; 
0920A:  BRA    9392
....................  
.................... 			case 0x11 : 
.................... 				// SETTING SLEEP_SECONDS 
.................... 				 
.................... 				lsb = (int16)new_value; 
0920C:  MOVLB  8
0920E:  CLRF   x59
09210:  MOVFF  855,858
.................... 				msb = (int16)new_value2; 
09214:  CLRF   x5B
09216:  MOVFF  856,85A
....................  
.................... 				int16 new_sleep_seconds = (msb<<8) | (lsb); 
0921A:  CLRF   x69
0921C:  MOVF   x69,W
0921E:  IORWF  x58,W
09220:  MOVWF  x5E
09222:  MOVF   x5A,W
09224:  IORWF  x59,W
09226:  MOVWF  x5F
....................  
.................... 				if(new_sleep_seconds<DEVICE_CONFIG.SLEEP_HOLDTIME) { 
09228:  MOVF   x5F,W
0922A:  SUBWF  46,W
0922C:  BNC   9246
0922E:  BNZ   9236
09230:  MOVF   45,W
09232:  SUBWF  x5E,W
09234:  BC    9246
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
09236:  MOVLW  30
09238:  MOVWF  x69
0923A:  MOVLB  0
0923C:  CALL   6E02
.................... 					return; 
09240:  MOVLB  6
09242:  BRA    986A
09244:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_SECONDS = new_sleep_seconds; 
09246:  MOVFF  85F,44
0924A:  MOVFF  85E,43
.................... 				perform_eeprom_save = 1; 
0924E:  MOVLW  01
09250:  MOVWF  x57
.................... 			break; 
09252:  BRA    9392
....................  
.................... 			case 0x12 : 
.................... 				// SETTING SLEEP_HOLDTIME 
.................... 				 
.................... 				lsb = (int16)new_value; 
09254:  MOVLB  8
09256:  CLRF   x59
09258:  MOVFF  855,858
.................... 				msb = (int16)new_value2; 
0925C:  CLRF   x5B
0925E:  MOVFF  856,85A
....................  
.................... 				int16 new_sleep_holdtime = (msb<<8) | (lsb); 
09262:  CLRF   x69
09264:  MOVF   x69,W
09266:  IORWF  x58,W
09268:  MOVWF  x60
0926A:  MOVF   x5A,W
0926C:  IORWF  x59,W
0926E:  MOVWF  x61
.................... 				//fprintf(RS232,"LSB: %ld, MSB: %ld, INT16 %ld\r\n",lsb, msb, new_sleep_holdtime); 
....................  
.................... 				if(new_sleep_holdtime>DEVICE_CONFIG.SLEEP_SECONDS) { 
09270:  MOVF   44,W
09272:  SUBWF  x61,W
09274:  BNC   928E
09276:  BNZ   927E
09278:  MOVF   x60,W
0927A:  SUBWF  43,W
0927C:  BC    928E
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
0927E:  MOVLW  30
09280:  MOVWF  x69
09282:  MOVLB  0
09284:  CALL   6E02
.................... 					return; 
09288:  MOVLB  6
0928A:  BRA    986A
0928C:  MOVLB  8
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_HOLDTIME = new_sleep_holdtime; 
0928E:  MOVFF  861,46
09292:  MOVFF  860,45
.................... 				perform_eeprom_save = 1; 
09296:  MOVLW  01
09298:  MOVWF  x57
.................... 			break; 
0929A:  BRA    9392
....................  
.................... 			case 0x13 : 
.................... 				// SETTING SERIAL NUMBER 
.................... 			 
.................... 				finished = false; 
0929C:  MOVLB  8
0929E:  CLRF   x08
....................  
.................... 				for(x = 0; x < 20; x++) { 
092A0:  CLRF   x1E
092A2:  MOVF   x1E,W
092A4:  SUBLW  13
092A6:  BNC   92BC
.................... 					DEVICE_CONFIG.SERIAL[x] = 0xFF; 
092A8:  CLRF   03
092AA:  MOVF   x1E,W
092AC:  ADDLW  47
092AE:  MOVWF  FE9
092B0:  MOVLW  00
092B2:  ADDWFC 03,W
092B4:  MOVWF  FEA
092B6:  SETF   FEF
.................... 				} 
092B8:  INCF   x1E,F
092BA:  BRA    92A2
....................  
....................  
.................... 				int16 char_receive_count = 0; 
092BC:  CLRF   x63
092BE:  CLRF   x62
....................  
.................... 				while((char_receive_count < 20)	&& (timeout_error == false)&& (finished == false)) 
.................... 				{ 
092C0:  MOVF   x63,F
092C2:  BNZ   930C
092C4:  MOVF   x62,W
092C6:  SUBLW  13
092C8:  BNC   930C
092CA:  MOVLB  6
092CC:  MOVF   xD4,F
092CE:  BTFSC  FD8.2
092D0:  BRA    92D6
092D2:  MOVLB  8
092D4:  BRA    930C
092D6:  MOVLB  8
092D8:  MOVF   x08,F
092DA:  BNZ   930C
.................... 					temp_byte = timed_getc(); 
092DC:  MOVLB  0
092DE:  CALL   6E1E
092E2:  MOVFF  01,809
.................... 					//temp_byte = fgetc(USB); 
.................... 					if(temp_byte == 0x0A) { 
092E6:  MOVLB  8
092E8:  MOVF   x09,W
092EA:  SUBLW  0A
092EC:  BNZ   92F4
.................... 						finished = true; 
092EE:  MOVLW  01
092F0:  MOVWF  x08
.................... 					} else { 
092F2:  BRA    9304
.................... 						DEVICE_CONFIG.SERIAL[char_receive_count] = temp_byte;	 
092F4:  MOVLW  47
092F6:  ADDWF  x62,W
092F8:  MOVWF  FE9
092FA:  MOVLW  00
092FC:  ADDWFC x63,W
092FE:  MOVWF  FEA
09300:  MOVFF  809,FEF
....................  
.................... 					} 
.................... 					char_receive_count++; 
09304:  INCF   x62,F
09306:  BTFSC  FD8.2
09308:  INCF   x63,F
.................... 				 
.................... 				} 
0930A:  BRA    92C0
....................  
.................... 				if(!finished) { 
0930C:  MOVF   x08,F
0930E:  BNZ   9378
.................... 					dummy_char = timed_getc(); 
09310:  MOVLB  0
09312:  CALL   6E1E
09316:  MOVFF  01,823
.................... 					 
.................... 					if(timeout_error == true) { 
0931A:  MOVLB  6
0931C:  DECFSZ xD4,W
0931E:  BRA    9348
.................... 						// Timed out. No command. Start over. 
.................... 						fputc(0x15,USB); 
09320:  MOVLW  15
09322:  MOVLB  8
09324:  MOVWF  x72
09326:  MOVLB  0
09328:  CALL   6DBC
.................... 						fputc(ERR_END_TIMEOUT,USB); 
0932C:  MOVLW  11
0932E:  MOVLB  8
09330:  MOVWF  x72
09332:  MOVLB  0
09334:  CALL   6DBC
.................... 						fputc(0x03,USB); 
09338:  MOVLW  03
0933A:  MOVLB  8
0933C:  MOVWF  x72
0933E:  MOVLB  0
09340:  CALL   6DBC
.................... 						return; 
09344:  MOVLB  6
09346:  BRA    986A
.................... 					} 
.................... 					 
.................... 					if(dummy_char != 0x03) { 
09348:  MOVLB  8
0934A:  MOVF   x23,W
0934C:  SUBLW  03
0934E:  BZ    9378
.................... 						// Ending char not 0x03 
.................... 						fputc(0x15,USB); 
09350:  MOVLW  15
09352:  MOVWF  x72
09354:  MOVLB  0
09356:  CALL   6DBC
.................... 						fputc(0x12,USB); 
0935A:  MOVLW  12
0935C:  MOVLB  8
0935E:  MOVWF  x72
09360:  MOVLB  0
09362:  CALL   6DBC
.................... 						fputc(0x03,USB); 
09366:  MOVLW  03
09368:  MOVLB  8
0936A:  MOVWF  x72
0936C:  MOVLB  0
0936E:  CALL   6DBC
.................... 						return; 
09372:  MOVLB  6
09374:  BRA    986A
09376:  MOVLB  8
.................... 						 
.................... 					} 
.................... 				} 
....................  
.................... 				perform_eeprom_save = 1; 
09378:  MOVLW  01
0937A:  MOVWF  x57
....................  
.................... 			break; 
0937C:  BRA    9392
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
0937E:  MOVLW  13
09380:  MOVLB  8
09382:  MOVWF  x69
09384:  MOVLB  0
09386:  CALL   6E02
.................... 				return; 
0938A:  MOVLB  6
0938C:  BRA    986A
.................... 			break; 
0938E:  MOVLB  8
09390:  BRA    9392
.................... 		} 
....................  
.................... 		if(perform_eeprom_save == 1) { 
09392:  DECFSZ x57,W
09394:  BRA    93E8
.................... 			INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
09396:  CLRF   x6C
09398:  MOVLW  33
0939A:  MOVWF  x6B
0939C:  CLRF   x6E
0939E:  MOVLW  28
093A0:  MOVWF  x6D
093A2:  CLRF   x70
093A4:  MOVLW  64
093A6:  MOVWF  x6F
093A8:  MOVLB  0
093AA:  CALL   5D98
.................... 			delay_ms(10); 
093AE:  MOVLW  0A
093B0:  MOVLB  8
093B2:  MOVWF  x74
093B4:  MOVLB  0
093B6:  CALL   5A08
....................  
.................... 			fputc(0x06,USB); 
093BA:  MOVLW  06
093BC:  MOVLB  8
093BE:  MOVWF  x72
093C0:  MOVLB  0
093C2:  CALL   6DBC
.................... 			fputc(command_char,USB); 
093C6:  MOVFF  822,872
093CA:  CALL   6DBC
.................... 			fputc(new_value,USB); 
093CE:  MOVFF  855,872
093D2:  CALL   6DBC
.................... 			fputc(0x03,USB); 
093D6:  MOVLW  03
093D8:  MOVLB  8
093DA:  MOVWF  x72
093DC:  MOVLB  0
093DE:  CALL   6DBC
....................  
.................... 			return; 
093E2:  MOVLB  6
093E4:  BRA    986A
093E6:  MOVLB  8
.................... 		} 
....................  
.................... GET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
093E8:  MOVLB  0
093EA:  CALL   6E1E
093EE:  MOVFF  01,822
.................... 	 
.................... 		if(timeout_error == true) { 
093F2:  MOVLB  6
093F4:  DECFSZ xD4,W
093F6:  BRA    9408
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
093F8:  MOVLW  10
093FA:  MOVLB  8
093FC:  MOVWF  x69
093FE:  MOVLB  0
09400:  CALL   6E02
.................... 			return; 
09404:  MOVLB  6
09406:  BRA    986A
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
09408:  MOVLB  0
0940A:  CALL   6E1E
0940E:  MOVFF  01,823
.................... 		 
.................... 		if(timeout_error == true) { 
09412:  MOVLB  6
09414:  DECFSZ xD4,W
09416:  BRA    9428
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
09418:  MOVLW  11
0941A:  MOVLB  8
0941C:  MOVWF  x69
0941E:  MOVLB  0
09420:  CALL   6E02
.................... 			return; 
09424:  MOVLB  6
09426:  BRA    986A
.................... 		} 
....................  
.................... 		switch(command_char) { 
09428:  MOVLB  8
0942A:  MOVF   x22,W
0942C:  XORLW  01
0942E:  MOVLB  0
09430:  BZ    947E
09432:  XORLW  03
09434:  BZ    94B0
09436:  XORLW  01
09438:  BZ    94E2
0943A:  XORLW  07
0943C:  BTFSC  FD8.2
0943E:  BRA    9538
09440:  XORLW  01
09442:  BTFSC  FD8.2
09444:  BRA    958E
09446:  XORLW  03
09448:  BTFSC  FD8.2
0944A:  BRA    95C0
0944C:  XORLW  01
0944E:  BTFSC  FD8.2
09450:  BRA    95F2
09452:  XORLW  0F
09454:  BTFSC  FD8.2
09456:  BRA    9624
09458:  XORLW  01
0945A:  BTFSC  FD8.2
0945C:  BRA    9656
0945E:  XORLW  19
09460:  BTFSC  FD8.2
09462:  BRA    9688
09464:  XORLW  01
09466:  BTFSC  FD8.2
09468:  BRA    96BA
0946A:  XORLW  03
0946C:  BTFSC  FD8.2
0946E:  BRA    96F4
09470:  XORLW  01
09472:  BTFSC  FD8.2
09474:  BRA    972E
09476:  XORLW  07
09478:  BTFSC  FD8.2
0947A:  BRA    97B0
0947C:  BRA    9832
....................  
.................... 			case 0x01 : 
.................... 				// GET AMPLIFIER MODE 
....................  
.................... 				fputc(0x06); 
0947E:  MOVLW  06
09480:  MOVLB  8
09482:  MOVWF  x72
09484:  MOVLB  0
09486:  CALL   6DBC
.................... 				fputc(0x01); 
0948A:  MOVLW  01
0948C:  MOVLB  8
0948E:  MOVWF  x72
09490:  MOVLB  0
09492:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.AMP_MODE); 
09496:  MOVFF  33,872
0949A:  CALL   6DBC
.................... 				fputc(0x03); 
0949E:  MOVLW  03
094A0:  MOVLB  8
094A2:  MOVWF  x72
094A4:  MOVLB  0
094A6:  CALL   6DBC
.................... 				return; 
094AA:  MOVLB  6
094AC:  BRA    986A
.................... 			break; 
094AE:  BRA    9844
....................  
.................... 			case 0x02 : 
.................... 				// GET 70V MODE 
.................... 				fputc(0x06); 
094B0:  MOVLW  06
094B2:  MOVLB  8
094B4:  MOVWF  x72
094B6:  MOVLB  0
094B8:  CALL   6DBC
.................... 				fputc(0x02); 
094BC:  MOVLW  02
094BE:  MOVLB  8
094C0:  MOVWF  x72
094C2:  MOVLB  0
094C4:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.IS_70V); 
094C8:  MOVFF  34,872
094CC:  CALL   6DBC
.................... 				fputc(0x03); 
094D0:  MOVLW  03
094D2:  MOVLB  8
094D4:  MOVWF  x72
094D6:  MOVLB  0
094D8:  CALL   6DBC
.................... 				return; 
094DC:  MOVLB  6
094DE:  BRA    986A
.................... 			break; 
094E0:  BRA    9844
....................  
.................... 			case 0x03 : 
.................... 				// GET ADC_MIN 
.................... 				fputc(0x06); 
094E2:  MOVLW  06
094E4:  MOVLB  8
094E6:  MOVWF  x72
094E8:  MOVLB  0
094EA:  CALL   6DBC
.................... 				fputc(0x03); 
094EE:  MOVLW  03
094F0:  MOVLB  8
094F2:  MOVWF  x72
094F4:  MOVLB  0
094F6:  CALL   6DBC
094FA:  CLRF   19
094FC:  BTFSC  FF2.7
094FE:  BSF    19.7
09500:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
09502:  MOVFF  38,8EC
09506:  MOVFF  37,8EB
0950A:  MOVFF  36,8EA
0950E:  MOVFF  35,8E9
09512:  CALL   13A0
09516:  BTFSC  19.7
09518:  BSF    FF2.7
0951A:  MOVFF  01,869
0951E:  MOVFF  01,872
09522:  CALL   6DBC
.................... 				fputc(0x03); 
09526:  MOVLW  03
09528:  MOVLB  8
0952A:  MOVWF  x72
0952C:  MOVLB  0
0952E:  CALL   6DBC
.................... 				return; 
09532:  MOVLB  6
09534:  BRA    986A
.................... 			break; 
09536:  BRA    9844
....................  
.................... 			case 0x04 : 
.................... 				// GET ADC_MAX 
.................... 				fputc(0x06); 
09538:  MOVLW  06
0953A:  MOVLB  8
0953C:  MOVWF  x72
0953E:  MOVLB  0
09540:  CALL   6DBC
.................... 				fputc(0x04); 
09544:  MOVLW  04
09546:  MOVLB  8
09548:  MOVWF  x72
0954A:  MOVLB  0
0954C:  CALL   6DBC
09550:  CLRF   19
09552:  BTFSC  FF2.7
09554:  BSF    19.7
09556:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
09558:  MOVFF  3C,8EC
0955C:  MOVFF  3B,8EB
09560:  MOVFF  3A,8EA
09564:  MOVFF  39,8E9
09568:  CALL   13A0
0956C:  BTFSC  19.7
0956E:  BSF    FF2.7
09570:  MOVFF  01,869
09574:  MOVFF  01,872
09578:  CALL   6DBC
.................... 				fputc(0x03); 
0957C:  MOVLW  03
0957E:  MOVLB  8
09580:  MOVWF  x72
09582:  MOVLB  0
09584:  CALL   6DBC
.................... 				return; 
09588:  MOVLB  6
0958A:  BRA    986A
.................... 			break; 
0958C:  BRA    9844
....................  
.................... 			case 0x05 : 
.................... 				// GET RVC_ENABLE 
.................... 				fputc(0x06); 
0958E:  MOVLW  06
09590:  MOVLB  8
09592:  MOVWF  x72
09594:  MOVLB  0
09596:  CALL   6DBC
.................... 				fputc(0x05); 
0959A:  MOVLW  05
0959C:  MOVLB  8
0959E:  MOVWF  x72
095A0:  MOVLB  0
095A2:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.RVC_ENABLE); 
095A6:  MOVFF  3D,872
095AA:  CALL   6DBC
.................... 				fputc(0x03); 
095AE:  MOVLW  03
095B0:  MOVLB  8
095B2:  MOVWF  x72
095B4:  MOVLB  0
095B6:  CALL   6DBC
.................... 				return; 
095BA:  MOVLB  6
095BC:  BRA    986A
.................... 			break; 
095BE:  BRA    9844
....................  
.................... 			case 0x06 : 
.................... 				// GET USBDETECT 
.................... 				fputc(0x06); 
095C0:  MOVLW  06
095C2:  MOVLB  8
095C4:  MOVWF  x72
095C6:  MOVLB  0
095C8:  CALL   6DBC
.................... 				fputc(0x06); 
095CC:  MOVLW  06
095CE:  MOVLB  8
095D0:  MOVWF  x72
095D2:  MOVLB  0
095D4:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.USBDETECT_ENABLE); 
095D8:  MOVFF  3E,872
095DC:  CALL   6DBC
.................... 				fputc(0x03); 
095E0:  MOVLW  03
095E2:  MOVLB  8
095E4:  MOVWF  x72
095E6:  MOVLB  0
095E8:  CALL   6DBC
.................... 				return; 
095EC:  MOVLB  6
095EE:  BRA    986A
.................... 			break; 
095F0:  BRA    9844
....................  
.................... 			case 0x07 : 
.................... 				// GET AMPBOOT 
.................... 				fputc(0x06); 
095F2:  MOVLW  06
095F4:  MOVLB  8
095F6:  MOVWF  x72
095F8:  MOVLB  0
095FA:  CALL   6DBC
.................... 				fputc(0x07); 
095FE:  MOVLW  07
09600:  MOVLB  8
09602:  MOVWF  x72
09604:  MOVLB  0
09606:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
0960A:  MOVFF  3F,872
0960E:  CALL   6DBC
.................... 				fputc(0x03); 
09612:  MOVLW  03
09614:  MOVLB  8
09616:  MOVWF  x72
09618:  MOVLB  0
0961A:  CALL   6DBC
.................... 				return; 
0961E:  MOVLB  6
09620:  BRA    986A
.................... 			break; 
09622:  BRA    9844
.................... 	 
.................... 			case 0x08 : 
.................... 				// GET PS_PIN 
.................... 				fputc(0x06); 
09624:  MOVLW  06
09626:  MOVLB  8
09628:  MOVWF  x72
0962A:  MOVLB  0
0962C:  CALL   6DBC
.................... 				fputc(0x08); 
09630:  MOVLW  08
09632:  MOVLB  8
09634:  MOVWF  x72
09636:  MOVLB  0
09638:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.PS_PIN_ENABLE); 
0963C:  MOVFF  40,872
09640:  CALL   6DBC
.................... 				fputc(0x03); 
09644:  MOVLW  03
09646:  MOVLB  8
09648:  MOVWF  x72
0964A:  MOVLB  0
0964C:  CALL   6DBC
.................... 				return; 
09650:  MOVLB  6
09652:  BRA    986A
.................... 			break; 
09654:  BRA    9844
....................  
.................... 			case 0x09 : 
.................... 				// DSP_VALUESEND 
.................... 				fputc(0x06); 
09656:  MOVLW  06
09658:  MOVLB  8
0965A:  MOVWF  x72
0965C:  MOVLB  0
0965E:  CALL   6DBC
.................... 				fputc(0x09); 
09662:  MOVLW  09
09664:  MOVLB  8
09666:  MOVWF  x72
09668:  MOVLB  0
0966A:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
0966E:  MOVFF  41,872
09672:  CALL   6DBC
.................... 				fputc(0x03); 
09676:  MOVLW  03
09678:  MOVLB  8
0967A:  MOVWF  x72
0967C:  MOVLB  0
0967E:  CALL   6DBC
.................... 				return; 
09682:  MOVLB  6
09684:  BRA    986A
.................... 			break; 
09686:  BRA    9844
....................  
.................... 			case 0x10 : 
.................... 				// SLEEP_ENABLE 
.................... 				fputc(0x06); 
09688:  MOVLW  06
0968A:  MOVLB  8
0968C:  MOVWF  x72
0968E:  MOVLB  0
09690:  CALL   6DBC
.................... 				fputc(0x10); 
09694:  MOVLW  10
09696:  MOVLB  8
09698:  MOVWF  x72
0969A:  MOVLB  0
0969C:  CALL   6DBC
.................... 				fputc(DEVICE_CONFIG.SLEEP_ENABLE); 
096A0:  MOVFF  42,872
096A4:  CALL   6DBC
.................... 				fputc(0x03); 
096A8:  MOVLW  03
096AA:  MOVLB  8
096AC:  MOVWF  x72
096AE:  MOVLB  0
096B0:  CALL   6DBC
.................... 				return; 
096B4:  MOVLB  6
096B6:  BRA    986A
.................... 			break; 
096B8:  BRA    9844
....................  
.................... 			case 0x11 : 
.................... 				// SLEEP_SECONDS 
.................... 				fputc(0x06); 
096BA:  MOVLW  06
096BC:  MOVLB  8
096BE:  MOVWF  x72
096C0:  MOVLB  0
096C2:  CALL   6DBC
.................... 				fputc(0x11); 
096C6:  MOVLW  11
096C8:  MOVLB  8
096CA:  MOVWF  x72
096CC:  MOVLB  0
096CE:  CALL   6DBC
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_SECONDS); 
096D2:  MOVLW  10
096D4:  MOVWF  FE9
096D6:  MOVFF  44,86A
096DA:  MOVFF  43,869
096DE:  CALL   7DF6
.................... 				fputc(0x0A); 
096E2:  MOVLW  0A
096E4:  MOVLB  8
096E6:  MOVWF  x72
096E8:  MOVLB  0
096EA:  CALL   6DBC
.................... 				return; 
096EE:  MOVLB  6
096F0:  BRA    986A
.................... 			break; 
096F2:  BRA    9844
....................  
.................... 			case 0x12 : 
.................... 				// SLEEP_HOLDTIME 
.................... 				fputc(0x06); 
096F4:  MOVLW  06
096F6:  MOVLB  8
096F8:  MOVWF  x72
096FA:  MOVLB  0
096FC:  CALL   6DBC
.................... 				fputc(0x12); 
09700:  MOVLW  12
09702:  MOVLB  8
09704:  MOVWF  x72
09706:  MOVLB  0
09708:  CALL   6DBC
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_HOLDTIME); 
0970C:  MOVLW  10
0970E:  MOVWF  FE9
09710:  MOVFF  46,86A
09714:  MOVFF  45,869
09718:  CALL   7DF6
.................... 				fputc(0x03); 
0971C:  MOVLW  03
0971E:  MOVLB  8
09720:  MOVWF  x72
09722:  MOVLB  0
09724:  CALL   6DBC
.................... 				return; 
09728:  MOVLB  6
0972A:  BRA    986A
.................... 			break; 
0972C:  BRA    9844
.................... 	 
.................... 			case 0x13 : 
.................... 				// SERIAL NUMBER 
.................... 				memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
0972E:  MOVLW  08
09730:  MOVWF  FEA
09732:  MOVLW  0A
09734:  MOVWF  FE9
09736:  CLRF   FE2
09738:  MOVLW  47
0973A:  MOVWF  FE1
0973C:  MOVLW  14
0973E:  MOVWF  01
09740:  MOVFF  FE6,FEE
09744:  DECFSZ 01,F
09746:  BRA    9740
....................  
.................... 				fputc(0x06); 
09748:  MOVLW  06
0974A:  MOVLB  8
0974C:  MOVWF  x72
0974E:  MOVLB  0
09750:  CALL   6DBC
.................... 				fputc(0x13); 
09754:  MOVLW  13
09756:  MOVLB  8
09758:  MOVWF  x72
0975A:  MOVLB  0
0975C:  CALL   6DBC
....................  
.................... 				for(y = 0; y < 20; y++) { 
09760:  MOVLB  8
09762:  CLRF   x1F
09764:  MOVF   x1F,W
09766:  SUBLW  13
09768:  BNC   97A0
.................... 					if(name_buffer[y] == 0xFF) { 
0976A:  CLRF   03
0976C:  MOVF   x1F,W
0976E:  ADDLW  0A
09770:  MOVWF  FE9
09772:  MOVLW  08
09774:  ADDWFC 03,W
09776:  MOVWF  FEA
09778:  INCFSZ FEF,W
0977A:  BRA    977E
.................... 						break; 
0977C:  BRA    97A0
.................... 					} 
.................... 			 
.................... 					fputc(name_buffer[y],USB); 
0977E:  CLRF   03
09780:  MOVF   x1F,W
09782:  ADDLW  0A
09784:  MOVWF  FE9
09786:  MOVLW  08
09788:  ADDWFC 03,W
0978A:  MOVWF  FEA
0978C:  MOVFF  FEF,869
09790:  MOVFF  869,872
09794:  MOVLB  0
09796:  CALL   6DBC
.................... 				} 
0979A:  MOVLB  8
0979C:  INCF   x1F,F
0979E:  BRA    9764
....................  
.................... 				fputc(0x03); 
097A0:  MOVLW  03
097A2:  MOVWF  x72
097A4:  MOVLB  0
097A6:  CALL   6DBC
.................... 				return; 
097AA:  MOVLB  6
097AC:  BRA    986A
.................... 			break; 
097AE:  BRA    9844
....................  
.................... 			case 0x14 : 
.................... 				// GET CURRENT RVC 
....................  
.................... 				int current_adc = read_adc(); 
....................  
.................... 				double percentage = RVC_to_decibel(current_adc); 
097B0:  BSF    FC2.1
097B2:  BTFSC  FC2.1
097B4:  BRA    97B2
097B6:  MOVFF  FC4,864
097BA:  MOVFF  864,869
097BE:  MOVLB  0
097C0:  GOTO   7EEC
097C4:  MOVFF  03,868
097C8:  MOVFF  02,867
097CC:  MOVFF  01,866
097D0:  MOVFF  00,865
....................  
.................... 				fputc(0x16); 
097D4:  MOVLW  16
097D6:  MOVLB  8
097D8:  MOVWF  x72
097DA:  MOVLB  0
097DC:  CALL   6DBC
.................... 				fputc(0x14); 
097E0:  MOVLW  14
097E2:  MOVLB  8
097E4:  MOVWF  x72
097E6:  MOVLB  0
097E8:  CALL   6DBC
.................... 				fputc(current_adc); 
097EC:  MOVFF  864,872
097F0:  CALL   6DBC
097F4:  CLRF   19
097F6:  BTFSC  FF2.7
097F8:  BSF    19.7
097FA:  BCF    FF2.7
.................... 				fputc((int)percentage); 
097FC:  MOVFF  868,8EC
09800:  MOVFF  867,8EB
09804:  MOVFF  866,8EA
09808:  MOVFF  865,8E9
0980C:  CALL   13A0
09810:  BTFSC  19.7
09812:  BSF    FF2.7
09814:  MOVFF  01,869
09818:  MOVFF  01,872
0981C:  CALL   6DBC
.................... 				fputc(0x03); 
09820:  MOVLW  03
09822:  MOVLB  8
09824:  MOVWF  x72
09826:  MOVLB  0
09828:  CALL   6DBC
.................... 				return; 
0982C:  MOVLB  6
0982E:  BRA    986A
.................... 			break; 
09830:  BRA    9844
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
09832:  MOVLW  13
09834:  MOVLB  8
09836:  MOVWF  x69
09838:  MOVLB  0
0983A:  CALL   6E02
.................... 				return; 
0983E:  MOVLB  6
09840:  BRA    986A
.................... 			break; 
09842:  BRA    9844
.................... 		} 
....................  
.................... 	// How did we get here? Should be impossible.. Let's send an error though... 
.................... 	// Someone probably forgot a return statement above... D'oh! 
....................  
....................  
.................... 	fputc(0x15,USB); 
09844:  MOVLW  15
09846:  MOVLB  8
09848:  MOVWF  x72
0984A:  MOVLB  0
0984C:  CALL   6DBC
.................... 	fputc(ERR_UNKNOWN,USB); 
09850:  MOVLW  09
09852:  MOVLB  8
09854:  MOVWF  x72
09856:  MOVLB  0
09858:  CALL   6DBC
.................... 	fputc(0x03,USB); 
0985C:  MOVLW  03
0985E:  MOVLB  8
09860:  MOVWF  x72
09862:  MOVLB  0
09864:  CALL   6DBC
09868:  MOVLB  6
.................... 	return; 
.................... } 
0986A:  MOVLB  0
0986C:  GOTO   C0C0 (RETURN)
....................  
....................  
.................... #include <rs232.c> 
.................... /* RS232 BUFFER */ 
....................  
.................... int log_volume_index = 0; 
....................  
.................... #INT_RDA2 
.................... void serial_isr() { 
....................    int t; 
....................    buffer[next_in]=fgetc(RS232); 
*
00BAE:  CLRF   03
00BB0:  MOVF   x9F,W
00BB2:  ADDLW  7F
00BB4:  MOVWF  FE9
00BB6:  MOVLW  00
00BB8:  ADDWFC 03,W
00BBA:  MOVWF  FEA
00BBC:  MOVFF  FEA,8B7
00BC0:  MOVFF  FE9,8B6
00BC4:  BRA    0B96
00BC6:  MOVFF  8B7,FEA
00BCA:  MOVFF  8B6,FE9
00BCE:  MOVFF  01,FEF
.................... 	buffer_unread++; 
00BD2:  INCF   x79,F
....................    t=next_in; 
00BD4:  MOVFF  9F,8B3
....................    next_in=(next_in+1) % RS232_BUFFER_SIZE; 
00BD8:  MOVLW  01
00BDA:  ADDWF  x9F,W
00BDC:  ANDLW  1F
00BDE:  MOVWF  x9F
....................    if(next_in==next_out) 
00BE0:  MOVF   xA0,W
00BE2:  SUBWF  x9F,W
00BE4:  BNZ   0BEA
....................      next_in=t;           // Buffer full! 
00BE6:  MOVFF  8B3,9F
.................... } 
....................  
00BEA:  BCF    FA4.5
00BEC:  GOTO   0090
.................... BYTE bgetc() { 
....................    BYTE c; 
....................  
....................    c=buffer[next_out]; 
*
09870:  CLRF   03
09872:  MOVF   xA0,W
09874:  ADDLW  7F
09876:  MOVWF  FE9
09878:  MOVLW  00
0987A:  ADDWFC 03,W
0987C:  MOVWF  FEA
0987E:  MOVFF  FEF,825
09882:  MOVLB  8
....................    next_out=(next_out+1) % RS232_BUFFER_SIZE; 
09884:  MOVLW  01
09886:  MOVLB  0
09888:  ADDWF  xA0,W
0988A:  ANDLW  1F
0988C:  MOVWF  xA0
....................    buffer_unread--; 
0988E:  DECF   x79,F
.................... 	return(c); 
09890:  MOVLB  8
09892:  MOVFF  825,01
.................... } 
09896:  MOVLB  0
09898:  RETURN 0
....................  
....................  
.................... void send_rs232_error(char error_code) 
.................... { 
.................... 	fputc(0x12,RS232); 
0989A:  MOVLW  12
0989C:  CALL   7366
.................... 	fputc(error_code,RS232); 
098A0:  MOVLB  8
098A2:  MOVF   x25,W
098A4:  MOVLB  0
098A6:  CALL   7366
.................... 	fputc(0x0A,RS232); 
098AA:  MOVLW  0A
098AC:  CALL   7366
....................  
.................... 	buffer_unread = 0; 
098B0:  CLRF   x79
.................... 	next_in = 0; 
098B2:  CLRF   x9F
.................... 	next_out = 0; 
098B4:  CLRF   xA0
.................... } 
098B6:  RETURN 0
....................  
....................  
.................... void process_rs232_data() 
.................... { 
.................... 	delay_ms(20); 
*
0B354:  MOVLW  14
0B356:  MOVLB  8
0B358:  MOVWF  x74
0B35A:  MOVLB  0
0B35C:  CALL   5A08
....................  
.................... 	if(buffer_unread == 4 || buffer_unread == 5) { 
0B360:  MOVF   x79,W
0B362:  SUBLW  04
0B364:  BZ    B370
0B366:  MOVF   x79,W
0B368:  SUBLW  05
0B36A:  BTFSS  FD8.2
0B36C:  GOTO   BBC4
.................... 		RS232_BYTE1 = bgetc(); 
0B370:  CALL   9870
0B374:  MOVFF  01,7A
.................... 		RS232_BYTE2 = bgetc(); 
0B378:  CALL   9870
0B37C:  MOVFF  01,7B
.................... 		RS232_BYTE3 = bgetc(); 
0B380:  CALL   9870
0B384:  MOVFF  01,7C
.................... 		RS232_BYTE4 = bgetc(); 
0B388:  CALL   9870
0B38C:  MOVFF  01,7D
....................  
.................... 		if(buffer_unread == 1) { 
0B390:  DECFSZ x79,W
0B392:  BRA    B39E
.................... 			RS232_BYTE5 = bgetc(); 
0B394:  CALL   9870
0B398:  MOVFF  01,7E
.................... 		} else { 
0B39C:  BRA    B3A0
.................... 			RS232_BYTE5 = 0xFF; 
0B39E:  SETF   x7E
.................... 		} 
....................  
.................... 		if(RS232_BYTE1 != 0x12) 
0B3A0:  MOVF   x7A,W
0B3A2:  SUBLW  12
0B3A4:  BZ    B3B6
.................... 		{ 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"Bad RS232 command: %x %x %x %x %x\r",RS232_BYTE1,RS232_BYTE2,RS232_BYTE3,RS232_BYTE4,RS232_BYTE5); 
.................... 			} 
....................  
.................... 			send_rs232_error(ERR_INVALID_START); 
0B3A6:  MOVLW  02
0B3A8:  MOVLB  8
0B3AA:  MOVWF  x25
0B3AC:  MOVLB  0
0B3AE:  CALL   989A
.................... 			return; 
0B3B2:  GOTO   BBDE
.................... 		} 
....................  
.................... 		switch(RS232_BYTE2) { 
0B3B6:  MOVF   x7B,W
0B3B8:  XORLW  01
0B3BA:  BZ    B464
0B3BC:  XORLW  54
0B3BE:  BZ    B464
0B3C0:  XORLW  57
0B3C2:  BTFSC  FD8.2
0B3C4:  BRA    B568
0B3C6:  XORLW  77
0B3C8:  BTFSC  FD8.2
0B3CA:  BRA    B568
0B3CC:  XORLW  71
0B3CE:  BTFSC  FD8.2
0B3D0:  BRA    B66C
0B3D2:  XORLW  40
0B3D4:  BTFSC  FD8.2
0B3D6:  BRA    B66C
0B3D8:  XORLW  41
0B3DA:  BTFSC  FD8.2
0B3DC:  BRA    B770
0B3DE:  XORLW  61
0B3E0:  BTFSC  FD8.2
0B3E2:  BRA    B770
0B3E4:  XORLW  62
0B3E6:  BTFSC  FD8.2
0B3E8:  BRA    B874
0B3EA:  XORLW  50
0B3EC:  BTFSC  FD8.2
0B3EE:  BRA    B874
0B3F0:  XORLW  51
0B3F2:  BTFSC  FD8.2
0B3F4:  BRA    B97C
0B3F6:  XORLW  45
0B3F8:  BTFSC  FD8.2
0B3FA:  BRA    B97C
0B3FC:  XORLW  4A
0B3FE:  BTFSC  FD8.2
0B400:  BRA    BA14
0B402:  XORLW  45
0B404:  BTFSC  FD8.2
0B406:  BRA    BA14
0B408:  XORLW  44
0B40A:  BTFSC  FD8.2
0B40C:  BRA    BA32
0B40E:  XORLW  64
0B410:  BTFSC  FD8.2
0B412:  BRA    BA32
0B414:  XORLW  7D
0B416:  BTFSC  FD8.2
0B418:  BRA    BA50
0B41A:  XORLW  44
0B41C:  BTFSC  FD8.2
0B41E:  BRA    BA50
0B420:  XORLW  45
0B422:  BTFSC  FD8.2
0B424:  BRA    BA76
0B426:  XORLW  52
0B428:  BTFSC  FD8.2
0B42A:  BRA    BA76
0B42C:  XORLW  51
0B42E:  BTFSC  FD8.2
0B430:  BRA    BAA4
0B432:  XORLW  01
0B434:  BTFSC  FD8.2
0B436:  BRA    BAC2
0B438:  XORLW  55
0B43A:  BTFSC  FD8.2
0B43C:  BRA    BAC2
0B43E:  XORLW  52
0B440:  BTFSC  FD8.2
0B442:  BRA    BB14
0B444:  XORLW  01
0B446:  BTFSC  FD8.2
0B448:  BRA    BB1A
0B44A:  XORLW  03
0B44C:  BTFSC  FD8.2
0B44E:  BRA    BB1E
0B450:  XORLW  01
0B452:  BTFSC  FD8.2
0B454:  BRA    BB50
0B456:  XORLW  0F
0B458:  BTFSC  FD8.2
0B45A:  BRA    BB82
0B45C:  XORLW  01
0B45E:  BTFSC  FD8.2
0B460:  BRA    BB90
0B462:  BRA    BBC2
....................  
.................... 			case 0x01: 
.................... 			case 0x55: 
.................... 				// Volume up 10% 
.................... 				 
.................... 				vol_big_up_output(RS232_BYTE3); 
0B464:  MOVFF  7C,825
0B468:  GOTO   98B8
....................  
.................... 				fputc(0x06,RS232); 
0B46C:  MOVLW  06
0B46E:  CALL   7366
.................... 				if(RS232_BYTE3 == 0) { 
0B472:  MOVF   x7C,F
0B474:  BNZ   B4D6
0B476:  CLRF   19
0B478:  BTFSC  FF2.7
0B47A:  BSF    19.7
0B47C:  BCF    FF2.7
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0B47E:  MOVFF  B8,8EC
0B482:  MOVFF  B7,8EB
0B486:  MOVFF  B6,8EA
0B48A:  MOVFF  B5,8E9
0B48E:  MOVLB  8
0B490:  CLRF   xF0
0B492:  CLRF   xEF
0B494:  MOVLW  48
0B496:  MOVWF  xEE
0B498:  MOVLW  85
0B49A:  MOVWF  xED
0B49C:  MOVLB  0
0B49E:  CALL   1230
0B4A2:  BTFSC  19.7
0B4A4:  BSF    FF2.7
0B4A6:  CLRF   19
0B4A8:  BTFSC  FF2.7
0B4AA:  BSF    19.7
0B4AC:  BCF    FF2.7
0B4AE:  MOVFF  03,8EC
0B4B2:  MOVFF  02,8EB
0B4B6:  MOVFF  01,8EA
0B4BA:  MOVFF  00,8E9
0B4BE:  CALL   13A0
0B4C2:  BTFSC  19.7
0B4C4:  BSF    FF2.7
0B4C6:  MOVFF  01,825
0B4CA:  MOVLB  8
0B4CC:  MOVF   x25,W
0B4CE:  MOVLB  0
0B4D0:  CALL   7366
.................... 				} else { 
0B4D4:  BRA    B55E
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B4D6:  MOVLW  01
0B4D8:  SUBWF  x7C,W
0B4DA:  MULLW  04
0B4DC:  MOVF   FF3,W
0B4DE:  CLRF   03
0B4E0:  ADDLW  B5
0B4E2:  MOVWF  FE9
0B4E4:  MOVLW  00
0B4E6:  ADDWFC 03,W
0B4E8:  MOVWF  FEA
0B4EA:  MOVFF  FEF,825
0B4EE:  MOVFF  FEC,826
0B4F2:  MOVFF  FEC,827
0B4F6:  MOVFF  FEC,828
0B4FA:  MOVF   FED,F
0B4FC:  MOVF   FED,F
0B4FE:  MOVF   FED,F
0B500:  CLRF   19
0B502:  BTFSC  FF2.7
0B504:  BSF    19.7
0B506:  BCF    FF2.7
0B508:  MOVFF  828,8EC
0B50C:  MOVFF  827,8EB
0B510:  MOVFF  826,8EA
0B514:  MOVFF  825,8E9
0B518:  MOVLB  8
0B51A:  CLRF   xF0
0B51C:  CLRF   xEF
0B51E:  MOVLW  48
0B520:  MOVWF  xEE
0B522:  MOVLW  85
0B524:  MOVWF  xED
0B526:  MOVLB  0
0B528:  CALL   1230
0B52C:  BTFSC  19.7
0B52E:  BSF    FF2.7
0B530:  CLRF   19
0B532:  BTFSC  FF2.7
0B534:  BSF    19.7
0B536:  BCF    FF2.7
0B538:  MOVFF  03,8EC
0B53C:  MOVFF  02,8EB
0B540:  MOVFF  01,8EA
0B544:  MOVFF  00,8E9
0B548:  CALL   13A0
0B54C:  BTFSC  19.7
0B54E:  BSF    FF2.7
0B550:  MOVFF  01,825
0B554:  MOVLB  8
0B556:  MOVF   x25,W
0B558:  MOVLB  0
0B55A:  CALL   7366
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0B55E:  MOVLW  0A
0B560:  CALL   7366
.................... 				return; 
0B564:  BRA    BBDE
.................... 			break; 
0B566:  BRA    BBC2
....................  
.................... 			case 0x02: 
.................... 			case 0x75: 
.................... 				// Volume up 5% 
....................  
.................... 				vol_small_up_output(RS232_BYTE3); 
0B568:  MOVFF  7C,825
0B56C:  GOTO   9C84
....................  
.................... 				fputc(0x06,RS232); 
0B570:  MOVLW  06
0B572:  CALL   7366
.................... 				if(RS232_BYTE3 == 0) { 
0B576:  MOVF   x7C,F
0B578:  BNZ   B5DA
0B57A:  CLRF   19
0B57C:  BTFSC  FF2.7
0B57E:  BSF    19.7
0B580:  BCF    FF2.7
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0B582:  MOVFF  B8,8EC
0B586:  MOVFF  B7,8EB
0B58A:  MOVFF  B6,8EA
0B58E:  MOVFF  B5,8E9
0B592:  MOVLB  8
0B594:  CLRF   xF0
0B596:  CLRF   xEF
0B598:  MOVLW  48
0B59A:  MOVWF  xEE
0B59C:  MOVLW  85
0B59E:  MOVWF  xED
0B5A0:  MOVLB  0
0B5A2:  CALL   1230
0B5A6:  BTFSC  19.7
0B5A8:  BSF    FF2.7
0B5AA:  CLRF   19
0B5AC:  BTFSC  FF2.7
0B5AE:  BSF    19.7
0B5B0:  BCF    FF2.7
0B5B2:  MOVFF  03,8EC
0B5B6:  MOVFF  02,8EB
0B5BA:  MOVFF  01,8EA
0B5BE:  MOVFF  00,8E9
0B5C2:  CALL   13A0
0B5C6:  BTFSC  19.7
0B5C8:  BSF    FF2.7
0B5CA:  MOVFF  01,825
0B5CE:  MOVLB  8
0B5D0:  MOVF   x25,W
0B5D2:  MOVLB  0
0B5D4:  CALL   7366
.................... 				} else { 
0B5D8:  BRA    B662
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B5DA:  MOVLW  01
0B5DC:  SUBWF  x7C,W
0B5DE:  MULLW  04
0B5E0:  MOVF   FF3,W
0B5E2:  CLRF   03
0B5E4:  ADDLW  B5
0B5E6:  MOVWF  FE9
0B5E8:  MOVLW  00
0B5EA:  ADDWFC 03,W
0B5EC:  MOVWF  FEA
0B5EE:  MOVFF  FEF,825
0B5F2:  MOVFF  FEC,826
0B5F6:  MOVFF  FEC,827
0B5FA:  MOVFF  FEC,828
0B5FE:  MOVF   FED,F
0B600:  MOVF   FED,F
0B602:  MOVF   FED,F
0B604:  CLRF   19
0B606:  BTFSC  FF2.7
0B608:  BSF    19.7
0B60A:  BCF    FF2.7
0B60C:  MOVFF  828,8EC
0B610:  MOVFF  827,8EB
0B614:  MOVFF  826,8EA
0B618:  MOVFF  825,8E9
0B61C:  MOVLB  8
0B61E:  CLRF   xF0
0B620:  CLRF   xEF
0B622:  MOVLW  48
0B624:  MOVWF  xEE
0B626:  MOVLW  85
0B628:  MOVWF  xED
0B62A:  MOVLB  0
0B62C:  CALL   1230
0B630:  BTFSC  19.7
0B632:  BSF    FF2.7
0B634:  CLRF   19
0B636:  BTFSC  FF2.7
0B638:  BSF    19.7
0B63A:  BCF    FF2.7
0B63C:  MOVFF  03,8EC
0B640:  MOVFF  02,8EB
0B644:  MOVFF  01,8EA
0B648:  MOVFF  00,8E9
0B64C:  CALL   13A0
0B650:  BTFSC  19.7
0B652:  BSF    FF2.7
0B654:  MOVFF  01,825
0B658:  MOVLB  8
0B65A:  MOVF   x25,W
0B65C:  MOVLB  0
0B65E:  CALL   7366
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0B662:  MOVLW  0A
0B664:  CALL   7366
.................... 				return; 
0B668:  BRA    BBDE
.................... 			break; 
0B66A:  BRA    BBC2
....................  
.................... 			case 0x04: 
.................... 			case 0x44: 
.................... 				// Volume down 10% 
....................  
.................... 				vol_big_down_output(RS232_BYTE3); 
0B66C:  MOVFF  7C,825
0B670:  GOTO   A04E
....................  
.................... 				fputc(0x06,RS232); 
0B674:  MOVLW  06
0B676:  CALL   7366
.................... 				if(RS232_BYTE3 == 0) { 
0B67A:  MOVF   x7C,F
0B67C:  BNZ   B6DE
0B67E:  CLRF   19
0B680:  BTFSC  FF2.7
0B682:  BSF    19.7
0B684:  BCF    FF2.7
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0B686:  MOVFF  B8,8EC
0B68A:  MOVFF  B7,8EB
0B68E:  MOVFF  B6,8EA
0B692:  MOVFF  B5,8E9
0B696:  MOVLB  8
0B698:  CLRF   xF0
0B69A:  CLRF   xEF
0B69C:  MOVLW  48
0B69E:  MOVWF  xEE
0B6A0:  MOVLW  85
0B6A2:  MOVWF  xED
0B6A4:  MOVLB  0
0B6A6:  CALL   1230
0B6AA:  BTFSC  19.7
0B6AC:  BSF    FF2.7
0B6AE:  CLRF   19
0B6B0:  BTFSC  FF2.7
0B6B2:  BSF    19.7
0B6B4:  BCF    FF2.7
0B6B6:  MOVFF  03,8EC
0B6BA:  MOVFF  02,8EB
0B6BE:  MOVFF  01,8EA
0B6C2:  MOVFF  00,8E9
0B6C6:  CALL   13A0
0B6CA:  BTFSC  19.7
0B6CC:  BSF    FF2.7
0B6CE:  MOVFF  01,825
0B6D2:  MOVLB  8
0B6D4:  MOVF   x25,W
0B6D6:  MOVLB  0
0B6D8:  CALL   7366
.................... 				} else { 
0B6DC:  BRA    B766
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B6DE:  MOVLW  01
0B6E0:  SUBWF  x7C,W
0B6E2:  MULLW  04
0B6E4:  MOVF   FF3,W
0B6E6:  CLRF   03
0B6E8:  ADDLW  B5
0B6EA:  MOVWF  FE9
0B6EC:  MOVLW  00
0B6EE:  ADDWFC 03,W
0B6F0:  MOVWF  FEA
0B6F2:  MOVFF  FEF,825
0B6F6:  MOVFF  FEC,826
0B6FA:  MOVFF  FEC,827
0B6FE:  MOVFF  FEC,828
0B702:  MOVF   FED,F
0B704:  MOVF   FED,F
0B706:  MOVF   FED,F
0B708:  CLRF   19
0B70A:  BTFSC  FF2.7
0B70C:  BSF    19.7
0B70E:  BCF    FF2.7
0B710:  MOVFF  828,8EC
0B714:  MOVFF  827,8EB
0B718:  MOVFF  826,8EA
0B71C:  MOVFF  825,8E9
0B720:  MOVLB  8
0B722:  CLRF   xF0
0B724:  CLRF   xEF
0B726:  MOVLW  48
0B728:  MOVWF  xEE
0B72A:  MOVLW  85
0B72C:  MOVWF  xED
0B72E:  MOVLB  0
0B730:  CALL   1230
0B734:  BTFSC  19.7
0B736:  BSF    FF2.7
0B738:  CLRF   19
0B73A:  BTFSC  FF2.7
0B73C:  BSF    19.7
0B73E:  BCF    FF2.7
0B740:  MOVFF  03,8EC
0B744:  MOVFF  02,8EB
0B748:  MOVFF  01,8EA
0B74C:  MOVFF  00,8E9
0B750:  CALL   13A0
0B754:  BTFSC  19.7
0B756:  BSF    FF2.7
0B758:  MOVFF  01,825
0B75C:  MOVLB  8
0B75E:  MOVF   x25,W
0B760:  MOVLB  0
0B762:  CALL   7366
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0B766:  MOVLW  0A
0B768:  CALL   7366
.................... 				return; 
0B76C:  BRA    BBDE
.................... 			break; 
0B76E:  BRA    BBC2
....................  
.................... 			case 0x05: 
.................... 			case 0x64: 
.................... 				// Volume down 5% 
....................  
.................... 				vol_small_down_output(RS232_BYTE3); 
0B770:  MOVFF  7C,825
0B774:  GOTO   A426
....................  
.................... 				fputc(0x06,RS232); 
0B778:  MOVLW  06
0B77A:  CALL   7366
.................... 				if(RS232_BYTE3 == 0) { 
0B77E:  MOVF   x7C,F
0B780:  BNZ   B7E2
0B782:  CLRF   19
0B784:  BTFSC  FF2.7
0B786:  BSF    19.7
0B788:  BCF    FF2.7
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0B78A:  MOVFF  B8,8EC
0B78E:  MOVFF  B7,8EB
0B792:  MOVFF  B6,8EA
0B796:  MOVFF  B5,8E9
0B79A:  MOVLB  8
0B79C:  CLRF   xF0
0B79E:  CLRF   xEF
0B7A0:  MOVLW  48
0B7A2:  MOVWF  xEE
0B7A4:  MOVLW  85
0B7A6:  MOVWF  xED
0B7A8:  MOVLB  0
0B7AA:  CALL   1230
0B7AE:  BTFSC  19.7
0B7B0:  BSF    FF2.7
0B7B2:  CLRF   19
0B7B4:  BTFSC  FF2.7
0B7B6:  BSF    19.7
0B7B8:  BCF    FF2.7
0B7BA:  MOVFF  03,8EC
0B7BE:  MOVFF  02,8EB
0B7C2:  MOVFF  01,8EA
0B7C6:  MOVFF  00,8E9
0B7CA:  CALL   13A0
0B7CE:  BTFSC  19.7
0B7D0:  BSF    FF2.7
0B7D2:  MOVFF  01,825
0B7D6:  MOVLB  8
0B7D8:  MOVF   x25,W
0B7DA:  MOVLB  0
0B7DC:  CALL   7366
.................... 				} else { 
0B7E0:  BRA    B86A
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B7E2:  MOVLW  01
0B7E4:  SUBWF  x7C,W
0B7E6:  MULLW  04
0B7E8:  MOVF   FF3,W
0B7EA:  CLRF   03
0B7EC:  ADDLW  B5
0B7EE:  MOVWF  FE9
0B7F0:  MOVLW  00
0B7F2:  ADDWFC 03,W
0B7F4:  MOVWF  FEA
0B7F6:  MOVFF  FEF,825
0B7FA:  MOVFF  FEC,826
0B7FE:  MOVFF  FEC,827
0B802:  MOVFF  FEC,828
0B806:  MOVF   FED,F
0B808:  MOVF   FED,F
0B80A:  MOVF   FED,F
0B80C:  CLRF   19
0B80E:  BTFSC  FF2.7
0B810:  BSF    19.7
0B812:  BCF    FF2.7
0B814:  MOVFF  828,8EC
0B818:  MOVFF  827,8EB
0B81C:  MOVFF  826,8EA
0B820:  MOVFF  825,8E9
0B824:  MOVLB  8
0B826:  CLRF   xF0
0B828:  CLRF   xEF
0B82A:  MOVLW  48
0B82C:  MOVWF  xEE
0B82E:  MOVLW  85
0B830:  MOVWF  xED
0B832:  MOVLB  0
0B834:  CALL   1230
0B838:  BTFSC  19.7
0B83A:  BSF    FF2.7
0B83C:  CLRF   19
0B83E:  BTFSC  FF2.7
0B840:  BSF    19.7
0B842:  BCF    FF2.7
0B844:  MOVFF  03,8EC
0B848:  MOVFF  02,8EB
0B84C:  MOVFF  01,8EA
0B850:  MOVFF  00,8E9
0B854:  CALL   13A0
0B858:  BTFSC  19.7
0B85A:  BSF    FF2.7
0B85C:  MOVFF  01,825
0B860:  MOVLB  8
0B862:  MOVF   x25,W
0B864:  MOVLB  0
0B866:  CALL   7366
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0B86A:  MOVLW  0A
0B86C:  CALL   7366
.................... 				return; 
0B870:  BRA    BBDE
.................... 			break; 
0B872:  BRA    BBC2
....................  
.................... 			case 0x06: 
.................... 			case 0x56: 
.................... 				// Discrete volume 
....................  
.................... 				discrete_vol_output(RS232_BYTE3,RS232_BYTE4); 
0B874:  MOVFF  7C,869
0B878:  MOVFF  7D,86A
0B87C:  CALL   79F8
....................  
.................... 				fputc(0x06,RS232); 
0B880:  MOVLW  06
0B882:  CALL   7366
.................... 			 
.................... 				if(RS232_BYTE3 == 0) { 
0B886:  MOVF   x7C,F
0B888:  BNZ   B8EA
0B88A:  CLRF   19
0B88C:  BTFSC  FF2.7
0B88E:  BSF    19.7
0B890:  BCF    FF2.7
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0B892:  MOVFF  B8,8EC
0B896:  MOVFF  B7,8EB
0B89A:  MOVFF  B6,8EA
0B89E:  MOVFF  B5,8E9
0B8A2:  MOVLB  8
0B8A4:  CLRF   xF0
0B8A6:  CLRF   xEF
0B8A8:  MOVLW  48
0B8AA:  MOVWF  xEE
0B8AC:  MOVLW  85
0B8AE:  MOVWF  xED
0B8B0:  MOVLB  0
0B8B2:  CALL   1230
0B8B6:  BTFSC  19.7
0B8B8:  BSF    FF2.7
0B8BA:  CLRF   19
0B8BC:  BTFSC  FF2.7
0B8BE:  BSF    19.7
0B8C0:  BCF    FF2.7
0B8C2:  MOVFF  03,8EC
0B8C6:  MOVFF  02,8EB
0B8CA:  MOVFF  01,8EA
0B8CE:  MOVFF  00,8E9
0B8D2:  CALL   13A0
0B8D6:  BTFSC  19.7
0B8D8:  BSF    FF2.7
0B8DA:  MOVFF  01,825
0B8DE:  MOVLB  8
0B8E0:  MOVF   x25,W
0B8E2:  MOVLB  0
0B8E4:  CALL   7366
.................... 				} else { 
0B8E8:  BRA    B972
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B8EA:  MOVLW  01
0B8EC:  SUBWF  x7C,W
0B8EE:  MULLW  04
0B8F0:  MOVF   FF3,W
0B8F2:  CLRF   03
0B8F4:  ADDLW  B5
0B8F6:  MOVWF  FE9
0B8F8:  MOVLW  00
0B8FA:  ADDWFC 03,W
0B8FC:  MOVWF  FEA
0B8FE:  MOVFF  FEF,825
0B902:  MOVFF  FEC,826
0B906:  MOVFF  FEC,827
0B90A:  MOVFF  FEC,828
0B90E:  MOVF   FED,F
0B910:  MOVF   FED,F
0B912:  MOVF   FED,F
0B914:  CLRF   19
0B916:  BTFSC  FF2.7
0B918:  BSF    19.7
0B91A:  BCF    FF2.7
0B91C:  MOVFF  828,8EC
0B920:  MOVFF  827,8EB
0B924:  MOVFF  826,8EA
0B928:  MOVFF  825,8E9
0B92C:  MOVLB  8
0B92E:  CLRF   xF0
0B930:  CLRF   xEF
0B932:  MOVLW  48
0B934:  MOVWF  xEE
0B936:  MOVLW  85
0B938:  MOVWF  xED
0B93A:  MOVLB  0
0B93C:  CALL   1230
0B940:  BTFSC  19.7
0B942:  BSF    FF2.7
0B944:  CLRF   19
0B946:  BTFSC  FF2.7
0B948:  BSF    19.7
0B94A:  BCF    FF2.7
0B94C:  MOVFF  03,8EC
0B950:  MOVFF  02,8EB
0B954:  MOVFF  01,8EA
0B958:  MOVFF  00,8E9
0B95C:  CALL   13A0
0B960:  BTFSC  19.7
0B962:  BSF    FF2.7
0B964:  MOVFF  01,825
0B968:  MOVLB  8
0B96A:  MOVF   x25,W
0B96C:  MOVLB  0
0B96E:  CALL   7366
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0B972:  MOVLW  0A
0B974:  CALL   7366
.................... 				return; 
0B978:  BRA    BBDE
.................... 			break; 
0B97A:  BRA    BBC2
....................  
.................... 			case 0x07: 
.................... 			case 0x42: 
.................... 				// Volume Status 
....................  
.................... 				fputc(0x06,RS232); 
0B97C:  MOVLW  06
0B97E:  CALL   7366
.................... 				fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0B982:  MOVLW  01
0B984:  SUBWF  x7C,W
0B986:  MULLW  04
0B988:  MOVF   FF3,W
0B98A:  CLRF   03
0B98C:  ADDLW  B5
0B98E:  MOVWF  FE9
0B990:  MOVLW  00
0B992:  ADDWFC 03,W
0B994:  MOVWF  FEA
0B996:  MOVFF  FEF,825
0B99A:  MOVFF  FEC,826
0B99E:  MOVFF  FEC,827
0B9A2:  MOVFF  FEC,828
0B9A6:  MOVF   FED,F
0B9A8:  MOVF   FED,F
0B9AA:  MOVF   FED,F
0B9AC:  CLRF   19
0B9AE:  BTFSC  FF2.7
0B9B0:  BSF    19.7
0B9B2:  BCF    FF2.7
0B9B4:  MOVFF  828,8EC
0B9B8:  MOVFF  827,8EB
0B9BC:  MOVFF  826,8EA
0B9C0:  MOVFF  825,8E9
0B9C4:  MOVLB  8
0B9C6:  CLRF   xF0
0B9C8:  CLRF   xEF
0B9CA:  MOVLW  48
0B9CC:  MOVWF  xEE
0B9CE:  MOVLW  85
0B9D0:  MOVWF  xED
0B9D2:  MOVLB  0
0B9D4:  CALL   1230
0B9D8:  BTFSC  19.7
0B9DA:  BSF    FF2.7
0B9DC:  CLRF   19
0B9DE:  BTFSC  FF2.7
0B9E0:  BSF    19.7
0B9E2:  BCF    FF2.7
0B9E4:  MOVFF  03,8EC
0B9E8:  MOVFF  02,8EB
0B9EC:  MOVFF  01,8EA
0B9F0:  MOVFF  00,8E9
0B9F4:  CALL   13A0
0B9F8:  BTFSC  19.7
0B9FA:  BSF    FF2.7
0B9FC:  MOVFF  01,825
0BA00:  MOVLB  8
0BA02:  MOVF   x25,W
0BA04:  MOVLB  0
0BA06:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BA0A:  MOVLW  0A
0BA0C:  CALL   7366
.................... 				return; 
0BA10:  BRA    BBDE
.................... 			break; 
0BA12:  BRA    BBC2
....................  
.................... 			case 0x08: 
.................... 			case 0x4D: 
.................... 				// Force mute on 
.................... 				 
.................... 				mute_on_output(RS232_BYTE3); 
0BA14:  MOVFF  7C,825
0BA18:  GOTO   A7FA
.................... 				fputc(0x06,RS232); 
0BA1C:  MOVLW  06
0BA1E:  CALL   7366
.................... 				fputc(0x01,RS232); 
0BA22:  MOVLW  01
0BA24:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BA28:  MOVLW  0A
0BA2A:  CALL   7366
.................... 				return; 
0BA2E:  BRA    BBDE
.................... 			break; 
0BA30:  BRA    BBC2
....................  
.................... 			case 0x09: 
.................... 			case 0x6D: 
.................... 				// Force mute off 
.................... 				 
.................... 				mute_off_output(RS232_BYTE3); 
0BA32:  MOVFF  7C,825
0BA36:  GOTO   A8CC
.................... 				fputc(0x06,RS232); 
0BA3A:  MOVLW  06
0BA3C:  CALL   7366
.................... 				fputc(0x00,RS232); 
0BA40:  MOVLW  00
0BA42:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BA46:  MOVLW  0A
0BA48:  CALL   7366
.................... 				return; 
0BA4C:  BRA    BBDE
.................... 			break; 
0BA4E:  BRA    BBC2
....................  
.................... 			case 0x10: 
.................... 			case 0x54: 
.................... 				// Toggle mute 
....................  
.................... 				fputc(0x06,RS232); 
0BA50:  MOVLW  06
0BA52:  CALL   7366
.................... 				fputc(mute_toggle_output(RS232_BYTE3),RS232); 
0BA56:  MOVFF  7C,869
0BA5A:  CALL   76F8
0BA5E:  MOVFF  01,825
0BA62:  MOVLB  8
0BA64:  MOVF   x25,W
0BA66:  MOVLB  0
0BA68:  CALL   7366
.................... 				fputc(0x0A,RS232);	 
0BA6C:  MOVLW  0A
0BA6E:  CALL   7366
.................... 				return; 
0BA72:  BRA    BBDE
.................... 			break; 
0BA74:  BRA    BBC2
....................  
.................... 			case 0x11: 
.................... 			case 0x43: 
.................... 			// Mute status 
....................  
.................... 				fputc(0x06,RS232); 
0BA76:  MOVLW  06
0BA78:  CALL   7366
.................... 				fputc(((int)(rs232_output_mute[RS232_BYTE3-1])),RS232); 
0BA7C:  MOVLW  01
0BA7E:  SUBWF  x7C,W
0BA80:  CLRF   03
0BA82:  ADDLW  C5
0BA84:  MOVWF  FE9
0BA86:  MOVLW  00
0BA88:  ADDWFC 03,W
0BA8A:  MOVWF  FEA
0BA8C:  MOVFF  FEF,825
0BA90:  MOVLB  8
0BA92:  MOVF   x25,W
0BA94:  MOVLB  0
0BA96:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BA9A:  MOVLW  0A
0BA9C:  CALL   7366
.................... 				return; 
0BAA0:  BRA    BBDE
.................... 			break; 
0BAA2:  BRA    BBC2
....................  
.................... 			case 0x12: 
.................... 				// Change preset 
....................  
.................... 				switch_flash_program(RS232_BYTE3); 
0BAA4:  MOVFF  7C,869
0BAA8:  CALL   70A8
....................  
.................... 				fputc(0x06,RS232); 
0BAAC:  MOVLW  06
0BAAE:  CALL   7366
.................... 				fputc(((int)CURRENT_FLASH_PROGRAM),RS232); 
0BAB2:  MOVF   xCD,W
0BAB4:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BAB8:  MOVLW  0A
0BABA:  CALL   7366
.................... 				return; 
0BABE:  BRA    BBDE
....................  
.................... 			break; 
0BAC0:  BRA    BBC2
....................  
.................... 			case 0x13: 
.................... 			case 0x46: 
.................... 				// Firmware version 
.................... 				fprintf(RS232,"PIC firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
0BAC2:  MOVLW  14
0BAC4:  MOVWF  FF6
0BAC6:  MOVLW  0C
0BAC8:  MOVWF  FF7
0BACA:  MOVLW  11
0BACC:  MOVLB  8
0BACE:  MOVWF  x77
0BAD0:  MOVLB  0
0BAD2:  CALL   5A52
0BAD6:  MOVFF  61,877
0BADA:  MOVLW  1B
0BADC:  MOVLB  8
0BADE:  MOVWF  x78
0BAE0:  MOVLB  0
0BAE2:  CALL   5AA8
0BAE6:  MOVLW  2E
0BAE8:  BTFSS  FA4.4
0BAEA:  BRA    BAE8
0BAEC:  MOVWF  F73
0BAEE:  MOVFF  62,877
0BAF2:  MOVLW  1B
0BAF4:  MOVLB  8
0BAF6:  MOVWF  x78
0BAF8:  MOVLB  0
0BAFA:  CALL   5AA8
0BAFE:  CLRF   FEA
0BB00:  MOVLW  63
0BB02:  MOVWF  FE9
0BB04:  CALL   5B26
0BB08:  MOVLW  0D
0BB0A:  BTFSS  FA4.4
0BB0C:  BRA    BB0A
0BB0E:  MOVWF  F73
.................... 				return; 
0BB10:  BRA    BBDE
.................... 			break; 
0BB12:  BRA    BBC2
....................  
.................... 			case 0x14: 
.................... 				// Softboot 
.................... 				softboot(); 
0BB14:  CALL   6786
....................  
.................... 			break; 
0BB18:  BRA    BBC2
....................  
.................... 			case 0x15 : 
.................... 				reset_cpu(); 
0BB1A:  RESET
.................... 			break; 
0BB1C:  BRA    BBC2
....................  
.................... 			case 0x16: 
.................... 				int return_log_vol_up = log_volume_up(RS232_BYTE3,RS232_BYTE4); 
0BB1E:  MOVFF  7C,825
0BB22:  MOVFF  7D,826
0BB26:  GOTO   AAA6
0BB2A:  MOVFF  01,821
.................... 				fputc(0x06,RS232); 
0BB2E:  MOVLW  06
0BB30:  CALL   7366
.................... 				fputc(60-return_log_vol_up,RS232); 
0BB34:  MOVLW  3C
0BB36:  BSF    FD8.0
0BB38:  MOVLB  8
0BB3A:  SUBFWB x21,W
0BB3C:  MOVWF  x25
0BB3E:  MOVF   x25,W
0BB40:  MOVLB  0
0BB42:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BB46:  MOVLW  0A
0BB48:  CALL   7366
.................... 				return; 
0BB4C:  BRA    BBDE
.................... 			break; 
0BB4E:  BRA    BBC2
....................  
.................... 			case 0x17: 
.................... 				int return_log_vol_down = log_volume_down(RS232_BYTE3,RS232_BYTE4); 
0BB50:  MOVFF  7C,825
0BB54:  MOVFF  7D,826
0BB58:  GOTO   AD62
0BB5C:  MOVFF  01,822
....................  
.................... 				fputc(0x06,RS232); 
0BB60:  MOVLW  06
0BB62:  CALL   7366
.................... 				fputc(60-return_log_vol_down,RS232); 
0BB66:  MOVLW  3C
0BB68:  BSF    FD8.0
0BB6A:  MOVLB  8
0BB6C:  SUBFWB x22,W
0BB6E:  MOVWF  x25
0BB70:  MOVF   x25,W
0BB72:  MOVLB  0
0BB74:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BB78:  MOVLW  0A
0BB7A:  CALL   7366
.................... 				return; 
0BB7E:  BRA    BBDE
.................... 			break; 
0BB80:  BRA    BBC2
....................  
.................... 			case 0x18: 
.................... 			   	discrete_log_volume(RS232_BYTE3,RS232_BYTE4); 
0BB82:  MOVFF  7C,825
0BB86:  MOVFF  7D,826
0BB8A:  GOTO   B01E
.................... 			break; 
0BB8E:  BRA    BBC2
....................  
.................... 			case 0x19: 
.................... 				// LOG VOLUME STATUS 
.................... 				fputc(0x06,RS232); 
0BB90:  MOVLW  06
0BB92:  CALL   7366
.................... 				fputc(60-rs232_log_output_vol_index[RS232_BYTE3-1],RS232); 
0BB96:  MOVLW  01
0BB98:  SUBWF  x7C,W
0BB9A:  CLRF   03
0BB9C:  ADDLW  C9
0BB9E:  MOVWF  FE9
0BBA0:  MOVLW  00
0BBA2:  ADDWFC 03,W
0BBA4:  MOVWF  FEA
0BBA6:  MOVF   FEF,W
0BBA8:  XORLW  FF
0BBAA:  ADDLW  3D
0BBAC:  MOVLB  8
0BBAE:  MOVWF  x25
0BBB0:  MOVF   x25,W
0BBB2:  MOVLB  0
0BBB4:  CALL   7366
.................... 				fputc(0x0A,RS232); 
0BBB8:  MOVLW  0A
0BBBA:  CALL   7366
.................... 				return; 
0BBBE:  BRA    BBDE
.................... 			break; 
0BBC0:  BRA    BBC2
....................  
....................  
.................... 		} 
.................... 		 
.................... 	} else { 
0BBC2:  BRA    BBDE
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"ERR unknown. Buffer unread: %u, next_in = %u, next_out = %u, \r\n",buffer_unread,next_in,next_out); 
.................... 			char temporary_byte = 0x00; 
0BBC4:  MOVLB  8
0BBC6:  CLRF   x23
....................  
.................... 			for(int bleah = 0; bleah < buffer_unread; bleah++) { 
0BBC8:  CLRF   x24
.................... 				temporary_byte = bgetc(); 
.................... 				fprintf(RS232,"Byte %u: %x\r\n",bleah,temporary_byte); 
.................... 			} 
.................... 		} 
....................  
.................... 		buffer_unread = 0; 
0BBCA:  MOVLB  0
0BBCC:  CLRF   x79
.................... 		next_in = 0; 
0BBCE:  CLRF   x9F
.................... 		next_out = 0; 
0BBD0:  CLRF   xA0
.................... 		send_rs232_error(ERR_UNKNOWN); 
0BBD2:  MOVLW  09
0BBD4:  MOVLB  8
0BBD6:  MOVWF  x25
0BBD8:  MOVLB  0
0BBDA:  CALL   989A
....................  
.................... 		 
.................... 	} 
.................... } 
0BBDE:  GOTO   C0CA (RETURN)
....................  
.................... #include <interrupts.c> 
.................... void disable_all_timers() 
.................... { 
.................... 	clear_interrupt(INT_TIMER0); 
*
02904:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02906:  BCF    F9E.0
.................... 	SETUP_TIMER_0(RTCC_OFF); 
02908:  CLRF   FD5
.................... 	setup_timer_1(T1_DISABLED); 
0290A:  CLRF   FCD
0290C:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
0290E:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02910:  BCF    F9E.0
.................... } 
02912:  GOTO   29B4 (RETURN)
....................  
.................... void enable_all_timers() 
.................... { 
....................  
.................... 	clear_interrupt(INT_TIMER0); 
*
02982:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02984:  BCF    F9E.0
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
02986:  MOVLW  85
02988:  MOVWF  FD5
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0298A:  MOVLW  37
0298C:  MOVWF  FCD
0298E:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
02990:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02992:  BCF    F9E.0
....................  
.................... 	setup_interrupts(); 
02994:  RCALL  2916
....................  
.................... } 
02996:  GOTO   29BC (RETURN)
....................  
.................... // SLEEP TIMER is every 1 seconds 
.................... #INT_TIMER0 
.................... void SLEEPTIMER_ISR(void)  
.................... { 
....................  
.................... 	sleepseconds++; 
*
00C7C:  MOVLB  1
00C7E:  INCF   xD2,F
00C80:  BTFSC  FD8.2
00C82:  INCF   xD3,F
....................  
.................... 	if(sleepseconds >= sleeptimeout_seconds) { 
00C84:  MOVF   xD5,W
00C86:  SUBWF  xD3,W
00C88:  BNC   0CA0
00C8A:  BNZ   0C92
00C8C:  MOVF   xD4,W
00C8E:  SUBWF  xD2,W
00C90:  BNC   0CA0
.................... 		sleepseconds = 0; 
00C92:  CLRF   xD3
00C94:  CLRF   xD2
.................... 		// TIMEOUT ROUTINE HERE 
.................... 		is_in_sleep = 1; 
00C96:  MOVLW  01
00C98:  MOVWF  xD6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, AMPLIFIER NOW IN SLEEP MODE\r\n",sleeptimeout_seconds); 
.................... 		} 
....................  
.................... 		disable_interrupts(INT_TIMER0); 
00C9A:  BCF    FF2.5
.................... 		clear_interrupt(INT_TIMER0); 
00C9C:  BCF    FF2.2
.................... 		return; 
00C9E:  BRA    0CA8
.................... 	} 
....................  
.................... 	set_timer0(7936); 
00CA0:  MOVLW  1F
00CA2:  MOVWF  FD7
00CA4:  CLRF   FD6
.................... 	clear_interrupt(INT_TIMER0); 
00CA6:  BCF    FF2.2
.................... } 
....................  
.................... // REMOTE VOLUME CONTROL 
00CA8:  BCF    FF2.2
00CAA:  MOVLB  0
00CAC:  GOTO   0090
.................... #INT_TIMER1  
.................... void RVCTIMER_ISR(void)  
.................... { 
....................  
.................... 	pin_in_mute_state = !input(PIN_AMP_nMUTE); 
*
0250A:  BSF    F94.1
0250C:  MOVLB  1
0250E:  CLRF   xD1
02510:  BTFSS  F82.1
02512:  INCF   xD1,F
.................... 	 
.................... 	set_adc_channel(0); 
02514:  MOVLW  00
02516:  MOVWF  01
02518:  MOVF   FC2,W
0251A:  ANDLW  83
0251C:  IORWF  01,W
0251E:  MOVWF  FC2
.................... 	delay_us(10); 
02520:  MOVLW  0B
02522:  MOVWF  00
02524:  DECFSZ 00,F
02526:  BRA    2524
02528:  BRA    252A
.................... 	current_adc = read_adc(); 
0252A:  BSF    FC2.1
0252C:  BTFSC  FC2.1
0252E:  BRA    252C
02530:  MOVFF  FC4,1CF
.................... 	 
.................... 	if(pin_in_mute_state && is_muted) { 
02534:  MOVF   xD1,F
02536:  BZ    2546
02538:  MOVF   xD0,F
0253A:  BZ    2546
.................... 		// Do nothing 
.................... 		set_timer1(15550); 
0253C:  MOVLW  3C
0253E:  MOVWF  FCF
02540:  MOVLW  BE
02542:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02544:  BCF    F9E.0
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(pin_in_mute_state && !is_muted) { 
02546:  MOVF   xD1,F
02548:  BZ    25CC
0254A:  MOVF   xD0,F
0254C:  BNZ   25CC
.................... 		is_muted = true; 
0254E:  MOVLW  01
02550:  MOVWF  xD0
.................... 		send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
02552:  MOVLW  83
02554:  MOVLB  8
02556:  MOVWF  xBF
02558:  CLRF   xBE
0255A:  CLRF   xBD
0255C:  MOVLW  0A
0255E:  MOVWF  xBC
02560:  CLRF   xC3
02562:  CLRF   xC2
02564:  CLRF   xC1
02566:  CLRF   xC0
02568:  MOVLB  0
0256A:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
0256E:  MOVLW  83
02570:  MOVLB  8
02572:  MOVWF  xBF
02574:  CLRF   xBE
02576:  CLRF   xBD
02578:  MOVLW  0B
0257A:  MOVWF  xBC
0257C:  CLRF   xC3
0257E:  CLRF   xC2
02580:  CLRF   xC1
02582:  CLRF   xC0
02584:  MOVLB  0
02586:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
0258A:  MOVLW  83
0258C:  MOVLB  8
0258E:  MOVWF  xBF
02590:  CLRF   xBE
02592:  CLRF   xBD
02594:  MOVLW  0C
02596:  MOVWF  xBC
02598:  CLRF   xC3
0259A:  CLRF   xC2
0259C:  CLRF   xC1
0259E:  CLRF   xC0
025A0:  MOVLB  0
025A2:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
025A6:  MOVLW  83
025A8:  MOVLB  8
025AA:  MOVWF  xBF
025AC:  CLRF   xBE
025AE:  CLRF   xBD
025B0:  MOVLW  0D
025B2:  MOVWF  xBC
025B4:  CLRF   xC3
025B6:  CLRF   xC2
025B8:  CLRF   xC1
025BA:  CLRF   xC0
025BC:  MOVLB  0
025BE:  CALL   0DB0
.................... 		set_timer1(15550); 
025C2:  MOVLW  3C
025C4:  MOVWF  FCF
025C6:  MOVLW  BE
025C8:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
025CA:  BCF    F9E.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Mute pin brought low. Muting\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	unsigned int difference = 0; 
025CC:  MOVLB  8
025CE:  CLRF   xB3
....................  
.................... 	if(current_adc > last_adc) { 
025D0:  MOVLB  1
025D2:  MOVF   xCF,W
025D4:  SUBWF  xCE,W
025D6:  BC    25E4
.................... 		difference = current_adc - last_adc; 
025D8:  MOVF   xCE,W
025DA:  SUBWF  xCF,W
025DC:  MOVLB  8
025DE:  MOVWF  xB3
.................... 	} else { 
025E0:  BRA    25EC
025E2:  MOVLB  1
.................... 		difference = last_adc - current_adc; 
025E4:  MOVF   xCF,W
025E6:  SUBWF  xCE,W
025E8:  MOVLB  8
025EA:  MOVWF  xB3
.................... 	} 
....................  
.................... 	if((!pin_in_mute_state && is_muted) || (difference > RVC_NOISE_FLOOR)) { 
025EC:  MOVLB  1
025EE:  MOVF   xD1,F
025F0:  BNZ   25F6
025F2:  MOVF   xD0,F
025F4:  BNZ   2602
025F6:  MOVLB  8
025F8:  MOVF   xB3,W
025FA:  SUBWF  1E,W
025FC:  BTFSC  FD8.0
025FE:  BRA    27E4
02600:  MOVLB  1
....................  
.................... 		 
.................... 		double dsp_value = RVC_to_dsp_value(current_adc); 
02602:  MOVFF  1CF,8B8
02606:  MOVLB  0
02608:  RCALL  23AE
0260A:  MOVFF  03,8B7
0260E:  MOVFF  02,8B6
02612:  MOVFF  01,8B5
02616:  MOVFF  00,8B4
....................  
.................... 		 
.................... 		if(current_adc < 30) { 
0261A:  MOVLB  1
0261C:  MOVF   xCF,W
0261E:  SUBLW  1D
02620:  BNC   2630
.................... 			dsp_value = 0; 
02622:  MOVLB  8
02624:  CLRF   xB7
02626:  CLRF   xB6
02628:  CLRF   xB5
0262A:  CLRF   xB4
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = 0.0000\r\n",current_adc); 
.................... 			}	 
.................... 		} else { 
0262C:  BRA    262E
0262E:  MOVLB  1
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		//double percentage = ADC_to_percentage(current_adc); 
.................... 		send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
02630:  MOVFF  8B7,8EC
02634:  MOVFF  8B6,8EB
02638:  MOVFF  8B5,8EA
0263C:  MOVFF  8B4,8E9
02640:  MOVLB  8
02642:  CLRF   xF0
02644:  CLRF   xEF
02646:  CLRF   xEE
02648:  MOVLW  9E
0264A:  MOVWF  xED
0264C:  MOVLB  0
0264E:  CALL   1230
02652:  MOVFF  03,8BB
02656:  MOVFF  02,8BA
0265A:  MOVFF  01,8B9
0265E:  MOVFF  00,8B8
02662:  RCALL  24C8
02664:  MOVFF  03,8BB
02668:  MOVFF  02,8BA
0266C:  MOVFF  01,8B9
02670:  MOVFF  00,8B8
02674:  MOVLW  83
02676:  MOVLB  8
02678:  MOVWF  xBF
0267A:  CLRF   xBE
0267C:  CLRF   xBD
0267E:  MOVLW  0A
02680:  MOVWF  xBC
02682:  MOVFF  03,8C3
02686:  MOVFF  02,8C2
0268A:  MOVFF  01,8C1
0268E:  MOVFF  00,8C0
02692:  MOVLB  0
02694:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
02698:  MOVFF  8B7,8EC
0269C:  MOVFF  8B6,8EB
026A0:  MOVFF  8B5,8EA
026A4:  MOVFF  8B4,8E9
026A8:  MOVLB  8
026AA:  CLRF   xF0
026AC:  CLRF   xEF
026AE:  CLRF   xEE
026B0:  MOVLW  9E
026B2:  MOVWF  xED
026B4:  MOVLB  0
026B6:  CALL   1230
026BA:  MOVFF  03,8BB
026BE:  MOVFF  02,8BA
026C2:  MOVFF  01,8B9
026C6:  MOVFF  00,8B8
026CA:  RCALL  24C8
026CC:  MOVFF  03,8BB
026D0:  MOVFF  02,8BA
026D4:  MOVFF  01,8B9
026D8:  MOVFF  00,8B8
026DC:  MOVLW  83
026DE:  MOVLB  8
026E0:  MOVWF  xBF
026E2:  CLRF   xBE
026E4:  CLRF   xBD
026E6:  MOVLW  0B
026E8:  MOVWF  xBC
026EA:  MOVFF  03,8C3
026EE:  MOVFF  02,8C2
026F2:  MOVFF  01,8C1
026F6:  MOVFF  00,8C0
026FA:  MOVLB  0
026FC:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
02700:  MOVFF  8B7,8EC
02704:  MOVFF  8B6,8EB
02708:  MOVFF  8B5,8EA
0270C:  MOVFF  8B4,8E9
02710:  MOVLB  8
02712:  CLRF   xF0
02714:  CLRF   xEF
02716:  CLRF   xEE
02718:  MOVLW  9E
0271A:  MOVWF  xED
0271C:  MOVLB  0
0271E:  CALL   1230
02722:  MOVFF  03,8BB
02726:  MOVFF  02,8BA
0272A:  MOVFF  01,8B9
0272E:  MOVFF  00,8B8
02732:  RCALL  24C8
02734:  MOVFF  03,8BB
02738:  MOVFF  02,8BA
0273C:  MOVFF  01,8B9
02740:  MOVFF  00,8B8
02744:  MOVLW  83
02746:  MOVLB  8
02748:  MOVWF  xBF
0274A:  CLRF   xBE
0274C:  CLRF   xBD
0274E:  MOVLW  0C
02750:  MOVWF  xBC
02752:  MOVFF  03,8C3
02756:  MOVFF  02,8C2
0275A:  MOVFF  01,8C1
0275E:  MOVFF  00,8C0
02762:  MOVLB  0
02764:  CALL   0DB0
.................... 		send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
02768:  MOVFF  8B7,8EC
0276C:  MOVFF  8B6,8EB
02770:  MOVFF  8B5,8EA
02774:  MOVFF  8B4,8E9
02778:  MOVLB  8
0277A:  CLRF   xF0
0277C:  CLRF   xEF
0277E:  CLRF   xEE
02780:  MOVLW  9E
02782:  MOVWF  xED
02784:  MOVLB  0
02786:  CALL   1230
0278A:  MOVFF  03,8BB
0278E:  MOVFF  02,8BA
02792:  MOVFF  01,8B9
02796:  MOVFF  00,8B8
0279A:  RCALL  24C8
0279C:  MOVFF  03,8BB
027A0:  MOVFF  02,8BA
027A4:  MOVFF  01,8B9
027A8:  MOVFF  00,8B8
027AC:  MOVLW  83
027AE:  MOVLB  8
027B0:  MOVWF  xBF
027B2:  CLRF   xBE
027B4:  CLRF   xBD
027B6:  MOVLW  0D
027B8:  MOVWF  xBC
027BA:  MOVFF  03,8C3
027BE:  MOVFF  02,8C2
027C2:  MOVFF  01,8C1
027C6:  MOVFF  00,8C0
027CA:  MOVLB  0
027CC:  CALL   0DB0
....................  
.................... 		is_muted = 0; 
027D0:  MOVLB  1
027D2:  CLRF   xD0
.................... 		last_adc = current_adc; 
027D4:  MOVFF  1CF,1CE
.................... 		set_timer1(15550); 
027D8:  MOVLW  3C
027DA:  MOVWF  FCF
027DC:  MOVLW  BE
027DE:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
027E0:  BCF    F9E.0
027E2:  MOVLB  8
.................... 	}   
.................... } 
....................  
.................... // AUDIO DETECT FOR SLEEP MODE 
027E4:  BCF    F9E.0
027E6:  MOVLB  0
027E8:  GOTO   0090
.................... #INT_EXT 
.................... void AUDIODETECT_ISR(void)  
.................... {  
....................    	disable_interrupts (INT_EXT); 
*
02852:  BCF    FF2.4
....................  
.................... 	clear_interrupt(INT_EXT); 
02854:  BCF    FF2.1
.................... 	 
....................  
.................... 	if(input(PIN_B0)) { 
02856:  BSF    F93.0
02858:  BTFSS  F81.0
0285A:  BRA    2870
....................  
.................... 		// Audio is now present 
.................... 		//if(is_in_sleep) { 
.................... 			is_in_sleep = 0; 
0285C:  MOVLB  1
0285E:  CLRF   xD6
.................... 			sleep_timer_active = 0; 
02860:  CLRF   xD7
.................... 			clear_interrupt(INT_TIMER0); 
02862:  BCF    FF2.2
.................... 			disable_interrupts(INT_TIMER0); 
02864:  BCF    FF2.5
.................... 			 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] AUDIO DETECTED. NO LONGER IN SLEEP MODE\r\n"); 
.................... 			} 
....................  
.................... 			// Now wait for it to go low again... 
....................  
.................... 			 
.................... 		//} 
....................  
.................... 			ext_int_edge(0,H_TO_L);  
02866:  BCF    FF1.6
.................... 			 
.................... 			enable_interrupts (INT_EXT); 
02868:  BSF    FF2.4
.................... 			return; 
0286A:  BRA    2890
.................... 	} else { 
0286C:  BRA    2890
0286E:  MOVLB  0
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, STARTING SLEEP TIMER\r\n",AUDIODETECT_HOLDTIME_SECONDS); 
.................... 		} 
.................... 		// Audio not detected for 1 minute.. start timer 
.................... 		clear_interrupt(INT_TIMER0); 
02870:  BCF    FF2.2
....................  
.................... 		sleepseconds = AUDIODETECT_HOLDTIME_SECONDS; 
02872:  MOVFF  1D,1D3
02876:  MOVFF  1C,1D2
.................... 		set_timer0(7936); 
0287A:  MOVLW  1F
0287C:  MOVWF  FD7
0287E:  CLRF   FD6
.................... 		enable_interrupts(INT_TIMER0); 
02880:  BSF    FF2.5
.................... 		sleep_timer_active = 1; 
02882:  MOVLW  01
02884:  MOVLB  1
02886:  MOVWF  xD7
.................... 		is_in_sleep = 0; 
02888:  CLRF   xD6
....................  
.................... 		ext_int_edge(0,L_TO_H);  
0288A:  BSF    FF1.6
.................... 		enable_interrupts (INT_EXT); 
0288C:  BSF    FF2.4
.................... 		return; 
0288E:  BRA    2890
.................... 	} 
.................... } 
....................  
.................... // USB DETECTION 
02890:  BCF    FF2.1
02892:  MOVLB  0
02894:  GOTO   0090
.................... #INT_EXT1  
.................... void USBDETECT_ISR(void)  
.................... {  
....................  
....................    	disable_interrupts (INT_EXT1); 
*
0299A:  BCF    FF0.3
....................  
.................... 	delay_us(100); 
0299C:  MOVLW  7A
0299E:  MOVWF  00
029A0:  DECFSZ 00,F
029A2:  BRA    29A0
029A4:  NOP   
....................  
.................... 	if(input(PIN_B1)) { 
029A6:  BSF    F93.1
029A8:  BTFSS  F81.1
029AA:  BRA    29B6
.................... 		IS_USB_CONNECTED = true; 
029AC:  MOVLW  01
029AE:  MOVWF  x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is high. USB CONNECT EVENT. Triggering on H_TO_L.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,H_TO_L);  
029B0:  BCF    FF1.5
....................  
.................... 		disable_all_timers(); 
029B2:  BRA    2904
....................  
.................... 	} else { 
029B4:  BRA    29BC
.................... 		IS_USB_CONNECTED = false; 
029B6:  CLRF   x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is low. USB DISCONNECT EVENT. Triggering on L_TO_H.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,L_TO_H);  
029B8:  BSF    FF1.5
....................  
.................... 		enable_all_timers(); 
029BA:  BRA    2982
.................... 	} 
.................... 	 
.................... 	enable_interrupts(INT_EXT1); 
029BC:  BSF    FF0.3
.................... 	clear_interrupt(INT_EXT1); 
029BE:  BCF    FF0.0
.................... }  
....................  
....................  
029C0:  BCF    FF0.0
029C2:  GOTO   0090
.................... void main() 
.................... { 
*
0BBE2:  CLRF   FF8
0BBE4:  BCF    FD0.7
0BBE6:  BSF    07.7
0BBE8:  CLRF   FEA
0BBEA:  CLRF   FE9
0BBEC:  MOVLW  01
0BBEE:  MOVWF  1B
0BBF0:  MOVLW  DE
0BBF2:  MOVWF  1A
0BBF4:  CLRF   1D
0BBF6:  MOVLW  02
0BBF8:  MOVWF  1C
0BBFA:  CLRF   1E
0BBFC:  CLRF   22
0BBFE:  CLRF   21
0BC00:  MOVLW  70
0BC02:  MOVWF  20
0BC04:  MOVLW  83
0BC06:  MOVWF  1F
0BC08:  CLRF   26
0BC0A:  CLRF   25
0BC0C:  MOVLW  70
0BC0E:  MOVWF  24
0BC10:  MOVLW  86
0BC12:  MOVWF  23
0BC14:  CLRF   27
0BC16:  CLRF   28
0BC18:  MOVLW  01
0BC1A:  MOVWF  29
0BC1C:  MOVWF  2A
0BC1E:  MOVWF  2B
0BC20:  CLRF   2C
0BC22:  MOVWF  2D
0BC24:  CLRF   2E
0BC26:  CLRF   30
0BC28:  MOVLW  41
0BC2A:  MOVWF  2F
0BC2C:  CLRF   32
0BC2E:  MOVLW  3C
0BC30:  MOVWF  31
0BC32:  MOVLW  01
0BC34:  MOVWF  x61
0BC36:  MOVLW  03
0BC38:  MOVWF  x62
0BC3A:  BCF    F94.5
0BC3C:  BSF    F8B.5
0BC3E:  CLRF   x77
0BC40:  BCF    F70.3
0BC42:  MOVLW  17
0BC44:  MOVWF  F75
0BC46:  MOVLW  A2
0BC48:  MOVWF  F72
0BC4A:  MOVLW  90
0BC4C:  MOVWF  F71
0BC4E:  BSF    F95.1
0BC50:  BCF    F95.4
0BC52:  BCF    F95.0
0BC54:  BCF    F8C.0
0BC56:  CLRF   x79
0BC58:  CLRF   x9F
0BC5A:  CLRF   xA0
0BC5C:  CLRF   xCD
0BC5E:  MOVLB  1
0BC60:  CLRF   xCE
0BC62:  CLRF   xCF
0BC64:  CLRF   xD0
0BC66:  CLRF   xD1
0BC68:  CLRF   xD5
0BC6A:  MOVLW  0A
0BC6C:  MOVWF  xD4
0BC6E:  CLRF   xD6
0BC70:  CLRF   xD7
0BC72:  MOVLB  7
0BC74:  CLRF   xF6
0BC76:  CLRF   xF5
0BC78:  CLRF   xF8
0BC7A:  CLRF   xF7
0BC7C:  CLRF   xFA
0BC7E:  CLRF   xF9
0BC80:  CLRF   xFB
0BC82:  CLRF   xFC
0BC84:  BCF    xFD.0
0BC86:  CLRF   xFF
0BC88:  CLRF   xFE
0BC8A:  MOVLB  8
0BC8C:  CLRF   x00
0BC8E:  CLRF   x01
0BC90:  CLRF   x02
0BC92:  CLRF   x20
0BC94:  MOVLB  1
0BC96:  CLRF   x88
0BC98:  MOVF   FC1,W
0BC9A:  ANDLW  F0
0BC9C:  MOVWF  FC1
0BC9E:  MOVLW  00
0BCA0:  MOVLB  F
0BCA2:  MOVWF  x38
0BCA4:  MOVWF  x3C
0BCA6:  MOVWF  x39
0BCA8:  MOVWF  x3A
0BCAA:  MOVWF  x3B
0BCAC:  CLRF   F77
0BCAE:  CLRF   F78
0BCB0:  CLRF   F79
0BCB2:  CLRF   5B
0BCB4:  CLRF   5C
0BCB6:  MOVLW  64
0BCB8:  MOVLB  0
0BCBA:  MOVWF  x63
0BCBC:  MOVLW  2D
0BCBE:  MOVWF  x64
0BCC0:  MOVLW  46
0BCC2:  MOVWF  x65
0BCC4:  MOVLW  4C
0BCC6:  MOVWF  x66
0BCC8:  MOVLW  58
0BCCA:  MOVWF  x67
0BCCC:  MOVLW  38
0BCCE:  MOVWF  x68
0BCD0:  MOVLW  30
0BCD2:  MOVWF  x69
0BCD4:  MOVLW  2D
0BCD6:  MOVWF  x6A
0BCD8:  MOVLW  34
0BCDA:  MOVWF  x6B
0BCDC:  CLRF   x6C
0BCDE:  MOVLB  1
0BCE0:  CLRF   xD8
0BCE2:  CLRF   xD9
0BCE4:  CLRF   xDA
0BCE6:  CLRF   xDB
0BCE8:  MOVLW  75
0BCEA:  MOVWF  xDC
0BCEC:  MOVLW  10
0BCEE:  MOVWF  xDD
0BCF0:  MOVLW  2D
0BCF2:  MOVWF  xDE
0BCF4:  MOVLW  E0
0BCF6:  MOVWF  xDF
0BCF8:  MOVLW  75
0BCFA:  MOVWF  xE0
0BCFC:  MOVLW  2A
0BCFE:  MOVWF  xE1
0BD00:  MOVLW  64
0BD02:  MOVWF  xE2
0BD04:  MOVLW  C3
0BD06:  MOVWF  xE3
0BD08:  MOVLW  75
0BD0A:  MOVWF  xE4
0BD0C:  MOVLW  37
0BD0E:  MOVWF  xE5
0BD10:  MOVLW  80
0BD12:  MOVWF  xE6
0BD14:  MOVLW  34
0BD16:  MOVWF  xE7
0BD18:  MOVLW  75
0BD1A:  MOVWF  xE8
0BD1C:  MOVLW  51
0BD1E:  MOVWF  xE9
0BD20:  MOVLW  B7
0BD22:  MOVWF  xEA
0BD24:  MOVLW  17
0BD26:  MOVWF  xEB
0BD28:  MOVLW  75
0BD2A:  MOVWF  xEC
0BD2C:  MOVLW  6B
0BD2E:  MOVWF  xED
0BD30:  MOVLW  ED
0BD32:  MOVWF  xEE
0BD34:  MOVLW  FA
0BD36:  MOVWF  xEF
0BD38:  MOVLW  76
0BD3A:  MOVWF  xF0
0BD3C:  MOVLW  03
0BD3E:  MOVWF  xF1
0BD40:  MOVLW  12
0BD42:  MOVWF  xF2
0BD44:  MOVLW  6F
0BD46:  MOVWF  xF3
0BD48:  MOVLW  76
0BD4A:  MOVWF  xF4
0BD4C:  MOVLW  10
0BD4E:  MOVWF  xF5
0BD50:  MOVLW  2D
0BD52:  MOVWF  xF6
0BD54:  MOVLW  E0
0BD56:  MOVWF  xF7
0BD58:  MOVLW  76
0BD5A:  MOVWF  xF8
0BD5C:  MOVLW  23
0BD5E:  MOVWF  xF9
0BD60:  MOVLW  D7
0BD62:  MOVWF  xFA
0BD64:  MOVLW  0A
0BD66:  MOVWF  xFB
0BD68:  MOVLW  76
0BD6A:  MOVWF  xFC
0BD6C:  MOVLW  37
0BD6E:  MOVWF  xFD
0BD70:  MOVLW  80
0BD72:  MOVWF  xFE
0BD74:  MOVLW  34
0BD76:  MOVWF  xFF
0BD78:  MOVLW  76
0BD7A:  MOVLB  2
0BD7C:  MOVWF  x00
0BD7E:  MOVLW  51
0BD80:  MOVWF  x01
0BD82:  MOVLW  B7
0BD84:  MOVWF  x02
0BD86:  MOVLW  17
0BD88:  MOVWF  x03
0BD8A:  MOVLW  76
0BD8C:  MOVWF  x04
0BD8E:  MOVLW  65
0BD90:  MOVWF  x05
0BD92:  MOVLW  60
0BD94:  MOVWF  x06
0BD96:  MOVLW  42
0BD98:  MOVWF  x07
0BD9A:  MOVLW  77
0BD9C:  MOVWF  x08
0BD9E:  MOVLW  03
0BDA0:  MOVWF  x09
0BDA2:  MOVLW  12
0BDA4:  MOVWF  x0A
0BDA6:  MOVLW  6F
0BDA8:  MOVWF  x0B
0BDAA:  MOVLW  77
0BDAC:  MOVWF  x0C
0BDAE:  MOVLW  13
0BDB0:  MOVWF  x0D
0BDB2:  MOVLW  74
0BDB4:  MOVWF  x0E
0BDB6:  MOVLW  BC
0BDB8:  MOVWF  x0F
0BDBA:  MOVLW  77
0BDBC:  MOVWF  x10
0BDBE:  MOVLW  23
0BDC0:  MOVWF  x11
0BDC2:  MOVLW  D7
0BDC4:  MOVWF  x12
0BDC6:  MOVLW  0A
0BDC8:  MOVWF  x13
0BDCA:  MOVLW  77
0BDCC:  MOVWF  x14
0BDCE:  MOVLW  37
0BDD0:  MOVWF  x15
0BDD2:  MOVLW  80
0BDD4:  MOVWF  x16
0BDD6:  MOVLW  34
0BDD8:  MOVWF  x17
0BDDA:  MOVLW  77
0BDDC:  MOVWF  x18
0BDDE:  MOVLW  4E
0BDE0:  MOVWF  x19
0BDE2:  MOVLW  70
0BDE4:  MOVWF  x1A
0BDE6:  MOVLW  3B
0BDE8:  MOVWF  x1B
0BDEA:  MOVLW  77
0BDEC:  MOVWF  x1C
0BDEE:  MOVLW  68
0BDF0:  MOVWF  x1D
0BDF2:  MOVLW  A7
0BDF4:  MOVWF  x1E
0BDF6:  MOVLW  1E
0BDF8:  MOVWF  x1F
0BDFA:  MOVLW  78
0BDFC:  MOVWF  x20
0BDFE:  MOVLW  01
0BE00:  MOVWF  x21
0BE02:  MOVLW  6F
0BE04:  MOVWF  x22
0BE06:  CLRF   x23
0BE08:  MOVLW  78
0BE0A:  MOVWF  x24
0BE0C:  MOVLW  11
0BE0E:  MOVWF  x25
0BE10:  MOVLW  D1
0BE12:  MOVWF  x26
0BE14:  MOVLW  4E
0BE16:  MOVWF  x27
0BE18:  MOVLW  78
0BE1A:  MOVWF  x28
0BE1C:  MOVLW  23
0BE1E:  MOVWF  x29
0BE20:  MOVLW  D7
0BE22:  MOVWF  x2A
0BE24:  MOVLW  0A
0BE26:  MOVWF  x2B
0BE28:  MOVLW  78
0BE2A:  MOVWF  x2C
0BE2C:  MOVLW  37
0BE2E:  MOVWF  x2D
0BE30:  MOVLW  80
0BE32:  MOVWF  x2E
0BE34:  MOVLW  34
0BE36:  MOVWF  x2F
0BE38:  MOVLW  78
0BE3A:  MOVWF  x30
0BE3C:  MOVLW  4E
0BE3E:  MOVWF  x31
0BE40:  MOVLW  70
0BE42:  MOVWF  x32
0BE44:  MOVLW  3B
0BE46:  MOVWF  x33
0BE48:  MOVLW  78
0BE4A:  MOVWF  x34
0BE4C:  MOVLW  67
0BE4E:  MOVWF  x35
0BE50:  MOVLW  03
0BE52:  MOVWF  x36
0BE54:  MOVLW  B0
0BE56:  MOVWF  x37
0BE58:  MOVLW  79
0BE5A:  MOVWF  x38
0BE5C:  MOVLW  01
0BE5E:  MOVWF  x39
0BE60:  MOVLW  6F
0BE62:  MOVWF  x3A
0BE64:  CLRF   x3B
0BE66:  MOVLW  79
0BE68:  MOVWF  x3C
0BE6A:  MOVLW  11
0BE6C:  MOVWF  x3D
0BE6E:  MOVLW  D1
0BE70:  MOVWF  x3E
0BE72:  MOVLW  4E
0BE74:  MOVWF  x3F
0BE76:  MOVLW  79
0BE78:  MOVWF  x40
0BE7A:  MOVLW  23
0BE7C:  MOVWF  x41
0BE7E:  MOVLW  D7
0BE80:  MOVWF  x42
0BE82:  MOVLW  0A
0BE84:  MOVWF  x43
0BE86:  MOVLW  79
0BE88:  MOVWF  x44
0BE8A:  MOVLW  37
0BE8C:  MOVWF  x45
0BE8E:  MOVLW  80
0BE90:  MOVWF  x46
0BE92:  MOVLW  34
0BE94:  MOVWF  x47
0BE96:  MOVLW  79
0BE98:  MOVWF  x48
0BE9A:  MOVLW  4D
0BE9C:  MOVWF  x49
0BE9E:  MOVLW  9E
0BEA0:  MOVWF  x4A
0BEA2:  MOVLW  84
0BEA4:  MOVWF  x4B
0BEA6:  MOVLW  79
0BEA8:  MOVWF  x4C
0BEAA:  MOVLW  67
0BEAC:  MOVWF  x4D
0BEAE:  MOVLW  03
0BEB0:  MOVWF  x4E
0BEB2:  MOVLW  B0
0BEB4:  MOVWF  x4F
0BEB6:  MOVLW  7A
0BEB8:  MOVWF  x50
0BEBA:  MOVLW  01
0BEBC:  MOVWF  x51
0BEBE:  MOVLW  6F
0BEC0:  MOVWF  x52
0BEC2:  CLRF   x53
0BEC4:  MOVLW  7A
0BEC6:  MOVWF  x54
0BEC8:  MOVLW  11
0BECA:  MOVWF  x55
0BECC:  MOVLW  68
0BECE:  MOVWF  x56
0BED0:  MOVLW  73
0BED2:  MOVWF  x57
0BED4:  MOVLW  7A
0BED6:  MOVWF  x58
0BED8:  MOVLW  23
0BEDA:  MOVWF  x59
0BEDC:  MOVLW  05
0BEDE:  MOVWF  x5A
0BEE0:  MOVLW  53
0BEE2:  MOVWF  x5B
0BEE4:  MOVLW  7A
0BEE6:  MOVWF  x5C
0BEE8:  MOVLW  37
0BEEA:  MOVWF  x5D
0BEEC:  MOVLW  17
0BEEE:  MOVWF  x5E
0BEF0:  MOVLW  59
0BEF2:  MOVWF  x5F
0BEF4:  MOVLW  7A
0BEF6:  MOVWF  x60
0BEF8:  MOVLW  4D
0BEFA:  MOVWF  x61
0BEFC:  MOVLW  35
0BEFE:  MOVWF  x62
0BF00:  MOVLW  A8
0BF02:  MOVWF  x63
0BF04:  MOVLW  7A
0BF06:  MOVWF  x64
0BF08:  MOVLW  66
0BF0A:  MOVWF  x65
0BF0C:  MOVLW  31
0BF0E:  MOVWF  x66
0BF10:  MOVLW  F9
0BF12:  MOVWF  x67
0BF14:  MOVLW  7B
0BF16:  MOVWF  x68
0BF18:  MOVLW  01
0BF1A:  MOVWF  x69
0BF1C:  MOVLW  3A
0BF1E:  MOVWF  x6A
0BF20:  MOVLW  93
0BF22:  MOVWF  x6B
0BF24:  MOVLW  7B
0BF26:  MOVWF  x6C
0BF28:  MOVLW  10
0BF2A:  MOVWF  x6D
0BF2C:  SETF   x6E
0BF2E:  MOVLW  97
0BF30:  MOVWF  x6F
0BF32:  MOVLW  7B
0BF34:  MOVWF  x70
0BF36:  MOVLW  22
0BF38:  MOVWF  x71
0BF3A:  MOVLW  9C
0BF3C:  MOVWF  x72
0BF3E:  MOVLW  78
0BF40:  MOVWF  x73
0BF42:  MOVLW  7B
0BF44:  MOVWF  x74
0BF46:  MOVLW  36
0BF48:  MOVWF  x75
0BF4A:  MOVLW  7A
0BF4C:  MOVWF  x76
0BF4E:  MOVLW  10
0BF50:  MOVWF  x77
0BF52:  MOVLW  7B
0BF54:  MOVWF  x78
0BF56:  MOVLW  4C
0BF58:  MOVWF  x79
0BF5A:  MOVLW  CC
0BF5C:  MOVWF  x7A
0BF5E:  MOVLW  CD
0BF60:  MOVWF  x7B
0BF62:  MOVLW  7B
0BF64:  MOVWF  x7C
0BF66:  MOVLW  65
0BF68:  MOVWF  x7D
0BF6A:  MOVLW  C9
0BF6C:  MOVWF  x7E
0BF6E:  MOVLW  1D
0BF70:  MOVWF  x7F
0BF72:  MOVLW  7C
0BF74:  MOVWF  x80
0BF76:  CLRF   x81
0BF78:  MOVLW  EB
0BF7A:  MOVWF  x82
0BF7C:  MOVLW  EE
0BF7E:  MOVWF  x83
0BF80:  MOVLW  7C
0BF82:  MOVWF  x84
0BF84:  MOVLW  10
0BF86:  MOVWF  x85
0BF88:  MOVLW  B0
0BF8A:  MOVWF  x86
0BF8C:  MOVLW  F2
0BF8E:  MOVWF  x87
0BF90:  MOVLW  7C
0BF92:  MOVWF  x88
0BF94:  MOVLW  22
0BF96:  MOVWF  x89
0BF98:  MOVLW  4D
0BF9A:  MOVWF  x8A
0BF9C:  MOVLW  D3
0BF9E:  MOVWF  x8B
0BFA0:  MOVLW  7C
0BFA2:  MOVWF  x8C
0BFA4:  MOVLW  36
0BFA6:  MOVWF  x8D
0BFA8:  MOVLW  11
0BFAA:  MOVWF  x8E
0BFAC:  MOVLW  34
0BFAE:  MOVWF  x8F
0BFB0:  MOVLW  7C
0BFB2:  MOVWF  x90
0BFB4:  MOVLW  4C
0BFB6:  MOVWF  x91
0BFB8:  MOVLW  49
0BFBA:  MOVWF  x92
0BFBC:  MOVLW  BA
0BFBE:  MOVWF  x93
0BFC0:  MOVLW  7C
0BFC2:  MOVWF  x94
0BFC4:  MOVLW  65
0BFC6:  MOVWF  x95
0BFC8:  MOVLW  46
0BFCA:  MOVWF  x96
0BFCC:  MOVLW  0B
0BFCE:  MOVWF  x97
0BFD0:  MOVLW  7D
0BFD2:  MOVWF  x98
0BFD4:  CLRF   x99
0BFD6:  MOVLW  9D
0BFD8:  MOVWF  x9A
0BFDA:  MOVLW  49
0BFDC:  MOVWF  x9B
0BFDE:  MOVLW  7D
0BFE0:  MOVWF  x9C
0BFE2:  MOVLW  10
0BFE4:  MOVWF  x9D
0BFE6:  MOVLW  48
0BFE8:  MOVWF  x9E
0BFEA:  MOVLW  17
0BFEC:  MOVWF  x9F
0BFEE:  MOVLW  7D
0BFF0:  MOVWF  xA0
0BFF2:  MOVLW  21
0BFF4:  MOVWF  xA1
0BFF6:  MOVLW  E4
0BFF8:  MOVWF  xA2
0BFFA:  MOVLW  F7
0BFFC:  MOVWF  xA3
0BFFE:  MOVLW  7D
0C000:  MOVWF  xA4
0C002:  MOVLW  35
0C004:  MOVWF  xA5
0C006:  MOVLW  A8
0C008:  MOVWF  xA6
0C00A:  MOVLW  58
0C00C:  MOVWF  xA7
0C00E:  MOVLW  7D
0C010:  MOVWF  xA8
0C012:  MOVLW  4B
0C014:  MOVWF  xA9
0C016:  MOVLW  D3
0C018:  MOVWF  xAA
0C01A:  MOVLW  C3
0C01C:  MOVWF  xAB
0C01E:  MOVLW  7D
0C020:  MOVWF  xAC
0C022:  MOVLW  64
0C024:  MOVWF  xAD
0C026:  MOVLW  B5
0C028:  MOVWF  xAE
0C02A:  MOVLW  DD
0C02C:  MOVWF  xAF
0C02E:  MOVLW  7E
0C030:  MOVWF  xB0
0C032:  CLRF   xB1
0C034:  MOVLW  4E
0C036:  MOVWF  xB2
0C038:  MOVLW  A5
0C03A:  MOVWF  xB3
0C03C:  MOVLW  7E
0C03E:  MOVWF  xB4
0C040:  MOVLW  0F
0C042:  MOVWF  xB5
0C044:  MOVLW  F2
0C046:  MOVWF  xB6
0C048:  MOVLW  E5
0C04A:  MOVWF  xB7
0C04C:  MOVLW  7E
0C04E:  MOVWF  xB8
0C050:  MOVLW  21
0C052:  MOVWF  xB9
0C054:  MOVLW  89
0C056:  MOVWF  xBA
0C058:  MOVLW  37
0C05A:  MOVWF  xBB
0C05C:  MOVLW  7E
0C05E:  MOVWF  xBC
0C060:  MOVLW  35
0C062:  MOVWF  xBD
0C064:  MOVLW  38
0C066:  MOVWF  xBE
0C068:  MOVLW  EF
0C06A:  MOVWF  xBF
0C06C:  MOVLW  7E
0C06E:  MOVWF  xC0
0C070:  MOVLW  4B
0C072:  MOVWF  xC1
0C074:  MOVLW  57
0C076:  MOVWF  xC2
0C078:  MOVLW  3F
0C07A:  MOVWF  xC3
0C07C:  MOVLW  7E
0C07E:  MOVWF  xC4
0C080:  MOVLW  64
0C082:  MOVWF  xC5
0C084:  MOVLW  2C
0C086:  MOVWF  xC6
0C088:  MOVLW  3D
0C08A:  MOVWF  xC7
0C08C:  MOVLW  7F
0C08E:  MOVWF  xC8
0C090:  CLRF   xC9
0C092:  CLRF   xCA
0C094:  CLRF   xCB
.................... 	// Setup ADC's and Timers 
.................... 	setup_peripherals(); 
0C096:  MOVLB  0
0C098:  GOTO   2A50
....................  
.................... 	default_addr(); 
0C09C:  GOTO   2C7A
....................  
.................... 	FLASH_ADDR_WRITE(14); 
0C0A0:  MOVLW  0E
0C0A2:  MOVLB  8
0C0A4:  MOVWF  x21
0C0A6:  MOVLB  0
0C0A8:  GOTO   58CC
....................  
.................... 	// Initializes and reads external EEPROM. Loads default DEVICE_CONFIG if necessary 
.................... 	device_boot(); 
0C0AC:  GOTO   60DE
.................... 	 
.................... 	// Reset amplifier and DSP then load values into DSP 
.................... 	softboot(); 
0C0B0:  CALL   6786
....................  
.................... 	// Enable/disable interrupts based on DEVICE_CONFIG parameters 
.................... 	setup_interrupts(); 
0C0B4:  CALL   2916
....................  
.................... 	while(true)	 
.................... 	{	 
.................... 		if(IS_USB_CONNECTED) { 
0C0B8:  MOVF   x78,F
0C0BA:  BZ    C0C0
.................... 			process_usb_data(); 
0C0BC:  GOTO   7FDE
.................... 		} 
.................... 		 
.................... 		if(rs232_data_available) { 
0C0C0:  MOVF   xA0,W
0C0C2:  SUBWF  x9F,W
0C0C4:  BZ    C0CA
.................... 			process_rs232_data(); 
0C0C6:  GOTO   B354
.................... 		} 
.................... 	} 
0C0CA:  BRA    C0B8
.................... } 
0C0CC:  SLEEP 

Configuration Fuses:
   Word  1: E300   HSM NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
