CCS PCH C Compiler, Version 4.130, 13671               21-Jul-14 11:02

               Filename: C:\SOURCE\PIC\DSP100-1 - PIC\main.lst

               ROM used: 36470 bytes (56%)
                         Largest free fragment is 27014
               RAM used: 1752 (45%) at main() level
                         1972 (51%) worst case
               Stack:    16 worst case (9 in main + 7 for interrupts)

*
00800:  GOTO   9560
*
00808:  MOVWF  04
0080A:  MOVFF  FD8,05
0080E:  MOVFF  FE0,06
00812:  MOVLB  0
00814:  MOVFF  FE9,0C
00818:  MOVFF  FEA,07
0081C:  MOVFF  FE1,08
00820:  MOVFF  FE2,09
00824:  MOVFF  FD9,0A
00828:  MOVFF  FDA,0B
0082C:  MOVFF  FF3,12
00830:  MOVFF  FF4,13
00834:  MOVFF  FFA,14
00838:  MOVFF  FF5,15
0083C:  MOVFF  FF6,16
00840:  MOVFF  FF7,17
00844:  MOVFF  00,0E
00848:  MOVFF  01,0F
0084C:  MOVFF  02,10
00850:  MOVFF  03,11
00854:  BTFSS  FF2.5
00856:  GOTO   0860
0085A:  BTFSC  FF2.2
0085C:  GOTO   12F8
00860:  BTFSS  F9D.0
00862:  GOTO   086C
00866:  BTFSC  F9E.0
00868:  GOTO   2B86
0086C:  BTFSS  FF2.4
0086E:  GOTO   0878
00872:  BTFSC  FF2.1
00874:  GOTO   2ECE
00878:  BTFSS  FF0.3
0087A:  GOTO   0884
0087E:  BTFSC  FF0.0
00880:  GOTO   3016
00884:  MOVFF  0E,00
00888:  MOVFF  0F,01
0088C:  MOVFF  10,02
00890:  MOVFF  11,03
00894:  MOVFF  0C,FE9
00898:  MOVFF  07,FEA
0089C:  BSF    07.7
0089E:  MOVFF  08,FE1
008A2:  MOVFF  09,FE2
008A6:  MOVFF  0A,FD9
008AA:  MOVFF  0B,FDA
008AE:  MOVFF  12,FF3
008B2:  MOVFF  13,FF4
008B6:  MOVFF  14,FFA
008BA:  MOVFF  15,FF5
008BE:  MOVFF  16,FF6
008C2:  MOVFF  17,FF7
008C6:  MOVF   04,W
008C8:  MOVFF  06,FE0
008CC:  MOVFF  05,FD8
008D0:  RETFIE 0
.................... #include <18LF46K22.h> 
.................... //////// Standard Header file for the PIC18LF46K22 device //////////////// 
.................... #device PIC18LF46K22 
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSM                   	//High speed Osc, medium power 4MHz-16MHz 
.................... #FUSES NOPLLEN               	//4X HW PLL disabled, 4X PLL enabled in software 
.................... #FUSES PUT                   	//Power Up Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES WDT_SW                	//No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=14745600) 
*
0608E:  MOVLW  07
06090:  MOVWF  FEA
06092:  MOVLW  2B
06094:  MOVWF  FE9
06096:  MOVF   FEF,W
06098:  BZ    60B4
0609A:  MOVLW  04
0609C:  MOVWF  01
0609E:  CLRF   00
060A0:  DECFSZ 00,F
060A2:  BRA    60A0
060A4:  DECFSZ 01,F
060A6:  BRA    609E
060A8:  MOVLW  C7
060AA:  MOVWF  00
060AC:  DECFSZ 00,F
060AE:  BRA    60AC
060B0:  DECFSZ FEF,F
060B2:  BRA    609A
060B4:  RETURN 0
....................  
....................  
.................... #define BOOTLOADER_START        0x2A  
.................... #define BOOTLOADER_END          0x3FF + 0x400 
.................... #build (reset=BOOTLOADER_END +1  , interrupt=0x408 + 0x400 )  
.................... #org 0, BOOTLOADER_END {}  
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
01A58:  MOVLB  7
01A5A:  BCF    x9F.0
....................    y = x; 
01A5C:  MOVFF  793,798
01A60:  MOVFF  792,797
01A64:  MOVFF  791,796
01A68:  MOVFF  790,795
....................  
....................    if (x < 0) 
01A6C:  MOVFF  793,7A3
01A70:  MOVFF  792,7A2
01A74:  MOVFF  791,7A1
01A78:  MOVFF  790,7A0
01A7C:  CLRF   xA7
01A7E:  CLRF   xA6
01A80:  CLRF   xA5
01A82:  CLRF   xA4
01A84:  MOVLB  0
01A86:  RCALL  19A2
01A88:  BNC   1A94
....................    { 
....................       s = 1; 
01A8A:  MOVLB  7
01A8C:  BSF    x9F.0
....................       y = -y; 
01A8E:  MOVF   x96,W
01A90:  XORLW  80
01A92:  MOVWF  x96
....................    } 
....................  
....................    if (y <= 32768.0) 
01A94:  MOVFF  798,7A3
01A98:  MOVFF  797,7A2
01A9C:  MOVFF  796,7A1
01AA0:  MOVFF  795,7A0
01AA4:  MOVLB  7
01AA6:  CLRF   xA7
01AA8:  CLRF   xA6
01AAA:  CLRF   xA5
01AAC:  MOVLW  8E
01AAE:  MOVWF  xA4
01AB0:  MOVLB  0
01AB2:  RCALL  19A2
01AB4:  BC    1AB8
01AB6:  BNZ   1AE6
....................       res = (float32)(unsigned int16)y; 
01AB8:  MOVFF  798,7A3
01ABC:  MOVFF  797,7A2
01AC0:  MOVFF  796,7A1
01AC4:  MOVFF  795,7A0
01AC8:  RCALL  1A1C
01ACA:  MOVFF  02,7A5
01ACE:  MOVFF  01,7A4
01AD2:  RCALL  14A0
01AD4:  MOVFF  03,79C
01AD8:  MOVFF  02,79B
01ADC:  MOVFF  01,79A
01AE0:  MOVFF  00,799
....................  
....................  else if (y < 10000000.0) 
01AE4:  BRA    1C74
01AE6:  MOVFF  798,7A3
01AEA:  MOVFF  797,7A2
01AEE:  MOVFF  796,7A1
01AF2:  MOVFF  795,7A0
01AF6:  MOVLW  80
01AF8:  MOVLB  7
01AFA:  MOVWF  xA7
01AFC:  MOVLW  96
01AFE:  MOVWF  xA6
01B00:  MOVLW  18
01B02:  MOVWF  xA5
01B04:  MOVLW  96
01B06:  MOVWF  xA4
01B08:  MOVLB  0
01B0A:  RCALL  19A2
01B0C:  BTFSS  FD8.0
01B0E:  BRA    1C64
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
01B10:  MOVFF  798,7A3
01B14:  MOVFF  797,7A2
01B18:  MOVFF  796,7A1
01B1C:  MOVFF  795,7A0
01B20:  MOVLB  7
01B22:  CLRF   xA7
01B24:  CLRF   xA6
01B26:  CLRF   xA5
01B28:  MOVLW  70
01B2A:  MOVWF  xA4
01B2C:  MOVLB  0
01B2E:  RCALL  18AC
01B30:  MOVFF  03,7A3
01B34:  MOVFF  02,7A2
01B38:  MOVFF  01,7A1
01B3C:  MOVFF  00,7A0
01B40:  RCALL  1A1C
01B42:  MOVFF  02,79E
01B46:  MOVFF  01,79D
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
01B4A:  MOVFF  798,7A3
01B4E:  MOVFF  797,7A2
01B52:  MOVFF  796,7A1
01B56:  MOVFF  795,7A0
01B5A:  MOVLB  7
01B5C:  CLRF   xA7
01B5E:  CLRF   xA6
01B60:  CLRF   xA5
01B62:  MOVLW  70
01B64:  MOVWF  xA4
01B66:  MOVLB  0
01B68:  RCALL  18AC
01B6A:  MOVFF  00,7A0
01B6E:  MOVFF  01,7A1
01B72:  MOVFF  02,7A2
01B76:  MOVFF  03,7A3
01B7A:  MOVFF  79E,7A5
01B7E:  MOVFF  79D,7A4
01B82:  RCALL  14A0
01B84:  BSF    FD8.1
01B86:  MOVFF  7A3,7A7
01B8A:  MOVFF  7A2,7A6
01B8E:  MOVFF  7A1,7A5
01B92:  MOVFF  7A0,7A4
01B96:  MOVFF  03,7AB
01B9A:  MOVFF  02,7AA
01B9E:  MOVFF  01,7A9
01BA2:  MOVFF  00,7A8
01BA6:  RCALL  14D6
01BA8:  MOVLB  7
01BAA:  CLRF   xA3
01BAC:  CLRF   xA2
01BAE:  CLRF   xA1
01BB0:  MOVLW  8E
01BB2:  MOVWF  xA0
01BB4:  MOVFF  03,7A7
01BB8:  MOVFF  02,7A6
01BBC:  MOVFF  01,7A5
01BC0:  MOVFF  00,7A4
01BC4:  MOVLB  0
01BC6:  RCALL  18AC
01BC8:  MOVFF  03,798
01BCC:  MOVFF  02,797
01BD0:  MOVFF  01,796
01BD4:  MOVFF  00,795
....................       res = 32768.0*(float32)l; 
01BD8:  MOVFF  79E,7A5
01BDC:  MOVFF  79D,7A4
01BE0:  RCALL  14A0
01BE2:  MOVLB  7
01BE4:  CLRF   xA3
01BE6:  CLRF   xA2
01BE8:  CLRF   xA1
01BEA:  MOVLW  8E
01BEC:  MOVWF  xA0
01BEE:  MOVFF  03,7A7
01BF2:  MOVFF  02,7A6
01BF6:  MOVFF  01,7A5
01BFA:  MOVFF  00,7A4
01BFE:  MOVLB  0
01C00:  RCALL  18AC
01C02:  MOVFF  03,79C
01C06:  MOVFF  02,79B
01C0A:  MOVFF  01,79A
01C0E:  MOVFF  00,799
....................       res += (float32)(unsigned int16)y; 
01C12:  MOVFF  798,7A3
01C16:  MOVFF  797,7A2
01C1A:  MOVFF  796,7A1
01C1E:  MOVFF  795,7A0
01C22:  RCALL  1A1C
01C24:  MOVFF  02,7A5
01C28:  MOVFF  01,7A4
01C2C:  RCALL  14A0
01C2E:  BCF    FD8.1
01C30:  MOVFF  79C,7A7
01C34:  MOVFF  79B,7A6
01C38:  MOVFF  79A,7A5
01C3C:  MOVFF  799,7A4
01C40:  MOVFF  03,7AB
01C44:  MOVFF  02,7AA
01C48:  MOVFF  01,7A9
01C4C:  MOVFF  00,7A8
01C50:  RCALL  14D6
01C52:  MOVFF  03,79C
01C56:  MOVFF  02,79B
01C5A:  MOVFF  01,79A
01C5E:  MOVFF  00,799
....................    } 
....................  
....................  else 
01C62:  BRA    1C74
....................   res = y; 
01C64:  MOVFF  798,79C
01C68:  MOVFF  797,79B
01C6C:  MOVFF  796,79A
01C70:  MOVFF  795,799
....................  
....................  y = y - (float32)(unsigned int16)y; 
01C74:  MOVFF  798,7A3
01C78:  MOVFF  797,7A2
01C7C:  MOVFF  796,7A1
01C80:  MOVFF  795,7A0
01C84:  RCALL  1A1C
01C86:  MOVFF  02,7A5
01C8A:  MOVFF  01,7A4
01C8E:  RCALL  14A0
01C90:  BSF    FD8.1
01C92:  MOVFF  798,7A7
01C96:  MOVFF  797,7A6
01C9A:  MOVFF  796,7A5
01C9E:  MOVFF  795,7A4
01CA2:  MOVFF  03,7AB
01CA6:  MOVFF  02,7AA
01CAA:  MOVFF  01,7A9
01CAE:  MOVFF  00,7A8
01CB2:  RCALL  14D6
01CB4:  MOVFF  03,798
01CB8:  MOVFF  02,797
01CBC:  MOVFF  01,796
01CC0:  MOVFF  00,795
....................  
....................  if (s) 
01CC4:  MOVLB  7
01CC6:  BTFSS  x9F.0
01CC8:  BRA    1CD0
....................   res = -res; 
01CCA:  MOVF   x9A,W
01CCC:  XORLW  80
01CCE:  MOVWF  x9A
....................  
....................  if (y != 0) 
01CD0:  MOVFF  798,7A3
01CD4:  MOVFF  797,7A2
01CD8:  MOVFF  796,7A1
01CDC:  MOVFF  795,7A0
01CE0:  CLRF   xA7
01CE2:  CLRF   xA6
01CE4:  CLRF   xA5
01CE6:  CLRF   xA4
01CE8:  MOVLB  0
01CEA:  RCALL  19A2
01CEC:  BZ    1D66
....................  { 
....................   if (s == 1 && n == 0) 
01CEE:  MOVLB  7
01CF0:  BTFSS  x9F.0
01CF2:  BRA    1D2C
01CF4:  MOVF   x94,F
01CF6:  BNZ   1D2C
....................    res -= 1.0; 
01CF8:  BSF    FD8.1
01CFA:  MOVFF  79C,7A7
01CFE:  MOVFF  79B,7A6
01D02:  MOVFF  79A,7A5
01D06:  MOVFF  799,7A4
01D0A:  CLRF   xAB
01D0C:  CLRF   xAA
01D0E:  CLRF   xA9
01D10:  MOVLW  7F
01D12:  MOVWF  xA8
01D14:  MOVLB  0
01D16:  CALL   14D6
01D1A:  MOVFF  03,79C
01D1E:  MOVFF  02,79B
01D22:  MOVFF  01,79A
01D26:  MOVFF  00,799
01D2A:  MOVLB  7
....................  
....................   if (s == 0 && n == 1) 
01D2C:  BTFSC  x9F.0
01D2E:  BRA    1D68
01D30:  DECFSZ x94,W
01D32:  BRA    1D68
....................    res += 1.0; 
01D34:  BCF    FD8.1
01D36:  MOVFF  79C,7A7
01D3A:  MOVFF  79B,7A6
01D3E:  MOVFF  79A,7A5
01D42:  MOVFF  799,7A4
01D46:  CLRF   xAB
01D48:  CLRF   xAA
01D4A:  CLRF   xA9
01D4C:  MOVLW  7F
01D4E:  MOVWF  xA8
01D50:  MOVLB  0
01D52:  CALL   14D6
01D56:  MOVFF  03,79C
01D5A:  MOVFF  02,79B
01D5E:  MOVFF  01,79A
01D62:  MOVFF  00,799
01D66:  MOVLB  7
....................  } 
....................  if (x == 0) 
01D68:  MOVFF  793,7A3
01D6C:  MOVFF  792,7A2
01D70:  MOVFF  791,7A1
01D74:  MOVFF  790,7A0
01D78:  CLRF   xA7
01D7A:  CLRF   xA6
01D7C:  CLRF   xA5
01D7E:  CLRF   xA4
01D80:  MOVLB  0
01D82:  RCALL  19A2
01D84:  BNZ   1D92
....................     res = 0; 
01D86:  MOVLB  7
01D88:  CLRF   x9C
01D8A:  CLRF   x9B
01D8C:  CLRF   x9A
01D8E:  CLRF   x99
01D90:  MOVLB  0
....................  
....................  return (res); 
01D92:  MOVFF  799,00
01D96:  MOVFF  79A,01
01D9A:  MOVFF  79B,02
01D9E:  MOVFF  79C,03
.................... } 
01DA2:  RETURN 0
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
01DC0:  MOVFF  78F,793
01DC4:  MOVFF  78E,792
01DC8:  MOVFF  78D,791
01DCC:  MOVFF  78C,790
01DD0:  MOVLB  7
01DD2:  CLRF   x94
01DD4:  MOVLB  0
01DD6:  RCALL  1A58
.................... } 
01DD8:  RETURN 0
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
01DA4:  MOVFF  78F,793
01DA8:  MOVFF  78E,792
01DAC:  MOVFF  78D,791
01DB0:  MOVFF  78C,790
01DB4:  MOVLW  01
01DB6:  MOVLB  7
01DB8:  MOVWF  x94
01DBA:  MOVLB  0
01DBC:  RCALL  1A58
.................... } 
01DBE:  RETURN 0
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
01DDA:  MOVFF  783,7A3
01DDE:  MOVFF  782,7A2
01DE2:  MOVFF  781,7A1
01DE6:  MOVFF  780,7A0
01DEA:  MOVLB  7
01DEC:  CLRF   xA7
01DEE:  CLRF   xA6
01DF0:  CLRF   xA5
01DF2:  CLRF   xA4
01DF4:  MOVLB  0
01DF6:  RCALL  19A2
01DF8:  BTFSC  FD8.2
01DFA:  BRA    1F34
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
01DFC:  MOVFF  77F,79C
01E00:  MOVFF  77E,79B
01E04:  MOVFF  77D,79A
01E08:  MOVFF  77C,799
01E0C:  MOVFF  783,7A0
01E10:  MOVFF  782,79F
01E14:  MOVFF  781,79E
01E18:  MOVFF  780,79D
01E1C:  RCALL  174E
01E1E:  MOVFF  00,788
01E22:  MOVFF  01,789
01E26:  MOVFF  02,78A
01E2A:  MOVFF  03,78B
01E2E:  MOVFF  03,7A3
01E32:  MOVFF  02,7A2
01E36:  MOVFF  01,7A1
01E3A:  MOVFF  00,7A0
01E3E:  MOVLB  7
01E40:  CLRF   xA7
01E42:  CLRF   xA6
01E44:  CLRF   xA5
01E46:  CLRF   xA4
01E48:  MOVLB  0
01E4A:  RCALL  19A2
01E4C:  BNC   1E94
01E4E:  MOVFF  77F,79C
01E52:  MOVFF  77E,79B
01E56:  MOVFF  77D,79A
01E5A:  MOVFF  77C,799
01E5E:  MOVFF  783,7A0
01E62:  MOVFF  782,79F
01E66:  MOVFF  781,79E
01E6A:  MOVFF  780,79D
01E6E:  RCALL  174E
01E70:  MOVFF  00,788
01E74:  MOVFF  01,789
01E78:  MOVFF  02,78A
01E7C:  MOVFF  03,78B
01E80:  MOVFF  03,78F
01E84:  MOVFF  02,78E
01E88:  MOVFF  01,78D
01E8C:  MOVFF  00,78C
01E90:  RCALL  1DA4
01E92:  BRA    1ED8
01E94:  MOVFF  77F,79C
01E98:  MOVFF  77E,79B
01E9C:  MOVFF  77D,79A
01EA0:  MOVFF  77C,799
01EA4:  MOVFF  783,7A0
01EA8:  MOVFF  782,79F
01EAC:  MOVFF  781,79E
01EB0:  MOVFF  780,79D
01EB4:  RCALL  174E
01EB6:  MOVFF  00,788
01EBA:  MOVFF  01,789
01EBE:  MOVFF  02,78A
01EC2:  MOVFF  03,78B
01EC6:  MOVFF  03,78F
01ECA:  MOVFF  02,78E
01ECE:  MOVFF  01,78D
01ED2:  MOVFF  00,78C
01ED6:  RCALL  1DC0
01ED8:  MOVFF  03,787
01EDC:  MOVFF  02,786
01EE0:  MOVFF  01,785
01EE4:  MOVFF  00,784
....................       return(x-(i*y)); 
01EE8:  MOVFF  787,7A3
01EEC:  MOVFF  786,7A2
01EF0:  MOVFF  785,7A1
01EF4:  MOVFF  784,7A0
01EF8:  MOVFF  783,7A7
01EFC:  MOVFF  782,7A6
01F00:  MOVFF  781,7A5
01F04:  MOVFF  780,7A4
01F08:  RCALL  18AC
01F0A:  BSF    FD8.1
01F0C:  MOVFF  77F,7A7
01F10:  MOVFF  77E,7A6
01F14:  MOVFF  77D,7A5
01F18:  MOVFF  77C,7A4
01F1C:  MOVFF  03,7AB
01F20:  MOVFF  02,7AA
01F24:  MOVFF  01,7A9
01F28:  MOVFF  00,7A8
01F2C:  CALL   14D6
01F30:  BRA    1F34
....................    } 
....................    else 
01F32:  BRA    1F34
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
01F34:  RETURN 0
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
02314:  MOVFF  783,7A3
02318:  MOVFF  782,7A2
0231C:  MOVFF  781,7A1
02320:  MOVFF  780,7A0
02324:  MOVLW  3B
02326:  MOVLB  7
02328:  MOVWF  xA7
0232A:  MOVLW  AA
0232C:  MOVWF  xA6
0232E:  MOVLW  38
02330:  MOVWF  xA5
02332:  MOVLW  7F
02334:  MOVWF  xA4
02336:  MOVLB  0
02338:  CALL   18AC
0233C:  MOVFF  03,7A3
02340:  MOVFF  02,7A2
02344:  MOVFF  01,7A1
02348:  MOVFF  00,7A0
0234C:  CALL   1A1C
02350:  MOVFF  01,790
....................    s = 0; 
02354:  MOVLB  7
02356:  BCF    x91.0
....................    y = x; 
02358:  MOVFF  783,787
0235C:  MOVFF  782,786
02360:  MOVFF  781,785
02364:  MOVFF  780,784
....................  
....................    if (x < 0) 
02368:  MOVFF  783,7A3
0236C:  MOVFF  782,7A2
02370:  MOVFF  781,7A1
02374:  MOVFF  780,7A0
02378:  CLRF   xA7
0237A:  CLRF   xA6
0237C:  CLRF   xA5
0237E:  CLRF   xA4
02380:  MOVLB  0
02382:  CALL   19A2
02386:  BNC   2394
....................    { 
....................       s = 1; 
02388:  MOVLB  7
0238A:  BSF    x91.0
....................       n = -n; 
0238C:  NEGF   x90
....................       y = -y; 
0238E:  MOVF   x85,W
02390:  XORLW  80
02392:  MOVWF  x85
....................    } 
....................  
....................    res = 0.0; 
02394:  MOVLB  7
02396:  CLRF   x8B
02398:  CLRF   x8A
0239A:  CLRF   x89
0239C:  CLRF   x88
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0239E:  MOVLW  07
023A0:  MOVWF  x93
023A2:  MOVLW  88
023A4:  MOVWF  FE9
023A6:  MOVFF  793,FEA
023AA:  MOVLW  7F
023AC:  ADDWF  x90,W
023AE:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
023B0:  MOVFF  787,7A3
023B4:  MOVFF  786,7A2
023B8:  MOVFF  785,7A1
023BC:  MOVFF  784,7A0
023C0:  MOVLW  3B
023C2:  MOVWF  xA7
023C4:  MOVLW  AA
023C6:  MOVWF  xA6
023C8:  MOVLW  38
023CA:  MOVWF  xA5
023CC:  MOVLW  7F
023CE:  MOVWF  xA4
023D0:  MOVLB  0
023D2:  CALL   18AC
023D6:  MOVFF  00,792
023DA:  MOVFF  01,793
023DE:  MOVFF  02,794
023E2:  MOVFF  03,795
023E6:  MOVLB  7
023E8:  CLRF   x97
023EA:  MOVFF  790,796
023EE:  BTFSC  x96.7
023F0:  DECF   x97,F
023F2:  MOVLB  0
023F4:  RCALL  1F36
023F6:  BSF    FD8.1
023F8:  MOVFF  795,7A7
023FC:  MOVFF  794,7A6
02400:  MOVFF  793,7A5
02404:  MOVFF  792,7A4
02408:  MOVFF  03,7AB
0240C:  MOVFF  02,7AA
02410:  MOVFF  01,7A9
02414:  MOVFF  00,7A8
02418:  CALL   14D6
0241C:  MOVFF  03,787
02420:  MOVFF  02,786
02424:  MOVFF  01,785
02428:  MOVFF  00,784
....................  
....................    r = pe[0]*y + pe[1]; 
0242C:  MOVLW  7C
0242E:  MOVLB  7
02430:  MOVWF  xA3
02432:  MOVLW  88
02434:  MOVWF  xA2
02436:  MOVLW  59
02438:  MOVWF  xA1
0243A:  MOVLW  72
0243C:  MOVWF  xA0
0243E:  MOVFF  787,7A7
02442:  MOVFF  786,7A6
02446:  MOVFF  785,7A5
0244A:  MOVFF  784,7A4
0244E:  MOVLB  0
02450:  CALL   18AC
02454:  MOVFF  00,792
02458:  MOVFF  01,793
0245C:  MOVFF  02,794
02460:  MOVFF  03,795
02464:  BCF    FD8.1
02466:  MOVFF  03,7A7
0246A:  MOVFF  02,7A6
0246E:  MOVFF  01,7A5
02472:  MOVFF  00,7A4
02476:  MOVLW  E0
02478:  MOVLB  7
0247A:  MOVWF  xAB
0247C:  MOVLW  97
0247E:  MOVWF  xAA
02480:  MOVLW  26
02482:  MOVWF  xA9
02484:  MOVLW  75
02486:  MOVWF  xA8
02488:  MOVLB  0
0248A:  CALL   14D6
0248E:  MOVFF  03,78F
02492:  MOVFF  02,78E
02496:  MOVFF  01,78D
0249A:  MOVFF  00,78C
....................    r = r*y + pe[2]; 
0249E:  MOVFF  78F,7A3
024A2:  MOVFF  78E,7A2
024A6:  MOVFF  78D,7A1
024AA:  MOVFF  78C,7A0
024AE:  MOVFF  787,7A7
024B2:  MOVFF  786,7A6
024B6:  MOVFF  785,7A5
024BA:  MOVFF  784,7A4
024BE:  CALL   18AC
024C2:  MOVFF  00,792
024C6:  MOVFF  01,793
024CA:  MOVFF  02,794
024CE:  MOVFF  03,795
024D2:  BCF    FD8.1
024D4:  MOVFF  03,7A7
024D8:  MOVFF  02,7A6
024DC:  MOVFF  01,7A5
024E0:  MOVFF  00,7A4
024E4:  MOVLW  C4
024E6:  MOVLB  7
024E8:  MOVWF  xAB
024EA:  MOVLW  1D
024EC:  MOVWF  xAA
024EE:  MOVLW  1E
024F0:  MOVWF  xA9
024F2:  MOVLW  78
024F4:  MOVWF  xA8
024F6:  MOVLB  0
024F8:  CALL   14D6
024FC:  MOVFF  03,78F
02500:  MOVFF  02,78E
02504:  MOVFF  01,78D
02508:  MOVFF  00,78C
....................    r = r*y + pe[3]; 
0250C:  MOVFF  78F,7A3
02510:  MOVFF  78E,7A2
02514:  MOVFF  78D,7A1
02518:  MOVFF  78C,7A0
0251C:  MOVFF  787,7A7
02520:  MOVFF  786,7A6
02524:  MOVFF  785,7A5
02528:  MOVFF  784,7A4
0252C:  CALL   18AC
02530:  MOVFF  00,792
02534:  MOVFF  01,793
02538:  MOVFF  02,794
0253C:  MOVFF  03,795
02540:  BCF    FD8.1
02542:  MOVFF  03,7A7
02546:  MOVFF  02,7A6
0254A:  MOVFF  01,7A5
0254E:  MOVFF  00,7A4
02552:  MOVLW  5E
02554:  MOVLB  7
02556:  MOVWF  xAB
02558:  MOVLW  50
0255A:  MOVWF  xAA
0255C:  MOVLW  63
0255E:  MOVWF  xA9
02560:  MOVLW  7A
02562:  MOVWF  xA8
02564:  MOVLB  0
02566:  CALL   14D6
0256A:  MOVFF  03,78F
0256E:  MOVFF  02,78E
02572:  MOVFF  01,78D
02576:  MOVFF  00,78C
....................    r = r*y + pe[4]; 
0257A:  MOVFF  78F,7A3
0257E:  MOVFF  78E,7A2
02582:  MOVFF  78D,7A1
02586:  MOVFF  78C,7A0
0258A:  MOVFF  787,7A7
0258E:  MOVFF  786,7A6
02592:  MOVFF  785,7A5
02596:  MOVFF  784,7A4
0259A:  CALL   18AC
0259E:  MOVFF  00,792
025A2:  MOVFF  01,793
025A6:  MOVFF  02,794
025AA:  MOVFF  03,795
025AE:  BCF    FD8.1
025B0:  MOVFF  03,7A7
025B4:  MOVFF  02,7A6
025B8:  MOVFF  01,7A5
025BC:  MOVFF  00,7A4
025C0:  MOVLW  1A
025C2:  MOVLB  7
025C4:  MOVWF  xAB
025C6:  MOVLW  FE
025C8:  MOVWF  xAA
025CA:  MOVLW  75
025CC:  MOVWF  xA9
025CE:  MOVLW  7C
025D0:  MOVWF  xA8
025D2:  MOVLB  0
025D4:  CALL   14D6
025D8:  MOVFF  03,78F
025DC:  MOVFF  02,78E
025E0:  MOVFF  01,78D
025E4:  MOVFF  00,78C
....................    r = r*y + pe[5]; 
025E8:  MOVFF  78F,7A3
025EC:  MOVFF  78E,7A2
025F0:  MOVFF  78D,7A1
025F4:  MOVFF  78C,7A0
025F8:  MOVFF  787,7A7
025FC:  MOVFF  786,7A6
02600:  MOVFF  785,7A5
02604:  MOVFF  784,7A4
02608:  CALL   18AC
0260C:  MOVFF  00,792
02610:  MOVFF  01,793
02614:  MOVFF  02,794
02618:  MOVFF  03,795
0261C:  BCF    FD8.1
0261E:  MOVFF  03,7A7
02622:  MOVFF  02,7A6
02626:  MOVFF  01,7A5
0262A:  MOVFF  00,7A4
0262E:  MOVLW  18
02630:  MOVLB  7
02632:  MOVWF  xAB
02634:  MOVLW  72
02636:  MOVWF  xAA
02638:  MOVLW  31
0263A:  MOVWF  xA9
0263C:  MOVLW  7E
0263E:  MOVWF  xA8
02640:  MOVLB  0
02642:  CALL   14D6
02646:  MOVFF  03,78F
0264A:  MOVFF  02,78E
0264E:  MOVFF  01,78D
02652:  MOVFF  00,78C
....................  
....................    res = res*(1.0 + y*r); 
02656:  MOVFF  787,7A3
0265A:  MOVFF  786,7A2
0265E:  MOVFF  785,7A1
02662:  MOVFF  784,7A0
02666:  MOVFF  78F,7A7
0266A:  MOVFF  78E,7A6
0266E:  MOVFF  78D,7A5
02672:  MOVFF  78C,7A4
02676:  CALL   18AC
0267A:  BCF    FD8.1
0267C:  MOVLB  7
0267E:  CLRF   xA7
02680:  CLRF   xA6
02682:  CLRF   xA5
02684:  MOVLW  7F
02686:  MOVWF  xA4
02688:  MOVFF  03,7AB
0268C:  MOVFF  02,7AA
02690:  MOVFF  01,7A9
02694:  MOVFF  00,7A8
02698:  MOVLB  0
0269A:  CALL   14D6
0269E:  MOVFF  78B,7A3
026A2:  MOVFF  78A,7A2
026A6:  MOVFF  789,7A1
026AA:  MOVFF  788,7A0
026AE:  MOVFF  03,7A7
026B2:  MOVFF  02,7A6
026B6:  MOVFF  01,7A5
026BA:  MOVFF  00,7A4
026BE:  CALL   18AC
026C2:  MOVFF  03,78B
026C6:  MOVFF  02,78A
026CA:  MOVFF  01,789
026CE:  MOVFF  00,788
....................  
....................    if (s) 
026D2:  MOVLB  7
026D4:  BTFSS  x91.0
026D6:  BRA    270A
....................       res = 1.0/res; 
026D8:  CLRF   x9C
026DA:  CLRF   x9B
026DC:  CLRF   x9A
026DE:  MOVLW  7F
026E0:  MOVWF  x99
026E2:  MOVFF  78B,7A0
026E6:  MOVFF  78A,79F
026EA:  MOVFF  789,79E
026EE:  MOVFF  788,79D
026F2:  MOVLB  0
026F4:  CALL   174E
026F8:  MOVFF  03,78B
026FC:  MOVFF  02,78A
02700:  MOVFF  01,789
02704:  MOVFF  00,788
02708:  MOVLB  7
....................    return(res); 
0270A:  MOVFF  788,00
0270E:  MOVFF  789,01
02712:  MOVFF  78A,02
02716:  MOVFF  78B,03
.................... } 
0271A:  MOVLB  0
0271C:  RETURN 0
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
01F86:  MOVFF  783,787
01F8A:  MOVFF  782,786
01F8E:  MOVFF  781,785
01F92:  MOVFF  780,784
....................  
....................    if (y != 1.0) 
01F96:  MOVFF  787,7A3
01F9A:  MOVFF  786,7A2
01F9E:  MOVFF  785,7A1
01FA2:  MOVFF  784,7A0
01FA6:  MOVLB  7
01FA8:  CLRF   xA7
01FAA:  CLRF   xA6
01FAC:  CLRF   xA5
01FAE:  MOVLW  7F
01FB0:  MOVWF  xA4
01FB2:  MOVLB  0
01FB4:  RCALL  19A2
01FB6:  BTFSC  FD8.2
01FB8:  BRA    22F6
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
01FBA:  MOVLW  07
01FBC:  MOVLB  7
01FBE:  MOVWF  x96
01FC0:  MOVLW  84
01FC2:  MOVWF  FE9
01FC4:  MOVFF  796,FEA
01FC8:  MOVLW  7E
01FCA:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
01FCC:  BSF    FD8.1
01FCE:  MOVFF  787,7A7
01FD2:  MOVFF  786,7A6
01FD6:  MOVFF  785,7A5
01FDA:  MOVFF  784,7A4
01FDE:  CLRF   xAB
01FE0:  CLRF   xAA
01FE2:  CLRF   xA9
01FE4:  MOVLW  7F
01FE6:  MOVWF  xA8
01FE8:  MOVLB  0
01FEA:  CALL   14D6
01FEE:  MOVFF  00,795
01FF2:  MOVFF  01,796
01FF6:  MOVFF  02,797
01FFA:  MOVFF  03,798
01FFE:  BCF    FD8.1
02000:  MOVFF  787,7A7
02004:  MOVFF  786,7A6
02008:  MOVFF  785,7A5
0200C:  MOVFF  784,7A4
02010:  MOVLB  7
02012:  CLRF   xAB
02014:  CLRF   xAA
02016:  CLRF   xA9
02018:  MOVLW  7F
0201A:  MOVWF  xA8
0201C:  MOVLB  0
0201E:  CALL   14D6
02022:  MOVFF  798,79C
02026:  MOVFF  797,79B
0202A:  MOVFF  796,79A
0202E:  MOVFF  795,799
02032:  MOVFF  03,7A0
02036:  MOVFF  02,79F
0203A:  MOVFF  01,79E
0203E:  MOVFF  00,79D
02042:  CALL   174E
02046:  MOVFF  03,787
0204A:  MOVFF  02,786
0204E:  MOVFF  01,785
02052:  MOVFF  00,784
....................  
....................       y2=y*y; 
02056:  MOVFF  787,7A3
0205A:  MOVFF  786,7A2
0205E:  MOVFF  785,7A1
02062:  MOVFF  784,7A0
02066:  MOVFF  787,7A7
0206A:  MOVFF  786,7A6
0206E:  MOVFF  785,7A5
02072:  MOVFF  784,7A4
02076:  RCALL  18AC
02078:  MOVFF  03,793
0207C:  MOVFF  02,792
02080:  MOVFF  01,791
02084:  MOVFF  00,790
....................  
....................       res = pl[0]*y2 + pl[1]; 
02088:  MOVLW  99
0208A:  MOVLB  7
0208C:  MOVWF  xA3
0208E:  MOVLW  47
02090:  MOVWF  xA2
02092:  MOVLW  8A
02094:  MOVWF  xA1
02096:  MOVLW  7F
02098:  MOVWF  xA0
0209A:  MOVFF  793,7A7
0209E:  MOVFF  792,7A6
020A2:  MOVFF  791,7A5
020A6:  MOVFF  790,7A4
020AA:  MOVLB  0
020AC:  CALL   18AC
020B0:  MOVFF  00,795
020B4:  MOVFF  01,796
020B8:  MOVFF  02,797
020BC:  MOVFF  03,798
020C0:  BCF    FD8.1
020C2:  MOVFF  03,7A7
020C6:  MOVFF  02,7A6
020CA:  MOVFF  01,7A5
020CE:  MOVFF  00,7A4
020D2:  MOVLB  7
020D4:  CLRF   xAB
020D6:  CLRF   xAA
020D8:  CLRF   xA9
020DA:  MOVLW  80
020DC:  MOVWF  xA8
020DE:  MOVLB  0
020E0:  CALL   14D6
020E4:  MOVFF  03,78B
020E8:  MOVFF  02,78A
020EC:  MOVFF  01,789
020F0:  MOVFF  00,788
....................  
....................       r = ql[0]*y2 + ql[1]; 
020F4:  MOVLW  4C
020F6:  MOVLB  7
020F8:  MOVWF  xA3
020FA:  MOVLW  F3
020FC:  MOVWF  xA2
020FE:  MOVLW  3A
02100:  MOVWF  xA1
02102:  MOVLW  7B
02104:  MOVWF  xA0
02106:  MOVFF  793,7A7
0210A:  MOVFF  792,7A6
0210E:  MOVFF  791,7A5
02112:  MOVFF  790,7A4
02116:  MOVLB  0
02118:  CALL   18AC
0211C:  MOVFF  00,795
02120:  MOVFF  01,796
02124:  MOVFF  02,797
02128:  MOVFF  03,798
0212C:  BCF    FD8.1
0212E:  MOVFF  03,7A7
02132:  MOVFF  02,7A6
02136:  MOVFF  01,7A5
0213A:  MOVFF  00,7A4
0213E:  MOVLW  2B
02140:  MOVLB  7
02142:  MOVWF  xAB
02144:  MOVLW  9D
02146:  MOVWF  xAA
02148:  MOVLW  DF
0214A:  MOVWF  xA9
0214C:  MOVLW  7E
0214E:  MOVWF  xA8
02150:  MOVLB  0
02152:  CALL   14D6
02156:  MOVFF  03,78F
0215A:  MOVFF  02,78E
0215E:  MOVFF  01,78D
02162:  MOVFF  00,78C
....................       r = r*y2 + 1.0; 
02166:  MOVFF  78F,7A3
0216A:  MOVFF  78E,7A2
0216E:  MOVFF  78D,7A1
02172:  MOVFF  78C,7A0
02176:  MOVFF  793,7A7
0217A:  MOVFF  792,7A6
0217E:  MOVFF  791,7A5
02182:  MOVFF  790,7A4
02186:  CALL   18AC
0218A:  MOVFF  00,795
0218E:  MOVFF  01,796
02192:  MOVFF  02,797
02196:  MOVFF  03,798
0219A:  BCF    FD8.1
0219C:  MOVFF  03,7A7
021A0:  MOVFF  02,7A6
021A4:  MOVFF  01,7A5
021A8:  MOVFF  00,7A4
021AC:  MOVLB  7
021AE:  CLRF   xAB
021B0:  CLRF   xAA
021B2:  CLRF   xA9
021B4:  MOVLW  7F
021B6:  MOVWF  xA8
021B8:  MOVLB  0
021BA:  CALL   14D6
021BE:  MOVFF  03,78F
021C2:  MOVFF  02,78E
021C6:  MOVFF  01,78D
021CA:  MOVFF  00,78C
....................  
....................       res = y*res/r; 
021CE:  MOVFF  787,7A3
021D2:  MOVFF  786,7A2
021D6:  MOVFF  785,7A1
021DA:  MOVFF  784,7A0
021DE:  MOVFF  78B,7A7
021E2:  MOVFF  78A,7A6
021E6:  MOVFF  789,7A5
021EA:  MOVFF  788,7A4
021EE:  CALL   18AC
021F2:  MOVFF  00,795
021F6:  MOVFF  01,796
021FA:  MOVFF  02,797
021FE:  MOVFF  03,798
02202:  MOVFF  03,79C
02206:  MOVFF  02,79B
0220A:  MOVFF  01,79A
0220E:  MOVFF  00,799
02212:  MOVFF  78F,7A0
02216:  MOVFF  78E,79F
0221A:  MOVFF  78D,79E
0221E:  MOVFF  78C,79D
02222:  CALL   174E
02226:  MOVFF  03,78B
0222A:  MOVFF  02,78A
0222E:  MOVFF  01,789
02232:  MOVFF  00,788
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
02236:  MOVLW  07
02238:  MOVLB  7
0223A:  MOVWF  x96
0223C:  MOVLW  80
0223E:  MOVWF  FE9
02240:  MOVFF  796,FEA
02244:  MOVLW  7E
02246:  SUBWF  FEF,W
02248:  MOVWF  x94
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0224A:  BTFSC  x94.7
0224C:  BRA    2250
0224E:  BRA    2278
....................          r = -(float32)-n; 
02250:  MOVLW  00
02252:  BSF    FD8.0
02254:  SUBFWB x94,W
02256:  CLRF   x97
02258:  MOVWF  x96
0225A:  BTFSC  x96.7
0225C:  DECF   x97,F
0225E:  MOVLB  0
02260:  RCALL  1F36
02262:  MOVFF  00,78C
02266:  MOVF   01,W
02268:  XORLW  80
0226A:  MOVLB  7
0226C:  MOVWF  x8D
0226E:  MOVFF  02,78E
02272:  MOVFF  03,78F
....................       else 
02276:  BRA    2298
....................          r = (float32)n; 
02278:  CLRF   x97
0227A:  MOVFF  794,796
0227E:  BTFSC  x96.7
02280:  DECF   x97,F
02282:  MOVLB  0
02284:  RCALL  1F36
02286:  MOVFF  03,78F
0228A:  MOVFF  02,78E
0228E:  MOVFF  01,78D
02292:  MOVFF  00,78C
02296:  MOVLB  7
....................  
....................       res += r*LN2; 
02298:  MOVFF  78F,7A3
0229C:  MOVFF  78E,7A2
022A0:  MOVFF  78D,7A1
022A4:  MOVFF  78C,7A0
022A8:  MOVLW  18
022AA:  MOVWF  xA7
022AC:  MOVLW  72
022AE:  MOVWF  xA6
022B0:  MOVLW  31
022B2:  MOVWF  xA5
022B4:  MOVLW  7E
022B6:  MOVWF  xA4
022B8:  MOVLB  0
022BA:  CALL   18AC
022BE:  BCF    FD8.1
022C0:  MOVFF  78B,7A7
022C4:  MOVFF  78A,7A6
022C8:  MOVFF  789,7A5
022CC:  MOVFF  788,7A4
022D0:  MOVFF  03,7AB
022D4:  MOVFF  02,7AA
022D8:  MOVFF  01,7A9
022DC:  MOVFF  00,7A8
022E0:  CALL   14D6
022E4:  MOVFF  03,78B
022E8:  MOVFF  02,78A
022EC:  MOVFF  01,789
022F0:  MOVFF  00,788
....................    } 
....................  
....................    else 
022F4:  BRA    2302
....................       res = 0.0; 
022F6:  MOVLB  7
022F8:  CLRF   x8B
022FA:  CLRF   x8A
022FC:  CLRF   x89
022FE:  CLRF   x88
02300:  MOVLB  0
....................  
....................    return(res); 
02302:  MOVFF  788,00
02306:  MOVFF  789,01
0230A:  MOVFF  78A,02
0230E:  MOVFF  78B,03
.................... } 
02312:  RETURN 0
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
0271E:  MOVFF  777,7A3
02722:  MOVFF  776,7A2
02726:  MOVFF  775,7A1
0272A:  MOVFF  774,7A0
0272E:  MOVLB  7
02730:  CLRF   xA7
02732:  CLRF   xA6
02734:  CLRF   xA5
02736:  CLRF   xA4
02738:  MOVLB  0
0273A:  CALL   19A2
0273E:  BTFSS  FD8.0
02740:  BRA    28F4
02742:  MOVFF  77B,77F
02746:  MOVFF  77A,77E
0274A:  MOVFF  779,77D
0274E:  MOVFF  778,77C
02752:  MOVLB  7
02754:  CLRF   x83
02756:  CLRF   x82
02758:  CLRF   x81
0275A:  MOVLW  7F
0275C:  MOVWF  x80
0275E:  MOVLB  0
02760:  CALL   1DDA
02764:  MOVFF  00,77C
02768:  MOVFF  01,77D
0276C:  MOVFF  02,77E
02770:  MOVFF  03,77F
02774:  MOVFF  03,7A3
02778:  MOVFF  02,7A2
0277C:  MOVFF  01,7A1
02780:  MOVFF  00,7A0
02784:  MOVLB  7
02786:  CLRF   xA7
02788:  CLRF   xA6
0278A:  CLRF   xA5
0278C:  CLRF   xA4
0278E:  MOVLB  0
02790:  CALL   19A2
02794:  BTFSS  FD8.2
02796:  BRA    28F4
....................       if(fmod(y, 2) == 0) { 
02798:  MOVFF  77B,77F
0279C:  MOVFF  77A,77E
027A0:  MOVFF  779,77D
027A4:  MOVFF  778,77C
027A8:  MOVLB  7
027AA:  CLRF   x83
027AC:  CLRF   x82
027AE:  CLRF   x81
027B0:  MOVLW  80
027B2:  MOVWF  x80
027B4:  MOVLB  0
027B6:  CALL   1DDA
027BA:  MOVFF  00,77C
027BE:  MOVFF  01,77D
027C2:  MOVFF  02,77E
027C6:  MOVFF  03,77F
027CA:  MOVFF  03,7A3
027CE:  MOVFF  02,7A2
027D2:  MOVFF  01,7A1
027D6:  MOVFF  00,7A0
027DA:  MOVLB  7
027DC:  CLRF   xA7
027DE:  CLRF   xA6
027E0:  CLRF   xA5
027E2:  CLRF   xA4
027E4:  MOVLB  0
027E6:  CALL   19A2
027EA:  BNZ   286E
....................          return (exp(log(-x) * y)); 
027EC:  MOVFF  774,77C
027F0:  MOVLB  7
027F2:  MOVF   x75,W
027F4:  XORLW  80
027F6:  MOVWF  x7D
027F8:  MOVFF  776,77E
027FC:  MOVFF  777,77F
02800:  MOVFF  777,783
02804:  MOVFF  776,782
02808:  MOVWF  x81
0280A:  MOVFF  774,780
0280E:  MOVLB  0
02810:  CALL   1F86
02814:  MOVFF  00,77C
02818:  MOVFF  01,77D
0281C:  MOVFF  02,77E
02820:  MOVFF  03,77F
02824:  MOVFF  03,7A3
02828:  MOVFF  02,7A2
0282C:  MOVFF  01,7A1
02830:  MOVFF  00,7A0
02834:  MOVFF  77B,7A7
02838:  MOVFF  77A,7A6
0283C:  MOVFF  779,7A5
02840:  MOVFF  778,7A4
02844:  CALL   18AC
02848:  MOVFF  00,77C
0284C:  MOVFF  01,77D
02850:  MOVFF  02,77E
02854:  MOVFF  03,77F
02858:  MOVFF  03,783
0285C:  MOVFF  02,782
02860:  MOVFF  01,781
02864:  MOVFF  00,780
02868:  RCALL  2314
0286A:  BRA    2A28
....................       } else { 
0286C:  BRA    28F2
....................          return (-exp(log(-x) * y)); 
0286E:  MOVFF  774,77C
02872:  MOVLB  7
02874:  MOVF   x75,W
02876:  XORLW  80
02878:  MOVWF  x7D
0287A:  MOVFF  776,77E
0287E:  MOVFF  777,77F
02882:  MOVFF  777,783
02886:  MOVFF  776,782
0288A:  MOVWF  x81
0288C:  MOVFF  774,780
02890:  MOVLB  0
02892:  CALL   1F86
02896:  MOVFF  00,77C
0289A:  MOVFF  01,77D
0289E:  MOVFF  02,77E
028A2:  MOVFF  03,77F
028A6:  MOVFF  03,7A3
028AA:  MOVFF  02,7A2
028AE:  MOVFF  01,7A1
028B2:  MOVFF  00,7A0
028B6:  MOVFF  77B,7A7
028BA:  MOVFF  77A,7A6
028BE:  MOVFF  779,7A5
028C2:  MOVFF  778,7A4
028C6:  CALL   18AC
028CA:  MOVFF  00,77C
028CE:  MOVFF  01,77D
028D2:  MOVFF  02,77E
028D6:  MOVFF  03,77F
028DA:  MOVFF  03,783
028DE:  MOVFF  02,782
028E2:  MOVFF  01,781
028E6:  MOVFF  00,780
028EA:  RCALL  2314
028EC:  MOVLW  80
028EE:  XORWF  01,F
028F0:  BRA    2A28
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
028F2:  BRA    2A28
028F4:  MOVFF  777,7A3
028F8:  MOVFF  776,7A2
028FC:  MOVFF  775,7A1
02900:  MOVFF  774,7A0
02904:  MOVLB  7
02906:  CLRF   xA7
02908:  CLRF   xA6
0290A:  CLRF   xA5
0290C:  CLRF   xA4
0290E:  MOVLB  0
02910:  CALL   19A2
02914:  BNC   2976
02916:  MOVFF  77B,77F
0291A:  MOVFF  77A,77E
0291E:  MOVFF  779,77D
02922:  MOVFF  778,77C
02926:  MOVLB  7
02928:  CLRF   x83
0292A:  CLRF   x82
0292C:  CLRF   x81
0292E:  MOVLW  7F
02930:  MOVWF  x80
02932:  MOVLB  0
02934:  CALL   1DDA
02938:  MOVFF  00,77C
0293C:  MOVFF  01,77D
02940:  MOVFF  02,77E
02944:  MOVFF  03,77F
02948:  MOVFF  03,7A3
0294C:  MOVFF  02,7A2
02950:  MOVFF  01,7A1
02954:  MOVFF  00,7A0
02958:  MOVLB  7
0295A:  CLRF   xA7
0295C:  CLRF   xA6
0295E:  CLRF   xA5
02960:  CLRF   xA4
02962:  MOVLB  0
02964:  CALL   19A2
02968:  BZ    2976
....................       return 0; 
0296A:  CLRF   00
0296C:  CLRF   01
0296E:  CLRF   02
02970:  CLRF   03
02972:  BRA    2A28
....................    } else { 
02974:  BRA    2A28
....................       if(x != 0 || 0 >= y) { 
02976:  MOVFF  777,7A3
0297A:  MOVFF  776,7A2
0297E:  MOVFF  775,7A1
02982:  MOVFF  774,7A0
02986:  MOVLB  7
02988:  CLRF   xA7
0298A:  CLRF   xA6
0298C:  CLRF   xA5
0298E:  CLRF   xA4
02990:  MOVLB  0
02992:  CALL   19A2
02996:  BNZ   29BC
02998:  MOVFF  77B,7A3
0299C:  MOVFF  77A,7A2
029A0:  MOVFF  779,7A1
029A4:  MOVFF  778,7A0
029A8:  MOVLB  7
029AA:  CLRF   xA7
029AC:  CLRF   xA6
029AE:  CLRF   xA5
029B0:  CLRF   xA4
029B2:  MOVLB  0
029B4:  CALL   19A2
029B8:  BC    29BC
029BA:  BNZ   2A28
....................          return (exp(log(x) * y)); 
029BC:  MOVFF  777,783
029C0:  MOVFF  776,782
029C4:  MOVFF  775,781
029C8:  MOVFF  774,780
029CC:  CALL   1F86
029D0:  MOVFF  00,77C
029D4:  MOVFF  01,77D
029D8:  MOVFF  02,77E
029DC:  MOVFF  03,77F
029E0:  MOVFF  03,7A3
029E4:  MOVFF  02,7A2
029E8:  MOVFF  01,7A1
029EC:  MOVFF  00,7A0
029F0:  MOVFF  77B,7A7
029F4:  MOVFF  77A,7A6
029F8:  MOVFF  779,7A5
029FC:  MOVFF  778,7A4
02A00:  CALL   18AC
02A04:  MOVFF  00,77C
02A08:  MOVFF  01,77D
02A0C:  MOVFF  02,77E
02A10:  MOVFF  03,77F
02A14:  MOVFF  03,783
02A18:  MOVFF  02,782
02A1C:  MOVFF  01,781
02A20:  MOVFF  00,780
02A24:  RCALL  2314
02A26:  BRA    2A28
....................       } 
....................    } 
.................... } 
02A28:  RETURN 0
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <DSP100_PINS.h> 
.................... // File DSP4x4_PINS.h 
....................  
.................... #define PIN_EEPROM_SDA  	PIN_C3  
.................... #define PIN_EEPROM_SCL  	PIN_C2  
....................  
.................... #define PIN_DSP_nRESET 		PIN_A4 
.................... #define PIN_DSP_SDA 		PIN_B0 
.................... #define PIN_DSP_SCL 		PIN_B1 
.................... #define PIN_DSP_IRQ			PIN_B2 
....................  
.................... #define PIN_AMP_nRESET 		PIN_A5 
.................... #define PIN_AMP_nMUTE		PIN_C1 
.................... #define PIN_AMP_READY		PIN_E2 
....................  
.................... #define PIN_AMP_M1			PIN_A1 
.................... #define PIN_AMP_M2			PIN_A2 
.................... #define PIN_AMP_M3			PIN_A3 
....................  
.................... #define PIN_USB_TX			PIN_C5 
.................... #define PIN_USB_RX			PIN_C4		 
....................  
.................... #define PIN_RS232_TX		PIN_D6 
.................... #define PIN_RS232_RX		PIN_D7 
....................  
.................... #define PIN_PHANTOM_ENABLE 	PIN_D5 
.................... #define PIN_PHANTOM_CH1 	PIN_B4 
.................... #define PIN_PHANTOM_CH2 	PIN_B5 
....................  
.................... #define AUD_MUTE			PIN_D3 
....................  
.................... // to be removed 
.................... #define PIN_CLIP1			PIN_A5 
.................... #define PIN_CLIP2			PIN_E0 
.................... #define PIN_CLIP3			PIN_E2 
.................... #define PIN_CLIP4			PIN_E1 
....................  
.................... #define PIN_PSON			PIN_B4 
....................  
.................... #define PIN_AUDIODETECT		PIN_B0 
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP100_CONFIG.h> 
.................... // File DSP4x4_CONFIG.h 
....................  
.................... #define POWERUP_DELAY	200 
....................  
.................... #define IEEPROM_PRESET_LOC	0x10 
.................... #define IEEPROM_DEVICE_CONFIG_LOC 0x64 
.................... #define IEEPROM_FLAG_LOC 0x20 
....................  
.................... #define FLASH_PHANTOM_LOC 0x200 
.................... #define NUM_PRESETS			10 
.................... #define DEFAULT_PRESET		0 
....................  
.................... long int num_dsp_values = 478; // Not a define since the software will automatically change this if necessary 
....................  
.................... #define NUM_PRESET_PAGES			12 
.................... #define NUM_DSP_VALUE_PAGES			8		 
.................... #define NUM_PLAIN_VALUE_PAGES		4 
.................... #define PLAIN_VALUE_PAGES_OFFSET	8	 
.................... #define NUM_ADDRESS_PAGES			4 
.................... #define IOLABEL_PAGE				11 
....................  
.................... #define DEFAULT_ADDR_BLOCK			14 
.................... #define DEFAULT_VALUE_BLOCK			15 
....................  
.................... long int AUDIODETECT_HOLDTIME_SECONDS = 2; 
....................  
....................  
.................... #define DELAY_POWERUP			100 
.................... #define DELAY_AMP_MODE_SETTLE	1000 
.................... #define DELAY_DSP_RESET_SETTLE	50 
....................  
.................... unsigned int RVC_NOISE_FLOOR = 0; // Higher the number the fewer the subdivisions 
....................  
.................... /* store in EEPROM */ 
....................  
.................... const int DEBUG = 0; 
....................  
.................... double DEFAULT_ADC_CALIBRATION_MIN	= 30.0; 
.................... double DEFAULT_ADC_CALIBRATION_MAX	= 240.0; 
....................  
.................... int DEFAULT_AMP_MODE = 1; // 0 = 4CH, 1 = 2CH, 2 = 1CH 
.................... int DEFAULT_IS_70V = 1; 
....................  
.................... int DEFAULT_RVC_ENABLE = 1; 
.................... int DEFAULT_USBDETECT_ENABLE = 1; 
.................... int DEFAULT_AMPBOOT_DELAY_ENABLE = 1; 
.................... int DEFAULT_PS_PIN_ENABLE = 0; 
.................... int DEFAULT_DSP_VALUESEND_ENABLE = 1; 
.................... int DEFAULT_SLEEP_ENABLE = 0; 
.................... int16 DEFAULT_SLEEP_SECONDS = 65; 
.................... int16 DEFAULT_SLEEP_HOLDTIME = 60; 
....................  
.................... #define DEVICE_ID_MSB	0 
.................... #define DEVICE_ID_LSB	0x1E 
....................  
.................... typedef struct { 
.................... 	 
.................... 	int AMP_MODE; 
.................... 	int IS_70V; 
.................... 	 
.................... 	double ADC_CALIBRATION_MIN; 
.................... 	double ADC_CALIBRATION_MAX; 
....................  
.................... 	 
.................... 	int RVC_ENABLE; 
.................... 	int USBDETECT_ENABLE; 
.................... 	int AMPBOOT_DELAY_ENABLE; 
.................... 	int PS_PIN_ENABLE; 
.................... 	int DSP_VALUESEND_ENABLE; 
.................... 	int SLEEP_ENABLE; 
.................... 	int16 SLEEP_SECONDS; 
.................... 	int16 SLEEP_HOLDTIME; 
.................... 	char SERIAL[20]; 
.................... } device_configuration; 
....................  
.................... device_configuration DEVICE_CONFIG; 
....................  
.................... 	 
....................  
....................  
.................... #include <main.h> 
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // VERSION INFO 
.................... int MAJOR_REVISION = 1; 
.................... int MINOR_REVISION = 0; 
.................... char REVISION_TEXT[20] = "-DSP100-1"; 
....................  
.................... // USEFUL DEFINES 
.................... #define hi(x) (*((int8*)&x+1))  
.................... #define ON     0x00000001 
.................... #define OFF    0x00000000 
....................  
.................... // Used for eeprom.c 
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... // EEPROM DEFINES 
.................... #use I2C(MASTER, SDA=PIN_C3, SCL=PIN_C2) 
*
0136C:  MOVLW  08
0136E:  MOVWF  01
01370:  MOVLW  03
01372:  MOVWF  00
01374:  DECFSZ 00,F
01376:  BRA    1374
01378:  BCF    F8B.2
0137A:  BCF    F94.2
0137C:  MOVLW  03
0137E:  MOVWF  00
01380:  DECFSZ 00,F
01382:  BRA    1380
01384:  MOVLB  7
01386:  RLCF   x83,F
01388:  BCF    F8B.3
0138A:  BTFSC  FD8.0
0138C:  BSF    F94.3
0138E:  BTFSS  FD8.0
01390:  BCF    F94.3
01392:  BSF    F94.2
01394:  BTFSS  F82.2
01396:  BRA    1394
01398:  DECFSZ 01,F
0139A:  BRA    139E
0139C:  BRA    13A2
0139E:  MOVLB  0
013A0:  BRA    1370
013A2:  MOVLW  03
013A4:  MOVWF  00
013A6:  DECFSZ 00,F
013A8:  BRA    13A6
013AA:  BCF    F8B.2
013AC:  BCF    F94.2
013AE:  NOP   
013B0:  BSF    F94.3
013B2:  MOVLW  03
013B4:  MOVWF  00
013B6:  DECFSZ 00,F
013B8:  BRA    13B6
013BA:  MOVLW  03
013BC:  MOVWF  00
013BE:  DECFSZ 00,F
013C0:  BRA    13BE
013C2:  BSF    F94.2
013C4:  BTFSS  F82.2
013C6:  BRA    13C4
013C8:  CLRF   01
013CA:  MOVLW  03
013CC:  MOVWF  00
013CE:  DECFSZ 00,F
013D0:  BRA    13CE
013D2:  BTFSC  F82.3
013D4:  BSF    01.0
013D6:  BCF    F8B.2
013D8:  BCF    F94.2
013DA:  BCF    F8B.3
013DC:  BCF    F94.3
013DE:  MOVLB  0
013E0:  RETURN 0
*
074EC:  MOVLW  08
074EE:  MOVLB  7
074F0:  MOVWF  x29
074F2:  MOVFF  00,72A
074F6:  BSF    F94.3
074F8:  MOVLW  03
074FA:  MOVWF  00
074FC:  DECFSZ 00,F
074FE:  BRA    74FC
07500:  BSF    F94.2
07502:  BTFSS  F82.2
07504:  BRA    7502
07506:  BTFSC  F82.3
07508:  BSF    FD8.0
0750A:  BTFSS  F82.3
0750C:  BCF    FD8.0
0750E:  RLCF   01,F
07510:  MOVLW  03
07512:  MOVWF  00
07514:  DECFSZ 00,F
07516:  BRA    7514
07518:  BCF    F94.2
0751A:  BCF    F8B.2
0751C:  DECFSZ x29,F
0751E:  BRA    74F6
07520:  BSF    F94.3
07522:  MOVLW  03
07524:  MOVWF  00
07526:  DECFSZ 00,F
07528:  BRA    7526
0752A:  BCF    F8B.3
0752C:  MOVF   x2A,W
0752E:  BTFSS  FD8.2
07530:  BCF    F94.3
07532:  NOP   
07534:  BSF    F94.2
07536:  BTFSS  F82.2
07538:  BRA    7536
0753A:  MOVLW  03
0753C:  MOVWF  00
0753E:  DECFSZ 00,F
07540:  BRA    753E
07542:  BCF    F8B.2
07544:  BCF    F94.2
07546:  MOVLW  03
07548:  MOVWF  00
0754A:  DECFSZ 00,F
0754C:  BRA    754A
0754E:  BCF    F8B.3
07550:  BCF    F94.3
07552:  MOVLB  0
07554:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int  
.................... #define EEPROM_SIZE   (128*8*8)  
....................  
.................... // RS232 DEFINES 
....................  
.................... #use rs232(baud=19200,parity=N,xmit=PIN_USB_TX,rcv=PIN_USB_RX,bits=8,errors,stream=USB,FORCE_SW) 
*
07360:  BSF    F94.4
07362:  BTFSC  F82.4
07364:  BRA    7362
07366:  MOVLW  08
07368:  MOVWF  00
0736A:  MOVLB  7
0736C:  CLRF   x2A
0736E:  BSF    00.7
07370:  BRA    738E
07372:  BCF    00.7
07374:  BRA    738E
07376:  BCF    FD8.0
07378:  BTFSC  F82.4
0737A:  BSF    FD8.0
0737C:  RRCF   x2A,F
0737E:  BSF    00.6
07380:  BRA    738E
07382:  BCF    00.6
07384:  DECFSZ 00,F
07386:  BRA    7376
07388:  MOVFF  72A,01
0738C:  BRA    73A6
0738E:  MOVLW  39
07390:  BTFSC  00.7
07392:  MOVLW  0F
07394:  MOVWF  01
07396:  DECFSZ 01,F
07398:  BRA    7396
0739A:  BRA    739C
0739C:  BTFSC  00.7
0739E:  BRA    7372
073A0:  BTFSC  00.6
073A2:  BRA    7382
073A4:  BRA    7376
073A6:  MOVLB  0
073A8:  RETURN 0
*
073FC:  BCF    F94.5
073FE:  BCF    F8B.5
07400:  MOVLW  08
07402:  MOVWF  01
07404:  BRA    7406
07406:  NOP   
07408:  BSF    01.7
0740A:  BRA    742C
0740C:  BCF    01.7
0740E:  MOVLB  7
07410:  RRCF   x29,F
07412:  MOVLB  0
07414:  BTFSC  FD8.0
07416:  BSF    F8B.5
07418:  BTFSS  FD8.0
0741A:  BCF    F8B.5
0741C:  BSF    01.6
0741E:  BRA    742C
07420:  BCF    01.6
07422:  DECFSZ 01,F
07424:  BRA    740E
07426:  BRA    7428
07428:  NOP   
0742A:  BSF    F8B.5
0742C:  MOVLW  39
0742E:  MOVWF  FE9
07430:  DECFSZ FE9,F
07432:  BRA    7430
07434:  BRA    7436
07436:  NOP   
07438:  BTFSC  01.7
0743A:  BRA    740C
0743C:  BTFSC  01.6
0743E:  BRA    7420
07440:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_RS232_TX,rcv=PIN_RS232_RX,bits=8,errors, stream=RS232) 
*
079A4:  BTFSS  FA4.4
079A6:  BRA    79A4
079A8:  MOVWF  F73
079AA:  GOTO   79F0 (RETURN)
....................  
.................... #define FLASH_CS	PIN_D2 
....................  
.................... #use SPI(DO = PIN_D4, DI = PIN_D1, CLK = PIN_D0,BITS = 8,MSB_FIRST, SAMPLE_RISE)  
*
05D6E:  MOVLB  7
05D70:  MOVF   x45,W
05D72:  SUBLW  08
05D74:  BZ    5D7E
05D76:  MOVWF  x46
05D78:  RLCF   x44,F
05D7A:  DECFSZ x46,F
05D7C:  BRA    5D78
05D7E:  BSF    F95.1
05D80:  BCF    F95.4
05D82:  BCF    F95.0
05D84:  BCF    F8C.0
05D86:  MOVFF  745,746
05D8A:  BTFSS  x44.7
05D8C:  BCF    F8C.4
05D8E:  BTFSC  x44.7
05D90:  BSF    F8C.4
05D92:  RLCF   x44,F
05D94:  BSF    F8C.0
05D96:  RLCF   01,F
05D98:  BTFSS  F83.1
05D9A:  BCF    01.0
05D9C:  BTFSC  F83.1
05D9E:  BSF    01.0
05DA0:  BCF    F8C.0
05DA2:  DECFSZ x46,F
05DA4:  BRA    5D8A
05DA6:  MOVLB  0
05DA8:  RETURN 0
....................  
.................... int IS_USB_CONNECTED; 
....................  
....................  
.................... // DSP DEFINES 
.................... #define DSP_I2C_ADDRESS 0x80 
....................  
.................... // MEMORY DEFINES 
.................... int CURRENT_FLASH_PROGRAM = 0; 
....................  
.................... #define PAGE_SIZE  64  
.................... #define NUM_PAGES 9 
.................... #define TOTAL_ARRAY_SIZE (PAGE_SIZE*NUM_PAGES) 
....................  
.................... int32 PAGE_BUFFER_A[PAGE_SIZE]; 
....................  
....................  
.................... /* VARIABLES FOR RVC */ 
.................... unsigned int last_adc = 0; 
.................... unsigned int current_adc = 0; 
....................  
.................... int is_muted = 0; 
.................... int pin_in_mute_state = 0; 
....................  
....................  
.................... /* VARIABLES FOR SLEEP TIMER */ 
.................... int16 sleepseconds; 
.................... int16 sleeptimeout_seconds = 10; 
....................  
.................... int is_in_sleep = 0; 
.................... int sleep_timer_active = 0; 
....................  
.................... typedef struct { 
.................... 	int16 ADDRESSES_1[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_2[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_3[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_4[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_5[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_6[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_7[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_8[PAGE_SIZE]; 
.................... } dsp_addresses; 
....................  
.................... dsp_addresses DSP_ADDR; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP_mapping.h> 
.................... // This map is for FLX4CHANNEL_WITHNET_REVI 
.................... // Map generated 1-30-14 by Patrick Paul 
....................  
.................... #define DSP_ADDRESS_WRITE_PREFIX 0xF000 
.................... #define DSP_ADDRESS_READ_PREFIX 0xF0C0 
....................  
.................... /** 'AUDIO MANAGER' **/ 
.................... #define AM_MASTERGAIN		0x83000000	 
.................... #define AM_ANALOG1_TRIM		0x8300000a 
.................... #define AM_ANALOG2_TRIM		0x8300000b 
.................... #define AM_ANALOG3_TRIM		0x8300000c 
.................... #define AM_ANALOG4_TRIM		0x8300000d 
....................  
.................... #define PREGAIN_CH1 0x0373 
.................... #define PREGAIN_MUTE_CH1 0x0443 
.................... #define PREGAIN_CH2 0x03cf 
.................... #define PREGAIN_MUTE_CH2 0x0441 
.................... #define PREGAIN_CH3 0x03cb 
.................... #define PREGAIN_MUTE_CH3 0x043f 
.................... #define PREGAIN_CH4 0x03c7 
.................... #define PREGAIN_MUTE_CH4 0x043d 
.................... #define PREGAIN_CH5 0x03c3 
.................... #define PREGAIN_MUTE_CH5 0x043b 
.................... #define PREGAIN_CH6 0x03bf 
.................... #define PREGAIN_MUTE_CH6 0x0439 
.................... #define PREGAIN_CH7 0x03bb 
.................... #define PREGAIN_MUTE_CH7 0x0437 
.................... #define PREGAIN_CH8 0x03b7 
.................... #define PREGAIN_MUTE_CH8 0x0435 
.................... #define PREMIX_CH1 0x03b3 
.................... #define PREMIX_MUTE_CH1 0x0433 
.................... #define PREMIX_CH2 0x03af 
.................... #define PREMIX_MUTE_CH2 0x0431 
.................... #define PREMIX_CH3 0x03ab 
.................... #define PREMIX_MUTE_CH3 0x042f 
.................... #define PREMIX_CH4 0x03a7 
.................... #define PREMIX_MUTE_CH4 0x042d 
.................... #define PREMIX_CH5 0x03a3 
.................... #define PREMIX_MUTE_CH5 0x042b 
.................... #define PREMIX_CH6 0x039f 
.................... #define PREMIX_MUTE_CH6 0x0429 
.................... #define PREMIX_CH7 0x039b 
.................... #define PREMIX_MUTE_CH7 0x0427 
.................... #define PREMIX_CH8 0x0397 
.................... #define PREMIX_MUTE_CH8 0x0425 
.................... #define TRIM_CH1 0x0393 
.................... #define TRIM_MUTE_CH1 0x0423 
.................... #define TRIM_CH2 0x038f 
.................... #define TRIM_MUTE_CH2 0x0421 
.................... #define TRIM_CH3 0x038b 
.................... #define TRIM_MUTE_CH3 0x041f 
.................... #define TRIM_CH4 0x0387 
.................... #define TRIM_MUTE_CH4 0x041d 
.................... #define OUTPUTGAIN_CH1 0x0383 
.................... #define OUTPUT_MUTE_CH1 0x041b 
.................... #define OUTPUTGAIN_CH2 0x037f 
.................... #define OUTPUT_MUTE_CH2 0x0419 
.................... #define OUTPUTGAIN_CH3 0x037b 
.................... #define OUTPUT_MUTE_CH3 0x0417 
.................... #define OUTPUTGAIN_CH4 0x0377 
.................... #define OUTPUT_MUTE_CH4 0x0415 
.................... #define INDUCKROUTER_SELECT0 0x020e 
.................... #define INDUCKROUTER_SELECT1 0x020f 
.................... #define INDUCKROUTER_SELECT2 0x0210 
.................... #define INDUCKROUTER_SELECT3 0x0211 
.................... #define INDUCKROUTER_SELECT4 0x0212 
.................... #define INDUCKROUTER_SELECT5 0x0213 
.................... #define INDUCKROUTER_SELECT6 0x0214 
.................... #define INDUCKROUTER_SELECT7 0x0215 
.................... #define OUTDUCKROUTER_SELECT0 0x0205 
.................... #define OUTDUCKROUTER_SELECT1 0x0206 
.................... #define OUTDUCKROUTER_SELECT2 0x0207 
.................... #define OUTDUCKROUTER_SELECT3 0x0208 
.................... #define OUTDUCKROUTER_SELECT4 0x0209 
.................... #define OUTDUCKROUTER_SELECT5 0x020a 
.................... #define OUTDUCKROUTER_SELECT6 0x020b 
.................... #define OUTDUCKROUTER_SELECT7 0x020c 
.................... #define DUCKER_THRESHOLD 0x0276 
.................... #define DUCKER_HOLD 0x0277 
.................... #define DUCKER_DEPTH 0x0278 
.................... #define DUCKER_ATTACK 0x0279 
.................... #define DUCKER_RELEASE 0x027a 
.................... #define DUCKER_BYPASS 0x027b 
.................... #define IN_1_1_FILTER_B0 0x036d 
.................... #define IN_1_1_FILTER_B1 0x036e 
.................... #define IN_1_1_FILTER_B2 0x036f 
.................... #define IN_1_1_FILTER_MINUSA1 0x0370 
.................... #define IN_1_1_FILTER_MINUSA2 0x0371 
.................... #define IN_1_2_FILTER_B0 0x0368 
.................... #define IN_1_2_FILTER_B1 0x0369 
.................... #define IN_1_2_FILTER_B2 0x036a 
.................... #define IN_1_2_FILTER_MINUSA1 0x036b 
.................... #define IN_1_2_FILTER_MINUSA2 0x036c 
.................... #define IN_1_3_FILTER_B0 0x0363 
.................... #define IN_1_3_FILTER_B1 0x0364 
.................... #define IN_1_3_FILTER_B2 0x0365 
.................... #define IN_1_3_FILTER_MINUSA1 0x0366 
.................... #define IN_1_3_FILTER_MINUSA2 0x0367 
.................... #define IN_2_1_FILTER_B0 0x035e 
.................... #define IN_2_1_FILTER_B1 0x035f 
.................... #define IN_2_1_FILTER_B2 0x0360 
.................... #define IN_2_1_FILTER_MINUSA1 0x0361 
.................... #define IN_2_1_FILTER_MINUSA2 0x0362 
.................... #define IN_2_2_FILTER_B0 0x0359 
.................... #define IN_2_2_FILTER_B1 0x035a 
.................... #define IN_2_2_FILTER_B2 0x035b 
.................... #define IN_2_2_FILTER_MINUSA1 0x035c 
.................... #define IN_2_2_FILTER_MINUSA2 0x035d 
.................... #define IN_2_3_FILTER_B0 0x0354 
.................... #define IN_2_3_FILTER_B1 0x0355 
.................... #define IN_2_3_FILTER_B2 0x0356 
.................... #define IN_2_3_FILTER_MINUSA1 0x0357 
.................... #define IN_2_3_FILTER_MINUSA2 0x0358 
.................... #define IN_3_1_FILTER_B0 0x034f 
.................... #define IN_3_1_FILTER_B1 0x0350 
.................... #define IN_3_1_FILTER_B2 0x0351 
.................... #define IN_3_1_FILTER_MINUSA1 0x0352 
.................... #define IN_3_1_FILTER_MINUSA2 0x0353 
.................... #define IN_3_2_FILTER_B0 0x034a 
.................... #define IN_3_2_FILTER_B1 0x034b 
.................... #define IN_3_2_FILTER_B2 0x034c 
.................... #define IN_3_2_FILTER_MINUSA1 0x034d 
.................... #define IN_3_2_FILTER_MINUSA2 0x034e 
.................... #define IN_3_3_FILTER_B0 0x0345 
.................... #define IN_3_3_FILTER_B1 0x0346 
.................... #define IN_3_3_FILTER_B2 0x0347 
.................... #define IN_3_3_FILTER_MINUSA1 0x0348 
.................... #define IN_3_3_FILTER_MINUSA2 0x0349 
.................... #define IN_4_1_FILTER_B0 0x0340 
.................... #define IN_4_1_FILTER_B1 0x0341 
.................... #define IN_4_1_FILTER_B2 0x0342 
.................... #define IN_4_1_FILTER_MINUSA1 0x0343 
.................... #define IN_4_1_FILTER_MINUSA2 0x0344 
.................... #define IN_4_2_FILTER_B0 0x033b 
.................... #define IN_4_2_FILTER_B1 0x033c 
.................... #define IN_4_2_FILTER_B2 0x033d 
.................... #define IN_4_2_FILTER_MINUSA1 0x033e 
.................... #define IN_4_2_FILTER_MINUSA2 0x033f 
.................... #define IN_4_3_FILTER_B0 0x0336 
.................... #define IN_4_3_FILTER_B1 0x0337 
.................... #define IN_4_3_FILTER_B2 0x0338 
.................... #define IN_4_3_FILTER_MINUSA1 0x0339 
.................... #define IN_4_3_FILTER_MINUSA2 0x033a 
.................... #define IN_5_1_FILTER_B0 0x0331 
.................... #define IN_5_1_FILTER_B1 0x0332 
.................... #define IN_5_1_FILTER_B2 0x0333 
.................... #define IN_5_1_FILTER_MINUSA1 0x0334 
.................... #define IN_5_1_FILTER_MINUSA2 0x0335 
.................... #define IN_5_2_FILTER_B0 0x032c 
.................... #define IN_5_2_FILTER_B1 0x032d 
.................... #define IN_5_2_FILTER_B2 0x032e 
.................... #define IN_5_2_FILTER_MINUSA1 0x032f 
.................... #define IN_5_2_FILTER_MINUSA2 0x0330 
.................... #define IN_5_3_FILTER_B0 0x0327 
.................... #define IN_5_3_FILTER_B1 0x0328 
.................... #define IN_5_3_FILTER_B2 0x0329 
.................... #define IN_5_3_FILTER_MINUSA1 0x032a 
.................... #define IN_5_3_FILTER_MINUSA2 0x032b 
.................... #define IN_6_1_FILTER_B0 0x0322 
.................... #define IN_6_1_FILTER_B1 0x0323 
.................... #define IN_6_1_FILTER_B2 0x0324 
.................... #define IN_6_1_FILTER_MINUSA1 0x0325 
.................... #define IN_6_1_FILTER_MINUSA2 0x0326 
.................... #define IN_6_2_FILTER_B0 0x031d 
.................... #define IN_6_2_FILTER_B1 0x031e 
.................... #define IN_6_2_FILTER_B2 0x031f 
.................... #define IN_6_2_FILTER_MINUSA1 0x0320 
.................... #define IN_6_2_FILTER_MINUSA2 0x0321 
.................... #define IN_6_3_FILTER_B0 0x0318 
.................... #define IN_6_3_FILTER_B1 0x0319 
.................... #define IN_6_3_FILTER_B2 0x031a 
.................... #define IN_6_3_FILTER_MINUSA1 0x031b 
.................... #define IN_6_3_FILTER_MINUSA2 0x031c 
.................... #define IN_7_1_FILTER_B0 0x0313 
.................... #define IN_7_1_FILTER_B1 0x0314 
.................... #define IN_7_1_FILTER_B2 0x0315 
.................... #define IN_7_1_FILTER_MINUSA1 0x0316 
.................... #define IN_7_1_FILTER_MINUSA2 0x0317 
.................... #define IN_7_2_FILTER_B0 0x030e 
.................... #define IN_7_2_FILTER_B1 0x030f 
.................... #define IN_7_2_FILTER_B2 0x0310 
.................... #define IN_7_2_FILTER_MINUSA1 0x0311 
.................... #define IN_7_2_FILTER_MINUSA2 0x0312 
.................... #define IN_7_3_FILTER_B0 0x0309 
.................... #define IN_7_3_FILTER_B1 0x030a 
.................... #define IN_7_3_FILTER_B2 0x030b 
.................... #define IN_7_3_FILTER_MINUSA1 0x030c 
.................... #define IN_7_3_FILTER_MINUSA2 0x030d 
.................... #define IN_8_1_FILTER_B0 0x0304 
.................... #define IN_8_1_FILTER_B1 0x0305 
.................... #define IN_8_1_FILTER_B2 0x0306 
.................... #define IN_8_1_FILTER_MINUSA1 0x0307 
.................... #define IN_8_1_FILTER_MINUSA2 0x0308 
.................... #define IN_8_2_FILTER_B0 0x02ff 
.................... #define IN_8_2_FILTER_B1 0x0300 
.................... #define IN_8_2_FILTER_B2 0x0301 
.................... #define IN_8_2_FILTER_MINUSA1 0x0302 
.................... #define IN_8_2_FILTER_MINUSA2 0x0303 
.................... #define IN_8_3_FILTER_B0 0x02fa 
.................... #define IN_8_3_FILTER_B1 0x02fb 
.................... #define IN_8_3_FILTER_B2 0x02fc 
.................... #define IN_8_3_FILTER_MINUSA1 0x02fd 
.................... #define IN_8_3_FILTER_MINUSA2 0x02fe 
.................... #define CH1COMP_THRESHOLD 0x026e 
.................... #define CH1COMP_KNEE 0x026f 
.................... #define CH1COMP_RATIO 0x0270 
.................... #define CH1COMP_ATTACK 0x0271 
.................... #define CH1COMP_RELEASE 0x0272 
.................... #define CH1COMP_BYPASS 0x0273 
.................... #define CH2COMP_THRESHOLD 0x0266 
.................... #define CH2COMP_KNEE 0x0267 
.................... #define CH2COMP_RATIO 0x0268 
.................... #define CH2COMP_ATTACK 0x0269 
.................... #define CH2COMP_RELEASE 0x026a 
.................... #define CH2COMP_BYPASS 0x026b 
.................... #define CH3COMP_THRESHOLD 0x025e 
.................... #define CH3COMP_KNEE 0x025f 
.................... #define CH3COMP_RATIO 0x0260 
.................... #define CH3COMP_ATTACK 0x0261 
.................... #define CH3COMP_RELEASE 0x0262 
.................... #define CH3COMP_BYPASS 0x0263 
.................... #define CH4COMP_THRESHOLD 0x0256 
.................... #define CH4COMP_KNEE 0x0257 
.................... #define CH4COMP_RATIO 0x0258 
.................... #define CH4COMP_ATTACK 0x0259 
.................... #define CH4COMP_RELEASE 0x025a 
.................... #define CH4COMP_BYPASS 0x025b 
.................... #define CH5COMP_THRESHOLD 0x024e 
.................... #define CH5COMP_KNEE 0x024f 
.................... #define CH5COMP_RATIO 0x0250 
.................... #define CH5COMP_ATTACK 0x0251 
.................... #define CH5COMP_RELEASE 0x0252 
.................... #define CH5COMP_BYPASS 0x0253 
.................... #define CH6COMP_THRESHOLD 0x0246 
.................... #define CH6COMP_KNEE 0x0247 
.................... #define CH6COMP_RATIO 0x0248 
.................... #define CH6COMP_ATTACK 0x0249 
.................... #define CH6COMP_RELEASE 0x024a 
.................... #define CH6COMP_BYPASS 0x024b 
.................... #define CH7COMP_THRESHOLD 0x023e 
.................... #define CH7COMP_KNEE 0x023f 
.................... #define CH7COMP_RATIO 0x0240 
.................... #define CH7COMP_ATTACK 0x0241 
.................... #define CH7COMP_RELEASE 0x0242 
.................... #define CH7COMP_BYPASS 0x0243 
.................... #define CH8COMP_THRESHOLD 0x0236 
.................... #define CH8COMP_KNEE 0x0237 
.................... #define CH8COMP_RATIO 0x0238 
.................... #define CH8COMP_ATTACK 0x0239 
.................... #define CH8COMP_RELEASE 0x023a 
.................... #define CH8COMP_BYPASS 0x023b 
.................... #define MIXER_SELECT0 0x0003 
.................... #define MIXER_SELECT1 0x0004 
.................... #define MIXER_SELECT2 0x0005 
.................... #define MIXER_SELECT3 0x0006 
.................... #define MIXER_SELECT4 0x0007 
.................... #define MIXER_SELECT5 0x0008 
.................... #define MIXER_SELECT6 0x0009 
.................... #define MIXER_SELECT7 0x000a 
.................... #define MIXER_SELECT8 0x000b 
.................... #define MIXER_SELECT9 0x000c 
.................... #define MIXER_SELECT10 0x000d 
.................... #define MIXER_SELECT11 0x000e 
.................... #define MIXER_SELECT12 0x000f 
.................... #define MIXER_SELECT13 0x0010 
.................... #define MIXER_SELECT14 0x0011 
.................... #define MIXER_SELECT15 0x0012 
.................... #define MIXER_SELECT16 0x0013 
.................... #define MIXER_SELECT17 0x0014 
.................... #define MIXER_SELECT18 0x0015 
.................... #define MIXER_SELECT19 0x0016 
.................... #define MIXER_SELECT20 0x0017 
.................... #define MIXER_SELECT21 0x0018 
.................... #define MIXER_SELECT22 0x0019 
.................... #define MIXER_SELECT23 0x001a 
.................... #define MIXER_SELECT24 0x001b 
.................... #define MIXER_SELECT25 0x001c 
.................... #define MIXER_SELECT26 0x001d 
.................... #define MIXER_SELECT27 0x001e 
.................... #define MIXER_SELECT28 0x001f 
.................... #define MIXER_SELECT29 0x0020 
.................... #define MIXER_SELECT30 0x0021 
.................... #define MIXER_SELECT31 0x0022 
.................... #define MIXER_SELECT32 0x0023 
.................... #define MIXER_SELECT33 0x0024 
.................... #define MIXER_SELECT34 0x0025 
.................... #define MIXER_SELECT35 0x0026 
.................... #define MIXER_SELECT36 0x0027 
.................... #define MIXER_SELECT37 0x0028 
.................... #define MIXER_SELECT38 0x0029 
.................... #define MIXER_SELECT39 0x002a 
.................... #define MIXER_SELECT40 0x002b 
.................... #define MIXER_SELECT41 0x002c 
.................... #define MIXER_SELECT42 0x002d 
.................... #define MIXER_SELECT43 0x002e 
.................... #define MIXER_SELECT44 0x002f 
.................... #define MIXER_SELECT45 0x0030 
.................... #define MIXER_SELECT46 0x0031 
.................... #define MIXER_SELECT47 0x0032 
.................... #define MIXER_SELECT48 0x0033 
.................... #define MIXER_SELECT49 0x0034 
.................... #define MIXER_SELECT50 0x0035 
.................... #define MIXER_SELECT51 0x0036 
.................... #define MIXER_SELECT52 0x0037 
.................... #define MIXER_SELECT53 0x0038 
.................... #define MIXER_SELECT54 0x0039 
.................... #define MIXER_SELECT55 0x003a 
.................... #define MIXER_SELECT56 0x003b 
.................... #define MIXER_SELECT57 0x003c 
.................... #define MIXER_SELECT58 0x003d 
.................... #define MIXER_SELECT59 0x003e 
.................... #define MIXER_SELECT60 0x003f 
.................... #define MIXER_SELECT61 0x0040 
.................... #define MIXER_SELECT62 0x0041 
.................... #define MIXER_SELECT63 0x0042 
.................... #define MIXER_SELECT64 0x0043 
.................... #define MIXER_SELECT65 0x0044 
.................... #define MIXER_SELECT66 0x0045 
.................... #define MIXER_SELECT67 0x0046 
.................... #define MIXER_SELECT68 0x0047 
.................... #define MIXER_SELECT69 0x0048 
.................... #define MIXER_SELECT70 0x0049 
.................... #define MIXER_SELECT71 0x004a 
.................... #define MIXER_SELECT72 0x004b 
.................... #define MIXER_SELECT73 0x004c 
.................... #define MIXER_SELECT74 0x004d 
.................... #define MIXER_SELECT75 0x004e 
.................... #define MIXER_SELECT76 0x004f 
.................... #define MIXER_SELECT77 0x0050 
.................... #define MIXER_SELECT78 0x0051 
.................... #define MIXER_SELECT79 0x0052 
.................... #define OUT_1_1_FILTER_B0 0x02f5 
.................... #define OUT_1_1_FILTER_B1 0x02f6 
.................... #define OUT_1_1_FILTER_B2 0x02f7 
.................... #define OUT_1_1_FILTER_NEGATIVEA1 0x02f8 
.................... #define OUT_1_1_FILTER_NEGATIVEA2 0x02f9 
.................... #define OUT_1_2_FILTER_B0 0x02f0 
.................... #define OUT_1_2_FILTER_B1 0x02f1 
.................... #define OUT_1_2_FILTER_B2 0x02f2 
.................... #define OUT_1_2_FILTER_NEGATIVEA1 0x02f3 
.................... #define OUT_1_2_FILTER_NEGATIVEA2 0x02f4 
.................... #define OUT_1_3_FILTER_B0 0x02eb 
.................... #define OUT_1_3_FILTER_B1 0x02ec 
.................... #define OUT_1_3_FILTER_B2 0x02ed 
.................... #define OUT_1_3_FILTER_NEGATIVEA1 0x02ee 
.................... #define OUT_1_3_FILTER_NEGATIVEA2 0x02ef 
.................... #define OUT_1_4_FILTER_B0 0x02b9 
.................... #define OUT_1_4_FILTER_B1 0x02ba 
.................... #define OUT_1_4_FILTER_B2 0x02bb 
.................... #define OUT_1_4_FILTER_NEGATIVEA1 0x02bc 
.................... #define OUT_1_4_FILTER_NEGATIVEA2 0x02bd 
.................... #define OUT_1_5_FILTER_B0 0x02b4 
.................... #define OUT_1_5_FILTER_B1 0x02b5 
.................... #define OUT_1_5_FILTER_B2 0x02b6 
.................... #define OUT_1_5_FILTER_NEGATIVEA1 0x02b7 
.................... #define OUT_1_5_FILTER_NEGATIVEA2 0x02b8 
.................... #define OUT_1_6_FILTER_B0 0x02af 
.................... #define OUT_1_6_FILTER_B1 0x02b0 
.................... #define OUT_1_6_FILTER_B2 0x02b1 
.................... #define OUT_1_6_FILTER_NEGATIVEA1 0x02b2 
.................... #define OUT_1_6_FILTER_NEGATIVEA2 0x02b3 
.................... #define OUT_2_1_FILTER_B0 0x02e6 
.................... #define OUT_2_1_FILTER_B1 0x02e7 
.................... #define OUT_2_1_FILTER_B2 0x02e8 
.................... #define OUT_2_1_FILTER_NEGATIVEA1 0x02e9 
.................... #define OUT_2_1_FILTER_NEGATIVEA2 0x02ea 
.................... #define OUT_2_2_FILTER_B0 0x02e1 
.................... #define OUT_2_2_FILTER_B1 0x02e2 
.................... #define OUT_2_2_FILTER_B2 0x02e3 
.................... #define OUT_2_2_FILTER_NEGATIVEA1 0x02e4 
.................... #define OUT_2_2_FILTER_NEGATIVEA2 0x02e5 
.................... #define OUT_2_3_FILTER_B0 0x02dc 
.................... #define OUT_2_3_FILTER_B1 0x02dd 
.................... #define OUT_2_3_FILTER_B2 0x02de 
.................... #define OUT_2_3_FILTER_NEGATIVEA1 0x02df 
.................... #define OUT_2_3_FILTER_NEGATIVEA2 0x02e0 
.................... #define OUT_2_4_FILTER_B0 0x02aa 
.................... #define OUT_2_4_FILTER_B1 0x02ab 
.................... #define OUT_2_4_FILTER_B2 0x02ac 
.................... #define OUT_2_4_FILTER_NEGATIVEA1 0x02ad 
.................... #define OUT_2_4_FILTER_NEGATIVEA2 0x02ae 
.................... #define OUT_2_5_FILTER_B0 0x02a5 
.................... #define OUT_2_5_FILTER_B1 0x02a6 
.................... #define OUT_2_5_FILTER_B2 0x02a7 
.................... #define OUT_2_5_FILTER_NEGATIVEA1 0x02a8 
.................... #define OUT_2_5_FILTER_NEGATIVEA2 0x02a9 
.................... #define OUT_2_6_FILTER_B0 0x02a0 
.................... #define OUT_2_6_FILTER_B1 0x02a1 
.................... #define OUT_2_6_FILTER_B2 0x02a2 
.................... #define OUT_2_6_FILTER_NEGATIVEA1 0x02a3 
.................... #define OUT_2_6_FILTER_NEGATIVEA2 0x02a4 
.................... #define OUT_3_1_FILTER_B0 0x02d7 
.................... #define OUT_3_1_FILTER_B1 0x02d8 
.................... #define OUT_3_1_FILTER_B2 0x02d9 
.................... #define OUT_3_1_FILTER_NEGATIVEA1 0x02da 
.................... #define OUT_3_1_FILTER_NEGATIVEA2 0x02db 
.................... #define OUT_3_2_FILTER_B0 0x02d2 
.................... #define OUT_3_2_FILTER_B1 0x02d3 
.................... #define OUT_3_2_FILTER_B2 0x02d4 
.................... #define OUT_3_2_FILTER_NEGATIVEA1 0x02d5 
.................... #define OUT_3_2_FILTER_NEGATIVEA2 0x02d6 
.................... #define OUT_3_3_FILTER_B0 0x02cd 
.................... #define OUT_3_3_FILTER_B1 0x02ce 
.................... #define OUT_3_3_FILTER_B2 0x02cf 
.................... #define OUT_3_3_FILTER_NEGATIVEA1 0x02d0 
.................... #define OUT_3_3_FILTER_NEGATIVEA2 0x02d1 
.................... #define OUT_3_4_FILTER_B0 0x029b 
.................... #define OUT_3_4_FILTER_B1 0x029c 
.................... #define OUT_3_4_FILTER_B2 0x029d 
.................... #define OUT_3_4_FILTER_NEGATIVEA1 0x029e 
.................... #define OUT_3_4_FILTER_NEGATIVEA2 0x029f 
.................... #define OUT_3_5_FILTER_B0 0x0296 
.................... #define OUT_3_5_FILTER_B1 0x0297 
.................... #define OUT_3_5_FILTER_B2 0x0298 
.................... #define OUT_3_5_FILTER_NEGATIVEA1 0x0299 
.................... #define OUT_3_5_FILTER_NEGATIVEA2 0x029a 
.................... #define OUT_3_6_FILTER_B0 0x0291 
.................... #define OUT_3_6_FILTER_B1 0x0292 
.................... #define OUT_3_6_FILTER_B2 0x0293 
.................... #define OUT_3_6_FILTER_NEGATIVEA1 0x0294 
.................... #define OUT_3_6_FILTER_NEGATIVEA2 0x0295 
.................... #define OUT_4_1_FILTER_B0 0x02c8 
.................... #define OUT_4_1_FILTER_B1 0x02c9 
.................... #define OUT_4_1_FILTER_B2 0x02ca 
.................... #define OUT_4_1_FILTER_NEGATIVEA1 0x02cb 
.................... #define OUT_4_1_FILTER_NEGATIVEA2 0x02cc 
.................... #define OUT_4_2_FILTER_B0 0x02c3 
.................... #define OUT_4_2_FILTER_B1 0x02c4 
.................... #define OUT_4_2_FILTER_B2 0x02c5 
.................... #define OUT_4_2_FILTER_NEGATIVEA1 0x02c6 
.................... #define OUT_4_2_FILTER_NEGATIVEA2 0x02c7 
.................... #define OUT_4_3_FILTER_B0 0x02be 
.................... #define OUT_4_3_FILTER_B1 0x02bf 
.................... #define OUT_4_3_FILTER_B2 0x02c0 
.................... #define OUT_4_3_FILTER_NEGATIVEA1 0x02c1 
.................... #define OUT_4_3_FILTER_NEGATIVEA2 0x02c2 
.................... #define OUT_4_4_FILTER_B0 0x028c 
.................... #define OUT_4_4_FILTER_B1 0x028d 
.................... #define OUT_4_4_FILTER_B2 0x028e 
.................... #define OUT_4_4_FILTER_NEGATIVEA1 0x028f 
.................... #define OUT_4_4_FILTER_NEGATIVEA2 0x0290 
.................... #define OUT_4_5_FILTER_B0 0x0287 
.................... #define OUT_4_5_FILTER_B1 0x0288 
.................... #define OUT_4_5_FILTER_B2 0x0289 
.................... #define OUT_4_5_FILTER_NEGATIVEA1 0x028a 
.................... #define OUT_4_5_FILTER_NEGATIVEA2 0x028b 
.................... #define OUT_4_6_FILTER_B0 0x0282 
.................... #define OUT_4_6_FILTER_B1 0x0283 
.................... #define OUT_4_6_FILTER_B2 0x0284 
.................... #define OUT_4_6_FILTER_NEGATIVEA1 0x0285 
.................... #define OUT_4_6_FILTER_NEGATIVEA2 0x0286 
.................... #define CH1LIM_THRESHOLD 0x022e 
.................... #define CH1LIM_KNEE 0x022f 
.................... #define CH1LIM_RATIO 0x0230 
.................... #define CH1LIM_ATTACK 0x0231 
.................... #define CH1LIM_RELEASE 0x0232 
.................... #define CH1LIM_BYPASS 0x0233 
.................... #define CH2LIM_THRESHOLD 0x0226 
.................... #define CH2LIM_KNEE 0x0227 
.................... #define CH2LIM_RATIO 0x0228 
.................... #define CH2LIM_ATTACK 0x0229 
.................... #define CH2LIM_RELEASE 0x022a 
.................... #define CH2LIM_BYPASS 0x022b 
.................... #define CH3LIM_THRESHOLD 0x021e 
.................... #define CH3LIM_KNEE 0x021f 
.................... #define CH3LIM_RATIO 0x0220 
.................... #define CH3LIM_ATTACK 0x0221 
.................... #define CH3LIM_RELEASE 0x0222 
.................... #define CH3LIM_BYPASS 0x0223 
.................... #define CH4LIM_THRESHOLD 0x0216 
.................... #define CH4LIM_KNEE 0x0217 
.................... #define CH4LIM_RATIO 0x0218 
.................... #define CH4LIM_ATTACK 0x0219 
.................... #define CH4LIM_RELEASE 0x021a 
.................... #define CH4LIM_BYPASS 0x021b 
.................... #define DELAY_CH1 0x03dd 
.................... #define DELAY_CH2 0x03da 
.................... #define DELAY_CH3 0x03d7 
.................... #define DELAY_CH4 0x03d4 
.................... #define DELAY_BYPASS_CH1 0x0448 
.................... #define DELAY_BYPASS_CH2 0x0447 
.................... #define DELAY_BYPASS_CH3 0x0446 
.................... #define DELAY_BYPASS_CH4 0x0445 
.................... #define BRIDGEROUTER_SELECT0 0x027e 
.................... #define BRIDGEROUTER_SELECT1 0x027f 
.................... #define BRIDGEROUTER_SELECT2 0x0280 
.................... #define BRIDGEROUTER_SELECT3 0x0281 
.................... #define GEN_PINK_GAIN 0x0411 
.................... #define GEN_SINE_OMEGA 0x03eb 
.................... #define GEN_SINE_GAIN 0x03ec 
.................... #define SEVENTYVHP_BYPASS 0x0444 
.................... #define MUTE_OUTPUTS 0x0413 
....................  
....................  
.................... #include <memory.c> 
.................... /*void WRITE_CONFIG_BOTH(int16 index, int16 address, int32 value) 
.................... { 
.................... 	if(index > num_dsp_values) { 
.................... 		num_dsp_values = index; 
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE * 2)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
.................... 		DSP_CONFIG.VALUES_2[index - (PAGE_SIZE*1)] = value;   
....................   	}  else if(index < (PAGE_SIZE * 3)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;    
.................... 		DSP_CONFIG.VALUES_3[index - (PAGE_SIZE*2)] = value;    
....................   	}  else if(index < ((PAGE_SIZE*4))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;    
.................... 		DSP_CONFIG.VALUES_4[index - (PAGE_SIZE*3)] = value;    
....................   	} else if(index < ((PAGE_SIZE*5))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;    
.................... 		DSP_CONFIG.VALUES_5[index - (PAGE_SIZE*4)] = value;    
....................   	} else if(index < ((PAGE_SIZE*6))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;    
.................... 		DSP_CONFIG.VALUES_6[index - (PAGE_SIZE*5)] = value;    
....................   	} else if(index < ((PAGE_SIZE*7))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;    
.................... 		DSP_CONFIG.VALUES_7[index - (PAGE_SIZE*6)] = value;    
....................   	} else if(index < ((PAGE_SIZE*8))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
.................... 		//DSP_CONFIG.VALUES_8[index - (PAGE_SIZE*7)] = value;    
....................   	} 
....................  
.................... } 
.................... */ 
.................... void WRITE_CONFIG_ADDRESS(int16 index, int16 address) 
.................... { 
.................... 	if(index > num_dsp_values) { 
*
03124:  MOVF   1B,W
03126:  MOVLB  6
03128:  SUBWF  xD9,W
0312A:  BNC   313C
0312C:  BNZ   3134
0312E:  MOVF   xD8,W
03130:  SUBWF  1A,W
03132:  BC    313C
.................... 		num_dsp_values = index; 
03134:  MOVFF  6D9,1B
03138:  MOVFF  6D8,1A
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
0313C:  MOVF   xD9,F
0313E:  BNZ   3168
03140:  MOVF   xD8,W
03142:  SUBLW  3F
03144:  BNC   3168
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
03146:  BCF    FD8.0
03148:  RLCF   xD8,W
0314A:  MOVWF  02
0314C:  RLCF   xD9,W
0314E:  MOVWF  03
03150:  MOVF   02,W
03152:  ADDLW  84
03154:  MOVWF  FE9
03156:  MOVLW  01
03158:  ADDWFC 03,W
0315A:  MOVWF  FEA
0315C:  MOVFF  6DB,FEC
03160:  MOVF   FED,F
03162:  MOVFF  6DA,FEF
....................   	} else if(index < (PAGE_SIZE * 2)) 
03166:  BRA    32F2
03168:  MOVF   xD9,F
0316A:  BNZ   31A0
0316C:  MOVF   xD8,W
0316E:  SUBLW  7F
03170:  BNC   31A0
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
03172:  MOVLW  40
03174:  SUBWF  xD8,W
03176:  MOVWF  xDC
03178:  MOVLW  00
0317A:  SUBWFB xD9,W
0317C:  MOVWF  xDD
0317E:  BCF    FD8.0
03180:  RLCF   xDC,W
03182:  MOVWF  02
03184:  RLCF   xDD,W
03186:  MOVWF  03
03188:  MOVF   02,W
0318A:  ADDLW  04
0318C:  MOVWF  FE9
0318E:  MOVLW  02
03190:  ADDWFC 03,W
03192:  MOVWF  FEA
03194:  MOVFF  6DB,FEC
03198:  MOVF   FED,F
0319A:  MOVFF  6DA,FEF
....................   	}  else if(index < (PAGE_SIZE * 3)) 
0319E:  BRA    32F2
031A0:  MOVF   xD9,F
031A2:  BNZ   31D8
031A4:  MOVF   xD8,W
031A6:  SUBLW  BF
031A8:  BNC   31D8
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;  
031AA:  MOVLW  80
031AC:  SUBWF  xD8,W
031AE:  MOVWF  xDC
031B0:  MOVLW  00
031B2:  SUBWFB xD9,W
031B4:  MOVWF  xDD
031B6:  BCF    FD8.0
031B8:  RLCF   xDC,W
031BA:  MOVWF  02
031BC:  RLCF   xDD,W
031BE:  MOVWF  03
031C0:  MOVF   02,W
031C2:  ADDLW  84
031C4:  MOVWF  FE9
031C6:  MOVLW  02
031C8:  ADDWFC 03,W
031CA:  MOVWF  FEA
031CC:  MOVFF  6DB,FEC
031D0:  MOVF   FED,F
031D2:  MOVFF  6DA,FEF
....................   	}  else if(index < ((PAGE_SIZE*4))) 
031D6:  BRA    32F2
031D8:  MOVF   xD9,W
031DA:  SUBLW  00
031DC:  BNC   320C
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;   
031DE:  MOVLW  C0
031E0:  SUBWF  xD8,W
031E2:  MOVWF  xDC
031E4:  MOVLW  00
031E6:  SUBWFB xD9,W
031E8:  MOVWF  xDD
031EA:  BCF    FD8.0
031EC:  RLCF   xDC,W
031EE:  MOVWF  02
031F0:  RLCF   xDD,W
031F2:  MOVWF  03
031F4:  MOVF   02,W
031F6:  ADDLW  04
031F8:  MOVWF  FE9
031FA:  MOVLW  03
031FC:  ADDWFC 03,W
031FE:  MOVWF  FEA
03200:  MOVFF  6DB,FEC
03204:  MOVF   FED,F
03206:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*5))) 
0320A:  BRA    32F2
0320C:  MOVF   xD9,W
0320E:  SUBLW  01
03210:  BNC   3248
03212:  BNZ   321A
03214:  MOVF   xD8,W
03216:  SUBLW  3F
03218:  BNC   3248
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;  
0321A:  MOVLW  00
0321C:  SUBWF  xD8,W
0321E:  MOVWF  xDC
03220:  MOVLW  01
03222:  SUBWFB xD9,W
03224:  MOVWF  xDD
03226:  BCF    FD8.0
03228:  RLCF   xDC,W
0322A:  MOVWF  02
0322C:  RLCF   xDD,W
0322E:  MOVWF  03
03230:  MOVF   02,W
03232:  ADDLW  84
03234:  MOVWF  FE9
03236:  MOVLW  03
03238:  ADDWFC 03,W
0323A:  MOVWF  FEA
0323C:  MOVFF  6DB,FEC
03240:  MOVF   FED,F
03242:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*6))) 
03246:  BRA    32F2
03248:  MOVF   xD9,W
0324A:  SUBLW  01
0324C:  BNC   3284
0324E:  BNZ   3256
03250:  MOVF   xD8,W
03252:  SUBLW  7F
03254:  BNC   3284
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;  
03256:  MOVLW  40
03258:  SUBWF  xD8,W
0325A:  MOVWF  xDC
0325C:  MOVLW  01
0325E:  SUBWFB xD9,W
03260:  MOVWF  xDD
03262:  BCF    FD8.0
03264:  RLCF   xDC,W
03266:  MOVWF  02
03268:  RLCF   xDD,W
0326A:  MOVWF  03
0326C:  MOVF   02,W
0326E:  ADDLW  04
03270:  MOVWF  FE9
03272:  MOVLW  04
03274:  ADDWFC 03,W
03276:  MOVWF  FEA
03278:  MOVFF  6DB,FEC
0327C:  MOVF   FED,F
0327E:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*7))) 
03282:  BRA    32F2
03284:  MOVF   xD9,W
03286:  SUBLW  01
03288:  BNC   32C0
0328A:  BNZ   3292
0328C:  MOVF   xD8,W
0328E:  SUBLW  BF
03290:  BNC   32C0
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;  
03292:  MOVLW  80
03294:  SUBWF  xD8,W
03296:  MOVWF  xDC
03298:  MOVLW  01
0329A:  SUBWFB xD9,W
0329C:  MOVWF  xDD
0329E:  BCF    FD8.0
032A0:  RLCF   xDC,W
032A2:  MOVWF  02
032A4:  RLCF   xDD,W
032A6:  MOVWF  03
032A8:  MOVF   02,W
032AA:  ADDLW  84
032AC:  MOVWF  FE9
032AE:  MOVLW  04
032B0:  ADDWFC 03,W
032B2:  MOVWF  FEA
032B4:  MOVFF  6DB,FEC
032B8:  MOVF   FED,F
032BA:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*8))) 
032BE:  BRA    32F2
032C0:  MOVF   xD9,W
032C2:  SUBLW  01
032C4:  BNC   32F2
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
032C6:  MOVLW  C0
032C8:  SUBWF  xD8,W
032CA:  MOVWF  xDC
032CC:  MOVLW  01
032CE:  SUBWFB xD9,W
032D0:  MOVWF  xDD
032D2:  BCF    FD8.0
032D4:  RLCF   xDC,W
032D6:  MOVWF  02
032D8:  RLCF   xDD,W
032DA:  MOVWF  03
032DC:  MOVF   02,W
032DE:  ADDLW  04
032E0:  MOVWF  FE9
032E2:  MOVLW  05
032E4:  ADDWFC 03,W
032E6:  MOVWF  FEA
032E8:  MOVFF  6DB,FEC
032EC:  MOVF   FED,F
032EE:  MOVFF  6DA,FEF
....................   	} 
....................  
.................... } 
032F2:  MOVLB  0
032F4:  RETURN 0
....................  
....................  
.................... int16 READ_CONFIG_ADDRESS(int16 index)  
.................... {  
.................... 	int16 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
*
069D4:  MOVLB  7
069D6:  MOVF   x2B,F
069D8:  BNZ   6A06
069DA:  MOVF   x2A,W
069DC:  SUBLW  3F
069DE:  BNC   6A06
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_1[index]; 
069E0:  BCF    FD8.0
069E2:  RLCF   x2A,W
069E4:  MOVWF  02
069E6:  RLCF   x2B,W
069E8:  MOVWF  03
069EA:  MOVF   02,W
069EC:  ADDLW  84
069EE:  MOVWF  FE9
069F0:  MOVLW  01
069F2:  ADDWFC 03,W
069F4:  MOVWF  FEA
069F6:  MOVFF  FEC,03
069FA:  MOVF   FED,F
069FC:  MOVFF  FEF,72C
06A00:  MOVFF  03,72D
....................   	} else if(index < (PAGE_SIZE * 2)) 
06A04:  BRA    6BAC
06A06:  MOVF   x2B,F
06A08:  BNZ   6A42
06A0A:  MOVF   x2A,W
06A0C:  SUBLW  7F
06A0E:  BNC   6A42
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)]; 
06A10:  MOVLW  40
06A12:  SUBWF  x2A,W
06A14:  MOVWF  x2E
06A16:  MOVLW  00
06A18:  SUBWFB x2B,W
06A1A:  MOVWF  x2F
06A1C:  BCF    FD8.0
06A1E:  RLCF   x2E,W
06A20:  MOVWF  02
06A22:  RLCF   x2F,W
06A24:  MOVWF  03
06A26:  MOVF   02,W
06A28:  ADDLW  04
06A2A:  MOVWF  FE9
06A2C:  MOVLW  02
06A2E:  ADDWFC 03,W
06A30:  MOVWF  FEA
06A32:  MOVFF  FEC,03
06A36:  MOVF   FED,F
06A38:  MOVFF  FEF,72C
06A3C:  MOVFF  03,72D
....................   	}  else if(index < (PAGE_SIZE * 3)) 
06A40:  BRA    6BAC
06A42:  MOVF   x2B,F
06A44:  BNZ   6A7E
06A46:  MOVF   x2A,W
06A48:  SUBLW  BF
06A4A:  BNC   6A7E
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)]; 
06A4C:  MOVLW  80
06A4E:  SUBWF  x2A,W
06A50:  MOVWF  x2E
06A52:  MOVLW  00
06A54:  SUBWFB x2B,W
06A56:  MOVWF  x2F
06A58:  BCF    FD8.0
06A5A:  RLCF   x2E,W
06A5C:  MOVWF  02
06A5E:  RLCF   x2F,W
06A60:  MOVWF  03
06A62:  MOVF   02,W
06A64:  ADDLW  84
06A66:  MOVWF  FE9
06A68:  MOVLW  02
06A6A:  ADDWFC 03,W
06A6C:  MOVWF  FEA
06A6E:  MOVFF  FEC,03
06A72:  MOVF   FED,F
06A74:  MOVFF  FEF,72C
06A78:  MOVFF  03,72D
....................   	}  else if(index < ((PAGE_SIZE*4))) 
06A7C:  BRA    6BAC
06A7E:  MOVF   x2B,W
06A80:  SUBLW  00
06A82:  BNC   6AB6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)]; 
06A84:  MOVLW  C0
06A86:  SUBWF  x2A,W
06A88:  MOVWF  x2E
06A8A:  MOVLW  00
06A8C:  SUBWFB x2B,W
06A8E:  MOVWF  x2F
06A90:  BCF    FD8.0
06A92:  RLCF   x2E,W
06A94:  MOVWF  02
06A96:  RLCF   x2F,W
06A98:  MOVWF  03
06A9A:  MOVF   02,W
06A9C:  ADDLW  04
06A9E:  MOVWF  FE9
06AA0:  MOVLW  03
06AA2:  ADDWFC 03,W
06AA4:  MOVWF  FEA
06AA6:  MOVFF  FEC,03
06AAA:  MOVF   FED,F
06AAC:  MOVFF  FEF,72C
06AB0:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*5))) 
06AB4:  BRA    6BAC
06AB6:  MOVF   x2B,W
06AB8:  SUBLW  01
06ABA:  BNC   6AF6
06ABC:  BNZ   6AC4
06ABE:  MOVF   x2A,W
06AC0:  SUBLW  3F
06AC2:  BNC   6AF6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)];   
06AC4:  MOVLW  00
06AC6:  SUBWF  x2A,W
06AC8:  MOVWF  x2E
06ACA:  MOVLW  01
06ACC:  SUBWFB x2B,W
06ACE:  MOVWF  x2F
06AD0:  BCF    FD8.0
06AD2:  RLCF   x2E,W
06AD4:  MOVWF  02
06AD6:  RLCF   x2F,W
06AD8:  MOVWF  03
06ADA:  MOVF   02,W
06ADC:  ADDLW  84
06ADE:  MOVWF  FE9
06AE0:  MOVLW  03
06AE2:  ADDWFC 03,W
06AE4:  MOVWF  FEA
06AE6:  MOVFF  FEC,03
06AEA:  MOVF   FED,F
06AEC:  MOVFF  FEF,72C
06AF0:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*6))) 
06AF4:  BRA    6BAC
06AF6:  MOVF   x2B,W
06AF8:  SUBLW  01
06AFA:  BNC   6B36
06AFC:  BNZ   6B04
06AFE:  MOVF   x2A,W
06B00:  SUBLW  7F
06B02:  BNC   6B36
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)]; 
06B04:  MOVLW  40
06B06:  SUBWF  x2A,W
06B08:  MOVWF  x2E
06B0A:  MOVLW  01
06B0C:  SUBWFB x2B,W
06B0E:  MOVWF  x2F
06B10:  BCF    FD8.0
06B12:  RLCF   x2E,W
06B14:  MOVWF  02
06B16:  RLCF   x2F,W
06B18:  MOVWF  03
06B1A:  MOVF   02,W
06B1C:  ADDLW  04
06B1E:  MOVWF  FE9
06B20:  MOVLW  04
06B22:  ADDWFC 03,W
06B24:  MOVWF  FEA
06B26:  MOVFF  FEC,03
06B2A:  MOVF   FED,F
06B2C:  MOVFF  FEF,72C
06B30:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*7))) 
06B34:  BRA    6BAC
06B36:  MOVF   x2B,W
06B38:  SUBLW  01
06B3A:  BNC   6B76
06B3C:  BNZ   6B44
06B3E:  MOVF   x2A,W
06B40:  SUBLW  BF
06B42:  BNC   6B76
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)]; 
06B44:  MOVLW  80
06B46:  SUBWF  x2A,W
06B48:  MOVWF  x2E
06B4A:  MOVLW  01
06B4C:  SUBWFB x2B,W
06B4E:  MOVWF  x2F
06B50:  BCF    FD8.0
06B52:  RLCF   x2E,W
06B54:  MOVWF  02
06B56:  RLCF   x2F,W
06B58:  MOVWF  03
06B5A:  MOVF   02,W
06B5C:  ADDLW  84
06B5E:  MOVWF  FE9
06B60:  MOVLW  04
06B62:  ADDWFC 03,W
06B64:  MOVWF  FEA
06B66:  MOVFF  FEC,03
06B6A:  MOVF   FED,F
06B6C:  MOVFF  FEF,72C
06B70:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*8))) 
06B74:  BRA    6BAC
06B76:  MOVF   x2B,W
06B78:  SUBLW  01
06B7A:  BNC   6BAC
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)]; 
06B7C:  MOVLW  C0
06B7E:  SUBWF  x2A,W
06B80:  MOVWF  x2E
06B82:  MOVLW  01
06B84:  SUBWFB x2B,W
06B86:  MOVWF  x2F
06B88:  BCF    FD8.0
06B8A:  RLCF   x2E,W
06B8C:  MOVWF  02
06B8E:  RLCF   x2F,W
06B90:  MOVWF  03
06B92:  MOVF   02,W
06B94:  ADDLW  04
06B96:  MOVWF  FE9
06B98:  MOVLW  05
06B9A:  ADDWFC 03,W
06B9C:  MOVWF  FEA
06B9E:  MOVFF  FEC,03
06BA2:  MOVF   FED,F
06BA4:  MOVFF  FEF,72C
06BA8:  MOVFF  03,72D
....................   	} 
....................  
.................... 	return(retval);  
06BAC:  MOVFF  72C,01
06BB0:  MOVFF  72D,02
.................... } 
06BB4:  MOVLB  0
06BB6:  RETURN 0
....................  
.................... /* 
.................... int32 READ_CONFIG_VALUE(int16 index)  
.................... {  
.................... 	int32 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_1[index];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_2[index - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE- PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else 
....................   	{  
....................    		retval = 0;  
....................   	}  
....................  
.................... 	return(retval);  
.................... } 
....................  
.................... void WRITE_CONFIG_VALUE(int16 index, int32 value)  
.................... {  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_2[index - PAGE_SIZE] = value;   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{     
.................... 		DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} 
.................... } 
....................  
.................... */ 
....................  
....................  
.................... #include <w25q80bv.c> 
.................... #define W25Q80BV_PAGE_LEN     		256  // in bytes 
.................... #define W25Q80BV_PAGES_PER_SECTOR	16 
....................  
.................... #define W25Q80BV_SECTOR_LEN			W25Q80BV_PAGE_LEN*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_SECTORS_PER_BLOCK	16 
....................  
.................... #define W25Q80BV_BLOCK_LEN			W25Q80BV_SECTOR_LEN*W25Q80BV_SECTORS_PER_BLOCK 
....................   	 
.................... #define W25Q80BV_NUM_BLOCKS			16 
.................... #define W25Q80BV_NUM_SECTORS		W25Q80BV_NUM_BLOCKS*W25Q80BV_SECTORS_PER_BLOCK 
.................... #define W25Q80BV_NUM_PAGES    		W25Q80BV_NUM_SECTORS*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_NUM_BYTES    		W25Q80BV_NUM_BLOCKS*W25Q80BV_BLOCK_LEN 
....................  
.................... #define W25Q80BV_WRITE_ENABLE 0x06 
.................... #define W25Q80BV_CHIP_ERASE   0xC7 
.................... #define W25Q80BV_SECTOR_ERASE 0x20 
.................... #define W25Q80BV_READ_STATUS1 0x05 
.................... #define W25Q80BV_PAGE_PROGRAM 0x02 
.................... #define W25Q80BV_DEVICE_ID    0xAB 
.................... #define W25Q80BV_UNIQUE_ID    0x4B 
....................  
.................... #define W25Q80BV_STATUS_BUSY  0x01 
....................  
.................... #define W25Q80BV_READ 0x03 
....................  
.................... #define W25Q80BV_DEVICE_ID_RES  0x13 /* Expected device_id for W25Q80BV */ 
....................  
.................... unsigned int32 page_address(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
*
05C96:  MOVFF  749,752
05C9A:  MOVFF  748,751
05C9E:  MOVFF  747,750
05CA2:  MOVLB  7
05CA4:  CLRF   x4F
05CA6:  CLRF   x53
05CA8:  RLCF   x53,W
05CAA:  MOVWF  00
05CAC:  RLCF   x43,W
05CAE:  MOVWF  01
05CB0:  RLCF   x44,W
05CB2:  MOVWF  02
05CB4:  RLCF   x45,W
05CB6:  MOVWF  03
05CB8:  RLCF   00,F
05CBA:  RLCF   01,F
05CBC:  RLCF   02,F
05CBE:  RLCF   03,F
05CC0:  RLCF   00,F
05CC2:  RLCF   01,F
05CC4:  RLCF   02,F
05CC6:  RLCF   03,F
05CC8:  RLCF   00,F
05CCA:  RLCF   01,F
05CCC:  RLCF   02,F
05CCE:  RLCF   03,F
05CD0:  MOVLW  F0
05CD2:  ANDWF  00,F
05CD4:  MOVF   00,W
05CD6:  ADDWF  x4F,F
05CD8:  MOVF   01,W
05CDA:  ADDWFC x50,F
05CDC:  MOVF   02,W
05CDE:  ADDWFC x51,F
05CE0:  MOVF   03,W
05CE2:  ADDWFC x52,F
05CE4:  MOVFF  741,756
05CE8:  MOVFF  740,755
05CEC:  MOVFF  73F,754
05CF0:  CLRF   x53
05CF2:  RLCF   x53,F
05CF4:  RLCF   x54,F
05CF6:  RLCF   x55,F
05CF8:  RLCF   x56,F
05CFA:  RLCF   x53,F
05CFC:  RLCF   x54,F
05CFE:  RLCF   x55,F
05D00:  RLCF   x56,F
05D02:  RLCF   x53,F
05D04:  RLCF   x54,F
05D06:  RLCF   x55,F
05D08:  RLCF   x56,F
05D0A:  RLCF   x53,F
05D0C:  RLCF   x54,F
05D0E:  RLCF   x55,F
05D10:  RLCF   x56,F
05D12:  MOVLW  F0
05D14:  ANDWF  x53,F
05D16:  RLCF   x53,W
05D18:  MOVWF  00
05D1A:  RLCF   x54,W
05D1C:  MOVWF  01
05D1E:  RLCF   x55,W
05D20:  MOVWF  02
05D22:  RLCF   x56,W
05D24:  MOVWF  03
05D26:  RLCF   00,F
05D28:  RLCF   01,F
05D2A:  RLCF   02,F
05D2C:  RLCF   03,F
05D2E:  RLCF   00,F
05D30:  RLCF   01,F
05D32:  RLCF   02,F
05D34:  RLCF   03,F
05D36:  RLCF   00,F
05D38:  RLCF   01,F
05D3A:  RLCF   02,F
05D3C:  RLCF   03,F
05D3E:  MOVLW  F0
05D40:  ANDWF  00,F
05D42:  MOVF   00,W
05D44:  ADDWF  x4F,W
05D46:  MOVWF  x4B
05D48:  MOVF   01,W
05D4A:  ADDWFC x50,W
05D4C:  MOVWF  x4C
05D4E:  MOVF   02,W
05D50:  ADDWFC x51,W
05D52:  MOVWF  x4D
05D54:  MOVF   03,W
05D56:  ADDWFC x52,W
05D58:  MOVWF  x4E
.................... 	unsigned int32 return_address = (page_index*W25Q80BV_PAGE_LEN) + (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
05D5A:  MOVFF  74B,00
05D5E:  MOVFF  74C,01
05D62:  MOVFF  74D,02
05D66:  MOVFF  74E,03
.................... } 
05D6A:  MOVLB  0
05D6C:  RETURN 0
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
.................... 	unsigned int32 return_address = (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index) 
.................... { 
.................... 	unsigned int32 return_address = (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
....................  
.................... int flash_get_device_id() 
.................... { 
*
05DAA:  MOVLB  7
05DAC:  CLRF   x3F
.................... 	int data = 0; 
....................  
....................     output_low(FLASH_CS); 
05DAE:  BCF    F95.2
05DB0:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_DEVICE_ID); 
05DB2:  MOVLW  AB
05DB4:  MOVWF  x44
05DB6:  MOVLW  08
05DB8:  MOVWF  x45
05DBA:  MOVLB  0
05DBC:  RCALL  5D6E
.................... 	 
.................... 	data = spi_xfer(0x00); 
05DBE:  MOVLB  7
05DC0:  CLRF   x44
05DC2:  MOVLW  08
05DC4:  MOVWF  x45
05DC6:  MOVLB  0
05DC8:  RCALL  5D6E
05DCA:  MOVF   01,W
05DCC:  MOVFF  01,73F
.................... 	data = spi_xfer(0x00); 
05DD0:  MOVLB  7
05DD2:  CLRF   x44
05DD4:  MOVLW  08
05DD6:  MOVWF  x45
05DD8:  MOVLB  0
05DDA:  RCALL  5D6E
05DDC:  MOVF   01,W
05DDE:  MOVFF  01,73F
.................... 	data = spi_xfer(0x00); 
05DE2:  MOVLB  7
05DE4:  CLRF   x44
05DE6:  MOVLW  08
05DE8:  MOVWF  x45
05DEA:  MOVLB  0
05DEC:  RCALL  5D6E
05DEE:  MOVF   01,W
05DF0:  MOVFF  01,73F
....................  
.................... 	data = spi_xfer(0xFF); 
05DF4:  MOVLB  7
05DF6:  SETF   x44
05DF8:  MOVLW  08
05DFA:  MOVWF  x45
05DFC:  MOVLB  0
05DFE:  RCALL  5D6E
05E00:  MOVF   01,W
05E02:  MOVFF  01,73F
....................  
.................... 	output_high(FLASH_CS); 
05E06:  BCF    F95.2
05E08:  BSF    F8C.2
....................  
.................... 	return data; 
05E0A:  MOVLB  7
05E0C:  MOVFF  73F,01
.................... } 
05E10:  MOVLB  0
05E12:  GOTO   5EBC (RETURN)
....................  
.................... short verify_device_id() 
.................... { 
.................... 	if(flash_get_device_id() == W25Q80BV_DEVICE_ID_RES) { 
.................... 		return 1; 
.................... 	} else { 
.................... 		return 0; 
.................... 	} 
.................... } 
....................  
.................... int flash_get_status() 
.................... { 
05E16:  MOVLB  7
05E18:  CLRF   x3F
.................... 	int value = 0; 
.................... 	output_low(FLASH_CS); 
05E1A:  BCF    F95.2
05E1C:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ_STATUS1); 
05E1E:  MOVLW  05
05E20:  MOVWF  x44
05E22:  MOVLW  08
05E24:  MOVWF  x45
05E26:  MOVLB  0
05E28:  RCALL  5D6E
....................     value = spi_xfer(0x00); 
05E2A:  MOVLB  7
05E2C:  CLRF   x44
05E2E:  MOVLW  08
05E30:  MOVWF  x45
05E32:  MOVLB  0
05E34:  RCALL  5D6E
05E36:  MOVF   01,W
05E38:  MOVFF  01,73F
....................     output_high(FLASH_CS); 
05E3C:  BCF    F95.2
05E3E:  BSF    F8C.2
.................... 	 
.................... 	return value; 
05E40:  MOVLB  7
05E42:  MOVFF  73F,01
.................... } 
05E46:  MOVLB  0
05E48:  RETURN 0
....................  
.................... void flash_wait_while_busy() 
.................... { 
.................... 	while ((flash_get_status() & W25Q80BV_STATUS_BUSY)) 
.................... 	{ 
05E4A:  RCALL  5E16
05E4C:  BTFSS  01.0
05E4E:  BRA    5E52
.................... 	} 
05E50:  BRA    5E4A
.................... } 
05E52:  RETURN 0
....................  
.................... void flash_write_enable() 
.................... { 
.................... 	flash_wait_while_busy(); 
05E54:  RCALL  5E4A
.................... 	output_low(FLASH_CS); 
05E56:  BCF    F95.2
05E58:  BCF    F8C.2
.................... 	spi_xfer(0x06); 
05E5A:  MOVLW  06
05E5C:  MOVLB  7
05E5E:  MOVWF  x44
05E60:  MOVLW  08
05E62:  MOVWF  x45
05E64:  MOVLB  0
05E66:  RCALL  5D6E
....................     output_high(FLASH_CS); 
05E68:  BCF    F95.2
05E6A:  BSF    F8C.2
.................... } 
05E6C:  RETURN 0
....................  
.................... void flash_chip_erase() 
.................... { 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting chip erase...\r\n"); 
.................... 		} 
....................         int device_id = 0; 
....................  
....................         device_id = 0; 
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
....................                 device_id = flash_get_device_id(); 
....................         } 
....................  
....................         flash_write_enable(); 
....................         flash_wait_while_busy(); 
.................... 		output_low(PIN_C0); 
....................         output_low(FLASH_CS); 
....................         spi_xfer(W25Q80BV_CHIP_ERASE); 
....................         output_high(FLASH_CS); 
.................... 		 
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
.................... 		} 
.................... 		output_high(PIN_C0); 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
.................... } 
....................  
.................... void flash_sector_erase(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
05E6E:  MOVLB  7
05E70:  CLRF   x3A
05E72:  MOVFF  735,742
05E76:  MOVFF  734,741
05E7A:  MOVFF  733,740
05E7E:  MOVFF  732,73F
05E82:  MOVFF  739,746
05E86:  MOVFF  738,745
05E8A:  MOVFF  737,744
05E8E:  MOVFF  736,743
05E92:  CLRF   x4A
05E94:  CLRF   x49
05E96:  CLRF   x48
05E98:  CLRF   x47
05E9A:  MOVLB  0
05E9C:  RCALL  5C96
05E9E:  MOVFF  03,73E
05EA2:  MOVFF  02,73D
05EA6:  MOVFF  01,73C
05EAA:  MOVFF  00,73B
....................         int device_id = 0; 
....................  
.................... 		unsigned int32 starting_address = page_address(block_index,sector_index,0); 
....................  
....................         device_id = 0; 
05EAE:  MOVLB  7
05EB0:  CLRF   x3A
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
05EB2:  MOVF   x3A,W
05EB4:  SUBLW  13
05EB6:  BZ    5EC4
....................                 device_id = flash_get_device_id(); 
05EB8:  MOVLB  0
05EBA:  BRA    5DAA
05EBC:  MOVFF  01,73A
....................         } 
05EC0:  MOVLB  7
05EC2:  BRA    5EB2
....................  
....................         flash_write_enable(); 
05EC4:  MOVLB  0
05EC6:  RCALL  5E54
....................         flash_wait_while_busy(); 
05EC8:  RCALL  5E4A
....................         output_low(FLASH_CS); 
05ECA:  BCF    F95.2
05ECC:  BCF    F8C.2
....................         spi_xfer(W25Q80BV_SECTOR_ERASE); 
05ECE:  MOVLW  20
05ED0:  MOVLB  7
05ED2:  MOVWF  x44
05ED4:  MOVLW  08
05ED6:  MOVWF  x45
05ED8:  MOVLB  0
05EDA:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05EDC:  MOVLB  7
05EDE:  CLRF   x3F
05EE0:  CLRF   x40
05EE2:  MOVFF  73D,741
05EE6:  CLRF   x42
05EE8:  MOVFF  73D,73F
05EEC:  MOVFF  742,740
05EF0:  CLRF   x41
05EF2:  CLRF   x42
05EF4:  MOVFF  73D,744
05EF8:  MOVLW  08
05EFA:  MOVWF  x45
05EFC:  MOVLB  0
05EFE:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05F00:  MOVLB  7
05F02:  CLRF   x3F
05F04:  CLRF   x41
05F06:  CLRF   x42
05F08:  MOVFF  73C,73F
05F0C:  MOVFF  741,740
05F10:  MOVFF  742,741
05F14:  CLRF   x42
05F16:  MOVFF  73C,744
05F1A:  MOVLW  08
05F1C:  MOVWF  x45
05F1E:  MOVLB  0
05F20:  RCALL  5D6E
.................... 		spi_xfer(starting_address & 0xFF); 
05F22:  MOVLB  7
05F24:  MOVFF  73B,73F
05F28:  CLRF   x40
05F2A:  CLRF   x41
05F2C:  CLRF   x42
05F2E:  MOVFF  73B,744
05F32:  MOVLW  08
05F34:  MOVWF  x45
05F36:  MOVLB  0
05F38:  RCALL  5D6E
....................         output_high(FLASH_CS); 
05F3A:  BCF    F95.2
05F3C:  BSF    F8C.2
....................  
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
05F3E:  RCALL  5E16
05F40:  BTFSS  01.0
05F42:  BRA    5F46
.................... 		} 
05F44:  BRA    5F3E
....................  
.................... } 
05F46:  RETURN 0
....................  
.................... int flash_write_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		spi_xfer(ptr[i]); 
.................... 		rolling_checksum += ptr[i]; 
.................... 	} 
.................... 	 
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void flash_read_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_read_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < number_of_bytes; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_write_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(block_index,sector_index); 
....................  
.................... 	starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
.................... 	 
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 	for (value_counter = 0; value_counter < number_of_bytes; value_counter++) 
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
....................  
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... /* DEBUG STUFF */ 
....................  
.................... void flash_print_page(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	//starting_address = 0; 
.................... 	fprintf(RS232,"\r\nPrinting flash at starting address (%u,%u,%u) %lu\r\n",block_index,sector_index,page_index,starting_address); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		printf("%x",data); 
....................  
.................... 		if((i % 4) == 3) { 
.................... 			printf(" "); 
.................... 		} 
....................  
.................... 		if((i % 32) == 31) { 
.................... 			printf("\r\n"); 
.................... 		} 
.................... 	} 
.................... 	output_high(FLASH_CS); 
.................... } 
....................  
....................  
.................... int flash_page_checksum(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		rolling_checksum += data; 
.................... 	} 
.................... 	output_high(FLASH_CS); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
.................... /* 
.................... void FLASH_PROGRAM_WRITE(int program_index) {  
....................     
....................  
....................     // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		flash_sector_erase(program_index,sector_counter); 
.................... 		//fprintf(RS232,"Status1: %x\r\n",flash_get_status()); 
.................... 		//delay_ms(40); 
.................... 		//fprintf(RS232,"Status2: %x\r\n",flash_get_status()); 
.................... 		//ptr = &DSP_CONFIG.TEST_VALUES[0]; 
.................... 		starting_address = page_address(program_index,sector_counter,0); 
.................... 		flash_write_enable(); 
.................... 		flash_wait_while_busy(); 
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			spi_xfer(ptr[value_counter]); 
.................... 			test_val++; 
.................... 			value_counter++; 
.................... 		} 
.................... 		 
.................... 		output_high(FLASH_CS); 
....................  
.................... 		flash_wait_while_busy(); 
.................... 	} 
.................... } 
.................... */ 
.................... /* 
.................... void FLASH_PROGRAM_READ(int program_index) 
.................... { 
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
....................  
.................... 		starting_address = page_address(program_index,sector_counter,0); 
....................  
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_READ); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
.................... 			ptr[value_counter] = data; 
.................... 			value_counter++; 
....................  
.................... 			//fprintf(RS232,"%x||",data); 
.................... 		} 
....................  
.................... 		output_high(FLASH_CS); 
.................... 	} 
.................... } 
.................... */ 
.................... void FLASH_ADDR_WRITE(int block_index) {  
05F48:  MOVLB  6
05F4A:  CLRF   xDA
05F4C:  CLRF   xD9
....................     
....................  
....................    // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
05F4E:  MOVLW  01
05F50:  MOVWF  xDA
05F52:  MOVLW  84
05F54:  MOVWF  xD9
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
05F56:  CLRF   xDC
05F58:  CLRF   xDB
05F5A:  CLRF   xE0
05F5C:  CLRF   xDF
05F5E:  CLRF   xDE
05F60:  CLRF   xDD
05F62:  CLRF   xE2
05F64:  CLRF   xE1
05F66:  CLRF   xE4
05F68:  CLRF   xE3
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
05F6A:  CLRF   xE5
05F6C:  MOVF   xE5,W
05F6E:  SUBLW  03
05F70:  BTFSS  FD8.0
05F72:  BRA    6088
.................... 		 
.................... 		flash_sector_erase(block_index,sector_counter); 
05F74:  MOVLB  7
05F76:  CLRF   x35
05F78:  CLRF   x34
05F7A:  CLRF   x33
05F7C:  MOVFF  6D8,732
05F80:  CLRF   x39
05F82:  CLRF   x38
05F84:  CLRF   x37
05F86:  MOVFF  6E5,736
05F8A:  MOVLB  0
05F8C:  RCALL  5E6E
.................... 		starting_address = page_address(block_index,sector_counter,0); 
05F8E:  MOVLB  7
05F90:  CLRF   x42
05F92:  CLRF   x41
05F94:  CLRF   x40
05F96:  MOVFF  6D8,73F
05F9A:  CLRF   x46
05F9C:  CLRF   x45
05F9E:  CLRF   x44
05FA0:  MOVFF  6E5,743
05FA4:  CLRF   x4A
05FA6:  CLRF   x49
05FA8:  CLRF   x48
05FAA:  CLRF   x47
05FAC:  MOVLB  0
05FAE:  RCALL  5C96
05FB0:  MOVFF  03,6E0
05FB4:  MOVFF  02,6DF
05FB8:  MOVFF  01,6DE
05FBC:  MOVFF  00,6DD
.................... 		flash_write_enable(); 
05FC0:  RCALL  5E54
.................... 		flash_wait_while_busy(); 
05FC2:  RCALL  5E4A
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
05FC4:  BCF    F95.2
05FC6:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
05FC8:  MOVLW  02
05FCA:  MOVLB  7
05FCC:  MOVWF  x44
05FCE:  MOVLW  08
05FD0:  MOVWF  x45
05FD2:  MOVLB  0
05FD4:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05FD6:  MOVLB  6
05FD8:  CLRF   xE6
05FDA:  CLRF   xE7
05FDC:  MOVFF  6DF,6E8
05FE0:  CLRF   xE9
05FE2:  MOVFF  6DF,6E6
05FE6:  MOVFF  6E9,6E7
05FEA:  CLRF   xE8
05FEC:  CLRF   xE9
05FEE:  MOVFF  6DF,744
05FF2:  MOVLW  08
05FF4:  MOVLB  7
05FF6:  MOVWF  x45
05FF8:  MOVLB  0
05FFA:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05FFC:  MOVLB  6
05FFE:  CLRF   xE6
06000:  CLRF   xE8
06002:  CLRF   xE9
06004:  MOVFF  6DE,6E6
06008:  MOVFF  6E8,6E7
0600C:  MOVFF  6E9,6E8
06010:  CLRF   xE9
06012:  MOVFF  6DE,744
06016:  MOVLW  08
06018:  MOVLB  7
0601A:  MOVWF  x45
0601C:  MOVLB  0
0601E:  RCALL  5D6E
.................... 		spi_xfer(starting_address & 0xFF); 
06020:  MOVLB  6
06022:  MOVFF  6DD,6E6
06026:  CLRF   xE7
06028:  CLRF   xE8
0602A:  CLRF   xE9
0602C:  MOVFF  6DD,744
06030:  MOVLW  08
06032:  MOVLB  7
06034:  MOVWF  x45
06036:  MOVLB  0
06038:  RCALL  5D6E
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
0603A:  MOVLB  6
0603C:  CLRF   xE4
0603E:  CLRF   xE3
06040:  MOVF   xE4,W
06042:  SUBLW  00
06044:  BNC   607A
.................... 		{ 
.................... 			//spi_xfer(value_counter); 
.................... 			spi_xfer(ptr[value_counter]); 
06046:  MOVF   xD9,W
06048:  ADDWF  xDB,W
0604A:  MOVWF  FE9
0604C:  MOVF   xDA,W
0604E:  ADDWFC xDC,W
06050:  MOVWF  FEA
06052:  MOVFF  FEF,6E6
06056:  MOVFF  6E6,744
0605A:  MOVLW  08
0605C:  MOVLB  7
0605E:  MOVWF  x45
06060:  MOVLB  0
06062:  RCALL  5D6E
.................... 			test_val++; 
06064:  MOVLB  6
06066:  INCF   xE1,F
06068:  BTFSC  FD8.2
0606A:  INCF   xE2,F
.................... 			value_counter++; 
0606C:  INCF   xDB,F
0606E:  BTFSC  FD8.2
06070:  INCF   xDC,F
.................... 		} 
06072:  INCF   xE3,F
06074:  BTFSC  FD8.2
06076:  INCF   xE4,F
06078:  BRA    6040
.................... 		 
.................... 		output_high(FLASH_CS); 
0607A:  BCF    F95.2
0607C:  BSF    F8C.2
....................  
.................... 		flash_wait_while_busy(); 
0607E:  MOVLB  0
06080:  RCALL  5E4A
....................  
.................... 		//fprintf(RS232,"Wrote %lu bytes\r\n",test_val); 
.................... 		 
.................... 	} 
06082:  MOVLB  6
06084:  INCF   xE5,F
06086:  BRA    5F6C
.................... } 
06088:  MOVLB  0
0608A:  GOTO   9662 (RETURN)
....................  
....................  
.................... void FLASH_ADDR_READ() 
.................... { 
*
061D4:  MOVLB  6
061D6:  CLRF   xDB
061D8:  CLRF   xDA
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
061DA:  MOVLW  01
061DC:  MOVWF  xDB
061DE:  MOVLW  84
061E0:  MOVWF  xDA
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
061E2:  CLRF   xDF
061E4:  CLRF   xDE
061E6:  CLRF   xDD
061E8:  CLRF   xDC
061EA:  CLRF   xE1
061EC:  CLRF   xE0
061EE:  CLRF   xE2
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
061F0:  CLRF   xE3
061F2:  MOVF   xE3,W
061F4:  SUBLW  03
061F6:  BTFSS  FD8.0
061F8:  BRA    62E8
....................  
.................... 		starting_address = page_address(DEFAULT_ADDR_BLOCK,sector_counter,0); 
061FA:  MOVLB  7
061FC:  CLRF   x42
061FE:  CLRF   x41
06200:  CLRF   x40
06202:  MOVLW  0E
06204:  MOVWF  x3F
06206:  CLRF   x46
06208:  CLRF   x45
0620A:  CLRF   x44
0620C:  MOVFF  6E3,743
06210:  CLRF   x4A
06212:  CLRF   x49
06214:  CLRF   x48
06216:  CLRF   x47
06218:  MOVLB  0
0621A:  RCALL  5C96
0621C:  MOVFF  03,6DF
06220:  MOVFF  02,6DE
06224:  MOVFF  01,6DD
06228:  MOVFF  00,6DC
....................  
.................... 		output_low(FLASH_CS); 
0622C:  BCF    F95.2
0622E:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_READ); 
06230:  MOVLW  03
06232:  MOVLB  7
06234:  MOVWF  x44
06236:  MOVLW  08
06238:  MOVWF  x45
0623A:  MOVLB  0
0623C:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
0623E:  MOVLB  6
06240:  CLRF   xE6
06242:  CLRF   xE7
06244:  MOVFF  6DE,6E8
06248:  CLRF   xE9
0624A:  MOVFF  6DE,6E6
0624E:  MOVFF  6E9,6E7
06252:  CLRF   xE8
06254:  CLRF   xE9
06256:  MOVFF  6DE,744
0625A:  MOVLW  08
0625C:  MOVLB  7
0625E:  MOVWF  x45
06260:  MOVLB  0
06262:  RCALL  5D6E
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
06264:  MOVLB  6
06266:  CLRF   xE6
06268:  CLRF   xE8
0626A:  CLRF   xE9
0626C:  MOVFF  6DD,6E6
06270:  MOVFF  6E8,6E7
06274:  MOVFF  6E9,6E8
06278:  CLRF   xE9
0627A:  MOVFF  6DD,744
0627E:  MOVLW  08
06280:  MOVLB  7
06282:  MOVWF  x45
06284:  MOVLB  0
06286:  RCALL  5D6E
.................... 		spi_xfer(starting_address & 0xFF); 
06288:  MOVLB  6
0628A:  MOVFF  6DC,6E6
0628E:  CLRF   xE7
06290:  CLRF   xE8
06292:  CLRF   xE9
06294:  MOVFF  6DC,744
06298:  MOVLW  08
0629A:  MOVLB  7
0629C:  MOVWF  x45
0629E:  MOVLB  0
062A0:  RCALL  5D6E
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
062A2:  MOVLB  6
062A4:  CLRF   xE5
062A6:  CLRF   xE4
062A8:  MOVF   xE5,W
062AA:  SUBLW  00
062AC:  BNC   62E0
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
062AE:  MOVLB  7
062B0:  CLRF   x44
062B2:  MOVLW  08
062B4:  MOVWF  x45
062B6:  MOVLB  0
062B8:  RCALL  5D6E
062BA:  MOVF   01,W
062BC:  MOVFF  01,6E2
.................... 			ptr[value_counter] = data; 
062C0:  MOVLB  6
062C2:  MOVF   xDA,W
062C4:  ADDWF  xE0,W
062C6:  MOVWF  FE9
062C8:  MOVF   xDB,W
062CA:  ADDWFC xE1,W
062CC:  MOVWF  FEA
062CE:  MOVFF  6E2,FEF
.................... 			value_counter++; 
062D2:  INCF   xE0,F
062D4:  BTFSC  FD8.2
062D6:  INCF   xE1,F
.................... 			 
.................... 		} 
062D8:  INCF   xE4,F
062DA:  BTFSC  FD8.2
062DC:  INCF   xE5,F
062DE:  BRA    62A8
....................  
.................... 		output_high(FLASH_CS); 
062E0:  BCF    F95.2
062E2:  BSF    F8C.2
.................... 	} 
062E4:  INCF   xE3,F
062E6:  BRA    61F2
.................... } 
062E8:  MOVLB  0
062EA:  GOTO   67FE (RETURN)
....................  
.................... /* 
.................... void PRINT_READ_PROGRAM() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
.................... */ 
.................... void PRINT_READ_ADDR() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void FLASH_COPY_PROGRAM(int from_index, int to_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\nCopying program from %u to %u ... ",from_index,to_index); 
*
07730:  MOVLW  32
07732:  MOVWF  FF6
07734:  MOVLW  09
07736:  MOVWF  FF7
07738:  MOVLW  17
0773A:  MOVLB  7
0773C:  MOVWF  x2E
0773E:  MOVLB  0
07740:  CALL   60D8
07744:  MOVFF  720,72E
07748:  MOVLW  1B
0774A:  MOVLB  7
0774C:  MOVWF  x2F
0774E:  MOVLB  0
07750:  CALL   612E
07754:  MOVLW  4B
07756:  MOVWF  FF6
07758:  MOVLW  09
0775A:  MOVWF  FF7
0775C:  MOVLW  04
0775E:  MOVLB  7
07760:  MOVWF  x2E
07762:  MOVLB  0
07764:  CALL   60D8
07768:  MOVFF  721,72E
0776C:  MOVLW  1B
0776E:  MOVLB  7
07770:  MOVWF  x2F
07772:  MOVLB  0
07774:  CALL   612E
07778:  MOVLW  51
0777A:  MOVWF  FF6
0777C:  MOVLW  09
0777E:  MOVWF  FF7
07780:  MOVLW  05
07782:  MOVLB  7
07784:  MOVWF  x2E
07786:  MOVLB  0
07788:  CALL   60D8
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int32 read_starting_address = 0; 
.................... 	int32 write_starting_address = 0; 
.................... 	 
.................... 	int read_data = 0; 
0778C:  MOVLB  7
0778E:  CLRF   x25
07790:  CLRF   x24
07792:  CLRF   x23
07794:  CLRF   x22
07796:  CLRF   x29
07798:  CLRF   x28
0779A:  CLRF   x27
0779C:  CLRF   x26
0779E:  CLRF   x2A
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
077A0:  CLRF   x2B
077A2:  MOVF   x2B,W
077A4:  SUBLW  0B
077A6:  BTFSS  FD8.0
077A8:  BRA    7992
....................  
.................... 		flash_sector_erase(to_index,sector_counter); 
077AA:  CLRF   x35
077AC:  CLRF   x34
077AE:  CLRF   x33
077B0:  MOVFF  721,732
077B4:  CLRF   x39
077B6:  CLRF   x38
077B8:  CLRF   x37
077BA:  MOVFF  72B,736
077BE:  MOVLB  0
077C0:  CALL   5E6E
....................  
.................... 		write_starting_address = page_address(to_index,sector_counter,0); 
077C4:  MOVLB  7
077C6:  CLRF   x42
077C8:  CLRF   x41
077CA:  CLRF   x40
077CC:  MOVFF  721,73F
077D0:  CLRF   x46
077D2:  CLRF   x45
077D4:  CLRF   x44
077D6:  MOVFF  72B,743
077DA:  CLRF   x4A
077DC:  CLRF   x49
077DE:  CLRF   x48
077E0:  CLRF   x47
077E2:  MOVLB  0
077E4:  CALL   5C96
077E8:  MOVFF  03,729
077EC:  MOVFF  02,728
077F0:  MOVFF  01,727
077F4:  MOVFF  00,726
.................... 		read_starting_address = page_address(from_index,sector_counter,0); 
077F8:  MOVLB  7
077FA:  CLRF   x42
077FC:  CLRF   x41
077FE:  CLRF   x40
07800:  MOVFF  720,73F
07804:  CLRF   x46
07806:  CLRF   x45
07808:  CLRF   x44
0780A:  MOVFF  72B,743
0780E:  CLRF   x4A
07810:  CLRF   x49
07812:  CLRF   x48
07814:  CLRF   x47
07816:  MOVLB  0
07818:  CALL   5C96
0781C:  MOVFF  03,725
07820:  MOVFF  02,724
07824:  MOVFF  01,723
07828:  MOVFF  00,722
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
0782C:  MOVLB  7
0782E:  CLRF   x2D
07830:  CLRF   x2C
07832:  MOVF   x2D,W
07834:  SUBLW  00
07836:  BTFSS  FD8.0
07838:  BRA    798E
.................... 		{ 
.................... 			output_low(FLASH_CS); 
0783A:  BCF    F95.2
0783C:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_READ); 
0783E:  MOVLW  03
07840:  MOVWF  x44
07842:  MOVLW  08
07844:  MOVWF  x45
07846:  MOVLB  0
07848:  CALL   5D6E
.................... 			spi_xfer((read_starting_address & 0xFF0000) >> 16); 
0784C:  MOVLB  7
0784E:  CLRF   x2E
07850:  CLRF   x2F
07852:  MOVFF  724,730
07856:  CLRF   x31
07858:  MOVFF  724,72E
0785C:  MOVFF  731,72F
07860:  CLRF   x30
07862:  CLRF   x31
07864:  MOVFF  724,744
07868:  MOVLW  08
0786A:  MOVWF  x45
0786C:  MOVLB  0
0786E:  CALL   5D6E
.................... 			spi_xfer((read_starting_address & 0xFF00) >> 8); 
07872:  MOVLB  7
07874:  CLRF   x2E
07876:  CLRF   x30
07878:  CLRF   x31
0787A:  MOVFF  723,72E
0787E:  MOVFF  730,72F
07882:  MOVFF  731,730
07886:  CLRF   x31
07888:  MOVFF  723,744
0788C:  MOVLW  08
0788E:  MOVWF  x45
07890:  MOVLB  0
07892:  CALL   5D6E
.................... 			spi_xfer(read_starting_address & 0xFF); 
07896:  MOVLB  7
07898:  MOVFF  722,72E
0789C:  CLRF   x2F
0789E:  CLRF   x30
078A0:  CLRF   x31
078A2:  MOVFF  722,744
078A6:  MOVLW  08
078A8:  MOVWF  x45
078AA:  MOVLB  0
078AC:  CALL   5D6E
.................... 		 
.................... 			read_data = spi_xfer(0x00); 
078B0:  MOVLB  7
078B2:  CLRF   x44
078B4:  MOVLW  08
078B6:  MOVWF  x45
078B8:  MOVLB  0
078BA:  CALL   5D6E
078BE:  MOVF   01,W
078C0:  MOVFF  01,72A
....................  
.................... 			output_high(FLASH_CS); 
078C4:  BCF    F95.2
078C6:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
078C8:  CALL   5E4A
....................  
.................... 			flash_write_enable(); 
078CC:  CALL   5E54
.................... 			flash_wait_while_busy(); 
078D0:  CALL   5E4A
....................  
.................... 			output_low(FLASH_CS); 
078D4:  BCF    F95.2
078D6:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_PAGE_PROGRAM); 
078D8:  MOVLW  02
078DA:  MOVLB  7
078DC:  MOVWF  x44
078DE:  MOVLW  08
078E0:  MOVWF  x45
078E2:  MOVLB  0
078E4:  CALL   5D6E
.................... 			spi_xfer((write_starting_address & 0xFF0000) >> 16); 
078E8:  MOVLB  7
078EA:  CLRF   x2E
078EC:  CLRF   x2F
078EE:  MOVFF  728,730
078F2:  CLRF   x31
078F4:  MOVFF  728,72E
078F8:  MOVFF  731,72F
078FC:  CLRF   x30
078FE:  CLRF   x31
07900:  MOVFF  728,744
07904:  MOVLW  08
07906:  MOVWF  x45
07908:  MOVLB  0
0790A:  CALL   5D6E
.................... 			spi_xfer((write_starting_address & 0xFF00) >> 8); 
0790E:  MOVLB  7
07910:  CLRF   x2E
07912:  CLRF   x30
07914:  CLRF   x31
07916:  MOVFF  727,72E
0791A:  MOVFF  730,72F
0791E:  MOVFF  731,730
07922:  CLRF   x31
07924:  MOVFF  727,744
07928:  MOVLW  08
0792A:  MOVWF  x45
0792C:  MOVLB  0
0792E:  CALL   5D6E
.................... 			spi_xfer(write_starting_address & 0xFF); 
07932:  MOVLB  7
07934:  MOVFF  726,72E
07938:  CLRF   x2F
0793A:  CLRF   x30
0793C:  CLRF   x31
0793E:  MOVFF  726,744
07942:  MOVLW  08
07944:  MOVWF  x45
07946:  MOVLB  0
07948:  CALL   5D6E
....................  
.................... 			spi_xfer(read_data); 
0794C:  MOVFF  72A,744
07950:  MOVLW  08
07952:  MOVLB  7
07954:  MOVWF  x45
07956:  MOVLB  0
07958:  CALL   5D6E
....................  
.................... 			output_high(FLASH_CS); 
0795C:  BCF    F95.2
0795E:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
07960:  CALL   5E4A
....................  
.................... 			read_starting_address++; 
07964:  MOVLW  01
07966:  MOVLB  7
07968:  ADDWF  x22,F
0796A:  BTFSC  FD8.0
0796C:  INCF   x23,F
0796E:  BTFSC  FD8.2
07970:  INCF   x24,F
07972:  BTFSC  FD8.2
07974:  INCF   x25,F
.................... 			write_starting_address++; 
07976:  MOVLW  01
07978:  ADDWF  x26,F
0797A:  BTFSC  FD8.0
0797C:  INCF   x27,F
0797E:  BTFSC  FD8.2
07980:  INCF   x28,F
07982:  BTFSC  FD8.2
07984:  INCF   x29,F
....................  
.................... 			//fprintf(RS232,"%x||",read_data); 
.................... 		} 
07986:  INCF   x2C,F
07988:  BTFSC  FD8.2
0798A:  INCF   x2D,F
0798C:  BRA    7832
.................... 	} 
0798E:  INCF   x2B,F
07990:  BRA    77A2
....................  
.................... 	fprintf(RS232,"DONE!\r\n"); 
07992:  MOVLW  58
07994:  MOVWF  FF6
07996:  MOVLW  09
07998:  MOVWF  FF7
0799A:  MOVLB  0
0799C:  CALL   60B6
.................... } 
079A0:  GOTO   8B3C (RETURN)
....................  
.................... void FLASH_COMPARE_PROGRAM(int a_index, int b_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\Comparing programs %u and %u ... ",a_index,b_index); 
....................  
.................... 	int32 compare_a_starting_address = 0; 
.................... 	int32 compare_b_starting_address = 0; 
.................... 	 
.................... 	int read_data_a = 0; 
.................... 	int read_data_b = 0; 
....................  
.................... 	int errors_found = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
....................  
....................  
.................... 		compare_a_starting_address = page_address(a_index,sector_counter,0); 
.................... 		compare_b_starting_address = page_address(b_index,sector_counter,0); 
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_a_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_a = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
....................  
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_b_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_b = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
.................... 			compare_a_starting_address++; 
.................... 			compare_b_starting_address++; 
....................  
.................... 			if(read_data_a != read_data_b) { 
.................... 				fprintf(RS232,"[ERROR] found in sector %u at address %lu. A = %x, B = %x\r\n",sector_counter,i,read_data_a,read_data_b); 
.................... 				errors_found++; 
.................... 			} else { 
.................... 				//fprintf(RS232,"%x == %x ",read_data_a,read_data_b); 
.................... 				 
.................... 			} 
.................... 		} 
....................  
.................... 		//fprintf(RS232,"Completed sector %u, %u errors found.\r\n",sector_counter,errors_in_sector); 
.................... 	} 
....................  
.................... 	fprintf(RS232,"%u errors found\r\n",errors_found); 
.................... } 
....................  
.................... int addr_index_to_page_index(int16 addr_index) { 
.................... 	return (int)(addr_index / PAGE_SIZE); 
*
074B0:  MOVLB  7
074B2:  RRCF   x21,W
074B4:  MOVWF  03
074B6:  RRCF   x20,W
074B8:  MOVWF  02
074BA:  RRCF   03,F
074BC:  RRCF   02,F
074BE:  RRCF   03,F
074C0:  RRCF   02,F
074C2:  RRCF   03,F
074C4:  RRCF   02,F
074C6:  RRCF   03,F
074C8:  RRCF   02,F
074CA:  RRCF   03,F
074CC:  RRCF   02,F
074CE:  MOVLW  03
074D0:  ANDWF  03,F
074D2:  MOVFF  02,01
.................... } 
074D6:  MOVLB  0
074D8:  RETURN 0
....................  
.................... int addr_index_to_buffer_index(int16 addr_index) { 
.................... 	return (int)(addr_index % PAGE_SIZE); 
074DA:  MOVLB  7
074DC:  MOVF   x20,W
074DE:  ANDLW  3F
074E0:  MOVWF  00
074E2:  CLRF   03
074E4:  MOVWF  01
.................... } 
074E6:  MOVLB  0
074E8:  GOTO   84DC (RETURN)
....................  
.................... void read_flash_page_into_buffer(int *ptr,int program_index, int page_index)  
.................... { 
*
0649C:  MOVLB  7
0649E:  CLRF   x31
064A0:  CLRF   x30
064A2:  CLRF   x2F
064A4:  CLRF   x2E
064A6:  CLRF   x32
.................... 	int32 starting_address = 0; 
.................... 	int data = 0; 
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
064A8:  CLRF   x42
064AA:  CLRF   x41
064AC:  CLRF   x40
064AE:  MOVFF  72C,73F
064B2:  CLRF   x46
064B4:  CLRF   x45
064B6:  CLRF   x44
064B8:  MOVFF  72D,743
064BC:  CLRF   x4A
064BE:  CLRF   x49
064C0:  CLRF   x48
064C2:  CLRF   x47
064C4:  MOVLB  0
064C6:  CALL   5C96
064CA:  MOVFF  03,731
064CE:  MOVFF  02,730
064D2:  MOVFF  01,72F
064D6:  MOVFF  00,72E
....................  
.................... 	output_low(FLASH_CS); 
064DA:  BCF    F95.2
064DC:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ); 
064DE:  MOVLW  03
064E0:  MOVLB  7
064E2:  MOVWF  x44
064E4:  MOVLW  08
064E6:  MOVWF  x45
064E8:  MOVLB  0
064EA:  RCALL  5D6E
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
064EC:  MOVLB  7
064EE:  CLRF   x35
064F0:  CLRF   x36
064F2:  MOVFF  730,737
064F6:  CLRF   x38
064F8:  MOVFF  730,735
064FC:  MOVFF  738,736
06500:  CLRF   x37
06502:  CLRF   x38
06504:  MOVFF  730,744
06508:  MOVLW  08
0650A:  MOVWF  x45
0650C:  MOVLB  0
0650E:  RCALL  5D6E
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
06510:  MOVLB  7
06512:  CLRF   x35
06514:  CLRF   x37
06516:  CLRF   x38
06518:  MOVFF  72F,735
0651C:  MOVFF  737,736
06520:  MOVFF  738,737
06524:  CLRF   x38
06526:  MOVFF  72F,744
0652A:  MOVLW  08
0652C:  MOVWF  x45
0652E:  MOVLB  0
06530:  RCALL  5D6E
.................... 	spi_xfer(starting_address & 0xFF); 
06532:  MOVLB  7
06534:  MOVFF  72E,735
06538:  CLRF   x36
0653A:  CLRF   x37
0653C:  CLRF   x38
0653E:  MOVFF  72E,744
06542:  MOVLW  08
06544:  MOVWF  x45
06546:  MOVLB  0
06548:  RCALL  5D6E
.................... 	 
.................... 	for (int16 i = 0; i < 256; i++) 
0654A:  MOVLB  7
0654C:  CLRF   x34
0654E:  CLRF   x33
06550:  MOVF   x34,W
06552:  SUBLW  00
06554:  BNC   6580
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
06556:  CLRF   x44
06558:  MOVLW  08
0655A:  MOVWF  x45
0655C:  MOVLB  0
0655E:  RCALL  5D6E
06560:  MOVF   01,W
06562:  MOVFF  01,732
.................... 		ptr[i] = data; 
06566:  MOVLB  7
06568:  MOVF   x2A,W
0656A:  ADDWF  x33,W
0656C:  MOVWF  FE9
0656E:  MOVF   x2B,W
06570:  ADDWFC x34,W
06572:  MOVWF  FEA
06574:  MOVFF  732,FEF
.................... 	} 
06578:  INCF   x33,F
0657A:  BTFSC  FD8.2
0657C:  INCF   x34,F
0657E:  BRA    6550
....................  
.................... 	output_high(FLASH_CS); 
06580:  BCF    F95.2
06582:  BSF    F8C.2
.................... } 
06584:  MOVLB  0
06586:  RETURN 0
....................  
....................  
.................... void write_buffer_to_flash_page(int *ptr,int program_index, int page_index)  
.................... { 
06588:  MOVLB  7
0658A:  CLRF   x2F
0658C:  CLRF   x2E
0658E:  CLRF   x2D
06590:  CLRF   x2C
06592:  CLRF   x31
06594:  CLRF   x30
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(program_index,page_index); 
06596:  CLRF   x35
06598:  CLRF   x34
0659A:  CLRF   x33
0659C:  MOVFF  72A,732
065A0:  CLRF   x39
065A2:  CLRF   x38
065A4:  CLRF   x37
065A6:  MOVFF  72B,736
065AA:  MOVLB  0
065AC:  RCALL  5E6E
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
065AE:  MOVLB  7
065B0:  CLRF   x42
065B2:  CLRF   x41
065B4:  CLRF   x40
065B6:  MOVFF  72A,73F
065BA:  CLRF   x46
065BC:  CLRF   x45
065BE:  CLRF   x44
065C0:  MOVFF  72B,743
065C4:  CLRF   x4A
065C6:  CLRF   x49
065C8:  CLRF   x48
065CA:  CLRF   x47
065CC:  MOVLB  0
065CE:  CALL   5C96
065D2:  MOVFF  03,72F
065D6:  MOVFF  02,72E
065DA:  MOVFF  01,72D
065DE:  MOVFF  00,72C
....................  
.................... 	flash_write_enable(); 
065E2:  RCALL  5E54
.................... 	flash_wait_while_busy(); 
065E4:  RCALL  5E4A
.................... 	 
.................... 	output_low(FLASH_CS); 
065E6:  BCF    F95.2
065E8:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
065EA:  MOVLW  02
065EC:  MOVLB  7
065EE:  MOVWF  x44
065F0:  MOVLW  08
065F2:  MOVWF  x45
065F4:  MOVLB  0
065F6:  CALL   5D6E
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
065FA:  MOVLB  7
065FC:  CLRF   x32
065FE:  CLRF   x33
06600:  MOVFF  72E,734
06604:  CLRF   x35
06606:  MOVFF  72E,732
0660A:  MOVFF  735,733
0660E:  CLRF   x34
06610:  CLRF   x35
06612:  MOVFF  72E,744
06616:  MOVLW  08
06618:  MOVWF  x45
0661A:  MOVLB  0
0661C:  CALL   5D6E
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
06620:  MOVLB  7
06622:  CLRF   x32
06624:  CLRF   x34
06626:  CLRF   x35
06628:  MOVFF  72D,732
0662C:  MOVFF  734,733
06630:  MOVFF  735,734
06634:  CLRF   x35
06636:  MOVFF  72D,744
0663A:  MOVLW  08
0663C:  MOVWF  x45
0663E:  MOVLB  0
06640:  CALL   5D6E
.................... 	spi_xfer(starting_address & 0xFF); 
06644:  MOVLB  7
06646:  MOVFF  72C,732
0664A:  CLRF   x33
0664C:  CLRF   x34
0664E:  CLRF   x35
06650:  MOVFF  72C,744
06654:  MOVLW  08
06656:  MOVWF  x45
06658:  MOVLB  0
0665A:  CALL   5D6E
.................... 		 
.................... 	for (value_counter = 0; value_counter < 256; value_counter++) 
0665E:  MOVLB  7
06660:  CLRF   x31
06662:  CLRF   x30
06664:  MOVF   x31,W
06666:  SUBLW  00
06668:  BNC   6692
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
0666A:  MOVF   x28,W
0666C:  ADDWF  x30,W
0666E:  MOVWF  FE9
06670:  MOVF   x29,W
06672:  ADDWFC x31,W
06674:  MOVWF  FEA
06676:  MOVFF  FEF,732
0667A:  MOVFF  732,744
0667E:  MOVLW  08
06680:  MOVWF  x45
06682:  MOVLB  0
06684:  CALL   5D6E
.................... 	} 
06688:  MOVLB  7
0668A:  INCF   x30,F
0668C:  BTFSC  FD8.2
0668E:  INCF   x31,F
06690:  BRA    6664
....................  
.................... 	output_high(FLASH_CS); 
06692:  BCF    F95.2
06694:  BSF    F8C.2
....................  
.................... 	flash_wait_while_busy(); 
06696:  MOVLB  0
06698:  CALL   5E4A
.................... } 
0669C:  RETURN 0
....................  
.................... void write_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
*
079AE:  MOVLB  7
079B0:  CLRF   x24
079B2:  CLRF   x23
079B4:  MOVF   x24,W
079B6:  SUBLW  00
079B8:  BNC   79FA
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
079BA:  DECFSZ x22,W
079BC:  BRA    79DA
.................... 			fputc(ptr[value_counter],USB); 
079BE:  MOVF   x20,W
079C0:  ADDWF  x23,W
079C2:  MOVWF  FE9
079C4:  MOVF   x21,W
079C6:  ADDWFC x24,W
079C8:  MOVWF  FEA
079CA:  MOVFF  FEF,725
079CE:  MOVFF  725,729
079D2:  MOVLB  0
079D4:  RCALL  73FC
.................... 		} else { 
079D6:  BRA    79F0
079D8:  MOVLB  7
.................... 			fputc(ptr[value_counter],RS232); 
079DA:  MOVF   x20,W
079DC:  ADDWF  x23,W
079DE:  MOVWF  FE9
079E0:  MOVF   x21,W
079E2:  ADDWFC x24,W
079E4:  MOVWF  FEA
079E6:  MOVFF  FEF,725
079EA:  MOVF   x25,W
079EC:  MOVLB  0
079EE:  BRA    79A4
.................... 		} 
.................... 	}	 
079F0:  MOVLB  7
079F2:  INCF   x23,F
079F4:  BTFSC  FD8.2
079F6:  INCF   x24,F
079F8:  BRA    79B4
.................... } 
079FA:  MOVLB  0
079FC:  GOTO   8BFC (RETURN)
....................  
.................... void print_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
.................... 			fprintf(USB,"%x",ptr[value_counter]); 
.................... 		} else { 
.................... 			fprintf(RS232,"%x",ptr[value_counter]); 
....................  
.................... 			if((value_counter % 4) == 3) { 
.................... 				fprintf(RS232," ");	 
.................... 			} 
....................  
.................... 			if((value_counter % 32) == 31) { 
.................... 				fprintf(RS232,"\r\n");	 
.................... 			} 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void print_flash_page_buffer(int *ptr) 
.................... { 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
....................  
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... } 
....................  
....................  
....................  
.................... #include <errorlist.h> 
....................  #define ERR_START 						0x15 
....................  
....................  #define ERR_INVALID_START 				0x02 
....................  
....................  #define ERR_UNKNOWN 					0x09 
....................  
....................  #define ERR_COMMAND_TIMEOUT 			0x10 
....................  #define ERR_COMMAND_INVALID			0x13 
....................  
....................  #define ERR_END_TIMEOUT 				0x11 
....................  #define ERR_END_INVALID 				0x12 
....................  
....................   
....................  #define ERR_ADDR_TIMEOUT 				0x14 
....................  #define ERR_ADDR_INVALID 				0x16 
....................  
....................  #define ERR_DATA_TIMEOUT 				0x17 
....................  #define ERR_DATA_INVALID 				0x17 
....................  
....................  #define ERR_PHANTOM_BOOL_TIMEOUT		0x18 
....................  #define ERR_PHANTOM_BOOL_INVALID 		0x19 
....................  
....................  #define ERR_PHANTOM_CH_TIMEOUT 		0x20 
....................  #define ERR_PHANTOM_CH_INVALID 		0x21 
....................  
....................  #define ERR_VOL_CH_TIMEOUT				0x22 
....................  #define ERR_VOL_CH_INVALID				0x23 
....................  
....................  #define ERR_VOL_TIMEOUT				0x24 
....................  #define ERR_VOL_INVALID				0x25 
....................  
....................  #define ERR_RS232_CH_TIMEOUT			0x26 
....................  #define ERR_RS232_CH_INVALID			0x27 
....................  
....................  #define ERR_RS232_DATA_TIMEOUT			0x28 
....................  #define ERR_RS232_DATA_INVALID			0x29 
....................  
....................  #define ERR_DEVICE_CONFIG_INVALID		0x30 
....................  
....................  
....................  
....................  
.................... #include <dsp_comm.c> 
.................... BYTE dsp_read_buffer[8]; 
....................  
.................... void i2c_write_4byte(int32 fourBytes) { 
*
013E2:  MOVLB  7
013E4:  MOVFF  77B,77F
....................  
....................       int byte4 = fourBytes & 0xFF; 
....................       fourBytes = fourBytes >> 8; 
013E8:  MOVFF  77C,77B
013EC:  MOVFF  77D,77C
013F0:  MOVFF  77E,77D
013F4:  CLRF   x7E
....................     
....................       int byte3 = fourBytes & 0xFF; 
013F6:  MOVFF  77B,780
....................       fourBytes = fourBytes >> 8; 
013FA:  MOVFF  77C,77B
013FE:  MOVFF  77D,77C
01402:  MOVFF  77E,77D
01406:  CLRF   x7E
....................     
....................       int byte2 = fourBytes & 0xFF; 
....................     
....................       int byte1 = fourBytes >> 8; 
01408:  MOVFF  77B,781
0140C:  MOVFF  77C,782
....................     
....................       i2c_write(byte1); 
01410:  MOVFF  782,783
01414:  MOVLB  0
01416:  RCALL  136C
....................       i2c_write(byte2);  
01418:  MOVFF  781,783
0141C:  RCALL  136C
....................       i2c_write(byte3); 
0141E:  MOVFF  780,783
01422:  RCALL  136C
....................       i2c_write(byte4); 
01424:  MOVFF  77F,783
01428:  RCALL  136C
....................     
.................... } 
0142A:  RETURN 0
....................  
.................... void reset_dsp() { 
....................  
.................... 	output_high(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_low(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_high(PIN_DSP_nRESET); 
.................... } 
....................  
....................  
.................... void send_dsp_command(int32 address, int32 command) { 
....................  
....................    i2c_start(); 
0142C:  BSF    F94.3
0142E:  MOVLW  03
01430:  MOVWF  00
01432:  DECFSZ 00,F
01434:  BRA    1432
01436:  BSF    F94.2
01438:  MOVLW  03
0143A:  MOVWF  00
0143C:  DECFSZ 00,F
0143E:  BRA    143C
01440:  BCF    F8B.3
01442:  BCF    F94.3
01444:  MOVLW  03
01446:  MOVWF  00
01448:  DECFSZ 00,F
0144A:  BRA    1448
0144C:  BCF    F8B.2
0144E:  BCF    F94.2
....................    i2c_write(DSP_I2C_ADDRESS); 
01450:  MOVLW  80
01452:  MOVLB  7
01454:  MOVWF  x83
01456:  MOVLB  0
01458:  RCALL  136C
....................    i2c_write_4byte(address); 
0145A:  MOVFF  776,77E
0145E:  MOVFF  775,77D
01462:  MOVFF  774,77C
01466:  MOVFF  773,77B
0146A:  RCALL  13E2
....................    i2c_write_4byte(command); 
0146C:  MOVFF  77A,77E
01470:  MOVFF  779,77D
01474:  MOVFF  778,77C
01478:  MOVFF  777,77B
0147C:  RCALL  13E2
....................    i2c_stop(); 
0147E:  BCF    F94.3
01480:  NOP   
01482:  BSF    F94.2
01484:  BTFSS  F82.2
01486:  BRA    1484
01488:  MOVLW  03
0148A:  MOVWF  00
0148C:  DECFSZ 00,F
0148E:  BRA    148C
01490:  BRA    1492
01492:  NOP   
01494:  BSF    F94.3
01496:  MOVLW  03
01498:  MOVWF  00
0149A:  DECFSZ 00,F
0149C:  BRA    149A
....................  
.................... } 
0149E:  RETURN 0
....................  
....................  
.................... void send_dsp_message(int32 message) { 
....................  
....................    i2c_start(); 
....................    i2c_write(DSP_I2C_ADDRESS); 
....................    i2c_write_4byte(message); 
....................    i2c_stop(); 
.................... } 
....................  
.................... void send_prefixed_dsp_command(int16 address_prefix, int16 address_suffix, int32 command) { 
....................  
....................    i2c_start(); 
*
068E8:  BSF    F94.3
068EA:  MOVLW  03
068EC:  MOVWF  00
068EE:  DECFSZ 00,F
068F0:  BRA    68EE
068F2:  BSF    F94.2
068F4:  MOVLW  03
068F6:  MOVWF  00
068F8:  DECFSZ 00,F
068FA:  BRA    68F8
068FC:  BCF    F8B.3
068FE:  BCF    F94.3
06900:  MOVLW  03
06902:  MOVWF  00
06904:  DECFSZ 00,F
06906:  BRA    6904
06908:  BCF    F8B.2
0690A:  BCF    F94.2
0690C:  CLRF   19
0690E:  BTFSC  FF2.7
06910:  BSF    19.7
06912:  BCF    FF2.7
....................    i2c_write(DSP_I2C_ADDRESS); 
06914:  MOVLW  80
06916:  MOVLB  7
06918:  MOVWF  x83
0691A:  MOVLB  0
0691C:  CALL   136C
06920:  BTFSC  19.7
06922:  BSF    FF2.7
....................  
....................    int32 address = address_prefix; 
06924:  MOVLB  7
06926:  CLRF   x3B
06928:  CLRF   x3A
0692A:  MOVFF  731,739
0692E:  MOVFF  730,738
....................    address <<= 16; 
06932:  MOVFF  739,73B
06936:  MOVFF  738,73A
0693A:  CLRF   x38
0693C:  CLRF   x39
....................    address |= address_suffix; 
0693E:  MOVF   x32,W
06940:  IORWF  x38,F
06942:  MOVF   x33,W
06944:  IORWF  x39,F
06946:  CLRF   19
06948:  BTFSC  FF2.7
0694A:  BSF    19.7
0694C:  BCF    FF2.7
....................    i2c_write_4byte(address); 
0694E:  MOVFF  73B,77E
06952:  MOVFF  73A,77D
06956:  MOVFF  739,77C
0695A:  MOVFF  738,77B
0695E:  MOVLB  0
06960:  CALL   13E2
06964:  BTFSC  19.7
06966:  BSF    FF2.7
06968:  CLRF   19
0696A:  BTFSC  FF2.7
0696C:  BSF    19.7
0696E:  BCF    FF2.7
....................    i2c_write_4byte(command); 
06970:  MOVFF  737,77E
06974:  MOVFF  736,77D
06978:  MOVFF  735,77C
0697C:  MOVFF  734,77B
06980:  CALL   13E2
06984:  BTFSC  19.7
06986:  BSF    FF2.7
....................    i2c_stop(); 
06988:  BCF    F94.3
0698A:  NOP   
0698C:  BSF    F94.2
0698E:  BTFSS  F82.2
06990:  BRA    698E
06992:  MOVLW  03
06994:  MOVWF  00
06996:  DECFSZ 00,F
06998:  BRA    6996
0699A:  BRA    699C
0699C:  NOP   
0699E:  BSF    F94.3
069A0:  MOVLW  03
069A2:  MOVWF  00
069A4:  DECFSZ 00,F
069A6:  BRA    69A4
....................  
.................... } 
069A8:  RETURN 0
....................  
.................... int read_dsp_int_prefixed(int16 address_prefix,int16 address_suffix) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	int32 address = address_prefix; 
....................    	address <<= 16; 
....................    	address |= address_suffix; 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
....................  
.................... 	return dsp_read_buffer[7]; 
.................... } 
....................  
....................  
.................... void read_dsp_and_send_to_usb(int32 address) 
.................... { 
.................... 	i2c_start(); 
*
07556:  BSF    F94.3
07558:  MOVLW  03
0755A:  MOVWF  00
0755C:  DECFSZ 00,F
0755E:  BRA    755C
07560:  BSF    F94.2
07562:  MOVLW  03
07564:  MOVWF  00
07566:  DECFSZ 00,F
07568:  BRA    7566
0756A:  BCF    F8B.3
0756C:  BCF    F94.3
0756E:  MOVLW  03
07570:  MOVWF  00
07572:  DECFSZ 00,F
07574:  BRA    7572
07576:  BCF    F8B.2
07578:  BCF    F94.2
0757A:  CLRF   19
0757C:  BTFSC  FF2.7
0757E:  BSF    19.7
07580:  BCF    FF2.7
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
07582:  MOVLW  80
07584:  MOVLB  7
07586:  MOVWF  x83
07588:  MOVLB  0
0758A:  CALL   136C
0758E:  BTFSC  19.7
07590:  BSF    FF2.7
07592:  CLRF   19
07594:  BTFSC  FF2.7
07596:  BSF    19.7
07598:  BCF    FF2.7
.................... 	i2c_write_4byte(address); 
0759A:  MOVFF  723,77E
0759E:  MOVFF  722,77D
075A2:  MOVFF  721,77C
075A6:  MOVFF  720,77B
075AA:  CALL   13E2
075AE:  BTFSC  19.7
075B0:  BSF    FF2.7
.................... 	i2c_stop(); 
075B2:  BCF    F94.3
075B4:  NOP   
075B6:  BSF    F94.2
075B8:  BTFSS  F82.2
075BA:  BRA    75B8
075BC:  MOVLW  03
075BE:  MOVWF  00
075C0:  DECFSZ 00,F
075C2:  BRA    75C0
075C4:  BRA    75C6
075C6:  NOP   
075C8:  BSF    F94.3
075CA:  MOVLW  03
075CC:  MOVWF  00
075CE:  DECFSZ 00,F
075D0:  BRA    75CE
....................  
.................... 	delay_ms(1); 
075D2:  MOVLW  01
075D4:  MOVLB  7
075D6:  MOVWF  x2B
075D8:  MOVLB  0
075DA:  CALL   608E
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
075DE:  BSF    F93.2
075E0:  BTFSC  F81.2
075E2:  BRA    76E4
....................  
.................... 		i2c_start(); 
075E4:  BSF    F94.3
075E6:  MOVLW  03
075E8:  MOVWF  00
075EA:  DECFSZ 00,F
075EC:  BRA    75EA
075EE:  BSF    F94.2
075F0:  MOVLW  03
075F2:  MOVWF  00
075F4:  DECFSZ 00,F
075F6:  BRA    75F4
075F8:  BCF    F8B.3
075FA:  BCF    F94.3
075FC:  MOVLW  03
075FE:  MOVWF  00
07600:  DECFSZ 00,F
07602:  BRA    7600
07604:  BCF    F8B.2
07606:  BCF    F94.2
07608:  CLRF   19
0760A:  BTFSC  FF2.7
0760C:  BSF    19.7
0760E:  BCF    FF2.7
....................  
.................... 		if(i2c_write(0x81) == 0) { 
07610:  MOVLW  81
07612:  MOVLB  7
07614:  MOVWF  x83
07616:  MOVLB  0
07618:  CALL   136C
0761C:  BTFSC  19.7
0761E:  BSF    FF2.7
07620:  MOVF   01,F
07622:  BNZ   76C2
....................  
.................... 			for(int i = 0; i < 8; i++) { 
07624:  MOVLB  7
07626:  CLRF   x24
07628:  MOVF   x24,W
0762A:  SUBLW  07
0762C:  BNC   767A
.................... 				if(i == 7) { 
0762E:  MOVF   x24,W
07630:  SUBLW  07
07632:  BNZ   7650
.................... 					dsp_read_buffer[i] = i2c_read(0); 
07634:  CLRF   03
07636:  MOVF   x24,W
07638:  ADDLW  84
0763A:  MOVWF  FE9
0763C:  MOVLW  05
0763E:  ADDWFC 03,W
07640:  MOVWF  FEA
07642:  CLRF   00
07644:  MOVLB  0
07646:  RCALL  74EC
07648:  MOVFF  01,FEF
.................... 				} else { 
0764C:  BRA    766A
0764E:  MOVLB  7
.................... 					dsp_read_buffer[i] = i2c_read(); 
07650:  CLRF   03
07652:  MOVF   x24,W
07654:  ADDLW  84
07656:  MOVWF  FE9
07658:  MOVLW  05
0765A:  ADDWFC 03,W
0765C:  MOVWF  FEA
0765E:  MOVLW  01
07660:  MOVWF  00
07662:  MOVLB  0
07664:  RCALL  74EC
07666:  MOVFF  01,FEF
.................... 				} 
....................  
.................... 				delay_us(100); 
0766A:  MOVLW  7A
0766C:  MOVWF  00
0766E:  DECFSZ 00,F
07670:  BRA    766E
07672:  NOP   
.................... 			} 
07674:  MOVLB  7
07676:  INCF   x24,F
07678:  BRA    7628
.................... 	 
.................... 			fputc(0x06,USB); 
0767A:  MOVLW  06
0767C:  MOVWF  x29
0767E:  MOVLB  0
07680:  RCALL  73FC
.................... 			//delay_ms(1); 
.................... 			for(int x = 4; x < 8; x++) { 
07682:  MOVLW  04
07684:  MOVLB  7
07686:  MOVWF  x25
07688:  MOVF   x25,W
0768A:  SUBLW  07
0768C:  BNC   76AE
.................... 				fputc(dsp_read_buffer[x],USB); 
0768E:  CLRF   03
07690:  MOVF   x25,W
07692:  ADDLW  84
07694:  MOVWF  FE9
07696:  MOVLW  05
07698:  ADDWFC 03,W
0769A:  MOVWF  FEA
0769C:  MOVFF  FEF,726
076A0:  MOVFF  726,729
076A4:  MOVLB  0
076A6:  RCALL  73FC
.................... 				//delay_ms(1); 
.................... 			} 
076A8:  MOVLB  7
076AA:  INCF   x25,F
076AC:  BRA    7688
.................... 			//delay_ms(1); 
.................... 			fputc(0x03,USB); 
076AE:  MOVLW  03
076B0:  MOVWF  x29
076B2:  MOVLB  0
076B4:  RCALL  73FC
.................... 			delay_ms(1); 
076B6:  MOVLW  01
076B8:  MOVLB  7
076BA:  MOVWF  x2B
076BC:  MOVLB  0
076BE:  CALL   608E
.................... 		} 
....................  
.................... 		i2c_stop(); 
076C2:  BCF    F94.3
076C4:  NOP   
076C6:  BSF    F94.2
076C8:  BTFSS  F82.2
076CA:  BRA    76C8
076CC:  MOVLW  03
076CE:  MOVWF  00
076D0:  DECFSZ 00,F
076D2:  BRA    76D0
076D4:  BRA    76D6
076D6:  NOP   
076D8:  BSF    F94.3
076DA:  MOVLW  03
076DC:  MOVWF  00
076DE:  DECFSZ 00,F
076E0:  BRA    76DE
.................... 	} else { 
076E2:  BRA    76E4
.................... 		//fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
076E4:  GOTO   8998 (RETURN)
....................  
.................... void read_dsp_and_send_to_rs232(int32 address) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 	 
.................... 			fprintf(RS232,"Read:"); 
.................... 			for(int x = 4; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
.................... void read_unsolicited_DSP_message() 
.................... { 
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_us(100); 
.................... 			} 
.................... 			for(int x = 0; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
....................  
.................... } 
....................  
.................... void load_dsp_values() { 
....................  
.................... /* 
.................... 	for(int16 i = 0; i <= num_dsp_values; i++) { 
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(i),READ_CONFIG_VALUE(i)); 
.................... 		//delay_ms(2);	 
.................... 	} 
.................... */ 
.................... } 
....................  
.................... void dsp_mute_outputs() 
.................... { 
*
069AA:  CLRF   19
069AC:  BTFSC  FF2.7
069AE:  BSF    19.7
069B0:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x00000000); 
069B2:  MOVLW  83
069B4:  MOVLB  7
069B6:  MOVWF  x76
069B8:  CLRF   x75
069BA:  CLRF   x74
069BC:  CLRF   x73
069BE:  CLRF   x7A
069C0:  CLRF   x79
069C2:  CLRF   x78
069C4:  CLRF   x77
069C6:  MOVLB  0
069C8:  CALL   142C
069CC:  BTFSC  19.7
069CE:  BSF    FF2.7
.................... } 
069D0:  GOTO   6FF6 (RETURN)
....................  
.................... void dsp_unmute_outputs() 
.................... { 
*
06D32:  CLRF   19
06D34:  BTFSC  FF2.7
06D36:  BSF    19.7
06D38:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x08000000); 
06D3A:  MOVLW  83
06D3C:  MOVLB  7
06D3E:  MOVWF  x76
06D40:  CLRF   x75
06D42:  CLRF   x74
06D44:  CLRF   x73
06D46:  MOVLW  08
06D48:  MOVWF  x7A
06D4A:  CLRF   x79
06D4C:  CLRF   x78
06D4E:  CLRF   x77
06D50:  MOVLB  0
06D52:  CALL   142C
06D56:  BTFSC  19.7
06D58:  BSF    FF2.7
.................... } 
06D5A:  RETURN 0
....................  
.................... void send_flash_program_to_dsp_buffered(int prog_index) 
.................... { 
*
06BB8:  MOVLB  7
06BBA:  CLRF   x27
06BBC:  CLRF   x26
.................... 	int16 overall_counter = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
06BBE:  CLRF   x28
06BC0:  MOVF   x28,W
06BC2:  SUBLW  07
06BC4:  BTFSS  FD8.0
06BC6:  BRA    6D2C
....................  
.................... 		read_flash_page_into_buffer(&PAGE_BUFFER_A,prog_index,sector_counter); 
06BC8:  CLRF   x2B
06BCA:  MOVLW  7A
06BCC:  MOVWF  x2A
06BCE:  MOVFF  725,72C
06BD2:  MOVFF  728,72D
06BD6:  MOVLB  0
06BD8:  RCALL  649C
....................  
.................... 		for(int i = 0; i < 64; i++) { 
06BDA:  MOVLB  7
06BDC:  CLRF   x29
06BDE:  MOVF   x29,W
06BE0:  SUBLW  3F
06BE2:  BTFSS  FD8.0
06BE4:  BRA    6D28
.................... 			if(PAGE_BUFFER_A[i] == 0xFFFFFFFF) { 
06BE6:  MOVF   x29,W
06BE8:  MULLW  04
06BEA:  MOVF   FF3,W
06BEC:  CLRF   03
06BEE:  ADDLW  7A
06BF0:  MOVWF  FE9
06BF2:  MOVLW  00
06BF4:  ADDWFC 03,W
06BF6:  MOVWF  FEA
06BF8:  MOVFF  FEF,72A
06BFC:  MOVFF  FEC,72B
06C00:  MOVFF  FEC,72C
06C04:  MOVFF  FEC,72D
06C08:  INCFSZ x2A,W
06C0A:  BRA    6C1A
06C0C:  INCFSZ x2B,W
06C0E:  BRA    6C1A
06C10:  INCFSZ x2C,W
06C12:  BRA    6C1A
06C14:  INCFSZ x2D,W
06C16:  BRA    6C1A
.................... 				break; 
06C18:  BRA    6D28
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT0) { 
06C1A:  MOVFF  727,72B
06C1E:  MOVFF  726,72A
06C22:  MOVLB  0
06C24:  RCALL  69D4
06C26:  MOVFF  02,72B
06C2A:  MOVFF  01,72A
06C2E:  MOVLB  7
06C30:  MOVF   01,W
06C32:  SUBLW  7E
06C34:  BNZ   6C44
06C36:  MOVF   x2B,W
06C38:  SUBLW  02
06C3A:  BNZ   6C44
.................... 				overall_counter++; 
06C3C:  INCF   x26,F
06C3E:  BTFSC  FD8.2
06C40:  INCF   x27,F
.................... 				continue;	 
06C42:  BRA    6D24
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT1) { 
06C44:  MOVFF  727,72B
06C48:  MOVFF  726,72A
06C4C:  MOVLB  0
06C4E:  RCALL  69D4
06C50:  MOVFF  02,72B
06C54:  MOVFF  01,72A
06C58:  MOVLB  7
06C5A:  MOVF   01,W
06C5C:  SUBLW  7F
06C5E:  BNZ   6C6E
06C60:  MOVF   x2B,W
06C62:  SUBLW  02
06C64:  BNZ   6C6E
.................... 				overall_counter++; 
06C66:  INCF   x26,F
06C68:  BTFSC  FD8.2
06C6A:  INCF   x27,F
.................... 				continue;	 
06C6C:  BRA    6D24
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT2) { 
06C6E:  MOVFF  727,72B
06C72:  MOVFF  726,72A
06C76:  MOVLB  0
06C78:  RCALL  69D4
06C7A:  MOVFF  02,72B
06C7E:  MOVFF  01,72A
06C82:  MOVLB  7
06C84:  MOVF   01,W
06C86:  SUBLW  80
06C88:  BNZ   6C98
06C8A:  MOVF   x2B,W
06C8C:  SUBLW  02
06C8E:  BNZ   6C98
.................... 				overall_counter++; 
06C90:  INCF   x26,F
06C92:  BTFSC  FD8.2
06C94:  INCF   x27,F
.................... 				continue;	 
06C96:  BRA    6D24
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT3) { 
06C98:  MOVFF  727,72B
06C9C:  MOVFF  726,72A
06CA0:  MOVLB  0
06CA2:  RCALL  69D4
06CA4:  MOVFF  02,72B
06CA8:  MOVFF  01,72A
06CAC:  MOVLB  7
06CAE:  MOVF   01,W
06CB0:  SUBLW  81
06CB2:  BNZ   6CC2
06CB4:  MOVF   x2B,W
06CB6:  SUBLW  02
06CB8:  BNZ   6CC2
.................... 				overall_counter++; 
06CBA:  INCF   x26,F
06CBC:  BTFSC  FD8.2
06CBE:  INCF   x27,F
.................... 				continue;	 
06CC0:  BRA    6D24
.................... 			} 
....................  
....................  
.................... 			send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(overall_counter),PAGE_BUFFER_A[i]); 
06CC2:  MOVFF  727,72B
06CC6:  MOVFF  726,72A
06CCA:  MOVLB  0
06CCC:  RCALL  69D4
06CCE:  MOVFF  02,72B
06CD2:  MOVFF  01,72A
06CD6:  MOVLB  7
06CD8:  MOVF   x29,W
06CDA:  MULLW  04
06CDC:  MOVF   FF3,W
06CDE:  CLRF   03
06CE0:  ADDLW  7A
06CE2:  MOVWF  FE9
06CE4:  MOVLW  00
06CE6:  ADDWFC 03,W
06CE8:  MOVWF  FEA
06CEA:  MOVFF  FEF,72C
06CEE:  MOVFF  FEC,72D
06CF2:  MOVFF  FEC,72E
06CF6:  MOVFF  FEC,72F
06CFA:  MOVLW  F0
06CFC:  MOVWF  x31
06CFE:  CLRF   x30
06D00:  MOVFF  02,733
06D04:  MOVFF  01,732
06D08:  MOVFF  72F,737
06D0C:  MOVFF  72E,736
06D10:  MOVFF  72D,735
06D14:  MOVFF  72C,734
06D18:  MOVLB  0
06D1A:  RCALL  68E8
.................... 			overall_counter++; 
06D1C:  MOVLB  7
06D1E:  INCF   x26,F
06D20:  BTFSC  FD8.2
06D22:  INCF   x27,F
.................... 		} 
06D24:  INCF   x29,F
06D26:  BRA    6BDE
....................  
.................... 		 
.................... 	} 
06D28:  INCF   x28,F
06D2A:  BRA    6BC0
.................... } 
06D2C:  MOVLB  0
06D2E:  GOTO   6FFC (RETURN)
....................  
....................  
.................... #include <debug.c> 
.................... // file debug.c 
....................  
.................... #include <eeprom.c> 
.................... #byte INTCON=0xFF2 //Change for a 16 chip  
.................... #bit INT_GIE=INTCON.7  
....................  
....................  
.................... void write_int16_eeprom(int16 address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
063BC:  MOVLB  7
063BE:  CLRF   x32
063C0:  MOVF   x32,W
063C2:  SUBLW  01
063C4:  BNC   6426
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
063C6:  MOVF   x32,W
063C8:  ADDWF  x2E,W
063CA:  MOVWF  x33
063CC:  MOVLW  00
063CE:  ADDWFC x2F,W
063D0:  MOVWF  x34
063D2:  MOVLW  07
063D4:  MOVWF  x36
063D6:  MOVLW  30
063D8:  MOVWF  x35
063DA:  MOVF   x32,W
063DC:  ADDWF  x35,W
063DE:  MOVWF  01
063E0:  MOVLW  00
063E2:  ADDWFC x36,W
063E4:  MOVWF  03
063E6:  MOVF   01,W
063E8:  MOVWF  FE9
063EA:  MOVFF  03,FEA
063EE:  MOVFF  FEF,735
063F2:  MOVFF  734,FAA
063F6:  MOVFF  733,FA9
063FA:  MOVFF  735,FA8
063FE:  BCF    FA6.6
06400:  BCF    FA6.7
06402:  BSF    FA6.2
06404:  MOVF   FF2,W
06406:  MOVWF  00
06408:  BCF    FF2.7
0640A:  MOVLB  F
0640C:  MOVLW  55
0640E:  MOVWF  FA7
06410:  MOVLW  AA
06412:  MOVWF  FA7
06414:  BSF    FA6.1
06416:  BTFSC  FA6.1
06418:  BRA    6416
0641A:  BCF    FA6.2
0641C:  MOVF   00,W
0641E:  IORWF  FF2,F
....................    } 
06420:  MOVLB  7
06422:  INCF   x32,F
06424:  BRA    63C0
.................... } 
06426:  MOVLB  0
06428:  GOTO   647C (RETURN)
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(int16 address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
062EE:  MOVLB  6
062F0:  CLRF   xE9
062F2:  MOVF   xE9,W
062F4:  SUBLW  01
062F6:  BNC   6340
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
062F8:  MOVLW  06
062FA:  MOVWF  xED
062FC:  MOVLW  EA
062FE:  MOVWF  xEC
06300:  MOVF   xE9,W
06302:  ADDWF  xEC,W
06304:  MOVWF  01
06306:  MOVLW  00
06308:  ADDWFC xED,W
0630A:  MOVWF  03
0630C:  MOVF   01,W
0630E:  MOVWF  FE9
06310:  MOVFF  03,FEA
06314:  MOVF   xE9,W
06316:  ADDWF  xE7,W
06318:  MOVWF  xEE
0631A:  MOVLW  00
0631C:  ADDWFC xE8,W
0631E:  MOVWF  xEF
06320:  MOVFF  FF2,6F0
06324:  BCF    FF2.7
06326:  MOVFF  6EF,FAA
0632A:  MOVFF  6EE,FA9
0632E:  BCF    FA6.6
06330:  BCF    FA6.7
06332:  BSF    FA6.0
06334:  MOVF   FA8,W
06336:  BTFSC  xF0.7
06338:  BSF    FF2.7
0633A:  MOVWF  FEF
....................    } 
0633C:  INCF   xE9,F
0633E:  BRA    62F2
....................  
....................    return(data); 
06340:  MOVFF  6EA,01
06344:  MOVFF  6EB,02
.................... } 
06348:  MOVLB  0
0634A:  GOTO   6398 (RETURN)
....................  
....................  
.................... void INTEEPROM_GET(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
0634E:  MOVLB  6
06350:  BCF    xE2.0
06352:  BTFSC  FF2.7
06354:  BSF    xE2.0
....................    for (count=0;count<num;count++)  
06356:  CLRF   xE1
06358:  CLRF   xE0
0635A:  MOVF   xE1,W
0635C:  SUBWF  xDD,W
0635E:  BNC   63B6
06360:  BNZ   6368
06362:  MOVF   xDC,W
06364:  SUBWF  xE0,W
06366:  BC    63B6
....................    {  
....................       disable_interrupts(global);  
06368:  BCF    FF2.6
0636A:  BCF    FF2.7
0636C:  BTFSC  FF2.7
0636E:  BRA    636A
....................       ptr[count]=read_int16_eeprom(addr+count);  
06370:  MOVF   xDA,W
06372:  ADDWF  xE0,W
06374:  MOVWF  01
06376:  MOVF   xDB,W
06378:  ADDWFC xE1,W
0637A:  MOVWF  03
0637C:  MOVFF  01,6E3
06380:  MOVWF  xE4
06382:  MOVF   xE0,W
06384:  ADDWF  xDE,W
06386:  MOVWF  xE5
06388:  MOVF   xE1,W
0638A:  ADDWFC xDF,W
0638C:  MOVWF  xE6
0638E:  MOVWF  xE8
06390:  MOVFF  6E5,6E7
06394:  MOVLB  0
06396:  BRA    62EE
06398:  MOVFF  6E4,FEA
0639C:  MOVFF  6E3,FE9
063A0:  MOVFF  01,FEF
....................       if (int_enabled) enable_interrupts(global);  
063A4:  MOVLB  6
063A6:  BTFSS  xE2.0
063A8:  BRA    63AE
063AA:  MOVLW  C0
063AC:  IORWF  FF2,F
....................    }  
063AE:  INCF   xE0,F
063B0:  BTFSC  FD8.2
063B2:  INCF   xE1,F
063B4:  BRA    635A
.................... }  
063B6:  MOVLB  0
063B8:  GOTO   6892 (RETURN)
....................  
.................... void INTEEPROM_PUT(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
*
0642C:  MOVLB  7
0642E:  BCF    x2A.0
06430:  BTFSC  FF2.7
06432:  BSF    x2A.0
....................    for (count=0;count<num;count++)  
06434:  CLRF   x29
06436:  CLRF   x28
06438:  MOVF   x29,W
0643A:  SUBWF  x25,W
0643C:  BNC   6498
0643E:  BNZ   6446
06440:  MOVF   x24,W
06442:  SUBWF  x28,W
06444:  BC    6498
....................    {  
....................       disable_interrupts(global);  
06446:  BCF    FF2.6
06448:  BCF    FF2.7
0644A:  BTFSC  FF2.7
0644C:  BRA    6448
....................       //WRITE_EEPROM  
.................... 		write_int16_eeprom(addr+count,ptr[count]); 
0644E:  MOVF   x28,W
06450:  ADDWF  x26,W
06452:  MOVWF  x2B
06454:  MOVF   x29,W
06456:  ADDWFC x27,W
06458:  MOVWF  x2C
0645A:  MOVF   x22,W
0645C:  ADDWF  x28,W
0645E:  MOVWF  FE9
06460:  MOVF   x23,W
06462:  ADDWFC x29,W
06464:  MOVWF  FEA
06466:  MOVFF  FEF,72D
0646A:  MOVFF  72C,72F
0646E:  MOVFF  72B,72E
06472:  CLRF   x31
06474:  MOVFF  72D,730
06478:  MOVLB  0
0647A:  BRA    63BC
.................... 		delay_ms(3); 
0647C:  MOVLW  03
0647E:  MOVLB  7
06480:  MOVWF  x2B
06482:  MOVLB  0
06484:  RCALL  608E
....................       if (int_enabled) enable_interrupts(global);  
06486:  MOVLB  7
06488:  BTFSS  x2A.0
0648A:  BRA    6490
0648C:  MOVLW  C0
0648E:  IORWF  FF2,F
....................    } 
06490:  INCF   x28,F
06492:  BTFSC  FD8.2
06494:  INCF   x29,F
06496:  BRA    6438
.................... }  
06498:  MOVLB  0
0649A:  RETURN 0
....................  
....................  
.................... void INTEEPROM_GET8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       ptr[count]=read_eeprom(addr+count);  
....................       if (int_enabled) enable_interrupts(global);  
....................    }  
.................... }  
....................  
.................... void INTEEPROM_PUT8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       //WRITE_EEPROM  
.................... 		write_eeprom(addr+count,ptr[count]); 
.................... 		delay_ms(3); 
....................       if (int_enabled) enable_interrupts(global);  
....................    } 
.................... }  
....................  
.................... void default_addr() 
.................... { 
.................... 	WRITE_CONFIG_ADDRESS(0, PREGAIN_CH1);     	// PREGAIN_CH1 
*
032F6:  MOVLB  6
032F8:  CLRF   xD9
032FA:  CLRF   xD8
032FC:  MOVLW  03
032FE:  MOVWF  xDB
03300:  MOVLW  73
03302:  MOVWF  xDA
03304:  MOVLB  0
03306:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(1, PREGAIN_MUTE_CH1);  // PREGAIN_MUTE_CH1 
03308:  MOVLB  6
0330A:  CLRF   xD9
0330C:  MOVLW  01
0330E:  MOVWF  xD8
03310:  MOVLW  04
03312:  MOVWF  xDB
03314:  MOVLW  43
03316:  MOVWF  xDA
03318:  MOVLB  0
0331A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(2, PREGAIN_CH2);     	// PREGAIN_CH2 
0331C:  MOVLB  6
0331E:  CLRF   xD9
03320:  MOVLW  02
03322:  MOVWF  xD8
03324:  MOVLW  03
03326:  MOVWF  xDB
03328:  MOVLW  CF
0332A:  MOVWF  xDA
0332C:  MOVLB  0
0332E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(3, PREGAIN_MUTE_CH2);  // PREGAIN_MUTE_CH2 
03330:  MOVLB  6
03332:  CLRF   xD9
03334:  MOVLW  03
03336:  MOVWF  xD8
03338:  MOVLW  04
0333A:  MOVWF  xDB
0333C:  MOVLW  41
0333E:  MOVWF  xDA
03340:  MOVLB  0
03342:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(4, PREGAIN_CH3);     	// PREGAIN_CH3 
03344:  MOVLB  6
03346:  CLRF   xD9
03348:  MOVLW  04
0334A:  MOVWF  xD8
0334C:  MOVLW  03
0334E:  MOVWF  xDB
03350:  MOVLW  CB
03352:  MOVWF  xDA
03354:  MOVLB  0
03356:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(5, PREGAIN_MUTE_CH3);  // PREGAIN_MUTE_CH3 
03358:  MOVLB  6
0335A:  CLRF   xD9
0335C:  MOVLW  05
0335E:  MOVWF  xD8
03360:  MOVLW  04
03362:  MOVWF  xDB
03364:  MOVLW  3F
03366:  MOVWF  xDA
03368:  MOVLB  0
0336A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(6, PREGAIN_CH4);     	// PREGAIN_CH4 
0336C:  MOVLB  6
0336E:  CLRF   xD9
03370:  MOVLW  06
03372:  MOVWF  xD8
03374:  MOVLW  03
03376:  MOVWF  xDB
03378:  MOVLW  C7
0337A:  MOVWF  xDA
0337C:  MOVLB  0
0337E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(7, PREGAIN_MUTE_CH4);  // PREGAIN_MUTE_CH4 
03380:  MOVLB  6
03382:  CLRF   xD9
03384:  MOVLW  07
03386:  MOVWF  xD8
03388:  MOVLW  04
0338A:  MOVWF  xDB
0338C:  MOVLW  3D
0338E:  MOVWF  xDA
03390:  MOVLB  0
03392:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(8, PREGAIN_CH5);     	// PREGAIN_CH5 
03394:  MOVLB  6
03396:  CLRF   xD9
03398:  MOVLW  08
0339A:  MOVWF  xD8
0339C:  MOVLW  03
0339E:  MOVWF  xDB
033A0:  MOVLW  C3
033A2:  MOVWF  xDA
033A4:  MOVLB  0
033A6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(9, PREGAIN_MUTE_CH5);  // PREGAIN_MUTE_CH5 
033A8:  MOVLB  6
033AA:  CLRF   xD9
033AC:  MOVLW  09
033AE:  MOVWF  xD8
033B0:  MOVLW  04
033B2:  MOVWF  xDB
033B4:  MOVLW  3B
033B6:  MOVWF  xDA
033B8:  MOVLB  0
033BA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(10, PREGAIN_CH6);     	// PREGAIN_CH6 
033BC:  MOVLB  6
033BE:  CLRF   xD9
033C0:  MOVLW  0A
033C2:  MOVWF  xD8
033C4:  MOVLW  03
033C6:  MOVWF  xDB
033C8:  MOVLW  BF
033CA:  MOVWF  xDA
033CC:  MOVLB  0
033CE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(11, PREGAIN_MUTE_CH6); // PREGAIN_MUTE_CH6 
033D0:  MOVLB  6
033D2:  CLRF   xD9
033D4:  MOVLW  0B
033D6:  MOVWF  xD8
033D8:  MOVLW  04
033DA:  MOVWF  xDB
033DC:  MOVLW  39
033DE:  MOVWF  xDA
033E0:  MOVLB  0
033E2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(12, PREGAIN_CH7);     	// PREGAIN_CH7 
033E4:  MOVLB  6
033E6:  CLRF   xD9
033E8:  MOVLW  0C
033EA:  MOVWF  xD8
033EC:  MOVLW  03
033EE:  MOVWF  xDB
033F0:  MOVLW  BB
033F2:  MOVWF  xDA
033F4:  MOVLB  0
033F6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(13, PREGAIN_MUTE_CH7); // PREGAIN_MUTE_CH7 
033F8:  MOVLB  6
033FA:  CLRF   xD9
033FC:  MOVLW  0D
033FE:  MOVWF  xD8
03400:  MOVLW  04
03402:  MOVWF  xDB
03404:  MOVLW  37
03406:  MOVWF  xDA
03408:  MOVLB  0
0340A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(14, PREGAIN_CH8);     	// PREGAIN_CH8 
0340C:  MOVLB  6
0340E:  CLRF   xD9
03410:  MOVLW  0E
03412:  MOVWF  xD8
03414:  MOVLW  03
03416:  MOVWF  xDB
03418:  MOVLW  B7
0341A:  MOVWF  xDA
0341C:  MOVLB  0
0341E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(15, PREGAIN_MUTE_CH8); // PREGAIN_MUTE_CH8 
03420:  MOVLB  6
03422:  CLRF   xD9
03424:  MOVLW  0F
03426:  MOVWF  xD8
03428:  MOVLW  04
0342A:  MOVWF  xDB
0342C:  MOVLW  35
0342E:  MOVWF  xDA
03430:  MOVLB  0
03432:  RCALL  3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(16, PREMIX_CH1);     	// PREMIX_CH1 
03434:  MOVLB  6
03436:  CLRF   xD9
03438:  MOVLW  10
0343A:  MOVWF  xD8
0343C:  MOVLW  03
0343E:  MOVWF  xDB
03440:  MOVLW  B3
03442:  MOVWF  xDA
03444:  MOVLB  0
03446:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(17, PREMIX_MUTE_CH1);  // PREMIX_MUTE_CH1 
03448:  MOVLB  6
0344A:  CLRF   xD9
0344C:  MOVLW  11
0344E:  MOVWF  xD8
03450:  MOVLW  04
03452:  MOVWF  xDB
03454:  MOVLW  33
03456:  MOVWF  xDA
03458:  MOVLB  0
0345A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(18, PREMIX_CH2);     	// PREMIX_CH2 
0345C:  MOVLB  6
0345E:  CLRF   xD9
03460:  MOVLW  12
03462:  MOVWF  xD8
03464:  MOVLW  03
03466:  MOVWF  xDB
03468:  MOVLW  AF
0346A:  MOVWF  xDA
0346C:  MOVLB  0
0346E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(19, PREMIX_MUTE_CH2);  // PREMIX_MUTE_CH2 
03470:  MOVLB  6
03472:  CLRF   xD9
03474:  MOVLW  13
03476:  MOVWF  xD8
03478:  MOVLW  04
0347A:  MOVWF  xDB
0347C:  MOVLW  31
0347E:  MOVWF  xDA
03480:  MOVLB  0
03482:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(20, PREMIX_CH3);     	// PREMIX_CH3 
03484:  MOVLB  6
03486:  CLRF   xD9
03488:  MOVLW  14
0348A:  MOVWF  xD8
0348C:  MOVLW  03
0348E:  MOVWF  xDB
03490:  MOVLW  AB
03492:  MOVWF  xDA
03494:  MOVLB  0
03496:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(21, PREMIX_MUTE_CH3);  // PREMIX_MUTE_CH3 
03498:  MOVLB  6
0349A:  CLRF   xD9
0349C:  MOVLW  15
0349E:  MOVWF  xD8
034A0:  MOVLW  04
034A2:  MOVWF  xDB
034A4:  MOVLW  2F
034A6:  MOVWF  xDA
034A8:  MOVLB  0
034AA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(22, PREMIX_CH4);     	// PREMIX_CH4 
034AC:  MOVLB  6
034AE:  CLRF   xD9
034B0:  MOVLW  16
034B2:  MOVWF  xD8
034B4:  MOVLW  03
034B6:  MOVWF  xDB
034B8:  MOVLW  A7
034BA:  MOVWF  xDA
034BC:  MOVLB  0
034BE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(23, PREMIX_MUTE_CH4);  // PREMIX_MUTE_CH4 
034C0:  MOVLB  6
034C2:  CLRF   xD9
034C4:  MOVLW  17
034C6:  MOVWF  xD8
034C8:  MOVLW  04
034CA:  MOVWF  xDB
034CC:  MOVLW  2D
034CE:  MOVWF  xDA
034D0:  MOVLB  0
034D2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(24, PREMIX_CH5);     	// PREMIX_CH5 
034D4:  MOVLB  6
034D6:  CLRF   xD9
034D8:  MOVLW  18
034DA:  MOVWF  xD8
034DC:  MOVLW  03
034DE:  MOVWF  xDB
034E0:  MOVLW  A3
034E2:  MOVWF  xDA
034E4:  MOVLB  0
034E6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(25, PREMIX_MUTE_CH5);  // PREMIX_MUTE_CH5 
034E8:  MOVLB  6
034EA:  CLRF   xD9
034EC:  MOVLW  19
034EE:  MOVWF  xD8
034F0:  MOVLW  04
034F2:  MOVWF  xDB
034F4:  MOVLW  2B
034F6:  MOVWF  xDA
034F8:  MOVLB  0
034FA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(26, PREMIX_CH6);     	// PREMIX_CH6 
034FC:  MOVLB  6
034FE:  CLRF   xD9
03500:  MOVLW  1A
03502:  MOVWF  xD8
03504:  MOVLW  03
03506:  MOVWF  xDB
03508:  MOVLW  9F
0350A:  MOVWF  xDA
0350C:  MOVLB  0
0350E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(27, PREMIX_MUTE_CH6);  // PREMIX_MUTE_CH6 
03510:  MOVLB  6
03512:  CLRF   xD9
03514:  MOVLW  1B
03516:  MOVWF  xD8
03518:  MOVLW  04
0351A:  MOVWF  xDB
0351C:  MOVLW  29
0351E:  MOVWF  xDA
03520:  MOVLB  0
03522:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(28, PREMIX_CH7);     	// PREMIX_CH7 
03524:  MOVLB  6
03526:  CLRF   xD9
03528:  MOVLW  1C
0352A:  MOVWF  xD8
0352C:  MOVLW  03
0352E:  MOVWF  xDB
03530:  MOVLW  9B
03532:  MOVWF  xDA
03534:  MOVLB  0
03536:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(29, PREMIX_MUTE_CH7);  // PREMIX_MUTE_CH7 
03538:  MOVLB  6
0353A:  CLRF   xD9
0353C:  MOVLW  1D
0353E:  MOVWF  xD8
03540:  MOVLW  04
03542:  MOVWF  xDB
03544:  MOVLW  27
03546:  MOVWF  xDA
03548:  MOVLB  0
0354A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(30, PREMIX_CH8);     	// PREMIX_CH8 
0354C:  MOVLB  6
0354E:  CLRF   xD9
03550:  MOVLW  1E
03552:  MOVWF  xD8
03554:  MOVLW  03
03556:  MOVWF  xDB
03558:  MOVLW  97
0355A:  MOVWF  xDA
0355C:  MOVLB  0
0355E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(31, PREMIX_MUTE_CH8);  // PREMIX_MUTE_CH8 
03560:  MOVLB  6
03562:  CLRF   xD9
03564:  MOVLW  1F
03566:  MOVWF  xD8
03568:  MOVLW  04
0356A:  MOVWF  xDB
0356C:  MOVLW  25
0356E:  MOVWF  xDA
03570:  MOVLB  0
03572:  RCALL  3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(32, TRIM_CH1);     	// TRIM_CH1 
03574:  MOVLB  6
03576:  CLRF   xD9
03578:  MOVLW  20
0357A:  MOVWF  xD8
0357C:  MOVLW  03
0357E:  MOVWF  xDB
03580:  MOVLW  93
03582:  MOVWF  xDA
03584:  MOVLB  0
03586:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(33, TRIM_MUTE_CH1);    // TRIM_MUTE_CH1 
03588:  MOVLB  6
0358A:  CLRF   xD9
0358C:  MOVLW  21
0358E:  MOVWF  xD8
03590:  MOVLW  04
03592:  MOVWF  xDB
03594:  MOVLW  23
03596:  MOVWF  xDA
03598:  MOVLB  0
0359A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(34, TRIM_CH2);     	// TRIM_CH2 
0359C:  MOVLB  6
0359E:  CLRF   xD9
035A0:  MOVLW  22
035A2:  MOVWF  xD8
035A4:  MOVLW  03
035A6:  MOVWF  xDB
035A8:  MOVLW  8F
035AA:  MOVWF  xDA
035AC:  MOVLB  0
035AE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(35, TRIM_MUTE_CH2);    // TRIM_MUTE_CH2 
035B0:  MOVLB  6
035B2:  CLRF   xD9
035B4:  MOVLW  23
035B6:  MOVWF  xD8
035B8:  MOVLW  04
035BA:  MOVWF  xDB
035BC:  MOVLW  21
035BE:  MOVWF  xDA
035C0:  MOVLB  0
035C2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(36, TRIM_CH3);     	// TRIM_CH3 
035C4:  MOVLB  6
035C6:  CLRF   xD9
035C8:  MOVLW  24
035CA:  MOVWF  xD8
035CC:  MOVLW  03
035CE:  MOVWF  xDB
035D0:  MOVLW  8B
035D2:  MOVWF  xDA
035D4:  MOVLB  0
035D6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(37, TRIM_MUTE_CH3);    // TRIM_MUTE_CH3 
035D8:  MOVLB  6
035DA:  CLRF   xD9
035DC:  MOVLW  25
035DE:  MOVWF  xD8
035E0:  MOVLW  04
035E2:  MOVWF  xDB
035E4:  MOVLW  1F
035E6:  MOVWF  xDA
035E8:  MOVLB  0
035EA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(38, TRIM_CH4);     	// TRIM_CH4 
035EC:  MOVLB  6
035EE:  CLRF   xD9
035F0:  MOVLW  26
035F2:  MOVWF  xD8
035F4:  MOVLW  03
035F6:  MOVWF  xDB
035F8:  MOVLW  87
035FA:  MOVWF  xDA
035FC:  MOVLB  0
035FE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(39, TRIM_MUTE_CH4);     // TRIM_MUTE_CH4 
03600:  MOVLB  6
03602:  CLRF   xD9
03604:  MOVLW  27
03606:  MOVWF  xD8
03608:  MOVLW  04
0360A:  MOVWF  xDB
0360C:  MOVLW  1D
0360E:  MOVWF  xDA
03610:  MOVLB  0
03612:  RCALL  3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(40, OUTPUTGAIN_CH1);     // OUTPUTGAIN_CH1 
03614:  MOVLB  6
03616:  CLRF   xD9
03618:  MOVLW  28
0361A:  MOVWF  xD8
0361C:  MOVLW  03
0361E:  MOVWF  xDB
03620:  MOVLW  83
03622:  MOVWF  xDA
03624:  MOVLB  0
03626:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(41, OUTPUT_MUTE_CH1);     // OUTPUT_MUTE_CH1 
03628:  MOVLB  6
0362A:  CLRF   xD9
0362C:  MOVLW  29
0362E:  MOVWF  xD8
03630:  MOVLW  04
03632:  MOVWF  xDB
03634:  MOVLW  1B
03636:  MOVWF  xDA
03638:  MOVLB  0
0363A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(42, OUTPUTGAIN_CH2);     // OUTPUTGAIN_CH2 
0363C:  MOVLB  6
0363E:  CLRF   xD9
03640:  MOVLW  2A
03642:  MOVWF  xD8
03644:  MOVLW  03
03646:  MOVWF  xDB
03648:  MOVLW  7F
0364A:  MOVWF  xDA
0364C:  MOVLB  0
0364E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(43, OUTPUT_MUTE_CH2);     // OUTPUT_MUTE_CH2 
03650:  MOVLB  6
03652:  CLRF   xD9
03654:  MOVLW  2B
03656:  MOVWF  xD8
03658:  MOVLW  04
0365A:  MOVWF  xDB
0365C:  MOVLW  19
0365E:  MOVWF  xDA
03660:  MOVLB  0
03662:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(44, OUTPUTGAIN_CH3);     // OUTPUTGAIN_CH3 
03664:  MOVLB  6
03666:  CLRF   xD9
03668:  MOVLW  2C
0366A:  MOVWF  xD8
0366C:  MOVLW  03
0366E:  MOVWF  xDB
03670:  MOVLW  7B
03672:  MOVWF  xDA
03674:  MOVLB  0
03676:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(45, OUTPUT_MUTE_CH3);     // OUTPUT_MUTE_CH3 
03678:  MOVLB  6
0367A:  CLRF   xD9
0367C:  MOVLW  2D
0367E:  MOVWF  xD8
03680:  MOVLW  04
03682:  MOVWF  xDB
03684:  MOVLW  17
03686:  MOVWF  xDA
03688:  MOVLB  0
0368A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(46, OUTPUTGAIN_CH4);     // OUTPUTGAIN_CH4 
0368C:  MOVLB  6
0368E:  CLRF   xD9
03690:  MOVLW  2E
03692:  MOVWF  xD8
03694:  MOVLW  03
03696:  MOVWF  xDB
03698:  MOVLW  77
0369A:  MOVWF  xDA
0369C:  MOVLB  0
0369E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(47, OUTPUT_MUTE_CH4);     // OUTPUT_MUTE_CH4 
036A0:  MOVLB  6
036A2:  CLRF   xD9
036A4:  MOVLW  2F
036A6:  MOVWF  xD8
036A8:  MOVLW  04
036AA:  MOVWF  xDB
036AC:  MOVLW  15
036AE:  MOVWF  xDA
036B0:  MOVLB  0
036B2:  RCALL  3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(48, INDUCKROUTER_SELECT0);     // INDUCKROUTER_SELECT0 
036B4:  MOVLB  6
036B6:  CLRF   xD9
036B8:  MOVLW  30
036BA:  MOVWF  xD8
036BC:  MOVLW  02
036BE:  MOVWF  xDB
036C0:  MOVLW  0E
036C2:  MOVWF  xDA
036C4:  MOVLB  0
036C6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(49, INDUCKROUTER_SELECT1);     // INDUCKROUTER_SELECT1 
036C8:  MOVLB  6
036CA:  CLRF   xD9
036CC:  MOVLW  31
036CE:  MOVWF  xD8
036D0:  MOVLW  02
036D2:  MOVWF  xDB
036D4:  MOVLW  0F
036D6:  MOVWF  xDA
036D8:  MOVLB  0
036DA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(50, INDUCKROUTER_SELECT2);     // INDUCKROUTER_SELECT2 
036DC:  MOVLB  6
036DE:  CLRF   xD9
036E0:  MOVLW  32
036E2:  MOVWF  xD8
036E4:  MOVLW  02
036E6:  MOVWF  xDB
036E8:  MOVLW  10
036EA:  MOVWF  xDA
036EC:  MOVLB  0
036EE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(51, INDUCKROUTER_SELECT3);     // INDUCKROUTER_SELECT3 
036F0:  MOVLB  6
036F2:  CLRF   xD9
036F4:  MOVLW  33
036F6:  MOVWF  xD8
036F8:  MOVLW  02
036FA:  MOVWF  xDB
036FC:  MOVLW  11
036FE:  MOVWF  xDA
03700:  MOVLB  0
03702:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(52, INDUCKROUTER_SELECT4);     // INDUCKROUTER_SELECT4 
03704:  MOVLB  6
03706:  CLRF   xD9
03708:  MOVLW  34
0370A:  MOVWF  xD8
0370C:  MOVLW  02
0370E:  MOVWF  xDB
03710:  MOVLW  12
03712:  MOVWF  xDA
03714:  MOVLB  0
03716:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(53, INDUCKROUTER_SELECT5);     // INDUCKROUTER_SELECT5 
03718:  MOVLB  6
0371A:  CLRF   xD9
0371C:  MOVLW  35
0371E:  MOVWF  xD8
03720:  MOVLW  02
03722:  MOVWF  xDB
03724:  MOVLW  13
03726:  MOVWF  xDA
03728:  MOVLB  0
0372A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(54, INDUCKROUTER_SELECT6);     // INDUCKROUTER_SELECT6 
0372C:  MOVLB  6
0372E:  CLRF   xD9
03730:  MOVLW  36
03732:  MOVWF  xD8
03734:  MOVLW  02
03736:  MOVWF  xDB
03738:  MOVLW  14
0373A:  MOVWF  xDA
0373C:  MOVLB  0
0373E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(55, INDUCKROUTER_SELECT7);     // INDUCKROUTER_SELECT7 
03740:  MOVLB  6
03742:  CLRF   xD9
03744:  MOVLW  37
03746:  MOVWF  xD8
03748:  MOVLW  02
0374A:  MOVWF  xDB
0374C:  MOVLW  15
0374E:  MOVWF  xDA
03750:  MOVLB  0
03752:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(56, OUTDUCKROUTER_SELECT0);     // OUTDUCKROUTER_SELECT0 
03754:  MOVLB  6
03756:  CLRF   xD9
03758:  MOVLW  38
0375A:  MOVWF  xD8
0375C:  MOVLW  02
0375E:  MOVWF  xDB
03760:  MOVLW  05
03762:  MOVWF  xDA
03764:  MOVLB  0
03766:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(57, OUTDUCKROUTER_SELECT1);     // OUTDUCKROUTER_SELECT1 
03768:  MOVLB  6
0376A:  CLRF   xD9
0376C:  MOVLW  39
0376E:  MOVWF  xD8
03770:  MOVLW  02
03772:  MOVWF  xDB
03774:  MOVLW  06
03776:  MOVWF  xDA
03778:  MOVLB  0
0377A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(58, OUTDUCKROUTER_SELECT2);     // OUTDUCKROUTER_SELECT2 
0377C:  MOVLB  6
0377E:  CLRF   xD9
03780:  MOVLW  3A
03782:  MOVWF  xD8
03784:  MOVLW  02
03786:  MOVWF  xDB
03788:  MOVLW  07
0378A:  MOVWF  xDA
0378C:  MOVLB  0
0378E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(59, OUTDUCKROUTER_SELECT3);     // OUTDUCKROUTER_SELECT3 
03790:  MOVLB  6
03792:  CLRF   xD9
03794:  MOVLW  3B
03796:  MOVWF  xD8
03798:  MOVLW  02
0379A:  MOVWF  xDB
0379C:  MOVLW  08
0379E:  MOVWF  xDA
037A0:  MOVLB  0
037A2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(60, OUTDUCKROUTER_SELECT4);     // OUTDUCKROUTER_SELECT4 
037A4:  MOVLB  6
037A6:  CLRF   xD9
037A8:  MOVLW  3C
037AA:  MOVWF  xD8
037AC:  MOVLW  02
037AE:  MOVWF  xDB
037B0:  MOVLW  09
037B2:  MOVWF  xDA
037B4:  MOVLB  0
037B6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(61, OUTDUCKROUTER_SELECT5);     // OUTDUCKROUTER_SELECT5 
037B8:  MOVLB  6
037BA:  CLRF   xD9
037BC:  MOVLW  3D
037BE:  MOVWF  xD8
037C0:  MOVLW  02
037C2:  MOVWF  xDB
037C4:  MOVLW  0A
037C6:  MOVWF  xDA
037C8:  MOVLB  0
037CA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(62, OUTDUCKROUTER_SELECT6);     // OUTDUCKROUTER_SELECT6 
037CC:  MOVLB  6
037CE:  CLRF   xD9
037D0:  MOVLW  3E
037D2:  MOVWF  xD8
037D4:  MOVLW  02
037D6:  MOVWF  xDB
037D8:  MOVLW  0B
037DA:  MOVWF  xDA
037DC:  MOVLB  0
037DE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(63, OUTDUCKROUTER_SELECT7);     // OUTDUCKROUTER_SELECT7 
037E0:  MOVLB  6
037E2:  CLRF   xD9
037E4:  MOVLW  3F
037E6:  MOVWF  xD8
037E8:  MOVLW  02
037EA:  MOVWF  xDB
037EC:  MOVLW  0C
037EE:  MOVWF  xDA
037F0:  MOVLB  0
037F2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(64, DUCKER_THRESHOLD);     // DUCKER_THRESHOLD 
037F4:  MOVLB  6
037F6:  CLRF   xD9
037F8:  MOVLW  40
037FA:  MOVWF  xD8
037FC:  MOVLW  02
037FE:  MOVWF  xDB
03800:  MOVLW  76
03802:  MOVWF  xDA
03804:  MOVLB  0
03806:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(65, DUCKER_HOLD);     // DUCKER_HOLD 
03808:  MOVLB  6
0380A:  CLRF   xD9
0380C:  MOVLW  41
0380E:  MOVWF  xD8
03810:  MOVLW  02
03812:  MOVWF  xDB
03814:  MOVLW  77
03816:  MOVWF  xDA
03818:  MOVLB  0
0381A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(66, DUCKER_DEPTH);     // DUCKER_DEPTH 
0381C:  MOVLB  6
0381E:  CLRF   xD9
03820:  MOVLW  42
03822:  MOVWF  xD8
03824:  MOVLW  02
03826:  MOVWF  xDB
03828:  MOVLW  78
0382A:  MOVWF  xDA
0382C:  MOVLB  0
0382E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(67, DUCKER_ATTACK);     // DUCKER_ATTACK 
03830:  MOVLB  6
03832:  CLRF   xD9
03834:  MOVLW  43
03836:  MOVWF  xD8
03838:  MOVLW  02
0383A:  MOVWF  xDB
0383C:  MOVLW  79
0383E:  MOVWF  xDA
03840:  MOVLB  0
03842:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(68, DUCKER_RELEASE);     // DUCKER_RELEASE 
03844:  MOVLB  6
03846:  CLRF   xD9
03848:  MOVLW  44
0384A:  MOVWF  xD8
0384C:  MOVLW  02
0384E:  MOVWF  xDB
03850:  MOVLW  7A
03852:  MOVWF  xDA
03854:  MOVLB  0
03856:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(69, DUCKER_BYPASS);     // DUCKER_BYPASS 
03858:  MOVLB  6
0385A:  CLRF   xD9
0385C:  MOVLW  45
0385E:  MOVWF  xD8
03860:  MOVLW  02
03862:  MOVWF  xDB
03864:  MOVLW  7B
03866:  MOVWF  xDA
03868:  MOVLB  0
0386A:  RCALL  3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(70, IN_1_1_FILTER_B0);     // IN_1_1_FILTER_B0 
0386C:  MOVLB  6
0386E:  CLRF   xD9
03870:  MOVLW  46
03872:  MOVWF  xD8
03874:  MOVLW  03
03876:  MOVWF  xDB
03878:  MOVLW  6D
0387A:  MOVWF  xDA
0387C:  MOVLB  0
0387E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(71, IN_1_1_FILTER_B1);     // IN_1_1_FILTER_B1 
03880:  MOVLB  6
03882:  CLRF   xD9
03884:  MOVLW  47
03886:  MOVWF  xD8
03888:  MOVLW  03
0388A:  MOVWF  xDB
0388C:  MOVLW  6E
0388E:  MOVWF  xDA
03890:  MOVLB  0
03892:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(72, IN_1_1_FILTER_B2);     // IN_1_1_FILTER_B2 
03894:  MOVLB  6
03896:  CLRF   xD9
03898:  MOVLW  48
0389A:  MOVWF  xD8
0389C:  MOVLW  03
0389E:  MOVWF  xDB
038A0:  MOVLW  6F
038A2:  MOVWF  xDA
038A4:  MOVLB  0
038A6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(73, IN_1_1_FILTER_MINUSA1);     // IN_1_1_FILTER_MINUSA1 
038A8:  MOVLB  6
038AA:  CLRF   xD9
038AC:  MOVLW  49
038AE:  MOVWF  xD8
038B0:  MOVLW  03
038B2:  MOVWF  xDB
038B4:  MOVLW  70
038B6:  MOVWF  xDA
038B8:  MOVLB  0
038BA:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(74, IN_1_1_FILTER_MINUSA2);     // IN_1_1_FILTER_MINUSA2 
038BC:  MOVLB  6
038BE:  CLRF   xD9
038C0:  MOVLW  4A
038C2:  MOVWF  xD8
038C4:  MOVLW  03
038C6:  MOVWF  xDB
038C8:  MOVLW  71
038CA:  MOVWF  xDA
038CC:  MOVLB  0
038CE:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(75, IN_1_2_FILTER_B0);     // IN_1_2_FILTER_B0 
038D0:  MOVLB  6
038D2:  CLRF   xD9
038D4:  MOVLW  4B
038D6:  MOVWF  xD8
038D8:  MOVLW  03
038DA:  MOVWF  xDB
038DC:  MOVLW  68
038DE:  MOVWF  xDA
038E0:  MOVLB  0
038E2:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(76, IN_1_2_FILTER_B1);     // IN_1_2_FILTER_B1 
038E4:  MOVLB  6
038E6:  CLRF   xD9
038E8:  MOVLW  4C
038EA:  MOVWF  xD8
038EC:  MOVLW  03
038EE:  MOVWF  xDB
038F0:  MOVLW  69
038F2:  MOVWF  xDA
038F4:  MOVLB  0
038F6:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(77, IN_1_2_FILTER_B2);     // IN_1_2_FILTER_B2 
038F8:  MOVLB  6
038FA:  CLRF   xD9
038FC:  MOVLW  4D
038FE:  MOVWF  xD8
03900:  MOVLW  03
03902:  MOVWF  xDB
03904:  MOVLW  6A
03906:  MOVWF  xDA
03908:  MOVLB  0
0390A:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(78, IN_1_2_FILTER_MINUSA1);     // IN_1_2_FILTER_MINUSA1 
0390C:  MOVLB  6
0390E:  CLRF   xD9
03910:  MOVLW  4E
03912:  MOVWF  xD8
03914:  MOVLW  03
03916:  MOVWF  xDB
03918:  MOVLW  6B
0391A:  MOVWF  xDA
0391C:  MOVLB  0
0391E:  RCALL  3124
.................... 	WRITE_CONFIG_ADDRESS(79, IN_1_2_FILTER_MINUSA2);     // IN_1_2_FILTER_MINUSA2 
03920:  MOVLB  6
03922:  CLRF   xD9
03924:  MOVLW  4F
03926:  MOVWF  xD8
03928:  MOVLW  03
0392A:  MOVWF  xDB
0392C:  MOVLW  6C
0392E:  MOVWF  xDA
03930:  MOVLB  0
03932:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(80, IN_1_3_FILTER_B0);     // IN_1_3_FILTER_B0 
03936:  MOVLB  6
03938:  CLRF   xD9
0393A:  MOVLW  50
0393C:  MOVWF  xD8
0393E:  MOVLW  03
03940:  MOVWF  xDB
03942:  MOVLW  63
03944:  MOVWF  xDA
03946:  MOVLB  0
03948:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(81, IN_1_3_FILTER_B1);     // IN_1_3_FILTER_B1 
0394C:  MOVLB  6
0394E:  CLRF   xD9
03950:  MOVLW  51
03952:  MOVWF  xD8
03954:  MOVLW  03
03956:  MOVWF  xDB
03958:  MOVLW  64
0395A:  MOVWF  xDA
0395C:  MOVLB  0
0395E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(82, IN_1_3_FILTER_B2);     // IN_1_3_FILTER_B2 
03962:  MOVLB  6
03964:  CLRF   xD9
03966:  MOVLW  52
03968:  MOVWF  xD8
0396A:  MOVLW  03
0396C:  MOVWF  xDB
0396E:  MOVLW  65
03970:  MOVWF  xDA
03972:  MOVLB  0
03974:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(83, IN_1_3_FILTER_MINUSA1);     // IN_1_3_FILTER_MINUSA1 
03978:  MOVLB  6
0397A:  CLRF   xD9
0397C:  MOVLW  53
0397E:  MOVWF  xD8
03980:  MOVLW  03
03982:  MOVWF  xDB
03984:  MOVLW  66
03986:  MOVWF  xDA
03988:  MOVLB  0
0398A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(84, IN_1_3_FILTER_MINUSA2);     // IN_1_3_FILTER_MINUSA2 
0398E:  MOVLB  6
03990:  CLRF   xD9
03992:  MOVLW  54
03994:  MOVWF  xD8
03996:  MOVLW  03
03998:  MOVWF  xDB
0399A:  MOVLW  67
0399C:  MOVWF  xDA
0399E:  MOVLB  0
039A0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(85, IN_2_1_FILTER_B0);     // IN_2_1_FILTER_B0 
039A4:  MOVLB  6
039A6:  CLRF   xD9
039A8:  MOVLW  55
039AA:  MOVWF  xD8
039AC:  MOVLW  03
039AE:  MOVWF  xDB
039B0:  MOVLW  5E
039B2:  MOVWF  xDA
039B4:  MOVLB  0
039B6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(86, IN_2_1_FILTER_B1);     // IN_2_1_FILTER_B1 
039BA:  MOVLB  6
039BC:  CLRF   xD9
039BE:  MOVLW  56
039C0:  MOVWF  xD8
039C2:  MOVLW  03
039C4:  MOVWF  xDB
039C6:  MOVLW  5F
039C8:  MOVWF  xDA
039CA:  MOVLB  0
039CC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(87, IN_2_1_FILTER_B2);     // IN_2_1_FILTER_B2 
039D0:  MOVLB  6
039D2:  CLRF   xD9
039D4:  MOVLW  57
039D6:  MOVWF  xD8
039D8:  MOVLW  03
039DA:  MOVWF  xDB
039DC:  MOVLW  60
039DE:  MOVWF  xDA
039E0:  MOVLB  0
039E2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(88, IN_2_1_FILTER_MINUSA1);     // IN_2_1_FILTER_MINUSA1 
039E6:  MOVLB  6
039E8:  CLRF   xD9
039EA:  MOVLW  58
039EC:  MOVWF  xD8
039EE:  MOVLW  03
039F0:  MOVWF  xDB
039F2:  MOVLW  61
039F4:  MOVWF  xDA
039F6:  MOVLB  0
039F8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(89, IN_2_1_FILTER_MINUSA2);     // IN_2_1_FILTER_MINUSA2 
039FC:  MOVLB  6
039FE:  CLRF   xD9
03A00:  MOVLW  59
03A02:  MOVWF  xD8
03A04:  MOVLW  03
03A06:  MOVWF  xDB
03A08:  MOVLW  62
03A0A:  MOVWF  xDA
03A0C:  MOVLB  0
03A0E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(90, IN_2_2_FILTER_B0);     // IN_2_2_FILTER_B0 
03A12:  MOVLB  6
03A14:  CLRF   xD9
03A16:  MOVLW  5A
03A18:  MOVWF  xD8
03A1A:  MOVLW  03
03A1C:  MOVWF  xDB
03A1E:  MOVLW  59
03A20:  MOVWF  xDA
03A22:  MOVLB  0
03A24:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(91, IN_2_2_FILTER_B1);     // IN_2_2_FILTER_B1 
03A28:  MOVLB  6
03A2A:  CLRF   xD9
03A2C:  MOVLW  5B
03A2E:  MOVWF  xD8
03A30:  MOVLW  03
03A32:  MOVWF  xDB
03A34:  MOVLW  5A
03A36:  MOVWF  xDA
03A38:  MOVLB  0
03A3A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(92, IN_2_2_FILTER_B2);     // IN_2_2_FILTER_B2 
03A3E:  MOVLB  6
03A40:  CLRF   xD9
03A42:  MOVLW  5C
03A44:  MOVWF  xD8
03A46:  MOVLW  03
03A48:  MOVWF  xDB
03A4A:  MOVLW  5B
03A4C:  MOVWF  xDA
03A4E:  MOVLB  0
03A50:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(93, IN_2_2_FILTER_MINUSA1);     // IN_2_2_FILTER_MINUSA1 
03A54:  MOVLB  6
03A56:  CLRF   xD9
03A58:  MOVLW  5D
03A5A:  MOVWF  xD8
03A5C:  MOVLW  03
03A5E:  MOVWF  xDB
03A60:  MOVLW  5C
03A62:  MOVWF  xDA
03A64:  MOVLB  0
03A66:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(94, IN_2_2_FILTER_MINUSA2);     // IN_2_2_FILTER_MINUSA2 
03A6A:  MOVLB  6
03A6C:  CLRF   xD9
03A6E:  MOVLW  5E
03A70:  MOVWF  xD8
03A72:  MOVLW  03
03A74:  MOVWF  xDB
03A76:  MOVLW  5D
03A78:  MOVWF  xDA
03A7A:  MOVLB  0
03A7C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(95, IN_2_3_FILTER_B0);     // IN_2_3_FILTER_B0 
03A80:  MOVLB  6
03A82:  CLRF   xD9
03A84:  MOVLW  5F
03A86:  MOVWF  xD8
03A88:  MOVLW  03
03A8A:  MOVWF  xDB
03A8C:  MOVLW  54
03A8E:  MOVWF  xDA
03A90:  MOVLB  0
03A92:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(96, IN_2_3_FILTER_B1);     // IN_2_3_FILTER_B1 
03A96:  MOVLB  6
03A98:  CLRF   xD9
03A9A:  MOVLW  60
03A9C:  MOVWF  xD8
03A9E:  MOVLW  03
03AA0:  MOVWF  xDB
03AA2:  MOVLW  55
03AA4:  MOVWF  xDA
03AA6:  MOVLB  0
03AA8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(97, IN_2_3_FILTER_B2);     // IN_2_3_FILTER_B2 
03AAC:  MOVLB  6
03AAE:  CLRF   xD9
03AB0:  MOVLW  61
03AB2:  MOVWF  xD8
03AB4:  MOVLW  03
03AB6:  MOVWF  xDB
03AB8:  MOVLW  56
03ABA:  MOVWF  xDA
03ABC:  MOVLB  0
03ABE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(98, IN_2_3_FILTER_MINUSA1);     // IN_2_3_FILTER_MINUSA1 
03AC2:  MOVLB  6
03AC4:  CLRF   xD9
03AC6:  MOVLW  62
03AC8:  MOVWF  xD8
03ACA:  MOVLW  03
03ACC:  MOVWF  xDB
03ACE:  MOVLW  57
03AD0:  MOVWF  xDA
03AD2:  MOVLB  0
03AD4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(99, IN_2_3_FILTER_MINUSA2);     // IN_2_3_FILTER_MINUSA2 
03AD8:  MOVLB  6
03ADA:  CLRF   xD9
03ADC:  MOVLW  63
03ADE:  MOVWF  xD8
03AE0:  MOVLW  03
03AE2:  MOVWF  xDB
03AE4:  MOVLW  58
03AE6:  MOVWF  xDA
03AE8:  MOVLB  0
03AEA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(100, IN_3_1_FILTER_B0);     // IN_3_1_FILTER_B0 
03AEE:  MOVLB  6
03AF0:  CLRF   xD9
03AF2:  MOVLW  64
03AF4:  MOVWF  xD8
03AF6:  MOVLW  03
03AF8:  MOVWF  xDB
03AFA:  MOVLW  4F
03AFC:  MOVWF  xDA
03AFE:  MOVLB  0
03B00:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(101, IN_3_1_FILTER_B1);     // IN_3_1_FILTER_B1 
03B04:  MOVLB  6
03B06:  CLRF   xD9
03B08:  MOVLW  65
03B0A:  MOVWF  xD8
03B0C:  MOVLW  03
03B0E:  MOVWF  xDB
03B10:  MOVLW  50
03B12:  MOVWF  xDA
03B14:  MOVLB  0
03B16:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(102, IN_3_1_FILTER_B2);     // IN_3_1_FILTER_B2 
03B1A:  MOVLB  6
03B1C:  CLRF   xD9
03B1E:  MOVLW  66
03B20:  MOVWF  xD8
03B22:  MOVLW  03
03B24:  MOVWF  xDB
03B26:  MOVLW  51
03B28:  MOVWF  xDA
03B2A:  MOVLB  0
03B2C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(103, IN_3_1_FILTER_MINUSA1);     // IN_3_1_FILTER_MINUSA1 
03B30:  MOVLB  6
03B32:  CLRF   xD9
03B34:  MOVLW  67
03B36:  MOVWF  xD8
03B38:  MOVLW  03
03B3A:  MOVWF  xDB
03B3C:  MOVLW  52
03B3E:  MOVWF  xDA
03B40:  MOVLB  0
03B42:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(104, IN_3_1_FILTER_MINUSA2);     // IN_3_1_FILTER_MINUSA2 
03B46:  MOVLB  6
03B48:  CLRF   xD9
03B4A:  MOVLW  68
03B4C:  MOVWF  xD8
03B4E:  MOVLW  03
03B50:  MOVWF  xDB
03B52:  MOVLW  53
03B54:  MOVWF  xDA
03B56:  MOVLB  0
03B58:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(105, IN_3_2_FILTER_B0);     // IN_3_2_FILTER_B0 
03B5C:  MOVLB  6
03B5E:  CLRF   xD9
03B60:  MOVLW  69
03B62:  MOVWF  xD8
03B64:  MOVLW  03
03B66:  MOVWF  xDB
03B68:  MOVLW  4A
03B6A:  MOVWF  xDA
03B6C:  MOVLB  0
03B6E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(106, IN_3_2_FILTER_B1);     // IN_3_2_FILTER_B1 
03B72:  MOVLB  6
03B74:  CLRF   xD9
03B76:  MOVLW  6A
03B78:  MOVWF  xD8
03B7A:  MOVLW  03
03B7C:  MOVWF  xDB
03B7E:  MOVLW  4B
03B80:  MOVWF  xDA
03B82:  MOVLB  0
03B84:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(107, IN_3_2_FILTER_B2);     // IN_3_2_FILTER_B2 
03B88:  MOVLB  6
03B8A:  CLRF   xD9
03B8C:  MOVLW  6B
03B8E:  MOVWF  xD8
03B90:  MOVLW  03
03B92:  MOVWF  xDB
03B94:  MOVLW  4C
03B96:  MOVWF  xDA
03B98:  MOVLB  0
03B9A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(108, IN_3_2_FILTER_MINUSA1);     // IN_3_2_FILTER_MINUSA1 
03B9E:  MOVLB  6
03BA0:  CLRF   xD9
03BA2:  MOVLW  6C
03BA4:  MOVWF  xD8
03BA6:  MOVLW  03
03BA8:  MOVWF  xDB
03BAA:  MOVLW  4D
03BAC:  MOVWF  xDA
03BAE:  MOVLB  0
03BB0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(109, IN_3_2_FILTER_MINUSA2);     // IN_3_2_FILTER_MINUSA2 
03BB4:  MOVLB  6
03BB6:  CLRF   xD9
03BB8:  MOVLW  6D
03BBA:  MOVWF  xD8
03BBC:  MOVLW  03
03BBE:  MOVWF  xDB
03BC0:  MOVLW  4E
03BC2:  MOVWF  xDA
03BC4:  MOVLB  0
03BC6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(110, IN_3_3_FILTER_B0);     // IN_3_3_FILTER_B0 
03BCA:  MOVLB  6
03BCC:  CLRF   xD9
03BCE:  MOVLW  6E
03BD0:  MOVWF  xD8
03BD2:  MOVLW  03
03BD4:  MOVWF  xDB
03BD6:  MOVLW  45
03BD8:  MOVWF  xDA
03BDA:  MOVLB  0
03BDC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(111, IN_3_3_FILTER_B1);     // IN_3_3_FILTER_B1 
03BE0:  MOVLB  6
03BE2:  CLRF   xD9
03BE4:  MOVLW  6F
03BE6:  MOVWF  xD8
03BE8:  MOVLW  03
03BEA:  MOVWF  xDB
03BEC:  MOVLW  46
03BEE:  MOVWF  xDA
03BF0:  MOVLB  0
03BF2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(112, IN_3_3_FILTER_B2);     // IN_3_3_FILTER_B2 
03BF6:  MOVLB  6
03BF8:  CLRF   xD9
03BFA:  MOVLW  70
03BFC:  MOVWF  xD8
03BFE:  MOVLW  03
03C00:  MOVWF  xDB
03C02:  MOVLW  47
03C04:  MOVWF  xDA
03C06:  MOVLB  0
03C08:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(113, IN_3_3_FILTER_MINUSA1);     // IN_3_3_FILTER_MINUSA1 
03C0C:  MOVLB  6
03C0E:  CLRF   xD9
03C10:  MOVLW  71
03C12:  MOVWF  xD8
03C14:  MOVLW  03
03C16:  MOVWF  xDB
03C18:  MOVLW  48
03C1A:  MOVWF  xDA
03C1C:  MOVLB  0
03C1E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(114, IN_3_3_FILTER_MINUSA2);     // IN_3_3_FILTER_MINUSA2 
03C22:  MOVLB  6
03C24:  CLRF   xD9
03C26:  MOVLW  72
03C28:  MOVWF  xD8
03C2A:  MOVLW  03
03C2C:  MOVWF  xDB
03C2E:  MOVLW  49
03C30:  MOVWF  xDA
03C32:  MOVLB  0
03C34:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(115, IN_4_1_FILTER_B0);     // IN_4_1_FILTER_B0 
03C38:  MOVLB  6
03C3A:  CLRF   xD9
03C3C:  MOVLW  73
03C3E:  MOVWF  xD8
03C40:  MOVLW  03
03C42:  MOVWF  xDB
03C44:  MOVLW  40
03C46:  MOVWF  xDA
03C48:  MOVLB  0
03C4A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(116, IN_4_1_FILTER_B1);     // IN_4_1_FILTER_B1 
03C4E:  MOVLB  6
03C50:  CLRF   xD9
03C52:  MOVLW  74
03C54:  MOVWF  xD8
03C56:  MOVLW  03
03C58:  MOVWF  xDB
03C5A:  MOVLW  41
03C5C:  MOVWF  xDA
03C5E:  MOVLB  0
03C60:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(117, IN_4_1_FILTER_B2);     // IN_4_1_FILTER_B2 
03C64:  MOVLB  6
03C66:  CLRF   xD9
03C68:  MOVLW  75
03C6A:  MOVWF  xD8
03C6C:  MOVLW  03
03C6E:  MOVWF  xDB
03C70:  MOVLW  42
03C72:  MOVWF  xDA
03C74:  MOVLB  0
03C76:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(118, IN_4_1_FILTER_MINUSA1);     // IN_4_1_FILTER_MINUSA1 
03C7A:  MOVLB  6
03C7C:  CLRF   xD9
03C7E:  MOVLW  76
03C80:  MOVWF  xD8
03C82:  MOVLW  03
03C84:  MOVWF  xDB
03C86:  MOVLW  43
03C88:  MOVWF  xDA
03C8A:  MOVLB  0
03C8C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(119, IN_4_1_FILTER_MINUSA2);     // IN_4_1_FILTER_MINUSA2 
03C90:  MOVLB  6
03C92:  CLRF   xD9
03C94:  MOVLW  77
03C96:  MOVWF  xD8
03C98:  MOVLW  03
03C9A:  MOVWF  xDB
03C9C:  MOVLW  44
03C9E:  MOVWF  xDA
03CA0:  MOVLB  0
03CA2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(120, IN_4_2_FILTER_B0);     // IN_4_2_FILTER_B0 
03CA6:  MOVLB  6
03CA8:  CLRF   xD9
03CAA:  MOVLW  78
03CAC:  MOVWF  xD8
03CAE:  MOVLW  03
03CB0:  MOVWF  xDB
03CB2:  MOVLW  3B
03CB4:  MOVWF  xDA
03CB6:  MOVLB  0
03CB8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(121, IN_4_2_FILTER_B1);     // IN_4_2_FILTER_B1 
03CBC:  MOVLB  6
03CBE:  CLRF   xD9
03CC0:  MOVLW  79
03CC2:  MOVWF  xD8
03CC4:  MOVLW  03
03CC6:  MOVWF  xDB
03CC8:  MOVLW  3C
03CCA:  MOVWF  xDA
03CCC:  MOVLB  0
03CCE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(122, IN_4_2_FILTER_B2);     // IN_4_2_FILTER_B2 
03CD2:  MOVLB  6
03CD4:  CLRF   xD9
03CD6:  MOVLW  7A
03CD8:  MOVWF  xD8
03CDA:  MOVLW  03
03CDC:  MOVWF  xDB
03CDE:  MOVLW  3D
03CE0:  MOVWF  xDA
03CE2:  MOVLB  0
03CE4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(123, IN_4_2_FILTER_MINUSA1);     // IN_4_2_FILTER_MINUSA1 
03CE8:  MOVLB  6
03CEA:  CLRF   xD9
03CEC:  MOVLW  7B
03CEE:  MOVWF  xD8
03CF0:  MOVLW  03
03CF2:  MOVWF  xDB
03CF4:  MOVLW  3E
03CF6:  MOVWF  xDA
03CF8:  MOVLB  0
03CFA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(124, IN_4_2_FILTER_MINUSA2);     // IN_4_2_FILTER_MINUSA2 
03CFE:  MOVLB  6
03D00:  CLRF   xD9
03D02:  MOVLW  7C
03D04:  MOVWF  xD8
03D06:  MOVLW  03
03D08:  MOVWF  xDB
03D0A:  MOVLW  3F
03D0C:  MOVWF  xDA
03D0E:  MOVLB  0
03D10:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(125, IN_4_3_FILTER_B0);     // IN_4_3_FILTER_B0 
03D14:  MOVLB  6
03D16:  CLRF   xD9
03D18:  MOVLW  7D
03D1A:  MOVWF  xD8
03D1C:  MOVLW  03
03D1E:  MOVWF  xDB
03D20:  MOVLW  36
03D22:  MOVWF  xDA
03D24:  MOVLB  0
03D26:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(126, IN_4_3_FILTER_B1);     // IN_4_3_FILTER_B1 
03D2A:  MOVLB  6
03D2C:  CLRF   xD9
03D2E:  MOVLW  7E
03D30:  MOVWF  xD8
03D32:  MOVLW  03
03D34:  MOVWF  xDB
03D36:  MOVLW  37
03D38:  MOVWF  xDA
03D3A:  MOVLB  0
03D3C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(127, IN_4_3_FILTER_B2);     // IN_4_3_FILTER_B2 
03D40:  MOVLB  6
03D42:  CLRF   xD9
03D44:  MOVLW  7F
03D46:  MOVWF  xD8
03D48:  MOVLW  03
03D4A:  MOVWF  xDB
03D4C:  MOVLW  38
03D4E:  MOVWF  xDA
03D50:  MOVLB  0
03D52:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(128, IN_4_3_FILTER_MINUSA1);     // IN_4_3_FILTER_MINUSA1 
03D56:  MOVLB  6
03D58:  CLRF   xD9
03D5A:  MOVLW  80
03D5C:  MOVWF  xD8
03D5E:  MOVLW  03
03D60:  MOVWF  xDB
03D62:  MOVLW  39
03D64:  MOVWF  xDA
03D66:  MOVLB  0
03D68:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(129, IN_4_3_FILTER_MINUSA2);     // IN_4_3_FILTER_MINUSA2 
03D6C:  MOVLB  6
03D6E:  CLRF   xD9
03D70:  MOVLW  81
03D72:  MOVWF  xD8
03D74:  MOVLW  03
03D76:  MOVWF  xDB
03D78:  MOVLW  3A
03D7A:  MOVWF  xDA
03D7C:  MOVLB  0
03D7E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(130, IN_5_1_FILTER_B0);     // IN_5_1_FILTER_B0 
03D82:  MOVLB  6
03D84:  CLRF   xD9
03D86:  MOVLW  82
03D88:  MOVWF  xD8
03D8A:  MOVLW  03
03D8C:  MOVWF  xDB
03D8E:  MOVLW  31
03D90:  MOVWF  xDA
03D92:  MOVLB  0
03D94:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(131, IN_5_1_FILTER_B1);     // IN_5_1_FILTER_B1 
03D98:  MOVLB  6
03D9A:  CLRF   xD9
03D9C:  MOVLW  83
03D9E:  MOVWF  xD8
03DA0:  MOVLW  03
03DA2:  MOVWF  xDB
03DA4:  MOVLW  32
03DA6:  MOVWF  xDA
03DA8:  MOVLB  0
03DAA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(132, IN_5_1_FILTER_B2);     // IN_5_1_FILTER_B2 
03DAE:  MOVLB  6
03DB0:  CLRF   xD9
03DB2:  MOVLW  84
03DB4:  MOVWF  xD8
03DB6:  MOVLW  03
03DB8:  MOVWF  xDB
03DBA:  MOVLW  33
03DBC:  MOVWF  xDA
03DBE:  MOVLB  0
03DC0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(133, IN_5_1_FILTER_MINUSA1);     // IN_5_1_FILTER_MINUSA1 
03DC4:  MOVLB  6
03DC6:  CLRF   xD9
03DC8:  MOVLW  85
03DCA:  MOVWF  xD8
03DCC:  MOVLW  03
03DCE:  MOVWF  xDB
03DD0:  MOVLW  34
03DD2:  MOVWF  xDA
03DD4:  MOVLB  0
03DD6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(134, IN_5_1_FILTER_MINUSA2);     // IN_5_1_FILTER_MINUSA2 
03DDA:  MOVLB  6
03DDC:  CLRF   xD9
03DDE:  MOVLW  86
03DE0:  MOVWF  xD8
03DE2:  MOVLW  03
03DE4:  MOVWF  xDB
03DE6:  MOVLW  35
03DE8:  MOVWF  xDA
03DEA:  MOVLB  0
03DEC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(135, IN_5_2_FILTER_B0);     // IN_5_2_FILTER_B0 
03DF0:  MOVLB  6
03DF2:  CLRF   xD9
03DF4:  MOVLW  87
03DF6:  MOVWF  xD8
03DF8:  MOVLW  03
03DFA:  MOVWF  xDB
03DFC:  MOVLW  2C
03DFE:  MOVWF  xDA
03E00:  MOVLB  0
03E02:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(136, IN_5_2_FILTER_B1);     // IN_5_2_FILTER_B1 
03E06:  MOVLB  6
03E08:  CLRF   xD9
03E0A:  MOVLW  88
03E0C:  MOVWF  xD8
03E0E:  MOVLW  03
03E10:  MOVWF  xDB
03E12:  MOVLW  2D
03E14:  MOVWF  xDA
03E16:  MOVLB  0
03E18:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(137, IN_5_2_FILTER_B2);     // IN_5_2_FILTER_B2 
03E1C:  MOVLB  6
03E1E:  CLRF   xD9
03E20:  MOVLW  89
03E22:  MOVWF  xD8
03E24:  MOVLW  03
03E26:  MOVWF  xDB
03E28:  MOVLW  2E
03E2A:  MOVWF  xDA
03E2C:  MOVLB  0
03E2E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(138, IN_5_2_FILTER_MINUSA1);     // IN_5_2_FILTER_MINUSA1 
03E32:  MOVLB  6
03E34:  CLRF   xD9
03E36:  MOVLW  8A
03E38:  MOVWF  xD8
03E3A:  MOVLW  03
03E3C:  MOVWF  xDB
03E3E:  MOVLW  2F
03E40:  MOVWF  xDA
03E42:  MOVLB  0
03E44:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(139, IN_5_2_FILTER_MINUSA2);     // IN_5_2_FILTER_MINUSA2 
03E48:  MOVLB  6
03E4A:  CLRF   xD9
03E4C:  MOVLW  8B
03E4E:  MOVWF  xD8
03E50:  MOVLW  03
03E52:  MOVWF  xDB
03E54:  MOVLW  30
03E56:  MOVWF  xDA
03E58:  MOVLB  0
03E5A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(140, IN_5_3_FILTER_B0);     // IN_5_3_FILTER_B0 
03E5E:  MOVLB  6
03E60:  CLRF   xD9
03E62:  MOVLW  8C
03E64:  MOVWF  xD8
03E66:  MOVLW  03
03E68:  MOVWF  xDB
03E6A:  MOVLW  27
03E6C:  MOVWF  xDA
03E6E:  MOVLB  0
03E70:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(141, IN_5_3_FILTER_B1);     // IN_5_3_FILTER_B1 
03E74:  MOVLB  6
03E76:  CLRF   xD9
03E78:  MOVLW  8D
03E7A:  MOVWF  xD8
03E7C:  MOVLW  03
03E7E:  MOVWF  xDB
03E80:  MOVLW  28
03E82:  MOVWF  xDA
03E84:  MOVLB  0
03E86:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(142, IN_5_3_FILTER_B2);     // IN_5_3_FILTER_B2 
03E8A:  MOVLB  6
03E8C:  CLRF   xD9
03E8E:  MOVLW  8E
03E90:  MOVWF  xD8
03E92:  MOVLW  03
03E94:  MOVWF  xDB
03E96:  MOVLW  29
03E98:  MOVWF  xDA
03E9A:  MOVLB  0
03E9C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(143, IN_5_3_FILTER_MINUSA1);     // IN_5_3_FILTER_MINUSA1 
03EA0:  MOVLB  6
03EA2:  CLRF   xD9
03EA4:  MOVLW  8F
03EA6:  MOVWF  xD8
03EA8:  MOVLW  03
03EAA:  MOVWF  xDB
03EAC:  MOVLW  2A
03EAE:  MOVWF  xDA
03EB0:  MOVLB  0
03EB2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(144, IN_5_3_FILTER_MINUSA2);     // IN_5_3_FILTER_MINUSA2 
03EB6:  MOVLB  6
03EB8:  CLRF   xD9
03EBA:  MOVLW  90
03EBC:  MOVWF  xD8
03EBE:  MOVLW  03
03EC0:  MOVWF  xDB
03EC2:  MOVLW  2B
03EC4:  MOVWF  xDA
03EC6:  MOVLB  0
03EC8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(145, IN_6_1_FILTER_B0);     // IN_6_1_FILTER_B0 
03ECC:  MOVLB  6
03ECE:  CLRF   xD9
03ED0:  MOVLW  91
03ED2:  MOVWF  xD8
03ED4:  MOVLW  03
03ED6:  MOVWF  xDB
03ED8:  MOVLW  22
03EDA:  MOVWF  xDA
03EDC:  MOVLB  0
03EDE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(146, IN_6_1_FILTER_B1);     // IN_6_1_FILTER_B1 
03EE2:  MOVLB  6
03EE4:  CLRF   xD9
03EE6:  MOVLW  92
03EE8:  MOVWF  xD8
03EEA:  MOVLW  03
03EEC:  MOVWF  xDB
03EEE:  MOVLW  23
03EF0:  MOVWF  xDA
03EF2:  MOVLB  0
03EF4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(147, IN_6_1_FILTER_B2);     // IN_6_1_FILTER_B2 
03EF8:  MOVLB  6
03EFA:  CLRF   xD9
03EFC:  MOVLW  93
03EFE:  MOVWF  xD8
03F00:  MOVLW  03
03F02:  MOVWF  xDB
03F04:  MOVLW  24
03F06:  MOVWF  xDA
03F08:  MOVLB  0
03F0A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(148, IN_6_1_FILTER_MINUSA1);     // IN_6_1_FILTER_MINUSA1 
03F0E:  MOVLB  6
03F10:  CLRF   xD9
03F12:  MOVLW  94
03F14:  MOVWF  xD8
03F16:  MOVLW  03
03F18:  MOVWF  xDB
03F1A:  MOVLW  25
03F1C:  MOVWF  xDA
03F1E:  MOVLB  0
03F20:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(149, IN_6_1_FILTER_MINUSA2);     // IN_6_1_FILTER_MINUSA2 
03F24:  MOVLB  6
03F26:  CLRF   xD9
03F28:  MOVLW  95
03F2A:  MOVWF  xD8
03F2C:  MOVLW  03
03F2E:  MOVWF  xDB
03F30:  MOVLW  26
03F32:  MOVWF  xDA
03F34:  MOVLB  0
03F36:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(150, IN_6_2_FILTER_B0);     // IN_6_2_FILTER_B0 
03F3A:  MOVLB  6
03F3C:  CLRF   xD9
03F3E:  MOVLW  96
03F40:  MOVWF  xD8
03F42:  MOVLW  03
03F44:  MOVWF  xDB
03F46:  MOVLW  1D
03F48:  MOVWF  xDA
03F4A:  MOVLB  0
03F4C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(151, IN_6_2_FILTER_B1);     // IN_6_2_FILTER_B1 
03F50:  MOVLB  6
03F52:  CLRF   xD9
03F54:  MOVLW  97
03F56:  MOVWF  xD8
03F58:  MOVLW  03
03F5A:  MOVWF  xDB
03F5C:  MOVLW  1E
03F5E:  MOVWF  xDA
03F60:  MOVLB  0
03F62:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(152, IN_6_2_FILTER_B2);     // IN_6_2_FILTER_B2 
03F66:  MOVLB  6
03F68:  CLRF   xD9
03F6A:  MOVLW  98
03F6C:  MOVWF  xD8
03F6E:  MOVLW  03
03F70:  MOVWF  xDB
03F72:  MOVLW  1F
03F74:  MOVWF  xDA
03F76:  MOVLB  0
03F78:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(153, IN_6_2_FILTER_MINUSA1);     // IN_6_2_FILTER_MINUSA1 
03F7C:  MOVLB  6
03F7E:  CLRF   xD9
03F80:  MOVLW  99
03F82:  MOVWF  xD8
03F84:  MOVLW  03
03F86:  MOVWF  xDB
03F88:  MOVLW  20
03F8A:  MOVWF  xDA
03F8C:  MOVLB  0
03F8E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(154, IN_6_2_FILTER_MINUSA2);     // IN_6_2_FILTER_MINUSA2 
03F92:  MOVLB  6
03F94:  CLRF   xD9
03F96:  MOVLW  9A
03F98:  MOVWF  xD8
03F9A:  MOVLW  03
03F9C:  MOVWF  xDB
03F9E:  MOVLW  21
03FA0:  MOVWF  xDA
03FA2:  MOVLB  0
03FA4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(155, IN_6_3_FILTER_B0);     // IN_6_3_FILTER_B0 
03FA8:  MOVLB  6
03FAA:  CLRF   xD9
03FAC:  MOVLW  9B
03FAE:  MOVWF  xD8
03FB0:  MOVLW  03
03FB2:  MOVWF  xDB
03FB4:  MOVLW  18
03FB6:  MOVWF  xDA
03FB8:  MOVLB  0
03FBA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(156, IN_6_3_FILTER_B1);     // IN_6_3_FILTER_B1 
03FBE:  MOVLB  6
03FC0:  CLRF   xD9
03FC2:  MOVLW  9C
03FC4:  MOVWF  xD8
03FC6:  MOVLW  03
03FC8:  MOVWF  xDB
03FCA:  MOVLW  19
03FCC:  MOVWF  xDA
03FCE:  MOVLB  0
03FD0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(157, IN_6_3_FILTER_B2);     // IN_6_3_FILTER_B2 
03FD4:  MOVLB  6
03FD6:  CLRF   xD9
03FD8:  MOVLW  9D
03FDA:  MOVWF  xD8
03FDC:  MOVLW  03
03FDE:  MOVWF  xDB
03FE0:  MOVLW  1A
03FE2:  MOVWF  xDA
03FE4:  MOVLB  0
03FE6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(158, IN_6_3_FILTER_MINUSA1);     // IN_6_3_FILTER_MINUSA1 
03FEA:  MOVLB  6
03FEC:  CLRF   xD9
03FEE:  MOVLW  9E
03FF0:  MOVWF  xD8
03FF2:  MOVLW  03
03FF4:  MOVWF  xDB
03FF6:  MOVLW  1B
03FF8:  MOVWF  xDA
03FFA:  MOVLB  0
03FFC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(159, IN_6_3_FILTER_MINUSA2);     // IN_6_3_FILTER_MINUSA2 
04000:  MOVLB  6
04002:  CLRF   xD9
04004:  MOVLW  9F
04006:  MOVWF  xD8
04008:  MOVLW  03
0400A:  MOVWF  xDB
0400C:  MOVLW  1C
0400E:  MOVWF  xDA
04010:  MOVLB  0
04012:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(160, IN_7_1_FILTER_B0);     // IN_7_1_FILTER_B0 
04016:  MOVLB  6
04018:  CLRF   xD9
0401A:  MOVLW  A0
0401C:  MOVWF  xD8
0401E:  MOVLW  03
04020:  MOVWF  xDB
04022:  MOVLW  13
04024:  MOVWF  xDA
04026:  MOVLB  0
04028:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(161, IN_7_1_FILTER_B1);     // IN_7_1_FILTER_B1 
0402C:  MOVLB  6
0402E:  CLRF   xD9
04030:  MOVLW  A1
04032:  MOVWF  xD8
04034:  MOVLW  03
04036:  MOVWF  xDB
04038:  MOVLW  14
0403A:  MOVWF  xDA
0403C:  MOVLB  0
0403E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(162, IN_7_1_FILTER_B2);     // IN_7_1_FILTER_B2 
04042:  MOVLB  6
04044:  CLRF   xD9
04046:  MOVLW  A2
04048:  MOVWF  xD8
0404A:  MOVLW  03
0404C:  MOVWF  xDB
0404E:  MOVLW  15
04050:  MOVWF  xDA
04052:  MOVLB  0
04054:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(163, IN_7_1_FILTER_MINUSA1);     // IN_7_1_FILTER_MINUSA1 
04058:  MOVLB  6
0405A:  CLRF   xD9
0405C:  MOVLW  A3
0405E:  MOVWF  xD8
04060:  MOVLW  03
04062:  MOVWF  xDB
04064:  MOVLW  16
04066:  MOVWF  xDA
04068:  MOVLB  0
0406A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(164, IN_7_1_FILTER_MINUSA2);     // IN_7_1_FILTER_MINUSA2 
0406E:  MOVLB  6
04070:  CLRF   xD9
04072:  MOVLW  A4
04074:  MOVWF  xD8
04076:  MOVLW  03
04078:  MOVWF  xDB
0407A:  MOVLW  17
0407C:  MOVWF  xDA
0407E:  MOVLB  0
04080:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(165, IN_7_2_FILTER_B0);     // IN_7_2_FILTER_B0 
04084:  MOVLB  6
04086:  CLRF   xD9
04088:  MOVLW  A5
0408A:  MOVWF  xD8
0408C:  MOVLW  03
0408E:  MOVWF  xDB
04090:  MOVLW  0E
04092:  MOVWF  xDA
04094:  MOVLB  0
04096:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(166, IN_7_2_FILTER_B1);     // IN_7_2_FILTER_B1 
0409A:  MOVLB  6
0409C:  CLRF   xD9
0409E:  MOVLW  A6
040A0:  MOVWF  xD8
040A2:  MOVLW  03
040A4:  MOVWF  xDB
040A6:  MOVLW  0F
040A8:  MOVWF  xDA
040AA:  MOVLB  0
040AC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(167, IN_7_2_FILTER_B2);     // IN_7_2_FILTER_B2 
040B0:  MOVLB  6
040B2:  CLRF   xD9
040B4:  MOVLW  A7
040B6:  MOVWF  xD8
040B8:  MOVLW  03
040BA:  MOVWF  xDB
040BC:  MOVLW  10
040BE:  MOVWF  xDA
040C0:  MOVLB  0
040C2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(168, IN_7_2_FILTER_MINUSA1);     // IN_7_2_FILTER_MINUSA1 
040C6:  MOVLB  6
040C8:  CLRF   xD9
040CA:  MOVLW  A8
040CC:  MOVWF  xD8
040CE:  MOVLW  03
040D0:  MOVWF  xDB
040D2:  MOVLW  11
040D4:  MOVWF  xDA
040D6:  MOVLB  0
040D8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(169, IN_7_2_FILTER_MINUSA2);     // IN_7_2_FILTER_MINUSA2 
040DC:  MOVLB  6
040DE:  CLRF   xD9
040E0:  MOVLW  A9
040E2:  MOVWF  xD8
040E4:  MOVLW  03
040E6:  MOVWF  xDB
040E8:  MOVLW  12
040EA:  MOVWF  xDA
040EC:  MOVLB  0
040EE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(170, IN_7_3_FILTER_B0);     // IN_7_3_FILTER_B0 
040F2:  MOVLB  6
040F4:  CLRF   xD9
040F6:  MOVLW  AA
040F8:  MOVWF  xD8
040FA:  MOVLW  03
040FC:  MOVWF  xDB
040FE:  MOVLW  09
04100:  MOVWF  xDA
04102:  MOVLB  0
04104:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(171, IN_7_3_FILTER_B1);     // IN_7_3_FILTER_B1 
04108:  MOVLB  6
0410A:  CLRF   xD9
0410C:  MOVLW  AB
0410E:  MOVWF  xD8
04110:  MOVLW  03
04112:  MOVWF  xDB
04114:  MOVLW  0A
04116:  MOVWF  xDA
04118:  MOVLB  0
0411A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(172, IN_7_3_FILTER_B2);     // IN_7_3_FILTER_B2 
0411E:  MOVLB  6
04120:  CLRF   xD9
04122:  MOVLW  AC
04124:  MOVWF  xD8
04126:  MOVLW  03
04128:  MOVWF  xDB
0412A:  MOVLW  0B
0412C:  MOVWF  xDA
0412E:  MOVLB  0
04130:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(173, IN_7_3_FILTER_MINUSA1);     // IN_7_3_FILTER_MINUSA1 
04134:  MOVLB  6
04136:  CLRF   xD9
04138:  MOVLW  AD
0413A:  MOVWF  xD8
0413C:  MOVLW  03
0413E:  MOVWF  xDB
04140:  MOVLW  0C
04142:  MOVWF  xDA
04144:  MOVLB  0
04146:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(174, IN_7_3_FILTER_MINUSA2);     // IN_7_3_FILTER_MINUSA2 
0414A:  MOVLB  6
0414C:  CLRF   xD9
0414E:  MOVLW  AE
04150:  MOVWF  xD8
04152:  MOVLW  03
04154:  MOVWF  xDB
04156:  MOVLW  0D
04158:  MOVWF  xDA
0415A:  MOVLB  0
0415C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(175, IN_8_1_FILTER_B0);     // IN_8_1_FILTER_B0 
04160:  MOVLB  6
04162:  CLRF   xD9
04164:  MOVLW  AF
04166:  MOVWF  xD8
04168:  MOVLW  03
0416A:  MOVWF  xDB
0416C:  MOVLW  04
0416E:  MOVWF  xDA
04170:  MOVLB  0
04172:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(176, IN_8_1_FILTER_B1);     // IN_8_1_FILTER_B1 
04176:  MOVLB  6
04178:  CLRF   xD9
0417A:  MOVLW  B0
0417C:  MOVWF  xD8
0417E:  MOVLW  03
04180:  MOVWF  xDB
04182:  MOVLW  05
04184:  MOVWF  xDA
04186:  MOVLB  0
04188:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(177, IN_8_1_FILTER_B2);     // IN_8_1_FILTER_B2 
0418C:  MOVLB  6
0418E:  CLRF   xD9
04190:  MOVLW  B1
04192:  MOVWF  xD8
04194:  MOVLW  03
04196:  MOVWF  xDB
04198:  MOVLW  06
0419A:  MOVWF  xDA
0419C:  MOVLB  0
0419E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(178, IN_8_1_FILTER_MINUSA1);     // IN_8_1_FILTER_MINUSA1 
041A2:  MOVLB  6
041A4:  CLRF   xD9
041A6:  MOVLW  B2
041A8:  MOVWF  xD8
041AA:  MOVLW  03
041AC:  MOVWF  xDB
041AE:  MOVLW  07
041B0:  MOVWF  xDA
041B2:  MOVLB  0
041B4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(179, IN_8_1_FILTER_MINUSA2);     // IN_8_1_FILTER_MINUSA2 
041B8:  MOVLB  6
041BA:  CLRF   xD9
041BC:  MOVLW  B3
041BE:  MOVWF  xD8
041C0:  MOVLW  03
041C2:  MOVWF  xDB
041C4:  MOVLW  08
041C6:  MOVWF  xDA
041C8:  MOVLB  0
041CA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(180, IN_8_2_FILTER_B0);     // IN_8_2_FILTER_B0 
041CE:  MOVLB  6
041D0:  CLRF   xD9
041D2:  MOVLW  B4
041D4:  MOVWF  xD8
041D6:  MOVLW  02
041D8:  MOVWF  xDB
041DA:  SETF   xDA
041DC:  MOVLB  0
041DE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(181, IN_8_2_FILTER_B1);     // IN_8_2_FILTER_B1 
041E2:  MOVLB  6
041E4:  CLRF   xD9
041E6:  MOVLW  B5
041E8:  MOVWF  xD8
041EA:  MOVLW  03
041EC:  MOVWF  xDB
041EE:  CLRF   xDA
041F0:  MOVLB  0
041F2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(182, IN_8_2_FILTER_B2);     // IN_8_2_FILTER_B2 
041F6:  MOVLB  6
041F8:  CLRF   xD9
041FA:  MOVLW  B6
041FC:  MOVWF  xD8
041FE:  MOVLW  03
04200:  MOVWF  xDB
04202:  MOVLW  01
04204:  MOVWF  xDA
04206:  MOVLB  0
04208:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(183, IN_8_2_FILTER_MINUSA1);     // IN_8_2_FILTER_MINUSA1 
0420C:  MOVLB  6
0420E:  CLRF   xD9
04210:  MOVLW  B7
04212:  MOVWF  xD8
04214:  MOVLW  03
04216:  MOVWF  xDB
04218:  MOVLW  02
0421A:  MOVWF  xDA
0421C:  MOVLB  0
0421E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(184, IN_8_2_FILTER_MINUSA2);     // IN_8_2_FILTER_MINUSA2 
04222:  MOVLB  6
04224:  CLRF   xD9
04226:  MOVLW  B8
04228:  MOVWF  xD8
0422A:  MOVLW  03
0422C:  MOVWF  xDB
0422E:  MOVWF  xDA
04230:  MOVLB  0
04232:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(185, IN_8_3_FILTER_B0);     // IN_8_3_FILTER_B0 
04236:  MOVLB  6
04238:  CLRF   xD9
0423A:  MOVLW  B9
0423C:  MOVWF  xD8
0423E:  MOVLW  02
04240:  MOVWF  xDB
04242:  MOVLW  FA
04244:  MOVWF  xDA
04246:  MOVLB  0
04248:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(186, IN_8_3_FILTER_B1);     // IN_8_3_FILTER_B1 
0424C:  MOVLB  6
0424E:  CLRF   xD9
04250:  MOVLW  BA
04252:  MOVWF  xD8
04254:  MOVLW  02
04256:  MOVWF  xDB
04258:  MOVLW  FB
0425A:  MOVWF  xDA
0425C:  MOVLB  0
0425E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(187, IN_8_3_FILTER_B2);     // IN_8_3_FILTER_B2 
04262:  MOVLB  6
04264:  CLRF   xD9
04266:  MOVLW  BB
04268:  MOVWF  xD8
0426A:  MOVLW  02
0426C:  MOVWF  xDB
0426E:  MOVLW  FC
04270:  MOVWF  xDA
04272:  MOVLB  0
04274:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(188, IN_8_3_FILTER_MINUSA1);     // IN_8_3_FILTER_MINUSA1 
04278:  MOVLB  6
0427A:  CLRF   xD9
0427C:  MOVLW  BC
0427E:  MOVWF  xD8
04280:  MOVLW  02
04282:  MOVWF  xDB
04284:  MOVLW  FD
04286:  MOVWF  xDA
04288:  MOVLB  0
0428A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(189, IN_8_3_FILTER_MINUSA2);     // IN_8_3_FILTER_MINUSA2 
0428E:  MOVLB  6
04290:  CLRF   xD9
04292:  MOVLW  BD
04294:  MOVWF  xD8
04296:  MOVLW  02
04298:  MOVWF  xDB
0429A:  MOVLW  FE
0429C:  MOVWF  xDA
0429E:  MOVLB  0
042A0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(190, CH1COMP_THRESHOLD);     // CH1COMP_THRESHOLD 
042A4:  MOVLB  6
042A6:  CLRF   xD9
042A8:  MOVLW  BE
042AA:  MOVWF  xD8
042AC:  MOVLW  02
042AE:  MOVWF  xDB
042B0:  MOVLW  6E
042B2:  MOVWF  xDA
042B4:  MOVLB  0
042B6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(191, CH1COMP_KNEE);     // CH1COMP_KNEE 
042BA:  MOVLB  6
042BC:  CLRF   xD9
042BE:  MOVLW  BF
042C0:  MOVWF  xD8
042C2:  MOVLW  02
042C4:  MOVWF  xDB
042C6:  MOVLW  6F
042C8:  MOVWF  xDA
042CA:  MOVLB  0
042CC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(192, CH1COMP_RATIO);     // CH1COMP_RATIO 
042D0:  MOVLB  6
042D2:  CLRF   xD9
042D4:  MOVLW  C0
042D6:  MOVWF  xD8
042D8:  MOVLW  02
042DA:  MOVWF  xDB
042DC:  MOVLW  70
042DE:  MOVWF  xDA
042E0:  MOVLB  0
042E2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(193, CH1COMP_ATTACK);     // CH1COMP_ATTACK 
042E6:  MOVLB  6
042E8:  CLRF   xD9
042EA:  MOVLW  C1
042EC:  MOVWF  xD8
042EE:  MOVLW  02
042F0:  MOVWF  xDB
042F2:  MOVLW  71
042F4:  MOVWF  xDA
042F6:  MOVLB  0
042F8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(194, CH1COMP_RELEASE);     // CH1COMP_RELEASE 
042FC:  MOVLB  6
042FE:  CLRF   xD9
04300:  MOVLW  C2
04302:  MOVWF  xD8
04304:  MOVLW  02
04306:  MOVWF  xDB
04308:  MOVLW  72
0430A:  MOVWF  xDA
0430C:  MOVLB  0
0430E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(195, CH1COMP_BYPASS);     // CH1COMP_BYPASS 
04312:  MOVLB  6
04314:  CLRF   xD9
04316:  MOVLW  C3
04318:  MOVWF  xD8
0431A:  MOVLW  02
0431C:  MOVWF  xDB
0431E:  MOVLW  73
04320:  MOVWF  xDA
04322:  MOVLB  0
04324:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(196, CH2COMP_THRESHOLD);     // CH2COMP_THRESHOLD 
04328:  MOVLB  6
0432A:  CLRF   xD9
0432C:  MOVLW  C4
0432E:  MOVWF  xD8
04330:  MOVLW  02
04332:  MOVWF  xDB
04334:  MOVLW  66
04336:  MOVWF  xDA
04338:  MOVLB  0
0433A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(197, CH2COMP_KNEE);     // CH2COMP_KNEE 
0433E:  MOVLB  6
04340:  CLRF   xD9
04342:  MOVLW  C5
04344:  MOVWF  xD8
04346:  MOVLW  02
04348:  MOVWF  xDB
0434A:  MOVLW  67
0434C:  MOVWF  xDA
0434E:  MOVLB  0
04350:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(198, CH2COMP_RATIO);     // CH2COMP_RATIO 
04354:  MOVLB  6
04356:  CLRF   xD9
04358:  MOVLW  C6
0435A:  MOVWF  xD8
0435C:  MOVLW  02
0435E:  MOVWF  xDB
04360:  MOVLW  68
04362:  MOVWF  xDA
04364:  MOVLB  0
04366:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(199, CH2COMP_ATTACK);     // CH2COMP_ATTACK 
0436A:  MOVLB  6
0436C:  CLRF   xD9
0436E:  MOVLW  C7
04370:  MOVWF  xD8
04372:  MOVLW  02
04374:  MOVWF  xDB
04376:  MOVLW  69
04378:  MOVWF  xDA
0437A:  MOVLB  0
0437C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(200, CH2COMP_RELEASE);     // CH2COMP_RELEASE 
04380:  MOVLB  6
04382:  CLRF   xD9
04384:  MOVLW  C8
04386:  MOVWF  xD8
04388:  MOVLW  02
0438A:  MOVWF  xDB
0438C:  MOVLW  6A
0438E:  MOVWF  xDA
04390:  MOVLB  0
04392:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(201, CH2COMP_BYPASS);     // CH2COMP_BYPASS 
04396:  MOVLB  6
04398:  CLRF   xD9
0439A:  MOVLW  C9
0439C:  MOVWF  xD8
0439E:  MOVLW  02
043A0:  MOVWF  xDB
043A2:  MOVLW  6B
043A4:  MOVWF  xDA
043A6:  MOVLB  0
043A8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(202, CH3COMP_THRESHOLD);     // CH3COMP_THRESHOLD 
043AC:  MOVLB  6
043AE:  CLRF   xD9
043B0:  MOVLW  CA
043B2:  MOVWF  xD8
043B4:  MOVLW  02
043B6:  MOVWF  xDB
043B8:  MOVLW  5E
043BA:  MOVWF  xDA
043BC:  MOVLB  0
043BE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(203, CH3COMP_KNEE);     // CH3COMP_KNEE 
043C2:  MOVLB  6
043C4:  CLRF   xD9
043C6:  MOVLW  CB
043C8:  MOVWF  xD8
043CA:  MOVLW  02
043CC:  MOVWF  xDB
043CE:  MOVLW  5F
043D0:  MOVWF  xDA
043D2:  MOVLB  0
043D4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(204, CH3COMP_RATIO);     // CH3COMP_RATIO 
043D8:  MOVLB  6
043DA:  CLRF   xD9
043DC:  MOVLW  CC
043DE:  MOVWF  xD8
043E0:  MOVLW  02
043E2:  MOVWF  xDB
043E4:  MOVLW  60
043E6:  MOVWF  xDA
043E8:  MOVLB  0
043EA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(205, CH3COMP_ATTACK);     // CH3COMP_ATTACK 
043EE:  MOVLB  6
043F0:  CLRF   xD9
043F2:  MOVLW  CD
043F4:  MOVWF  xD8
043F6:  MOVLW  02
043F8:  MOVWF  xDB
043FA:  MOVLW  61
043FC:  MOVWF  xDA
043FE:  MOVLB  0
04400:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(206, CH3COMP_RELEASE);     // CH3COMP_RELEASE 
04404:  MOVLB  6
04406:  CLRF   xD9
04408:  MOVLW  CE
0440A:  MOVWF  xD8
0440C:  MOVLW  02
0440E:  MOVWF  xDB
04410:  MOVLW  62
04412:  MOVWF  xDA
04414:  MOVLB  0
04416:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(207, CH3COMP_BYPASS);     // CH3COMP_BYPASS 
0441A:  MOVLB  6
0441C:  CLRF   xD9
0441E:  MOVLW  CF
04420:  MOVWF  xD8
04422:  MOVLW  02
04424:  MOVWF  xDB
04426:  MOVLW  63
04428:  MOVWF  xDA
0442A:  MOVLB  0
0442C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(208, CH4COMP_THRESHOLD);     // CH4COMP_THRESHOLD 
04430:  MOVLB  6
04432:  CLRF   xD9
04434:  MOVLW  D0
04436:  MOVWF  xD8
04438:  MOVLW  02
0443A:  MOVWF  xDB
0443C:  MOVLW  56
0443E:  MOVWF  xDA
04440:  MOVLB  0
04442:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(209, CH4COMP_KNEE);     // CH4COMP_KNEE 
04446:  MOVLB  6
04448:  CLRF   xD9
0444A:  MOVLW  D1
0444C:  MOVWF  xD8
0444E:  MOVLW  02
04450:  MOVWF  xDB
04452:  MOVLW  57
04454:  MOVWF  xDA
04456:  MOVLB  0
04458:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(210, CH4COMP_RATIO);     // CH4COMP_RATIO 
0445C:  MOVLB  6
0445E:  CLRF   xD9
04460:  MOVLW  D2
04462:  MOVWF  xD8
04464:  MOVLW  02
04466:  MOVWF  xDB
04468:  MOVLW  58
0446A:  MOVWF  xDA
0446C:  MOVLB  0
0446E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(211, CH4COMP_ATTACK);     // CH4COMP_ATTACK 
04472:  MOVLB  6
04474:  CLRF   xD9
04476:  MOVLW  D3
04478:  MOVWF  xD8
0447A:  MOVLW  02
0447C:  MOVWF  xDB
0447E:  MOVLW  59
04480:  MOVWF  xDA
04482:  MOVLB  0
04484:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(212, CH4COMP_RELEASE);     // CH4COMP_RELEASE 
04488:  MOVLB  6
0448A:  CLRF   xD9
0448C:  MOVLW  D4
0448E:  MOVWF  xD8
04490:  MOVLW  02
04492:  MOVWF  xDB
04494:  MOVLW  5A
04496:  MOVWF  xDA
04498:  MOVLB  0
0449A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(213, CH4COMP_BYPASS);     // CH4COMP_BYPASS 
0449E:  MOVLB  6
044A0:  CLRF   xD9
044A2:  MOVLW  D5
044A4:  MOVWF  xD8
044A6:  MOVLW  02
044A8:  MOVWF  xDB
044AA:  MOVLW  5B
044AC:  MOVWF  xDA
044AE:  MOVLB  0
044B0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(214, CH5COMP_THRESHOLD);     // CH5COMP_THRESHOLD 
044B4:  MOVLB  6
044B6:  CLRF   xD9
044B8:  MOVLW  D6
044BA:  MOVWF  xD8
044BC:  MOVLW  02
044BE:  MOVWF  xDB
044C0:  MOVLW  4E
044C2:  MOVWF  xDA
044C4:  MOVLB  0
044C6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(215, CH5COMP_KNEE);     // CH5COMP_KNEE 
044CA:  MOVLB  6
044CC:  CLRF   xD9
044CE:  MOVLW  D7
044D0:  MOVWF  xD8
044D2:  MOVLW  02
044D4:  MOVWF  xDB
044D6:  MOVLW  4F
044D8:  MOVWF  xDA
044DA:  MOVLB  0
044DC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(216, CH5COMP_RATIO);     // CH5COMP_RATIO 
044E0:  MOVLB  6
044E2:  CLRF   xD9
044E4:  MOVLW  D8
044E6:  MOVWF  xD8
044E8:  MOVLW  02
044EA:  MOVWF  xDB
044EC:  MOVLW  50
044EE:  MOVWF  xDA
044F0:  MOVLB  0
044F2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(217, CH5COMP_ATTACK);     // CH5COMP_ATTACK 
044F6:  MOVLB  6
044F8:  CLRF   xD9
044FA:  MOVLW  D9
044FC:  MOVWF  xD8
044FE:  MOVLW  02
04500:  MOVWF  xDB
04502:  MOVLW  51
04504:  MOVWF  xDA
04506:  MOVLB  0
04508:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(218, CH5COMP_RELEASE);     // CH5COMP_RELEASE 
0450C:  MOVLB  6
0450E:  CLRF   xD9
04510:  MOVLW  DA
04512:  MOVWF  xD8
04514:  MOVLW  02
04516:  MOVWF  xDB
04518:  MOVLW  52
0451A:  MOVWF  xDA
0451C:  MOVLB  0
0451E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(219, CH5COMP_BYPASS);     // CH5COMP_BYPASS 
04522:  MOVLB  6
04524:  CLRF   xD9
04526:  MOVLW  DB
04528:  MOVWF  xD8
0452A:  MOVLW  02
0452C:  MOVWF  xDB
0452E:  MOVLW  53
04530:  MOVWF  xDA
04532:  MOVLB  0
04534:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(220, CH6COMP_THRESHOLD);     // CH6COMP_THRESHOLD 
04538:  MOVLB  6
0453A:  CLRF   xD9
0453C:  MOVLW  DC
0453E:  MOVWF  xD8
04540:  MOVLW  02
04542:  MOVWF  xDB
04544:  MOVLW  46
04546:  MOVWF  xDA
04548:  MOVLB  0
0454A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(221, CH6COMP_KNEE);     // CH6COMP_KNEE 
0454E:  MOVLB  6
04550:  CLRF   xD9
04552:  MOVLW  DD
04554:  MOVWF  xD8
04556:  MOVLW  02
04558:  MOVWF  xDB
0455A:  MOVLW  47
0455C:  MOVWF  xDA
0455E:  MOVLB  0
04560:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(222, CH6COMP_RATIO);     // CH6COMP_RATIO 
04564:  MOVLB  6
04566:  CLRF   xD9
04568:  MOVLW  DE
0456A:  MOVWF  xD8
0456C:  MOVLW  02
0456E:  MOVWF  xDB
04570:  MOVLW  48
04572:  MOVWF  xDA
04574:  MOVLB  0
04576:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(223, CH6COMP_ATTACK);     // CH6COMP_ATTACK 
0457A:  MOVLB  6
0457C:  CLRF   xD9
0457E:  MOVLW  DF
04580:  MOVWF  xD8
04582:  MOVLW  02
04584:  MOVWF  xDB
04586:  MOVLW  49
04588:  MOVWF  xDA
0458A:  MOVLB  0
0458C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(224, CH6COMP_RELEASE);     // CH6COMP_RELEASE 
04590:  MOVLB  6
04592:  CLRF   xD9
04594:  MOVLW  E0
04596:  MOVWF  xD8
04598:  MOVLW  02
0459A:  MOVWF  xDB
0459C:  MOVLW  4A
0459E:  MOVWF  xDA
045A0:  MOVLB  0
045A2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(225, CH6COMP_BYPASS);     // CH6COMP_BYPASS 
045A6:  MOVLB  6
045A8:  CLRF   xD9
045AA:  MOVLW  E1
045AC:  MOVWF  xD8
045AE:  MOVLW  02
045B0:  MOVWF  xDB
045B2:  MOVLW  4B
045B4:  MOVWF  xDA
045B6:  MOVLB  0
045B8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(226, CH7COMP_THRESHOLD);     // CH7COMP_THRESHOLD 
045BC:  MOVLB  6
045BE:  CLRF   xD9
045C0:  MOVLW  E2
045C2:  MOVWF  xD8
045C4:  MOVLW  02
045C6:  MOVWF  xDB
045C8:  MOVLW  3E
045CA:  MOVWF  xDA
045CC:  MOVLB  0
045CE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(227, CH7COMP_KNEE);     // CH7COMP_KNEE 
045D2:  MOVLB  6
045D4:  CLRF   xD9
045D6:  MOVLW  E3
045D8:  MOVWF  xD8
045DA:  MOVLW  02
045DC:  MOVWF  xDB
045DE:  MOVLW  3F
045E0:  MOVWF  xDA
045E2:  MOVLB  0
045E4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(228, CH7COMP_RATIO);     // CH7COMP_RATIO 
045E8:  MOVLB  6
045EA:  CLRF   xD9
045EC:  MOVLW  E4
045EE:  MOVWF  xD8
045F0:  MOVLW  02
045F2:  MOVWF  xDB
045F4:  MOVLW  40
045F6:  MOVWF  xDA
045F8:  MOVLB  0
045FA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(229, CH7COMP_ATTACK);     // CH7COMP_ATTACK 
045FE:  MOVLB  6
04600:  CLRF   xD9
04602:  MOVLW  E5
04604:  MOVWF  xD8
04606:  MOVLW  02
04608:  MOVWF  xDB
0460A:  MOVLW  41
0460C:  MOVWF  xDA
0460E:  MOVLB  0
04610:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(230, CH7COMP_RELEASE);     // CH7COMP_RELEASE 
04614:  MOVLB  6
04616:  CLRF   xD9
04618:  MOVLW  E6
0461A:  MOVWF  xD8
0461C:  MOVLW  02
0461E:  MOVWF  xDB
04620:  MOVLW  42
04622:  MOVWF  xDA
04624:  MOVLB  0
04626:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(231, CH7COMP_BYPASS);     // CH7COMP_BYPASS 
0462A:  MOVLB  6
0462C:  CLRF   xD9
0462E:  MOVLW  E7
04630:  MOVWF  xD8
04632:  MOVLW  02
04634:  MOVWF  xDB
04636:  MOVLW  43
04638:  MOVWF  xDA
0463A:  MOVLB  0
0463C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(232, CH8COMP_THRESHOLD);     // CH8COMP_THRESHOLD 
04640:  MOVLB  6
04642:  CLRF   xD9
04644:  MOVLW  E8
04646:  MOVWF  xD8
04648:  MOVLW  02
0464A:  MOVWF  xDB
0464C:  MOVLW  36
0464E:  MOVWF  xDA
04650:  MOVLB  0
04652:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(233, CH8COMP_KNEE);     // CH8COMP_KNEE 
04656:  MOVLB  6
04658:  CLRF   xD9
0465A:  MOVLW  E9
0465C:  MOVWF  xD8
0465E:  MOVLW  02
04660:  MOVWF  xDB
04662:  MOVLW  37
04664:  MOVWF  xDA
04666:  MOVLB  0
04668:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(234, CH8COMP_RATIO);     // CH8COMP_RATIO 
0466C:  MOVLB  6
0466E:  CLRF   xD9
04670:  MOVLW  EA
04672:  MOVWF  xD8
04674:  MOVLW  02
04676:  MOVWF  xDB
04678:  MOVLW  38
0467A:  MOVWF  xDA
0467C:  MOVLB  0
0467E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(235, CH8COMP_ATTACK);     // CH8COMP_ATTACK 
04682:  MOVLB  6
04684:  CLRF   xD9
04686:  MOVLW  EB
04688:  MOVWF  xD8
0468A:  MOVLW  02
0468C:  MOVWF  xDB
0468E:  MOVLW  39
04690:  MOVWF  xDA
04692:  MOVLB  0
04694:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(236, CH8COMP_RELEASE);     // CH8COMP_RELEASE 
04698:  MOVLB  6
0469A:  CLRF   xD9
0469C:  MOVLW  EC
0469E:  MOVWF  xD8
046A0:  MOVLW  02
046A2:  MOVWF  xDB
046A4:  MOVLW  3A
046A6:  MOVWF  xDA
046A8:  MOVLB  0
046AA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(237, CH8COMP_BYPASS);     // CH8COMP_BYPASS 
046AE:  MOVLB  6
046B0:  CLRF   xD9
046B2:  MOVLW  ED
046B4:  MOVWF  xD8
046B6:  MOVLW  02
046B8:  MOVWF  xDB
046BA:  MOVLW  3B
046BC:  MOVWF  xDA
046BE:  MOVLB  0
046C0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(238, MIXER_SELECT0);     // MIXER_SELECT0 
046C4:  MOVLB  6
046C6:  CLRF   xD9
046C8:  MOVLW  EE
046CA:  MOVWF  xD8
046CC:  CLRF   xDB
046CE:  MOVLW  03
046D0:  MOVWF  xDA
046D2:  MOVLB  0
046D4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(239, MIXER_SELECT1);     // MIXER_SELECT1 
046D8:  MOVLB  6
046DA:  CLRF   xD9
046DC:  MOVLW  EF
046DE:  MOVWF  xD8
046E0:  CLRF   xDB
046E2:  MOVLW  04
046E4:  MOVWF  xDA
046E6:  MOVLB  0
046E8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(240, MIXER_SELECT2);     // MIXER_SELECT2 
046EC:  MOVLB  6
046EE:  CLRF   xD9
046F0:  MOVLW  F0
046F2:  MOVWF  xD8
046F4:  CLRF   xDB
046F6:  MOVLW  05
046F8:  MOVWF  xDA
046FA:  MOVLB  0
046FC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(241, MIXER_SELECT3);     // MIXER_SELECT3 
04700:  MOVLB  6
04702:  CLRF   xD9
04704:  MOVLW  F1
04706:  MOVWF  xD8
04708:  CLRF   xDB
0470A:  MOVLW  06
0470C:  MOVWF  xDA
0470E:  MOVLB  0
04710:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(242, MIXER_SELECT4);     // MIXER_SELECT4 
04714:  MOVLB  6
04716:  CLRF   xD9
04718:  MOVLW  F2
0471A:  MOVWF  xD8
0471C:  CLRF   xDB
0471E:  MOVLW  07
04720:  MOVWF  xDA
04722:  MOVLB  0
04724:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(243, MIXER_SELECT5);     // MIXER_SELECT5 
04728:  MOVLB  6
0472A:  CLRF   xD9
0472C:  MOVLW  F3
0472E:  MOVWF  xD8
04730:  CLRF   xDB
04732:  MOVLW  08
04734:  MOVWF  xDA
04736:  MOVLB  0
04738:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(244, MIXER_SELECT6);     // MIXER_SELECT6 
0473C:  MOVLB  6
0473E:  CLRF   xD9
04740:  MOVLW  F4
04742:  MOVWF  xD8
04744:  CLRF   xDB
04746:  MOVLW  09
04748:  MOVWF  xDA
0474A:  MOVLB  0
0474C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(245, MIXER_SELECT7);     // MIXER_SELECT7 
04750:  MOVLB  6
04752:  CLRF   xD9
04754:  MOVLW  F5
04756:  MOVWF  xD8
04758:  CLRF   xDB
0475A:  MOVLW  0A
0475C:  MOVWF  xDA
0475E:  MOVLB  0
04760:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(246, MIXER_SELECT8);     // MIXER_SELECT8 
04764:  MOVLB  6
04766:  CLRF   xD9
04768:  MOVLW  F6
0476A:  MOVWF  xD8
0476C:  CLRF   xDB
0476E:  MOVLW  0B
04770:  MOVWF  xDA
04772:  MOVLB  0
04774:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(247, MIXER_SELECT9);     // MIXER_SELECT9 
04778:  MOVLB  6
0477A:  CLRF   xD9
0477C:  MOVLW  F7
0477E:  MOVWF  xD8
04780:  CLRF   xDB
04782:  MOVLW  0C
04784:  MOVWF  xDA
04786:  MOVLB  0
04788:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(248, MIXER_SELECT10);     // MIXER_SELECT10 
0478C:  MOVLB  6
0478E:  CLRF   xD9
04790:  MOVLW  F8
04792:  MOVWF  xD8
04794:  CLRF   xDB
04796:  MOVLW  0D
04798:  MOVWF  xDA
0479A:  MOVLB  0
0479C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(249, MIXER_SELECT11);     // MIXER_SELECT11 
047A0:  MOVLB  6
047A2:  CLRF   xD9
047A4:  MOVLW  F9
047A6:  MOVWF  xD8
047A8:  CLRF   xDB
047AA:  MOVLW  0E
047AC:  MOVWF  xDA
047AE:  MOVLB  0
047B0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(250, MIXER_SELECT12);     // MIXER_SELECT12 
047B4:  MOVLB  6
047B6:  CLRF   xD9
047B8:  MOVLW  FA
047BA:  MOVWF  xD8
047BC:  CLRF   xDB
047BE:  MOVLW  0F
047C0:  MOVWF  xDA
047C2:  MOVLB  0
047C4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(251, MIXER_SELECT13);     // MIXER_SELECT13 
047C8:  MOVLB  6
047CA:  CLRF   xD9
047CC:  MOVLW  FB
047CE:  MOVWF  xD8
047D0:  CLRF   xDB
047D2:  MOVLW  10
047D4:  MOVWF  xDA
047D6:  MOVLB  0
047D8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(252, MIXER_SELECT14);     // MIXER_SELECT14 
047DC:  MOVLB  6
047DE:  CLRF   xD9
047E0:  MOVLW  FC
047E2:  MOVWF  xD8
047E4:  CLRF   xDB
047E6:  MOVLW  11
047E8:  MOVWF  xDA
047EA:  MOVLB  0
047EC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(253, MIXER_SELECT15);     // MIXER_SELECT15 
047F0:  MOVLB  6
047F2:  CLRF   xD9
047F4:  MOVLW  FD
047F6:  MOVWF  xD8
047F8:  CLRF   xDB
047FA:  MOVLW  12
047FC:  MOVWF  xDA
047FE:  MOVLB  0
04800:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(254, MIXER_SELECT16);     // MIXER_SELECT16 
04804:  MOVLB  6
04806:  CLRF   xD9
04808:  MOVLW  FE
0480A:  MOVWF  xD8
0480C:  CLRF   xDB
0480E:  MOVLW  13
04810:  MOVWF  xDA
04812:  MOVLB  0
04814:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(255, MIXER_SELECT17);     // MIXER_SELECT17 
04818:  MOVLB  6
0481A:  CLRF   xD9
0481C:  SETF   xD8
0481E:  CLRF   xDB
04820:  MOVLW  14
04822:  MOVWF  xDA
04824:  MOVLB  0
04826:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(256, MIXER_SELECT18);     // MIXER_SELECT18 
0482A:  MOVLW  01
0482C:  MOVLB  6
0482E:  MOVWF  xD9
04830:  CLRF   xD8
04832:  CLRF   xDB
04834:  MOVLW  15
04836:  MOVWF  xDA
04838:  MOVLB  0
0483A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(257, MIXER_SELECT19);     // MIXER_SELECT19 
0483E:  MOVLW  01
04840:  MOVLB  6
04842:  MOVWF  xD9
04844:  MOVWF  xD8
04846:  CLRF   xDB
04848:  MOVLW  16
0484A:  MOVWF  xDA
0484C:  MOVLB  0
0484E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(258, MIXER_SELECT20);     // MIXER_SELECT20 
04852:  MOVLW  01
04854:  MOVLB  6
04856:  MOVWF  xD9
04858:  MOVLW  02
0485A:  MOVWF  xD8
0485C:  CLRF   xDB
0485E:  MOVLW  17
04860:  MOVWF  xDA
04862:  MOVLB  0
04864:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(259, MIXER_SELECT21);     // MIXER_SELECT21 
04868:  MOVLW  01
0486A:  MOVLB  6
0486C:  MOVWF  xD9
0486E:  MOVLW  03
04870:  MOVWF  xD8
04872:  CLRF   xDB
04874:  MOVLW  18
04876:  MOVWF  xDA
04878:  MOVLB  0
0487A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(260, MIXER_SELECT22);     // MIXER_SELECT22 
0487E:  MOVLW  01
04880:  MOVLB  6
04882:  MOVWF  xD9
04884:  MOVLW  04
04886:  MOVWF  xD8
04888:  CLRF   xDB
0488A:  MOVLW  19
0488C:  MOVWF  xDA
0488E:  MOVLB  0
04890:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(261, MIXER_SELECT23);     // MIXER_SELECT23 
04894:  MOVLW  01
04896:  MOVLB  6
04898:  MOVWF  xD9
0489A:  MOVLW  05
0489C:  MOVWF  xD8
0489E:  CLRF   xDB
048A0:  MOVLW  1A
048A2:  MOVWF  xDA
048A4:  MOVLB  0
048A6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(262, MIXER_SELECT24);     // MIXER_SELECT24 
048AA:  MOVLW  01
048AC:  MOVLB  6
048AE:  MOVWF  xD9
048B0:  MOVLW  06
048B2:  MOVWF  xD8
048B4:  CLRF   xDB
048B6:  MOVLW  1B
048B8:  MOVWF  xDA
048BA:  MOVLB  0
048BC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(263, MIXER_SELECT25);     // MIXER_SELECT25 
048C0:  MOVLW  01
048C2:  MOVLB  6
048C4:  MOVWF  xD9
048C6:  MOVLW  07
048C8:  MOVWF  xD8
048CA:  CLRF   xDB
048CC:  MOVLW  1C
048CE:  MOVWF  xDA
048D0:  MOVLB  0
048D2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(264, MIXER_SELECT26);     // MIXER_SELECT26 
048D6:  MOVLW  01
048D8:  MOVLB  6
048DA:  MOVWF  xD9
048DC:  MOVLW  08
048DE:  MOVWF  xD8
048E0:  CLRF   xDB
048E2:  MOVLW  1D
048E4:  MOVWF  xDA
048E6:  MOVLB  0
048E8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(265, MIXER_SELECT27);     // MIXER_SELECT27 
048EC:  MOVLW  01
048EE:  MOVLB  6
048F0:  MOVWF  xD9
048F2:  MOVLW  09
048F4:  MOVWF  xD8
048F6:  CLRF   xDB
048F8:  MOVLW  1E
048FA:  MOVWF  xDA
048FC:  MOVLB  0
048FE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(266, MIXER_SELECT28);     // MIXER_SELECT28 
04902:  MOVLW  01
04904:  MOVLB  6
04906:  MOVWF  xD9
04908:  MOVLW  0A
0490A:  MOVWF  xD8
0490C:  CLRF   xDB
0490E:  MOVLW  1F
04910:  MOVWF  xDA
04912:  MOVLB  0
04914:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(267, MIXER_SELECT29);     // MIXER_SELECT29 
04918:  MOVLW  01
0491A:  MOVLB  6
0491C:  MOVWF  xD9
0491E:  MOVLW  0B
04920:  MOVWF  xD8
04922:  CLRF   xDB
04924:  MOVLW  20
04926:  MOVWF  xDA
04928:  MOVLB  0
0492A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(268, MIXER_SELECT30);     // MIXER_SELECT30 
0492E:  MOVLW  01
04930:  MOVLB  6
04932:  MOVWF  xD9
04934:  MOVLW  0C
04936:  MOVWF  xD8
04938:  CLRF   xDB
0493A:  MOVLW  21
0493C:  MOVWF  xDA
0493E:  MOVLB  0
04940:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(269, MIXER_SELECT31);     // MIXER_SELECT31 
04944:  MOVLW  01
04946:  MOVLB  6
04948:  MOVWF  xD9
0494A:  MOVLW  0D
0494C:  MOVWF  xD8
0494E:  CLRF   xDB
04950:  MOVLW  22
04952:  MOVWF  xDA
04954:  MOVLB  0
04956:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(270, MIXER_SELECT32);     // MIXER_SELECT32 
0495A:  MOVLW  01
0495C:  MOVLB  6
0495E:  MOVWF  xD9
04960:  MOVLW  0E
04962:  MOVWF  xD8
04964:  CLRF   xDB
04966:  MOVLW  23
04968:  MOVWF  xDA
0496A:  MOVLB  0
0496C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(271, MIXER_SELECT33);     // MIXER_SELECT33 
04970:  MOVLW  01
04972:  MOVLB  6
04974:  MOVWF  xD9
04976:  MOVLW  0F
04978:  MOVWF  xD8
0497A:  CLRF   xDB
0497C:  MOVLW  24
0497E:  MOVWF  xDA
04980:  MOVLB  0
04982:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(272, MIXER_SELECT34);     // MIXER_SELECT34 
04986:  MOVLW  01
04988:  MOVLB  6
0498A:  MOVWF  xD9
0498C:  MOVLW  10
0498E:  MOVWF  xD8
04990:  CLRF   xDB
04992:  MOVLW  25
04994:  MOVWF  xDA
04996:  MOVLB  0
04998:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(273, MIXER_SELECT35);     // MIXER_SELECT35 
0499C:  MOVLW  01
0499E:  MOVLB  6
049A0:  MOVWF  xD9
049A2:  MOVLW  11
049A4:  MOVWF  xD8
049A6:  CLRF   xDB
049A8:  MOVLW  26
049AA:  MOVWF  xDA
049AC:  MOVLB  0
049AE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(274, MIXER_SELECT36);     // MIXER_SELECT36 
049B2:  MOVLW  01
049B4:  MOVLB  6
049B6:  MOVWF  xD9
049B8:  MOVLW  12
049BA:  MOVWF  xD8
049BC:  CLRF   xDB
049BE:  MOVLW  27
049C0:  MOVWF  xDA
049C2:  MOVLB  0
049C4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(275, MIXER_SELECT37);     // MIXER_SELECT37 
049C8:  MOVLW  01
049CA:  MOVLB  6
049CC:  MOVWF  xD9
049CE:  MOVLW  13
049D0:  MOVWF  xD8
049D2:  CLRF   xDB
049D4:  MOVLW  28
049D6:  MOVWF  xDA
049D8:  MOVLB  0
049DA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(276, MIXER_SELECT38);     // MIXER_SELECT38 
049DE:  MOVLW  01
049E0:  MOVLB  6
049E2:  MOVWF  xD9
049E4:  MOVLW  14
049E6:  MOVWF  xD8
049E8:  CLRF   xDB
049EA:  MOVLW  29
049EC:  MOVWF  xDA
049EE:  MOVLB  0
049F0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(277, MIXER_SELECT39);     // MIXER_SELECT39 
049F4:  MOVLW  01
049F6:  MOVLB  6
049F8:  MOVWF  xD9
049FA:  MOVLW  15
049FC:  MOVWF  xD8
049FE:  CLRF   xDB
04A00:  MOVLW  2A
04A02:  MOVWF  xDA
04A04:  MOVLB  0
04A06:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(278, MIXER_SELECT40);     // MIXER_SELECT40 
04A0A:  MOVLW  01
04A0C:  MOVLB  6
04A0E:  MOVWF  xD9
04A10:  MOVLW  16
04A12:  MOVWF  xD8
04A14:  CLRF   xDB
04A16:  MOVLW  2B
04A18:  MOVWF  xDA
04A1A:  MOVLB  0
04A1C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(279, MIXER_SELECT41);     // MIXER_SELECT41 
04A20:  MOVLW  01
04A22:  MOVLB  6
04A24:  MOVWF  xD9
04A26:  MOVLW  17
04A28:  MOVWF  xD8
04A2A:  CLRF   xDB
04A2C:  MOVLW  2C
04A2E:  MOVWF  xDA
04A30:  MOVLB  0
04A32:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(280, MIXER_SELECT42);     // MIXER_SELECT42 
04A36:  MOVLW  01
04A38:  MOVLB  6
04A3A:  MOVWF  xD9
04A3C:  MOVLW  18
04A3E:  MOVWF  xD8
04A40:  CLRF   xDB
04A42:  MOVLW  2D
04A44:  MOVWF  xDA
04A46:  MOVLB  0
04A48:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(281, MIXER_SELECT43);     // MIXER_SELECT43 
04A4C:  MOVLW  01
04A4E:  MOVLB  6
04A50:  MOVWF  xD9
04A52:  MOVLW  19
04A54:  MOVWF  xD8
04A56:  CLRF   xDB
04A58:  MOVLW  2E
04A5A:  MOVWF  xDA
04A5C:  MOVLB  0
04A5E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(282, MIXER_SELECT44);     // MIXER_SELECT44 
04A62:  MOVLW  01
04A64:  MOVLB  6
04A66:  MOVWF  xD9
04A68:  MOVLW  1A
04A6A:  MOVWF  xD8
04A6C:  CLRF   xDB
04A6E:  MOVLW  2F
04A70:  MOVWF  xDA
04A72:  MOVLB  0
04A74:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(283, MIXER_SELECT45);     // MIXER_SELECT45 
04A78:  MOVLW  01
04A7A:  MOVLB  6
04A7C:  MOVWF  xD9
04A7E:  MOVLW  1B
04A80:  MOVWF  xD8
04A82:  CLRF   xDB
04A84:  MOVLW  30
04A86:  MOVWF  xDA
04A88:  MOVLB  0
04A8A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(284, MIXER_SELECT46);     // MIXER_SELECT46 
04A8E:  MOVLW  01
04A90:  MOVLB  6
04A92:  MOVWF  xD9
04A94:  MOVLW  1C
04A96:  MOVWF  xD8
04A98:  CLRF   xDB
04A9A:  MOVLW  31
04A9C:  MOVWF  xDA
04A9E:  MOVLB  0
04AA0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(285, MIXER_SELECT47);     // MIXER_SELECT47 
04AA4:  MOVLW  01
04AA6:  MOVLB  6
04AA8:  MOVWF  xD9
04AAA:  MOVLW  1D
04AAC:  MOVWF  xD8
04AAE:  CLRF   xDB
04AB0:  MOVLW  32
04AB2:  MOVWF  xDA
04AB4:  MOVLB  0
04AB6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(286, MIXER_SELECT48);     // MIXER_SELECT48 
04ABA:  MOVLW  01
04ABC:  MOVLB  6
04ABE:  MOVWF  xD9
04AC0:  MOVLW  1E
04AC2:  MOVWF  xD8
04AC4:  CLRF   xDB
04AC6:  MOVLW  33
04AC8:  MOVWF  xDA
04ACA:  MOVLB  0
04ACC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(287, MIXER_SELECT49);     // MIXER_SELECT49 
04AD0:  MOVLW  01
04AD2:  MOVLB  6
04AD4:  MOVWF  xD9
04AD6:  MOVLW  1F
04AD8:  MOVWF  xD8
04ADA:  CLRF   xDB
04ADC:  MOVLW  34
04ADE:  MOVWF  xDA
04AE0:  MOVLB  0
04AE2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(288, MIXER_SELECT50);     // MIXER_SELECT50 
04AE6:  MOVLW  01
04AE8:  MOVLB  6
04AEA:  MOVWF  xD9
04AEC:  MOVLW  20
04AEE:  MOVWF  xD8
04AF0:  CLRF   xDB
04AF2:  MOVLW  35
04AF4:  MOVWF  xDA
04AF6:  MOVLB  0
04AF8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(289, MIXER_SELECT51);     // MIXER_SELECT51 
04AFC:  MOVLW  01
04AFE:  MOVLB  6
04B00:  MOVWF  xD9
04B02:  MOVLW  21
04B04:  MOVWF  xD8
04B06:  CLRF   xDB
04B08:  MOVLW  36
04B0A:  MOVWF  xDA
04B0C:  MOVLB  0
04B0E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(290, MIXER_SELECT52);     // MIXER_SELECT52 
04B12:  MOVLW  01
04B14:  MOVLB  6
04B16:  MOVWF  xD9
04B18:  MOVLW  22
04B1A:  MOVWF  xD8
04B1C:  CLRF   xDB
04B1E:  MOVLW  37
04B20:  MOVWF  xDA
04B22:  MOVLB  0
04B24:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(291, MIXER_SELECT53);     // MIXER_SELECT53 
04B28:  MOVLW  01
04B2A:  MOVLB  6
04B2C:  MOVWF  xD9
04B2E:  MOVLW  23
04B30:  MOVWF  xD8
04B32:  CLRF   xDB
04B34:  MOVLW  38
04B36:  MOVWF  xDA
04B38:  MOVLB  0
04B3A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(292, MIXER_SELECT54);     // MIXER_SELECT54 
04B3E:  MOVLW  01
04B40:  MOVLB  6
04B42:  MOVWF  xD9
04B44:  MOVLW  24
04B46:  MOVWF  xD8
04B48:  CLRF   xDB
04B4A:  MOVLW  39
04B4C:  MOVWF  xDA
04B4E:  MOVLB  0
04B50:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(293, MIXER_SELECT55);     // MIXER_SELECT55 
04B54:  MOVLW  01
04B56:  MOVLB  6
04B58:  MOVWF  xD9
04B5A:  MOVLW  25
04B5C:  MOVWF  xD8
04B5E:  CLRF   xDB
04B60:  MOVLW  3A
04B62:  MOVWF  xDA
04B64:  MOVLB  0
04B66:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(294, MIXER_SELECT56);     // MIXER_SELECT56 
04B6A:  MOVLW  01
04B6C:  MOVLB  6
04B6E:  MOVWF  xD9
04B70:  MOVLW  26
04B72:  MOVWF  xD8
04B74:  CLRF   xDB
04B76:  MOVLW  3B
04B78:  MOVWF  xDA
04B7A:  MOVLB  0
04B7C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(295, MIXER_SELECT57);     // MIXER_SELECT57 
04B80:  MOVLW  01
04B82:  MOVLB  6
04B84:  MOVWF  xD9
04B86:  MOVLW  27
04B88:  MOVWF  xD8
04B8A:  CLRF   xDB
04B8C:  MOVLW  3C
04B8E:  MOVWF  xDA
04B90:  MOVLB  0
04B92:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(296, MIXER_SELECT58);     // MIXER_SELECT58 
04B96:  MOVLW  01
04B98:  MOVLB  6
04B9A:  MOVWF  xD9
04B9C:  MOVLW  28
04B9E:  MOVWF  xD8
04BA0:  CLRF   xDB
04BA2:  MOVLW  3D
04BA4:  MOVWF  xDA
04BA6:  MOVLB  0
04BA8:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(297, MIXER_SELECT59);     // MIXER_SELECT59 
04BAC:  MOVLW  01
04BAE:  MOVLB  6
04BB0:  MOVWF  xD9
04BB2:  MOVLW  29
04BB4:  MOVWF  xD8
04BB6:  CLRF   xDB
04BB8:  MOVLW  3E
04BBA:  MOVWF  xDA
04BBC:  MOVLB  0
04BBE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(298, MIXER_SELECT60);     // MIXER_SELECT60 
04BC2:  MOVLW  01
04BC4:  MOVLB  6
04BC6:  MOVWF  xD9
04BC8:  MOVLW  2A
04BCA:  MOVWF  xD8
04BCC:  CLRF   xDB
04BCE:  MOVLW  3F
04BD0:  MOVWF  xDA
04BD2:  MOVLB  0
04BD4:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(299, MIXER_SELECT61);     // MIXER_SELECT61 
04BD8:  MOVLW  01
04BDA:  MOVLB  6
04BDC:  MOVWF  xD9
04BDE:  MOVLW  2B
04BE0:  MOVWF  xD8
04BE2:  CLRF   xDB
04BE4:  MOVLW  40
04BE6:  MOVWF  xDA
04BE8:  MOVLB  0
04BEA:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(300, MIXER_SELECT62);     // MIXER_SELECT62 
04BEE:  MOVLW  01
04BF0:  MOVLB  6
04BF2:  MOVWF  xD9
04BF4:  MOVLW  2C
04BF6:  MOVWF  xD8
04BF8:  CLRF   xDB
04BFA:  MOVLW  41
04BFC:  MOVWF  xDA
04BFE:  MOVLB  0
04C00:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(301, MIXER_SELECT63);     // MIXER_SELECT63 
04C04:  MOVLW  01
04C06:  MOVLB  6
04C08:  MOVWF  xD9
04C0A:  MOVLW  2D
04C0C:  MOVWF  xD8
04C0E:  CLRF   xDB
04C10:  MOVLW  42
04C12:  MOVWF  xDA
04C14:  MOVLB  0
04C16:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(302, MIXER_SELECT64);     // MIXER_SELECT64 
04C1A:  MOVLW  01
04C1C:  MOVLB  6
04C1E:  MOVWF  xD9
04C20:  MOVLW  2E
04C22:  MOVWF  xD8
04C24:  CLRF   xDB
04C26:  MOVLW  43
04C28:  MOVWF  xDA
04C2A:  MOVLB  0
04C2C:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(303, MIXER_SELECT65);     // MIXER_SELECT65 
04C30:  MOVLW  01
04C32:  MOVLB  6
04C34:  MOVWF  xD9
04C36:  MOVLW  2F
04C38:  MOVWF  xD8
04C3A:  CLRF   xDB
04C3C:  MOVLW  44
04C3E:  MOVWF  xDA
04C40:  MOVLB  0
04C42:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(304, MIXER_SELECT66);     // MIXER_SELECT66 
04C46:  MOVLW  01
04C48:  MOVLB  6
04C4A:  MOVWF  xD9
04C4C:  MOVLW  30
04C4E:  MOVWF  xD8
04C50:  CLRF   xDB
04C52:  MOVLW  45
04C54:  MOVWF  xDA
04C56:  MOVLB  0
04C58:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(305, MIXER_SELECT67);     // MIXER_SELECT67 
04C5C:  MOVLW  01
04C5E:  MOVLB  6
04C60:  MOVWF  xD9
04C62:  MOVLW  31
04C64:  MOVWF  xD8
04C66:  CLRF   xDB
04C68:  MOVLW  46
04C6A:  MOVWF  xDA
04C6C:  MOVLB  0
04C6E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(306, MIXER_SELECT68);     // MIXER_SELECT68 
04C72:  MOVLW  01
04C74:  MOVLB  6
04C76:  MOVWF  xD9
04C78:  MOVLW  32
04C7A:  MOVWF  xD8
04C7C:  CLRF   xDB
04C7E:  MOVLW  47
04C80:  MOVWF  xDA
04C82:  MOVLB  0
04C84:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(307, MIXER_SELECT69);     // MIXER_SELECT69 
04C88:  MOVLW  01
04C8A:  MOVLB  6
04C8C:  MOVWF  xD9
04C8E:  MOVLW  33
04C90:  MOVWF  xD8
04C92:  CLRF   xDB
04C94:  MOVLW  48
04C96:  MOVWF  xDA
04C98:  MOVLB  0
04C9A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(308, MIXER_SELECT70);     // MIXER_SELECT70 
04C9E:  MOVLW  01
04CA0:  MOVLB  6
04CA2:  MOVWF  xD9
04CA4:  MOVLW  34
04CA6:  MOVWF  xD8
04CA8:  CLRF   xDB
04CAA:  MOVLW  49
04CAC:  MOVWF  xDA
04CAE:  MOVLB  0
04CB0:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(309, MIXER_SELECT71);     // MIXER_SELECT71 
04CB4:  MOVLW  01
04CB6:  MOVLB  6
04CB8:  MOVWF  xD9
04CBA:  MOVLW  35
04CBC:  MOVWF  xD8
04CBE:  CLRF   xDB
04CC0:  MOVLW  4A
04CC2:  MOVWF  xDA
04CC4:  MOVLB  0
04CC6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(310, MIXER_SELECT72);     // MIXER_SELECT72 
04CCA:  MOVLW  01
04CCC:  MOVLB  6
04CCE:  MOVWF  xD9
04CD0:  MOVLW  36
04CD2:  MOVWF  xD8
04CD4:  CLRF   xDB
04CD6:  MOVLW  4B
04CD8:  MOVWF  xDA
04CDA:  MOVLB  0
04CDC:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(311, MIXER_SELECT73);     // MIXER_SELECT73 
04CE0:  MOVLW  01
04CE2:  MOVLB  6
04CE4:  MOVWF  xD9
04CE6:  MOVLW  37
04CE8:  MOVWF  xD8
04CEA:  CLRF   xDB
04CEC:  MOVLW  4C
04CEE:  MOVWF  xDA
04CF0:  MOVLB  0
04CF2:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(312, MIXER_SELECT74);     // MIXER_SELECT74 
04CF6:  MOVLW  01
04CF8:  MOVLB  6
04CFA:  MOVWF  xD9
04CFC:  MOVLW  38
04CFE:  MOVWF  xD8
04D00:  CLRF   xDB
04D02:  MOVLW  4D
04D04:  MOVWF  xDA
04D06:  MOVLB  0
04D08:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(313, MIXER_SELECT75);     // MIXER_SELECT75 
04D0C:  MOVLW  01
04D0E:  MOVLB  6
04D10:  MOVWF  xD9
04D12:  MOVLW  39
04D14:  MOVWF  xD8
04D16:  CLRF   xDB
04D18:  MOVLW  4E
04D1A:  MOVWF  xDA
04D1C:  MOVLB  0
04D1E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(314, MIXER_SELECT76);     // MIXER_SELECT76 
04D22:  MOVLW  01
04D24:  MOVLB  6
04D26:  MOVWF  xD9
04D28:  MOVLW  3A
04D2A:  MOVWF  xD8
04D2C:  CLRF   xDB
04D2E:  MOVLW  4F
04D30:  MOVWF  xDA
04D32:  MOVLB  0
04D34:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(315, MIXER_SELECT77);     // MIXER_SELECT77 
04D38:  MOVLW  01
04D3A:  MOVLB  6
04D3C:  MOVWF  xD9
04D3E:  MOVLW  3B
04D40:  MOVWF  xD8
04D42:  CLRF   xDB
04D44:  MOVLW  50
04D46:  MOVWF  xDA
04D48:  MOVLB  0
04D4A:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(316, MIXER_SELECT78);     // MIXER_SELECT78 
04D4E:  MOVLW  01
04D50:  MOVLB  6
04D52:  MOVWF  xD9
04D54:  MOVLW  3C
04D56:  MOVWF  xD8
04D58:  CLRF   xDB
04D5A:  MOVLW  51
04D5C:  MOVWF  xDA
04D5E:  MOVLB  0
04D60:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(317, MIXER_SELECT79);     // MIXER_SELECT79 
04D64:  MOVLW  01
04D66:  MOVLB  6
04D68:  MOVWF  xD9
04D6A:  MOVLW  3D
04D6C:  MOVWF  xD8
04D6E:  CLRF   xDB
04D70:  MOVLW  52
04D72:  MOVWF  xDA
04D74:  MOVLB  0
04D76:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(318, OUT_1_1_FILTER_B0);     // OUT_1_1_FILTER_B0 
04D7A:  MOVLW  01
04D7C:  MOVLB  6
04D7E:  MOVWF  xD9
04D80:  MOVLW  3E
04D82:  MOVWF  xD8
04D84:  MOVLW  02
04D86:  MOVWF  xDB
04D88:  MOVLW  F5
04D8A:  MOVWF  xDA
04D8C:  MOVLB  0
04D8E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(319, OUT_1_1_FILTER_B1);     // OUT_1_1_FILTER_B1 
04D92:  MOVLW  01
04D94:  MOVLB  6
04D96:  MOVWF  xD9
04D98:  MOVLW  3F
04D9A:  MOVWF  xD8
04D9C:  MOVLW  02
04D9E:  MOVWF  xDB
04DA0:  MOVLW  F6
04DA2:  MOVWF  xDA
04DA4:  MOVLB  0
04DA6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(320, OUT_1_1_FILTER_B2);     // OUT_1_1_FILTER_B2 
04DAA:  MOVLW  01
04DAC:  MOVLB  6
04DAE:  MOVWF  xD9
04DB0:  MOVLW  40
04DB2:  MOVWF  xD8
04DB4:  MOVLW  02
04DB6:  MOVWF  xDB
04DB8:  MOVLW  F7
04DBA:  MOVWF  xDA
04DBC:  MOVLB  0
04DBE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(321, OUT_1_1_FILTER_NEGATIVEA1);     // OUT_1_1_FILTER_NEGATIVEA1 
04DC2:  MOVLW  01
04DC4:  MOVLB  6
04DC6:  MOVWF  xD9
04DC8:  MOVLW  41
04DCA:  MOVWF  xD8
04DCC:  MOVLW  02
04DCE:  MOVWF  xDB
04DD0:  MOVLW  F8
04DD2:  MOVWF  xDA
04DD4:  MOVLB  0
04DD6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(322, OUT_1_1_FILTER_NEGATIVEA2);     // OUT_1_1_FILTER_NEGATIVEA2 
04DDA:  MOVLW  01
04DDC:  MOVLB  6
04DDE:  MOVWF  xD9
04DE0:  MOVLW  42
04DE2:  MOVWF  xD8
04DE4:  MOVLW  02
04DE6:  MOVWF  xDB
04DE8:  MOVLW  F9
04DEA:  MOVWF  xDA
04DEC:  MOVLB  0
04DEE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(323, OUT_1_2_FILTER_B0);     // OUT_1_2_FILTER_B0 
04DF2:  MOVLW  01
04DF4:  MOVLB  6
04DF6:  MOVWF  xD9
04DF8:  MOVLW  43
04DFA:  MOVWF  xD8
04DFC:  MOVLW  02
04DFE:  MOVWF  xDB
04E00:  MOVLW  F0
04E02:  MOVWF  xDA
04E04:  MOVLB  0
04E06:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(324, OUT_1_2_FILTER_B1);     // OUT_1_2_FILTER_B1 
04E0A:  MOVLW  01
04E0C:  MOVLB  6
04E0E:  MOVWF  xD9
04E10:  MOVLW  44
04E12:  MOVWF  xD8
04E14:  MOVLW  02
04E16:  MOVWF  xDB
04E18:  MOVLW  F1
04E1A:  MOVWF  xDA
04E1C:  MOVLB  0
04E1E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(325, OUT_1_2_FILTER_B2);     // OUT_1_2_FILTER_B2 
04E22:  MOVLW  01
04E24:  MOVLB  6
04E26:  MOVWF  xD9
04E28:  MOVLW  45
04E2A:  MOVWF  xD8
04E2C:  MOVLW  02
04E2E:  MOVWF  xDB
04E30:  MOVLW  F2
04E32:  MOVWF  xDA
04E34:  MOVLB  0
04E36:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(326, OUT_1_2_FILTER_NEGATIVEA1);     // OUT_1_2_FILTER_NEGATIVEA1 
04E3A:  MOVLW  01
04E3C:  MOVLB  6
04E3E:  MOVWF  xD9
04E40:  MOVLW  46
04E42:  MOVWF  xD8
04E44:  MOVLW  02
04E46:  MOVWF  xDB
04E48:  MOVLW  F3
04E4A:  MOVWF  xDA
04E4C:  MOVLB  0
04E4E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(327, OUT_1_2_FILTER_NEGATIVEA2);     // OUT_1_2_FILTER_NEGATIVEA2 
04E52:  MOVLW  01
04E54:  MOVLB  6
04E56:  MOVWF  xD9
04E58:  MOVLW  47
04E5A:  MOVWF  xD8
04E5C:  MOVLW  02
04E5E:  MOVWF  xDB
04E60:  MOVLW  F4
04E62:  MOVWF  xDA
04E64:  MOVLB  0
04E66:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(328, OUT_1_3_FILTER_B0);     // OUT_1_3_FILTER_B0 
04E6A:  MOVLW  01
04E6C:  MOVLB  6
04E6E:  MOVWF  xD9
04E70:  MOVLW  48
04E72:  MOVWF  xD8
04E74:  MOVLW  02
04E76:  MOVWF  xDB
04E78:  MOVLW  EB
04E7A:  MOVWF  xDA
04E7C:  MOVLB  0
04E7E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(329, OUT_1_3_FILTER_B1);     // OUT_1_3_FILTER_B1 
04E82:  MOVLW  01
04E84:  MOVLB  6
04E86:  MOVWF  xD9
04E88:  MOVLW  49
04E8A:  MOVWF  xD8
04E8C:  MOVLW  02
04E8E:  MOVWF  xDB
04E90:  MOVLW  EC
04E92:  MOVWF  xDA
04E94:  MOVLB  0
04E96:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(330, OUT_1_3_FILTER_B2);     // OUT_1_3_FILTER_B2 
04E9A:  MOVLW  01
04E9C:  MOVLB  6
04E9E:  MOVWF  xD9
04EA0:  MOVLW  4A
04EA2:  MOVWF  xD8
04EA4:  MOVLW  02
04EA6:  MOVWF  xDB
04EA8:  MOVLW  ED
04EAA:  MOVWF  xDA
04EAC:  MOVLB  0
04EAE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(331, OUT_1_3_FILTER_NEGATIVEA1);     // OUT_1_3_FILTER_NEGATIVEA1 
04EB2:  MOVLW  01
04EB4:  MOVLB  6
04EB6:  MOVWF  xD9
04EB8:  MOVLW  4B
04EBA:  MOVWF  xD8
04EBC:  MOVLW  02
04EBE:  MOVWF  xDB
04EC0:  MOVLW  EE
04EC2:  MOVWF  xDA
04EC4:  MOVLB  0
04EC6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(332, OUT_1_3_FILTER_NEGATIVEA2);     // OUT_1_3_FILTER_NEGATIVEA2 
04ECA:  MOVLW  01
04ECC:  MOVLB  6
04ECE:  MOVWF  xD9
04ED0:  MOVLW  4C
04ED2:  MOVWF  xD8
04ED4:  MOVLW  02
04ED6:  MOVWF  xDB
04ED8:  MOVLW  EF
04EDA:  MOVWF  xDA
04EDC:  MOVLB  0
04EDE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(333, OUT_1_4_FILTER_B0);     // OUT_1_4_FILTER_B0 
04EE2:  MOVLW  01
04EE4:  MOVLB  6
04EE6:  MOVWF  xD9
04EE8:  MOVLW  4D
04EEA:  MOVWF  xD8
04EEC:  MOVLW  02
04EEE:  MOVWF  xDB
04EF0:  MOVLW  B9
04EF2:  MOVWF  xDA
04EF4:  MOVLB  0
04EF6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(334, OUT_1_4_FILTER_B1);     // OUT_1_4_FILTER_B1 
04EFA:  MOVLW  01
04EFC:  MOVLB  6
04EFE:  MOVWF  xD9
04F00:  MOVLW  4E
04F02:  MOVWF  xD8
04F04:  MOVLW  02
04F06:  MOVWF  xDB
04F08:  MOVLW  BA
04F0A:  MOVWF  xDA
04F0C:  MOVLB  0
04F0E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(335, OUT_1_4_FILTER_B2);     // OUT_1_4_FILTER_B2 
04F12:  MOVLW  01
04F14:  MOVLB  6
04F16:  MOVWF  xD9
04F18:  MOVLW  4F
04F1A:  MOVWF  xD8
04F1C:  MOVLW  02
04F1E:  MOVWF  xDB
04F20:  MOVLW  BB
04F22:  MOVWF  xDA
04F24:  MOVLB  0
04F26:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(336, OUT_1_4_FILTER_NEGATIVEA1);     // OUT_1_4_FILTER_NEGATIVEA1 
04F2A:  MOVLW  01
04F2C:  MOVLB  6
04F2E:  MOVWF  xD9
04F30:  MOVLW  50
04F32:  MOVWF  xD8
04F34:  MOVLW  02
04F36:  MOVWF  xDB
04F38:  MOVLW  BC
04F3A:  MOVWF  xDA
04F3C:  MOVLB  0
04F3E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(337, OUT_1_4_FILTER_NEGATIVEA2);     // OUT_1_4_FILTER_NEGATIVEA2 
04F42:  MOVLW  01
04F44:  MOVLB  6
04F46:  MOVWF  xD9
04F48:  MOVLW  51
04F4A:  MOVWF  xD8
04F4C:  MOVLW  02
04F4E:  MOVWF  xDB
04F50:  MOVLW  BD
04F52:  MOVWF  xDA
04F54:  MOVLB  0
04F56:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(338, OUT_1_5_FILTER_B0);     // OUT_1_5_FILTER_B0 
04F5A:  MOVLW  01
04F5C:  MOVLB  6
04F5E:  MOVWF  xD9
04F60:  MOVLW  52
04F62:  MOVWF  xD8
04F64:  MOVLW  02
04F66:  MOVWF  xDB
04F68:  MOVLW  B4
04F6A:  MOVWF  xDA
04F6C:  MOVLB  0
04F6E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(339, OUT_1_5_FILTER_B1);     // OUT_1_5_FILTER_B1 
04F72:  MOVLW  01
04F74:  MOVLB  6
04F76:  MOVWF  xD9
04F78:  MOVLW  53
04F7A:  MOVWF  xD8
04F7C:  MOVLW  02
04F7E:  MOVWF  xDB
04F80:  MOVLW  B5
04F82:  MOVWF  xDA
04F84:  MOVLB  0
04F86:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(340, OUT_1_5_FILTER_B2);     // OUT_1_5_FILTER_B2 
04F8A:  MOVLW  01
04F8C:  MOVLB  6
04F8E:  MOVWF  xD9
04F90:  MOVLW  54
04F92:  MOVWF  xD8
04F94:  MOVLW  02
04F96:  MOVWF  xDB
04F98:  MOVLW  B6
04F9A:  MOVWF  xDA
04F9C:  MOVLB  0
04F9E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(341, OUT_1_5_FILTER_NEGATIVEA1);     // OUT_1_5_FILTER_NEGATIVEA1 
04FA2:  MOVLW  01
04FA4:  MOVLB  6
04FA6:  MOVWF  xD9
04FA8:  MOVLW  55
04FAA:  MOVWF  xD8
04FAC:  MOVLW  02
04FAE:  MOVWF  xDB
04FB0:  MOVLW  B7
04FB2:  MOVWF  xDA
04FB4:  MOVLB  0
04FB6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(342, OUT_1_5_FILTER_NEGATIVEA2);     // OUT_1_5_FILTER_NEGATIVEA2 
04FBA:  MOVLW  01
04FBC:  MOVLB  6
04FBE:  MOVWF  xD9
04FC0:  MOVLW  56
04FC2:  MOVWF  xD8
04FC4:  MOVLW  02
04FC6:  MOVWF  xDB
04FC8:  MOVLW  B8
04FCA:  MOVWF  xDA
04FCC:  MOVLB  0
04FCE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(343, OUT_1_6_FILTER_B0);     // OUT_1_6_FILTER_B0 
04FD2:  MOVLW  01
04FD4:  MOVLB  6
04FD6:  MOVWF  xD9
04FD8:  MOVLW  57
04FDA:  MOVWF  xD8
04FDC:  MOVLW  02
04FDE:  MOVWF  xDB
04FE0:  MOVLW  AF
04FE2:  MOVWF  xDA
04FE4:  MOVLB  0
04FE6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(344, OUT_1_6_FILTER_B1);     // OUT_1_6_FILTER_B1 
04FEA:  MOVLW  01
04FEC:  MOVLB  6
04FEE:  MOVWF  xD9
04FF0:  MOVLW  58
04FF2:  MOVWF  xD8
04FF4:  MOVLW  02
04FF6:  MOVWF  xDB
04FF8:  MOVLW  B0
04FFA:  MOVWF  xDA
04FFC:  MOVLB  0
04FFE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(345, OUT_1_6_FILTER_B2);     // OUT_1_6_FILTER_B2 
05002:  MOVLW  01
05004:  MOVLB  6
05006:  MOVWF  xD9
05008:  MOVLW  59
0500A:  MOVWF  xD8
0500C:  MOVLW  02
0500E:  MOVWF  xDB
05010:  MOVLW  B1
05012:  MOVWF  xDA
05014:  MOVLB  0
05016:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(346, OUT_1_6_FILTER_NEGATIVEA1);     // OUT_1_6_FILTER_NEGATIVEA1 
0501A:  MOVLW  01
0501C:  MOVLB  6
0501E:  MOVWF  xD9
05020:  MOVLW  5A
05022:  MOVWF  xD8
05024:  MOVLW  02
05026:  MOVWF  xDB
05028:  MOVLW  B2
0502A:  MOVWF  xDA
0502C:  MOVLB  0
0502E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(347, OUT_1_6_FILTER_NEGATIVEA2);     // OUT_1_6_FILTER_NEGATIVEA2 
05032:  MOVLW  01
05034:  MOVLB  6
05036:  MOVWF  xD9
05038:  MOVLW  5B
0503A:  MOVWF  xD8
0503C:  MOVLW  02
0503E:  MOVWF  xDB
05040:  MOVLW  B3
05042:  MOVWF  xDA
05044:  MOVLB  0
05046:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(348, OUT_2_1_FILTER_B0);     // OUT_2_1_FILTER_B0 
0504A:  MOVLW  01
0504C:  MOVLB  6
0504E:  MOVWF  xD9
05050:  MOVLW  5C
05052:  MOVWF  xD8
05054:  MOVLW  02
05056:  MOVWF  xDB
05058:  MOVLW  E6
0505A:  MOVWF  xDA
0505C:  MOVLB  0
0505E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(349, OUT_2_1_FILTER_B1);     // OUT_2_1_FILTER_B1 
05062:  MOVLW  01
05064:  MOVLB  6
05066:  MOVWF  xD9
05068:  MOVLW  5D
0506A:  MOVWF  xD8
0506C:  MOVLW  02
0506E:  MOVWF  xDB
05070:  MOVLW  E7
05072:  MOVWF  xDA
05074:  MOVLB  0
05076:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(350, OUT_2_1_FILTER_B2);     // OUT_2_1_FILTER_B2 
0507A:  MOVLW  01
0507C:  MOVLB  6
0507E:  MOVWF  xD9
05080:  MOVLW  5E
05082:  MOVWF  xD8
05084:  MOVLW  02
05086:  MOVWF  xDB
05088:  MOVLW  E8
0508A:  MOVWF  xDA
0508C:  MOVLB  0
0508E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(351, OUT_2_1_FILTER_NEGATIVEA1);     // OUT_2_1_FILTER_NEGATIVEA1 
05092:  MOVLW  01
05094:  MOVLB  6
05096:  MOVWF  xD9
05098:  MOVLW  5F
0509A:  MOVWF  xD8
0509C:  MOVLW  02
0509E:  MOVWF  xDB
050A0:  MOVLW  E9
050A2:  MOVWF  xDA
050A4:  MOVLB  0
050A6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(352, OUT_2_1_FILTER_NEGATIVEA2);     // OUT_2_1_FILTER_NEGATIVEA2 
050AA:  MOVLW  01
050AC:  MOVLB  6
050AE:  MOVWF  xD9
050B0:  MOVLW  60
050B2:  MOVWF  xD8
050B4:  MOVLW  02
050B6:  MOVWF  xDB
050B8:  MOVLW  EA
050BA:  MOVWF  xDA
050BC:  MOVLB  0
050BE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(353, OUT_2_2_FILTER_B0);     // OUT_2_2_FILTER_B0 
050C2:  MOVLW  01
050C4:  MOVLB  6
050C6:  MOVWF  xD9
050C8:  MOVLW  61
050CA:  MOVWF  xD8
050CC:  MOVLW  02
050CE:  MOVWF  xDB
050D0:  MOVLW  E1
050D2:  MOVWF  xDA
050D4:  MOVLB  0
050D6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(354, OUT_2_2_FILTER_B1);     // OUT_2_2_FILTER_B1 
050DA:  MOVLW  01
050DC:  MOVLB  6
050DE:  MOVWF  xD9
050E0:  MOVLW  62
050E2:  MOVWF  xD8
050E4:  MOVLW  02
050E6:  MOVWF  xDB
050E8:  MOVLW  E2
050EA:  MOVWF  xDA
050EC:  MOVLB  0
050EE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(355, OUT_2_2_FILTER_B2);     // OUT_2_2_FILTER_B2 
050F2:  MOVLW  01
050F4:  MOVLB  6
050F6:  MOVWF  xD9
050F8:  MOVLW  63
050FA:  MOVWF  xD8
050FC:  MOVLW  02
050FE:  MOVWF  xDB
05100:  MOVLW  E3
05102:  MOVWF  xDA
05104:  MOVLB  0
05106:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(356, OUT_2_2_FILTER_NEGATIVEA1);     // OUT_2_2_FILTER_NEGATIVEA1 
0510A:  MOVLW  01
0510C:  MOVLB  6
0510E:  MOVWF  xD9
05110:  MOVLW  64
05112:  MOVWF  xD8
05114:  MOVLW  02
05116:  MOVWF  xDB
05118:  MOVLW  E4
0511A:  MOVWF  xDA
0511C:  MOVLB  0
0511E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(357, OUT_2_2_FILTER_NEGATIVEA2);     // OUT_2_2_FILTER_NEGATIVEA2 
05122:  MOVLW  01
05124:  MOVLB  6
05126:  MOVWF  xD9
05128:  MOVLW  65
0512A:  MOVWF  xD8
0512C:  MOVLW  02
0512E:  MOVWF  xDB
05130:  MOVLW  E5
05132:  MOVWF  xDA
05134:  MOVLB  0
05136:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(358, OUT_2_3_FILTER_B0);     // OUT_2_3_FILTER_B0 
0513A:  MOVLW  01
0513C:  MOVLB  6
0513E:  MOVWF  xD9
05140:  MOVLW  66
05142:  MOVWF  xD8
05144:  MOVLW  02
05146:  MOVWF  xDB
05148:  MOVLW  DC
0514A:  MOVWF  xDA
0514C:  MOVLB  0
0514E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(359, OUT_2_3_FILTER_B1);     // OUT_2_3_FILTER_B1 
05152:  MOVLW  01
05154:  MOVLB  6
05156:  MOVWF  xD9
05158:  MOVLW  67
0515A:  MOVWF  xD8
0515C:  MOVLW  02
0515E:  MOVWF  xDB
05160:  MOVLW  DD
05162:  MOVWF  xDA
05164:  MOVLB  0
05166:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(360, OUT_2_3_FILTER_B2);     // OUT_2_3_FILTER_B2 
0516A:  MOVLW  01
0516C:  MOVLB  6
0516E:  MOVWF  xD9
05170:  MOVLW  68
05172:  MOVWF  xD8
05174:  MOVLW  02
05176:  MOVWF  xDB
05178:  MOVLW  DE
0517A:  MOVWF  xDA
0517C:  MOVLB  0
0517E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(361, OUT_2_3_FILTER_NEGATIVEA1);     // OUT_2_3_FILTER_NEGATIVEA1 
05182:  MOVLW  01
05184:  MOVLB  6
05186:  MOVWF  xD9
05188:  MOVLW  69
0518A:  MOVWF  xD8
0518C:  MOVLW  02
0518E:  MOVWF  xDB
05190:  MOVLW  DF
05192:  MOVWF  xDA
05194:  MOVLB  0
05196:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(362, OUT_2_3_FILTER_NEGATIVEA2);     // OUT_2_3_FILTER_NEGATIVEA2 
0519A:  MOVLW  01
0519C:  MOVLB  6
0519E:  MOVWF  xD9
051A0:  MOVLW  6A
051A2:  MOVWF  xD8
051A4:  MOVLW  02
051A6:  MOVWF  xDB
051A8:  MOVLW  E0
051AA:  MOVWF  xDA
051AC:  MOVLB  0
051AE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(363, OUT_2_4_FILTER_B0);     // OUT_2_4_FILTER_B0 
051B2:  MOVLW  01
051B4:  MOVLB  6
051B6:  MOVWF  xD9
051B8:  MOVLW  6B
051BA:  MOVWF  xD8
051BC:  MOVLW  02
051BE:  MOVWF  xDB
051C0:  MOVLW  AA
051C2:  MOVWF  xDA
051C4:  MOVLB  0
051C6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(364, OUT_2_4_FILTER_B1);     // OUT_2_4_FILTER_B1 
051CA:  MOVLW  01
051CC:  MOVLB  6
051CE:  MOVWF  xD9
051D0:  MOVLW  6C
051D2:  MOVWF  xD8
051D4:  MOVLW  02
051D6:  MOVWF  xDB
051D8:  MOVLW  AB
051DA:  MOVWF  xDA
051DC:  MOVLB  0
051DE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(365, OUT_2_4_FILTER_B2);     // OUT_2_4_FILTER_B2 
051E2:  MOVLW  01
051E4:  MOVLB  6
051E6:  MOVWF  xD9
051E8:  MOVLW  6D
051EA:  MOVWF  xD8
051EC:  MOVLW  02
051EE:  MOVWF  xDB
051F0:  MOVLW  AC
051F2:  MOVWF  xDA
051F4:  MOVLB  0
051F6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(366, OUT_2_4_FILTER_NEGATIVEA1);     // OUT_2_4_FILTER_NEGATIVEA1 
051FA:  MOVLW  01
051FC:  MOVLB  6
051FE:  MOVWF  xD9
05200:  MOVLW  6E
05202:  MOVWF  xD8
05204:  MOVLW  02
05206:  MOVWF  xDB
05208:  MOVLW  AD
0520A:  MOVWF  xDA
0520C:  MOVLB  0
0520E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(367, OUT_2_4_FILTER_NEGATIVEA2);     // OUT_2_4_FILTER_NEGATIVEA2 
05212:  MOVLW  01
05214:  MOVLB  6
05216:  MOVWF  xD9
05218:  MOVLW  6F
0521A:  MOVWF  xD8
0521C:  MOVLW  02
0521E:  MOVWF  xDB
05220:  MOVLW  AE
05222:  MOVWF  xDA
05224:  MOVLB  0
05226:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(368, OUT_2_5_FILTER_B0);     // OUT_2_5_FILTER_B0 
0522A:  MOVLW  01
0522C:  MOVLB  6
0522E:  MOVWF  xD9
05230:  MOVLW  70
05232:  MOVWF  xD8
05234:  MOVLW  02
05236:  MOVWF  xDB
05238:  MOVLW  A5
0523A:  MOVWF  xDA
0523C:  MOVLB  0
0523E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(369, OUT_2_5_FILTER_B1);     // OUT_2_5_FILTER_B1 
05242:  MOVLW  01
05244:  MOVLB  6
05246:  MOVWF  xD9
05248:  MOVLW  71
0524A:  MOVWF  xD8
0524C:  MOVLW  02
0524E:  MOVWF  xDB
05250:  MOVLW  A6
05252:  MOVWF  xDA
05254:  MOVLB  0
05256:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(370, OUT_2_5_FILTER_B2);     // OUT_2_5_FILTER_B2 
0525A:  MOVLW  01
0525C:  MOVLB  6
0525E:  MOVWF  xD9
05260:  MOVLW  72
05262:  MOVWF  xD8
05264:  MOVLW  02
05266:  MOVWF  xDB
05268:  MOVLW  A7
0526A:  MOVWF  xDA
0526C:  MOVLB  0
0526E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(371, OUT_2_5_FILTER_NEGATIVEA1);     // OUT_2_5_FILTER_NEGATIVEA1 
05272:  MOVLW  01
05274:  MOVLB  6
05276:  MOVWF  xD9
05278:  MOVLW  73
0527A:  MOVWF  xD8
0527C:  MOVLW  02
0527E:  MOVWF  xDB
05280:  MOVLW  A8
05282:  MOVWF  xDA
05284:  MOVLB  0
05286:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(372, OUT_2_5_FILTER_NEGATIVEA2);     // OUT_2_5_FILTER_NEGATIVEA2 
0528A:  MOVLW  01
0528C:  MOVLB  6
0528E:  MOVWF  xD9
05290:  MOVLW  74
05292:  MOVWF  xD8
05294:  MOVLW  02
05296:  MOVWF  xDB
05298:  MOVLW  A9
0529A:  MOVWF  xDA
0529C:  MOVLB  0
0529E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(373, OUT_2_6_FILTER_B0);     // OUT_2_6_FILTER_B0 
052A2:  MOVLW  01
052A4:  MOVLB  6
052A6:  MOVWF  xD9
052A8:  MOVLW  75
052AA:  MOVWF  xD8
052AC:  MOVLW  02
052AE:  MOVWF  xDB
052B0:  MOVLW  A0
052B2:  MOVWF  xDA
052B4:  MOVLB  0
052B6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(374, OUT_2_6_FILTER_B1);     // OUT_2_6_FILTER_B1 
052BA:  MOVLW  01
052BC:  MOVLB  6
052BE:  MOVWF  xD9
052C0:  MOVLW  76
052C2:  MOVWF  xD8
052C4:  MOVLW  02
052C6:  MOVWF  xDB
052C8:  MOVLW  A1
052CA:  MOVWF  xDA
052CC:  MOVLB  0
052CE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(375, OUT_2_6_FILTER_B2);     // OUT_2_6_FILTER_B2 
052D2:  MOVLW  01
052D4:  MOVLB  6
052D6:  MOVWF  xD9
052D8:  MOVLW  77
052DA:  MOVWF  xD8
052DC:  MOVLW  02
052DE:  MOVWF  xDB
052E0:  MOVLW  A2
052E2:  MOVWF  xDA
052E4:  MOVLB  0
052E6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(376, OUT_2_6_FILTER_NEGATIVEA1);     // OUT_2_6_FILTER_NEGATIVEA1 
052EA:  MOVLW  01
052EC:  MOVLB  6
052EE:  MOVWF  xD9
052F0:  MOVLW  78
052F2:  MOVWF  xD8
052F4:  MOVLW  02
052F6:  MOVWF  xDB
052F8:  MOVLW  A3
052FA:  MOVWF  xDA
052FC:  MOVLB  0
052FE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(377, OUT_2_6_FILTER_NEGATIVEA2);     // OUT_2_6_FILTER_NEGATIVEA2 
05302:  MOVLW  01
05304:  MOVLB  6
05306:  MOVWF  xD9
05308:  MOVLW  79
0530A:  MOVWF  xD8
0530C:  MOVLW  02
0530E:  MOVWF  xDB
05310:  MOVLW  A4
05312:  MOVWF  xDA
05314:  MOVLB  0
05316:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(378, OUT_3_1_FILTER_B0);     // OUT_3_1_FILTER_B0 
0531A:  MOVLW  01
0531C:  MOVLB  6
0531E:  MOVWF  xD9
05320:  MOVLW  7A
05322:  MOVWF  xD8
05324:  MOVLW  02
05326:  MOVWF  xDB
05328:  MOVLW  D7
0532A:  MOVWF  xDA
0532C:  MOVLB  0
0532E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(379, OUT_3_1_FILTER_B1);     // OUT_3_1_FILTER_B1 
05332:  MOVLW  01
05334:  MOVLB  6
05336:  MOVWF  xD9
05338:  MOVLW  7B
0533A:  MOVWF  xD8
0533C:  MOVLW  02
0533E:  MOVWF  xDB
05340:  MOVLW  D8
05342:  MOVWF  xDA
05344:  MOVLB  0
05346:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(380, OUT_3_1_FILTER_B2);     // OUT_3_1_FILTER_B2 
0534A:  MOVLW  01
0534C:  MOVLB  6
0534E:  MOVWF  xD9
05350:  MOVLW  7C
05352:  MOVWF  xD8
05354:  MOVLW  02
05356:  MOVWF  xDB
05358:  MOVLW  D9
0535A:  MOVWF  xDA
0535C:  MOVLB  0
0535E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(381, OUT_3_1_FILTER_NEGATIVEA1);     // OUT_3_1_FILTER_NEGATIVEA1 
05362:  MOVLW  01
05364:  MOVLB  6
05366:  MOVWF  xD9
05368:  MOVLW  7D
0536A:  MOVWF  xD8
0536C:  MOVLW  02
0536E:  MOVWF  xDB
05370:  MOVLW  DA
05372:  MOVWF  xDA
05374:  MOVLB  0
05376:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(382, OUT_3_1_FILTER_NEGATIVEA2);     // OUT_3_1_FILTER_NEGATIVEA2 
0537A:  MOVLW  01
0537C:  MOVLB  6
0537E:  MOVWF  xD9
05380:  MOVLW  7E
05382:  MOVWF  xD8
05384:  MOVLW  02
05386:  MOVWF  xDB
05388:  MOVLW  DB
0538A:  MOVWF  xDA
0538C:  MOVLB  0
0538E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(383, OUT_3_2_FILTER_B0);     // OUT_3_2_FILTER_B0 
05392:  MOVLW  01
05394:  MOVLB  6
05396:  MOVWF  xD9
05398:  MOVLW  7F
0539A:  MOVWF  xD8
0539C:  MOVLW  02
0539E:  MOVWF  xDB
053A0:  MOVLW  D2
053A2:  MOVWF  xDA
053A4:  MOVLB  0
053A6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(384, OUT_3_2_FILTER_B1);     // OUT_3_2_FILTER_B1 
053AA:  MOVLW  01
053AC:  MOVLB  6
053AE:  MOVWF  xD9
053B0:  MOVLW  80
053B2:  MOVWF  xD8
053B4:  MOVLW  02
053B6:  MOVWF  xDB
053B8:  MOVLW  D3
053BA:  MOVWF  xDA
053BC:  MOVLB  0
053BE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(385, OUT_3_2_FILTER_B2);     // OUT_3_2_FILTER_B2 
053C2:  MOVLW  01
053C4:  MOVLB  6
053C6:  MOVWF  xD9
053C8:  MOVLW  81
053CA:  MOVWF  xD8
053CC:  MOVLW  02
053CE:  MOVWF  xDB
053D0:  MOVLW  D4
053D2:  MOVWF  xDA
053D4:  MOVLB  0
053D6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(386, OUT_3_2_FILTER_NEGATIVEA1);     // OUT_3_2_FILTER_NEGATIVEA1 
053DA:  MOVLW  01
053DC:  MOVLB  6
053DE:  MOVWF  xD9
053E0:  MOVLW  82
053E2:  MOVWF  xD8
053E4:  MOVLW  02
053E6:  MOVWF  xDB
053E8:  MOVLW  D5
053EA:  MOVWF  xDA
053EC:  MOVLB  0
053EE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(387, OUT_3_2_FILTER_NEGATIVEA2);     // OUT_3_2_FILTER_NEGATIVEA2 
053F2:  MOVLW  01
053F4:  MOVLB  6
053F6:  MOVWF  xD9
053F8:  MOVLW  83
053FA:  MOVWF  xD8
053FC:  MOVLW  02
053FE:  MOVWF  xDB
05400:  MOVLW  D6
05402:  MOVWF  xDA
05404:  MOVLB  0
05406:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(388, OUT_3_3_FILTER_B0);     // OUT_3_3_FILTER_B0 
0540A:  MOVLW  01
0540C:  MOVLB  6
0540E:  MOVWF  xD9
05410:  MOVLW  84
05412:  MOVWF  xD8
05414:  MOVLW  02
05416:  MOVWF  xDB
05418:  MOVLW  CD
0541A:  MOVWF  xDA
0541C:  MOVLB  0
0541E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(389, OUT_3_3_FILTER_B1);     // OUT_3_3_FILTER_B1 
05422:  MOVLW  01
05424:  MOVLB  6
05426:  MOVWF  xD9
05428:  MOVLW  85
0542A:  MOVWF  xD8
0542C:  MOVLW  02
0542E:  MOVWF  xDB
05430:  MOVLW  CE
05432:  MOVWF  xDA
05434:  MOVLB  0
05436:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(390, OUT_3_3_FILTER_B2);     // OUT_3_3_FILTER_B2 
0543A:  MOVLW  01
0543C:  MOVLB  6
0543E:  MOVWF  xD9
05440:  MOVLW  86
05442:  MOVWF  xD8
05444:  MOVLW  02
05446:  MOVWF  xDB
05448:  MOVLW  CF
0544A:  MOVWF  xDA
0544C:  MOVLB  0
0544E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(391, OUT_3_3_FILTER_NEGATIVEA1);     // OUT_3_3_FILTER_NEGATIVEA1 
05452:  MOVLW  01
05454:  MOVLB  6
05456:  MOVWF  xD9
05458:  MOVLW  87
0545A:  MOVWF  xD8
0545C:  MOVLW  02
0545E:  MOVWF  xDB
05460:  MOVLW  D0
05462:  MOVWF  xDA
05464:  MOVLB  0
05466:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(392, OUT_3_3_FILTER_NEGATIVEA2);     // OUT_3_3_FILTER_NEGATIVEA2 
0546A:  MOVLW  01
0546C:  MOVLB  6
0546E:  MOVWF  xD9
05470:  MOVLW  88
05472:  MOVWF  xD8
05474:  MOVLW  02
05476:  MOVWF  xDB
05478:  MOVLW  D1
0547A:  MOVWF  xDA
0547C:  MOVLB  0
0547E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(393, OUT_3_4_FILTER_B0);     // OUT_3_4_FILTER_B0 
05482:  MOVLW  01
05484:  MOVLB  6
05486:  MOVWF  xD9
05488:  MOVLW  89
0548A:  MOVWF  xD8
0548C:  MOVLW  02
0548E:  MOVWF  xDB
05490:  MOVLW  9B
05492:  MOVWF  xDA
05494:  MOVLB  0
05496:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(394, OUT_3_4_FILTER_B1);     // OUT_3_4_FILTER_B1 
0549A:  MOVLW  01
0549C:  MOVLB  6
0549E:  MOVWF  xD9
054A0:  MOVLW  8A
054A2:  MOVWF  xD8
054A4:  MOVLW  02
054A6:  MOVWF  xDB
054A8:  MOVLW  9C
054AA:  MOVWF  xDA
054AC:  MOVLB  0
054AE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(395, OUT_3_4_FILTER_B2);     // OUT_3_4_FILTER_B2 
054B2:  MOVLW  01
054B4:  MOVLB  6
054B6:  MOVWF  xD9
054B8:  MOVLW  8B
054BA:  MOVWF  xD8
054BC:  MOVLW  02
054BE:  MOVWF  xDB
054C0:  MOVLW  9D
054C2:  MOVWF  xDA
054C4:  MOVLB  0
054C6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(396, OUT_3_4_FILTER_NEGATIVEA1);     // OUT_3_4_FILTER_NEGATIVEA1 
054CA:  MOVLW  01
054CC:  MOVLB  6
054CE:  MOVWF  xD9
054D0:  MOVLW  8C
054D2:  MOVWF  xD8
054D4:  MOVLW  02
054D6:  MOVWF  xDB
054D8:  MOVLW  9E
054DA:  MOVWF  xDA
054DC:  MOVLB  0
054DE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(397, OUT_3_4_FILTER_NEGATIVEA2);     // OUT_3_4_FILTER_NEGATIVEA2 
054E2:  MOVLW  01
054E4:  MOVLB  6
054E6:  MOVWF  xD9
054E8:  MOVLW  8D
054EA:  MOVWF  xD8
054EC:  MOVLW  02
054EE:  MOVWF  xDB
054F0:  MOVLW  9F
054F2:  MOVWF  xDA
054F4:  MOVLB  0
054F6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(398, OUT_3_5_FILTER_B0);     // OUT_3_5_FILTER_B0 
054FA:  MOVLW  01
054FC:  MOVLB  6
054FE:  MOVWF  xD9
05500:  MOVLW  8E
05502:  MOVWF  xD8
05504:  MOVLW  02
05506:  MOVWF  xDB
05508:  MOVLW  96
0550A:  MOVWF  xDA
0550C:  MOVLB  0
0550E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(399, OUT_3_5_FILTER_B1);     // OUT_3_5_FILTER_B1 
05512:  MOVLW  01
05514:  MOVLB  6
05516:  MOVWF  xD9
05518:  MOVLW  8F
0551A:  MOVWF  xD8
0551C:  MOVLW  02
0551E:  MOVWF  xDB
05520:  MOVLW  97
05522:  MOVWF  xDA
05524:  MOVLB  0
05526:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(400, OUT_3_5_FILTER_B2);     // OUT_3_5_FILTER_B2 
0552A:  MOVLW  01
0552C:  MOVLB  6
0552E:  MOVWF  xD9
05530:  MOVLW  90
05532:  MOVWF  xD8
05534:  MOVLW  02
05536:  MOVWF  xDB
05538:  MOVLW  98
0553A:  MOVWF  xDA
0553C:  MOVLB  0
0553E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(401, OUT_3_5_FILTER_NEGATIVEA1);     // OUT_3_5_FILTER_NEGATIVEA1 
05542:  MOVLW  01
05544:  MOVLB  6
05546:  MOVWF  xD9
05548:  MOVLW  91
0554A:  MOVWF  xD8
0554C:  MOVLW  02
0554E:  MOVWF  xDB
05550:  MOVLW  99
05552:  MOVWF  xDA
05554:  MOVLB  0
05556:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(402, OUT_3_5_FILTER_NEGATIVEA2);     // OUT_3_5_FILTER_NEGATIVEA2 
0555A:  MOVLW  01
0555C:  MOVLB  6
0555E:  MOVWF  xD9
05560:  MOVLW  92
05562:  MOVWF  xD8
05564:  MOVLW  02
05566:  MOVWF  xDB
05568:  MOVLW  9A
0556A:  MOVWF  xDA
0556C:  MOVLB  0
0556E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(403, OUT_3_6_FILTER_B0);     // OUT_3_6_FILTER_B0 
05572:  MOVLW  01
05574:  MOVLB  6
05576:  MOVWF  xD9
05578:  MOVLW  93
0557A:  MOVWF  xD8
0557C:  MOVLW  02
0557E:  MOVWF  xDB
05580:  MOVLW  91
05582:  MOVWF  xDA
05584:  MOVLB  0
05586:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(404, OUT_3_6_FILTER_B1);     // OUT_3_6_FILTER_B1 
0558A:  MOVLW  01
0558C:  MOVLB  6
0558E:  MOVWF  xD9
05590:  MOVLW  94
05592:  MOVWF  xD8
05594:  MOVLW  02
05596:  MOVWF  xDB
05598:  MOVLW  92
0559A:  MOVWF  xDA
0559C:  MOVLB  0
0559E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(405, OUT_3_6_FILTER_B2);     // OUT_3_6_FILTER_B2 
055A2:  MOVLW  01
055A4:  MOVLB  6
055A6:  MOVWF  xD9
055A8:  MOVLW  95
055AA:  MOVWF  xD8
055AC:  MOVLW  02
055AE:  MOVWF  xDB
055B0:  MOVLW  93
055B2:  MOVWF  xDA
055B4:  MOVLB  0
055B6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(406, OUT_3_6_FILTER_NEGATIVEA1);     // OUT_3_6_FILTER_NEGATIVEA1 
055BA:  MOVLW  01
055BC:  MOVLB  6
055BE:  MOVWF  xD9
055C0:  MOVLW  96
055C2:  MOVWF  xD8
055C4:  MOVLW  02
055C6:  MOVWF  xDB
055C8:  MOVLW  94
055CA:  MOVWF  xDA
055CC:  MOVLB  0
055CE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(407, OUT_3_6_FILTER_NEGATIVEA2);     // OUT_3_6_FILTER_NEGATIVEA2 
055D2:  MOVLW  01
055D4:  MOVLB  6
055D6:  MOVWF  xD9
055D8:  MOVLW  97
055DA:  MOVWF  xD8
055DC:  MOVLW  02
055DE:  MOVWF  xDB
055E0:  MOVLW  95
055E2:  MOVWF  xDA
055E4:  MOVLB  0
055E6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(408, OUT_4_1_FILTER_B0);     // OUT_4_1_FILTER_B0 
055EA:  MOVLW  01
055EC:  MOVLB  6
055EE:  MOVWF  xD9
055F0:  MOVLW  98
055F2:  MOVWF  xD8
055F4:  MOVLW  02
055F6:  MOVWF  xDB
055F8:  MOVLW  C8
055FA:  MOVWF  xDA
055FC:  MOVLB  0
055FE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(409, OUT_4_1_FILTER_B1);     // OUT_4_1_FILTER_B1 
05602:  MOVLW  01
05604:  MOVLB  6
05606:  MOVWF  xD9
05608:  MOVLW  99
0560A:  MOVWF  xD8
0560C:  MOVLW  02
0560E:  MOVWF  xDB
05610:  MOVLW  C9
05612:  MOVWF  xDA
05614:  MOVLB  0
05616:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(410, OUT_4_1_FILTER_B2);     // OUT_4_1_FILTER_B2 
0561A:  MOVLW  01
0561C:  MOVLB  6
0561E:  MOVWF  xD9
05620:  MOVLW  9A
05622:  MOVWF  xD8
05624:  MOVLW  02
05626:  MOVWF  xDB
05628:  MOVLW  CA
0562A:  MOVWF  xDA
0562C:  MOVLB  0
0562E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(411, OUT_4_1_FILTER_NEGATIVEA1);     // OUT_4_1_FILTER_NEGATIVEA1 
05632:  MOVLW  01
05634:  MOVLB  6
05636:  MOVWF  xD9
05638:  MOVLW  9B
0563A:  MOVWF  xD8
0563C:  MOVLW  02
0563E:  MOVWF  xDB
05640:  MOVLW  CB
05642:  MOVWF  xDA
05644:  MOVLB  0
05646:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(412, OUT_4_1_FILTER_NEGATIVEA2);     // OUT_4_1_FILTER_NEGATIVEA2 
0564A:  MOVLW  01
0564C:  MOVLB  6
0564E:  MOVWF  xD9
05650:  MOVLW  9C
05652:  MOVWF  xD8
05654:  MOVLW  02
05656:  MOVWF  xDB
05658:  MOVLW  CC
0565A:  MOVWF  xDA
0565C:  MOVLB  0
0565E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(413, OUT_4_2_FILTER_B0);     // OUT_4_2_FILTER_B0 
05662:  MOVLW  01
05664:  MOVLB  6
05666:  MOVWF  xD9
05668:  MOVLW  9D
0566A:  MOVWF  xD8
0566C:  MOVLW  02
0566E:  MOVWF  xDB
05670:  MOVLW  C3
05672:  MOVWF  xDA
05674:  MOVLB  0
05676:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(414, OUT_4_2_FILTER_B1);     // OUT_4_2_FILTER_B1 
0567A:  MOVLW  01
0567C:  MOVLB  6
0567E:  MOVWF  xD9
05680:  MOVLW  9E
05682:  MOVWF  xD8
05684:  MOVLW  02
05686:  MOVWF  xDB
05688:  MOVLW  C4
0568A:  MOVWF  xDA
0568C:  MOVLB  0
0568E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(415, OUT_4_2_FILTER_B2);     // OUT_4_2_FILTER_B2 
05692:  MOVLW  01
05694:  MOVLB  6
05696:  MOVWF  xD9
05698:  MOVLW  9F
0569A:  MOVWF  xD8
0569C:  MOVLW  02
0569E:  MOVWF  xDB
056A0:  MOVLW  C5
056A2:  MOVWF  xDA
056A4:  MOVLB  0
056A6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(416, OUT_4_2_FILTER_NEGATIVEA1);     // OUT_4_2_FILTER_NEGATIVEA1 
056AA:  MOVLW  01
056AC:  MOVLB  6
056AE:  MOVWF  xD9
056B0:  MOVLW  A0
056B2:  MOVWF  xD8
056B4:  MOVLW  02
056B6:  MOVWF  xDB
056B8:  MOVLW  C6
056BA:  MOVWF  xDA
056BC:  MOVLB  0
056BE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(417, OUT_4_2_FILTER_NEGATIVEA2);     // OUT_4_2_FILTER_NEGATIVEA2 
056C2:  MOVLW  01
056C4:  MOVLB  6
056C6:  MOVWF  xD9
056C8:  MOVLW  A1
056CA:  MOVWF  xD8
056CC:  MOVLW  02
056CE:  MOVWF  xDB
056D0:  MOVLW  C7
056D2:  MOVWF  xDA
056D4:  MOVLB  0
056D6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(418, OUT_4_3_FILTER_B0);     // OUT_4_3_FILTER_B0 
056DA:  MOVLW  01
056DC:  MOVLB  6
056DE:  MOVWF  xD9
056E0:  MOVLW  A2
056E2:  MOVWF  xD8
056E4:  MOVLW  02
056E6:  MOVWF  xDB
056E8:  MOVLW  BE
056EA:  MOVWF  xDA
056EC:  MOVLB  0
056EE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(419, OUT_4_3_FILTER_B1);     // OUT_4_3_FILTER_B1 
056F2:  MOVLW  01
056F4:  MOVLB  6
056F6:  MOVWF  xD9
056F8:  MOVLW  A3
056FA:  MOVWF  xD8
056FC:  MOVLW  02
056FE:  MOVWF  xDB
05700:  MOVLW  BF
05702:  MOVWF  xDA
05704:  MOVLB  0
05706:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(420, OUT_4_3_FILTER_B2);     // OUT_4_3_FILTER_B2 
0570A:  MOVLW  01
0570C:  MOVLB  6
0570E:  MOVWF  xD9
05710:  MOVLW  A4
05712:  MOVWF  xD8
05714:  MOVLW  02
05716:  MOVWF  xDB
05718:  MOVLW  C0
0571A:  MOVWF  xDA
0571C:  MOVLB  0
0571E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(421, OUT_4_3_FILTER_NEGATIVEA1);     // OUT_4_3_FILTER_NEGATIVEA1 
05722:  MOVLW  01
05724:  MOVLB  6
05726:  MOVWF  xD9
05728:  MOVLW  A5
0572A:  MOVWF  xD8
0572C:  MOVLW  02
0572E:  MOVWF  xDB
05730:  MOVLW  C1
05732:  MOVWF  xDA
05734:  MOVLB  0
05736:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(422, OUT_4_3_FILTER_NEGATIVEA2);     // OUT_4_3_FILTER_NEGATIVEA2 
0573A:  MOVLW  01
0573C:  MOVLB  6
0573E:  MOVWF  xD9
05740:  MOVLW  A6
05742:  MOVWF  xD8
05744:  MOVLW  02
05746:  MOVWF  xDB
05748:  MOVLW  C2
0574A:  MOVWF  xDA
0574C:  MOVLB  0
0574E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(423, OUT_4_4_FILTER_B0);     // OUT_4_4_FILTER_B0 
05752:  MOVLW  01
05754:  MOVLB  6
05756:  MOVWF  xD9
05758:  MOVLW  A7
0575A:  MOVWF  xD8
0575C:  MOVLW  02
0575E:  MOVWF  xDB
05760:  MOVLW  8C
05762:  MOVWF  xDA
05764:  MOVLB  0
05766:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(424, OUT_4_4_FILTER_B1);     // OUT_4_4_FILTER_B1 
0576A:  MOVLW  01
0576C:  MOVLB  6
0576E:  MOVWF  xD9
05770:  MOVLW  A8
05772:  MOVWF  xD8
05774:  MOVLW  02
05776:  MOVWF  xDB
05778:  MOVLW  8D
0577A:  MOVWF  xDA
0577C:  MOVLB  0
0577E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(425, OUT_4_4_FILTER_B2);     // OUT_4_4_FILTER_B2 
05782:  MOVLW  01
05784:  MOVLB  6
05786:  MOVWF  xD9
05788:  MOVLW  A9
0578A:  MOVWF  xD8
0578C:  MOVLW  02
0578E:  MOVWF  xDB
05790:  MOVLW  8E
05792:  MOVWF  xDA
05794:  MOVLB  0
05796:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(426, OUT_4_4_FILTER_NEGATIVEA1);     // OUT_4_4_FILTER_NEGATIVEA1 
0579A:  MOVLW  01
0579C:  MOVLB  6
0579E:  MOVWF  xD9
057A0:  MOVLW  AA
057A2:  MOVWF  xD8
057A4:  MOVLW  02
057A6:  MOVWF  xDB
057A8:  MOVLW  8F
057AA:  MOVWF  xDA
057AC:  MOVLB  0
057AE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(427, OUT_4_4_FILTER_NEGATIVEA2);     // OUT_4_4_FILTER_NEGATIVEA2 
057B2:  MOVLW  01
057B4:  MOVLB  6
057B6:  MOVWF  xD9
057B8:  MOVLW  AB
057BA:  MOVWF  xD8
057BC:  MOVLW  02
057BE:  MOVWF  xDB
057C0:  MOVLW  90
057C2:  MOVWF  xDA
057C4:  MOVLB  0
057C6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(428, OUT_4_5_FILTER_B0);     // OUT_4_5_FILTER_B0 
057CA:  MOVLW  01
057CC:  MOVLB  6
057CE:  MOVWF  xD9
057D0:  MOVLW  AC
057D2:  MOVWF  xD8
057D4:  MOVLW  02
057D6:  MOVWF  xDB
057D8:  MOVLW  87
057DA:  MOVWF  xDA
057DC:  MOVLB  0
057DE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(429, OUT_4_5_FILTER_B1);     // OUT_4_5_FILTER_B1 
057E2:  MOVLW  01
057E4:  MOVLB  6
057E6:  MOVWF  xD9
057E8:  MOVLW  AD
057EA:  MOVWF  xD8
057EC:  MOVLW  02
057EE:  MOVWF  xDB
057F0:  MOVLW  88
057F2:  MOVWF  xDA
057F4:  MOVLB  0
057F6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(430, OUT_4_5_FILTER_B2);     // OUT_4_5_FILTER_B2 
057FA:  MOVLW  01
057FC:  MOVLB  6
057FE:  MOVWF  xD9
05800:  MOVLW  AE
05802:  MOVWF  xD8
05804:  MOVLW  02
05806:  MOVWF  xDB
05808:  MOVLW  89
0580A:  MOVWF  xDA
0580C:  MOVLB  0
0580E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(431, OUT_4_5_FILTER_NEGATIVEA1);     // OUT_4_5_FILTER_NEGATIVEA1 
05812:  MOVLW  01
05814:  MOVLB  6
05816:  MOVWF  xD9
05818:  MOVLW  AF
0581A:  MOVWF  xD8
0581C:  MOVLW  02
0581E:  MOVWF  xDB
05820:  MOVLW  8A
05822:  MOVWF  xDA
05824:  MOVLB  0
05826:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(432, OUT_4_5_FILTER_NEGATIVEA2);     // OUT_4_5_FILTER_NEGATIVEA2 
0582A:  MOVLW  01
0582C:  MOVLB  6
0582E:  MOVWF  xD9
05830:  MOVLW  B0
05832:  MOVWF  xD8
05834:  MOVLW  02
05836:  MOVWF  xDB
05838:  MOVLW  8B
0583A:  MOVWF  xDA
0583C:  MOVLB  0
0583E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(433, OUT_4_6_FILTER_B0);     // OUT_4_6_FILTER_B0 
05842:  MOVLW  01
05844:  MOVLB  6
05846:  MOVWF  xD9
05848:  MOVLW  B1
0584A:  MOVWF  xD8
0584C:  MOVLW  02
0584E:  MOVWF  xDB
05850:  MOVLW  82
05852:  MOVWF  xDA
05854:  MOVLB  0
05856:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(434, OUT_4_6_FILTER_B1);     // OUT_4_6_FILTER_B1 
0585A:  MOVLW  01
0585C:  MOVLB  6
0585E:  MOVWF  xD9
05860:  MOVLW  B2
05862:  MOVWF  xD8
05864:  MOVLW  02
05866:  MOVWF  xDB
05868:  MOVLW  83
0586A:  MOVWF  xDA
0586C:  MOVLB  0
0586E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(435, OUT_4_6_FILTER_B2);     // OUT_4_6_FILTER_B2 
05872:  MOVLW  01
05874:  MOVLB  6
05876:  MOVWF  xD9
05878:  MOVLW  B3
0587A:  MOVWF  xD8
0587C:  MOVLW  02
0587E:  MOVWF  xDB
05880:  MOVLW  84
05882:  MOVWF  xDA
05884:  MOVLB  0
05886:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(436, OUT_4_6_FILTER_NEGATIVEA1);     // OUT_4_6_FILTER_NEGATIVEA1 
0588A:  MOVLW  01
0588C:  MOVLB  6
0588E:  MOVWF  xD9
05890:  MOVLW  B4
05892:  MOVWF  xD8
05894:  MOVLW  02
05896:  MOVWF  xDB
05898:  MOVLW  85
0589A:  MOVWF  xDA
0589C:  MOVLB  0
0589E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(437, OUT_4_6_FILTER_NEGATIVEA2);     // OUT_4_6_FILTER_NEGATIVEA2 
058A2:  MOVLW  01
058A4:  MOVLB  6
058A6:  MOVWF  xD9
058A8:  MOVLW  B5
058AA:  MOVWF  xD8
058AC:  MOVLW  02
058AE:  MOVWF  xDB
058B0:  MOVLW  86
058B2:  MOVWF  xDA
058B4:  MOVLB  0
058B6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(438, CH1LIM_THRESHOLD);     // CH1LIM_THRESHOLD 
058BA:  MOVLW  01
058BC:  MOVLB  6
058BE:  MOVWF  xD9
058C0:  MOVLW  B6
058C2:  MOVWF  xD8
058C4:  MOVLW  02
058C6:  MOVWF  xDB
058C8:  MOVLW  2E
058CA:  MOVWF  xDA
058CC:  MOVLB  0
058CE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(439, CH1LIM_KNEE);     // CH1LIM_KNEE 
058D2:  MOVLW  01
058D4:  MOVLB  6
058D6:  MOVWF  xD9
058D8:  MOVLW  B7
058DA:  MOVWF  xD8
058DC:  MOVLW  02
058DE:  MOVWF  xDB
058E0:  MOVLW  2F
058E2:  MOVWF  xDA
058E4:  MOVLB  0
058E6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(440, CH1LIM_RATIO);     // CH1LIM_RATIO 
058EA:  MOVLW  01
058EC:  MOVLB  6
058EE:  MOVWF  xD9
058F0:  MOVLW  B8
058F2:  MOVWF  xD8
058F4:  MOVLW  02
058F6:  MOVWF  xDB
058F8:  MOVLW  30
058FA:  MOVWF  xDA
058FC:  MOVLB  0
058FE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(441, CH1LIM_ATTACK);     // CH1LIM_ATTACK 
05902:  MOVLW  01
05904:  MOVLB  6
05906:  MOVWF  xD9
05908:  MOVLW  B9
0590A:  MOVWF  xD8
0590C:  MOVLW  02
0590E:  MOVWF  xDB
05910:  MOVLW  31
05912:  MOVWF  xDA
05914:  MOVLB  0
05916:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(442, CH1LIM_RELEASE);     // CH1LIM_RELEASE 
0591A:  MOVLW  01
0591C:  MOVLB  6
0591E:  MOVWF  xD9
05920:  MOVLW  BA
05922:  MOVWF  xD8
05924:  MOVLW  02
05926:  MOVWF  xDB
05928:  MOVLW  32
0592A:  MOVWF  xDA
0592C:  MOVLB  0
0592E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(443, CH1LIM_BYPASS);     // CH1LIM_BYPASS 
05932:  MOVLW  01
05934:  MOVLB  6
05936:  MOVWF  xD9
05938:  MOVLW  BB
0593A:  MOVWF  xD8
0593C:  MOVLW  02
0593E:  MOVWF  xDB
05940:  MOVLW  33
05942:  MOVWF  xDA
05944:  MOVLB  0
05946:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(444, CH2LIM_THRESHOLD);     // CH2LIM_THRESHOLD 
0594A:  MOVLW  01
0594C:  MOVLB  6
0594E:  MOVWF  xD9
05950:  MOVLW  BC
05952:  MOVWF  xD8
05954:  MOVLW  02
05956:  MOVWF  xDB
05958:  MOVLW  26
0595A:  MOVWF  xDA
0595C:  MOVLB  0
0595E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(445, CH2LIM_KNEE);     // CH2LIM_KNEE 
05962:  MOVLW  01
05964:  MOVLB  6
05966:  MOVWF  xD9
05968:  MOVLW  BD
0596A:  MOVWF  xD8
0596C:  MOVLW  02
0596E:  MOVWF  xDB
05970:  MOVLW  27
05972:  MOVWF  xDA
05974:  MOVLB  0
05976:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(446, CH2LIM_RATIO);     // CH2LIM_RATIO 
0597A:  MOVLW  01
0597C:  MOVLB  6
0597E:  MOVWF  xD9
05980:  MOVLW  BE
05982:  MOVWF  xD8
05984:  MOVLW  02
05986:  MOVWF  xDB
05988:  MOVLW  28
0598A:  MOVWF  xDA
0598C:  MOVLB  0
0598E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(447, CH2LIM_ATTACK);     // CH2LIM_ATTACK 
05992:  MOVLW  01
05994:  MOVLB  6
05996:  MOVWF  xD9
05998:  MOVLW  BF
0599A:  MOVWF  xD8
0599C:  MOVLW  02
0599E:  MOVWF  xDB
059A0:  MOVLW  29
059A2:  MOVWF  xDA
059A4:  MOVLB  0
059A6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(448, CH2LIM_RELEASE);     // CH2LIM_RELEASE 
059AA:  MOVLW  01
059AC:  MOVLB  6
059AE:  MOVWF  xD9
059B0:  MOVLW  C0
059B2:  MOVWF  xD8
059B4:  MOVLW  02
059B6:  MOVWF  xDB
059B8:  MOVLW  2A
059BA:  MOVWF  xDA
059BC:  MOVLB  0
059BE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(449, CH2LIM_BYPASS);     // CH2LIM_BYPASS 
059C2:  MOVLW  01
059C4:  MOVLB  6
059C6:  MOVWF  xD9
059C8:  MOVLW  C1
059CA:  MOVWF  xD8
059CC:  MOVLW  02
059CE:  MOVWF  xDB
059D0:  MOVLW  2B
059D2:  MOVWF  xDA
059D4:  MOVLB  0
059D6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(450, CH3LIM_THRESHOLD);     // CH3LIM_THRESHOLD 
059DA:  MOVLW  01
059DC:  MOVLB  6
059DE:  MOVWF  xD9
059E0:  MOVLW  C2
059E2:  MOVWF  xD8
059E4:  MOVLW  02
059E6:  MOVWF  xDB
059E8:  MOVLW  1E
059EA:  MOVWF  xDA
059EC:  MOVLB  0
059EE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(451, CH3LIM_KNEE);     // CH3LIM_KNEE 
059F2:  MOVLW  01
059F4:  MOVLB  6
059F6:  MOVWF  xD9
059F8:  MOVLW  C3
059FA:  MOVWF  xD8
059FC:  MOVLW  02
059FE:  MOVWF  xDB
05A00:  MOVLW  1F
05A02:  MOVWF  xDA
05A04:  MOVLB  0
05A06:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(452, CH3LIM_RATIO);     // CH3LIM_RATIO 
05A0A:  MOVLW  01
05A0C:  MOVLB  6
05A0E:  MOVWF  xD9
05A10:  MOVLW  C4
05A12:  MOVWF  xD8
05A14:  MOVLW  02
05A16:  MOVWF  xDB
05A18:  MOVLW  20
05A1A:  MOVWF  xDA
05A1C:  MOVLB  0
05A1E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(453, CH3LIM_ATTACK);     // CH3LIM_ATTACK 
05A22:  MOVLW  01
05A24:  MOVLB  6
05A26:  MOVWF  xD9
05A28:  MOVLW  C5
05A2A:  MOVWF  xD8
05A2C:  MOVLW  02
05A2E:  MOVWF  xDB
05A30:  MOVLW  21
05A32:  MOVWF  xDA
05A34:  MOVLB  0
05A36:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(454, CH3LIM_RELEASE);     // CH3LIM_RELEASE 
05A3A:  MOVLW  01
05A3C:  MOVLB  6
05A3E:  MOVWF  xD9
05A40:  MOVLW  C6
05A42:  MOVWF  xD8
05A44:  MOVLW  02
05A46:  MOVWF  xDB
05A48:  MOVLW  22
05A4A:  MOVWF  xDA
05A4C:  MOVLB  0
05A4E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(455, CH3LIM_BYPASS);     // CH3LIM_BYPASS 
05A52:  MOVLW  01
05A54:  MOVLB  6
05A56:  MOVWF  xD9
05A58:  MOVLW  C7
05A5A:  MOVWF  xD8
05A5C:  MOVLW  02
05A5E:  MOVWF  xDB
05A60:  MOVLW  23
05A62:  MOVWF  xDA
05A64:  MOVLB  0
05A66:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(456, CH4LIM_THRESHOLD);     // CH4LIM_THRESHOLD 
05A6A:  MOVLW  01
05A6C:  MOVLB  6
05A6E:  MOVWF  xD9
05A70:  MOVLW  C8
05A72:  MOVWF  xD8
05A74:  MOVLW  02
05A76:  MOVWF  xDB
05A78:  MOVLW  16
05A7A:  MOVWF  xDA
05A7C:  MOVLB  0
05A7E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(457, CH4LIM_KNEE);     // CH4LIM_KNEE 
05A82:  MOVLW  01
05A84:  MOVLB  6
05A86:  MOVWF  xD9
05A88:  MOVLW  C9
05A8A:  MOVWF  xD8
05A8C:  MOVLW  02
05A8E:  MOVWF  xDB
05A90:  MOVLW  17
05A92:  MOVWF  xDA
05A94:  MOVLB  0
05A96:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(458, CH4LIM_RATIO);     // CH4LIM_RATIO 
05A9A:  MOVLW  01
05A9C:  MOVLB  6
05A9E:  MOVWF  xD9
05AA0:  MOVLW  CA
05AA2:  MOVWF  xD8
05AA4:  MOVLW  02
05AA6:  MOVWF  xDB
05AA8:  MOVLW  18
05AAA:  MOVWF  xDA
05AAC:  MOVLB  0
05AAE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(459, CH4LIM_ATTACK);     // CH4LIM_ATTACK 
05AB2:  MOVLW  01
05AB4:  MOVLB  6
05AB6:  MOVWF  xD9
05AB8:  MOVLW  CB
05ABA:  MOVWF  xD8
05ABC:  MOVLW  02
05ABE:  MOVWF  xDB
05AC0:  MOVLW  19
05AC2:  MOVWF  xDA
05AC4:  MOVLB  0
05AC6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(460, CH4LIM_RELEASE);     // CH4LIM_RELEASE 
05ACA:  MOVLW  01
05ACC:  MOVLB  6
05ACE:  MOVWF  xD9
05AD0:  MOVLW  CC
05AD2:  MOVWF  xD8
05AD4:  MOVLW  02
05AD6:  MOVWF  xDB
05AD8:  MOVLW  1A
05ADA:  MOVWF  xDA
05ADC:  MOVLB  0
05ADE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(461, CH4LIM_BYPASS);     // CH4LIM_BYPASS 
05AE2:  MOVLW  01
05AE4:  MOVLB  6
05AE6:  MOVWF  xD9
05AE8:  MOVLW  CD
05AEA:  MOVWF  xD8
05AEC:  MOVLW  02
05AEE:  MOVWF  xDB
05AF0:  MOVLW  1B
05AF2:  MOVWF  xDA
05AF4:  MOVLB  0
05AF6:  CALL   3124
....................  
.................... 	WRITE_CONFIG_ADDRESS(462, DELAY_CH1);     // DELAY_CH1 
05AFA:  MOVLW  01
05AFC:  MOVLB  6
05AFE:  MOVWF  xD9
05B00:  MOVLW  CE
05B02:  MOVWF  xD8
05B04:  MOVLW  03
05B06:  MOVWF  xDB
05B08:  MOVLW  DD
05B0A:  MOVWF  xDA
05B0C:  MOVLB  0
05B0E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(463, DELAY_BYPASS_CH1);     // DELAY_BYPASS_CH1 
05B12:  MOVLW  01
05B14:  MOVLB  6
05B16:  MOVWF  xD9
05B18:  MOVLW  CF
05B1A:  MOVWF  xD8
05B1C:  MOVLW  04
05B1E:  MOVWF  xDB
05B20:  MOVLW  48
05B22:  MOVWF  xDA
05B24:  MOVLB  0
05B26:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(464, DELAY_CH2);     // DELAY_CH2 
05B2A:  MOVLW  01
05B2C:  MOVLB  6
05B2E:  MOVWF  xD9
05B30:  MOVLW  D0
05B32:  MOVWF  xD8
05B34:  MOVLW  03
05B36:  MOVWF  xDB
05B38:  MOVLW  DA
05B3A:  MOVWF  xDA
05B3C:  MOVLB  0
05B3E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(465, DELAY_BYPASS_CH2);     // DELAY_BYPASS_CH2 
05B42:  MOVLW  01
05B44:  MOVLB  6
05B46:  MOVWF  xD9
05B48:  MOVLW  D1
05B4A:  MOVWF  xD8
05B4C:  MOVLW  04
05B4E:  MOVWF  xDB
05B50:  MOVLW  47
05B52:  MOVWF  xDA
05B54:  MOVLB  0
05B56:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(466, DELAY_CH3);     // DELAY_CH3 
05B5A:  MOVLW  01
05B5C:  MOVLB  6
05B5E:  MOVWF  xD9
05B60:  MOVLW  D2
05B62:  MOVWF  xD8
05B64:  MOVLW  03
05B66:  MOVWF  xDB
05B68:  MOVLW  D7
05B6A:  MOVWF  xDA
05B6C:  MOVLB  0
05B6E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(467, DELAY_BYPASS_CH3);     // DELAY_BYPASS_CH3 
05B72:  MOVLW  01
05B74:  MOVLB  6
05B76:  MOVWF  xD9
05B78:  MOVLW  D3
05B7A:  MOVWF  xD8
05B7C:  MOVLW  04
05B7E:  MOVWF  xDB
05B80:  MOVLW  46
05B82:  MOVWF  xDA
05B84:  MOVLB  0
05B86:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(468, DELAY_CH4);     // DELAY_CH4 
05B8A:  MOVLW  01
05B8C:  MOVLB  6
05B8E:  MOVWF  xD9
05B90:  MOVLW  D4
05B92:  MOVWF  xD8
05B94:  MOVLW  03
05B96:  MOVWF  xDB
05B98:  MOVLW  D4
05B9A:  MOVWF  xDA
05B9C:  MOVLB  0
05B9E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(469, DELAY_BYPASS_CH4);     // DELAY_BYPASS_CH4 
05BA2:  MOVLW  01
05BA4:  MOVLB  6
05BA6:  MOVWF  xD9
05BA8:  MOVLW  D5
05BAA:  MOVWF  xD8
05BAC:  MOVLW  04
05BAE:  MOVWF  xDB
05BB0:  MOVLW  45
05BB2:  MOVWF  xDA
05BB4:  MOVLB  0
05BB6:  CALL   3124
.................... 	 
.................... 	WRITE_CONFIG_ADDRESS(470, BRIDGEROUTER_SELECT0);     // BRIDGEROUTER_SELECT0 
05BBA:  MOVLW  01
05BBC:  MOVLB  6
05BBE:  MOVWF  xD9
05BC0:  MOVLW  D6
05BC2:  MOVWF  xD8
05BC4:  MOVLW  02
05BC6:  MOVWF  xDB
05BC8:  MOVLW  7E
05BCA:  MOVWF  xDA
05BCC:  MOVLB  0
05BCE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(471, BRIDGEROUTER_SELECT1);     // BRIDGEROUTER_SELECT1 
05BD2:  MOVLW  01
05BD4:  MOVLB  6
05BD6:  MOVWF  xD9
05BD8:  MOVLW  D7
05BDA:  MOVWF  xD8
05BDC:  MOVLW  02
05BDE:  MOVWF  xDB
05BE0:  MOVLW  7F
05BE2:  MOVWF  xDA
05BE4:  MOVLB  0
05BE6:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(472, BRIDGEROUTER_SELECT2);     // BRIDGEROUTER_SELECT2 
05BEA:  MOVLW  01
05BEC:  MOVLB  6
05BEE:  MOVWF  xD9
05BF0:  MOVLW  D8
05BF2:  MOVWF  xD8
05BF4:  MOVLW  02
05BF6:  MOVWF  xDB
05BF8:  MOVLW  80
05BFA:  MOVWF  xDA
05BFC:  MOVLB  0
05BFE:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(473, BRIDGEROUTER_SELECT3);     // BRIDGEROUTER_SELECT3 
05C02:  MOVLW  01
05C04:  MOVLB  6
05C06:  MOVWF  xD9
05C08:  MOVLW  D9
05C0A:  MOVWF  xD8
05C0C:  MOVLW  02
05C0E:  MOVWF  xDB
05C10:  MOVLW  81
05C12:  MOVWF  xDA
05C14:  MOVLB  0
05C16:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(474, GEN_PINK_GAIN);     // GEN_PINK_GAIN 
05C1A:  MOVLW  01
05C1C:  MOVLB  6
05C1E:  MOVWF  xD9
05C20:  MOVLW  DA
05C22:  MOVWF  xD8
05C24:  MOVLW  04
05C26:  MOVWF  xDB
05C28:  MOVLW  11
05C2A:  MOVWF  xDA
05C2C:  MOVLB  0
05C2E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(475, GEN_SINE_OMEGA);     // GEN_SINE_OMEGA 
05C32:  MOVLW  01
05C34:  MOVLB  6
05C36:  MOVWF  xD9
05C38:  MOVLW  DB
05C3A:  MOVWF  xD8
05C3C:  MOVLW  03
05C3E:  MOVWF  xDB
05C40:  MOVLW  EB
05C42:  MOVWF  xDA
05C44:  MOVLB  0
05C46:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(476, GEN_SINE_GAIN);     // GEN_SINE_GAIN 
05C4A:  MOVLW  01
05C4C:  MOVLB  6
05C4E:  MOVWF  xD9
05C50:  MOVLW  DC
05C52:  MOVWF  xD8
05C54:  MOVLW  03
05C56:  MOVWF  xDB
05C58:  MOVLW  EC
05C5A:  MOVWF  xDA
05C5C:  MOVLB  0
05C5E:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(477, SEVENTYVHP_BYPASS);     // 70VHP_BYPASS 
05C62:  MOVLW  01
05C64:  MOVLB  6
05C66:  MOVWF  xD9
05C68:  MOVLW  DD
05C6A:  MOVWF  xD8
05C6C:  MOVLW  04
05C6E:  MOVWF  xDB
05C70:  MOVLW  44
05C72:  MOVWF  xDA
05C74:  MOVLB  0
05C76:  CALL   3124
.................... 	WRITE_CONFIG_ADDRESS(478, MUTE_OUTPUTS);     // MUTE_OUTPUTS 
05C7A:  MOVLW  01
05C7C:  MOVLB  6
05C7E:  MOVWF  xD9
05C80:  MOVLW  DE
05C82:  MOVWF  xD8
05C84:  MOVLW  04
05C86:  MOVWF  xDB
05C88:  MOVLW  13
05C8A:  MOVWF  xDA
05C8C:  MOVLB  0
05C8E:  CALL   3124
....................  
.................... } 
05C92:  GOTO   9656 (RETURN)
....................  
.................... #include <phantom.c> 
.................... void update_phantom_power() 
.................... { 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
*
06D5C:  MOVLB  7
06D5E:  CLRF   x2B
06D60:  MOVLW  7A
06D62:  MOVWF  x2A
06D64:  MOVFF  79,72C
06D68:  MOVLW  08
06D6A:  MOVWF  x2D
06D6C:  MOVLB  0
06D6E:  CALL   649C
....................  
.................... 	int32 phantom_mask = PAGE_BUFFER_A[54]; 
06D72:  MOVFF  155,728
06D76:  MOVFF  154,727
06D7A:  MOVFF  153,726
06D7E:  MOVFF  152,725
....................  
.................... 	if((phantom_mask & 0x03) > 0) { 
06D82:  MOVLB  7
06D84:  MOVF   x25,W
06D86:  ANDLW  03
06D88:  MOVWF  x29
06D8A:  CLRF   x2A
06D8C:  CLRF   x2B
06D8E:  CLRF   x2C
06D90:  MOVF   x29,F
06D92:  BNZ   6DA0
06D94:  MOVF   x2A,F
06D96:  BNZ   6DA0
06D98:  MOVF   x2B,F
06D9A:  BNZ   6DA0
06D9C:  MOVF   x2C,F
06D9E:  BZ    6DA6
.................... 		output_high(PIN_PHANTOM_ENABLE); 
06DA0:  BCF    F95.5
06DA2:  BSF    F8C.5
.................... 	} else { 
06DA4:  BRA    6DAA
.................... 		output_low(PIN_PHANTOM_ENABLE); 
06DA6:  BCF    F95.5
06DA8:  BCF    F8C.5
.................... 	} 
....................  
....................  
.................... 	output_bit(PIN_PHANTOM_CH1,bit_test(phantom_mask,0)); 
06DAA:  BTFSC  x25.0
06DAC:  BRA    6DB2
06DAE:  BCF    F8A.4
06DB0:  BRA    6DB4
06DB2:  BSF    F8A.4
06DB4:  BCF    F93.4
.................... 	output_bit(PIN_PHANTOM_CH2,bit_test(phantom_mask,1)); 
06DB6:  BTFSC  x25.1
06DB8:  BRA    6DBE
06DBA:  BCF    F8A.5
06DBC:  BRA    6DC0
06DBE:  BSF    F8A.5
06DC0:  BCF    F93.5
....................  
.................... } 
06DC2:  MOVLB  0
06DC4:  RETURN 0
....................  
.................... #include <presets.c> 
.................... // presets.c 
....................  
.................... void softboot(); 
....................  
.................... void save_flash_program() 
.................... { 
.................... 	//FLASH_PROGRAM_WRITE(CURRENT_PRESET); 
.................... } 
*
0772C:  GOTO   8AC0 (RETURN)
....................  
.................... void switch_flash_program(int new_index) 
.................... { 
.................... 	CURRENT_FLASH_PROGRAM = new_index; 
*
076E8:  MOVFF  720,79
....................  
.................... 	softboot(); 
076EC:  CALL   6DC6
....................  
.................... 	write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
076F0:  CLRF   FAA
076F2:  MOVLW  10
076F4:  MOVWF  FA9
076F6:  MOVFF  79,FA8
076FA:  BCF    FA6.6
076FC:  BCF    FA6.7
076FE:  BSF    FA6.2
07700:  MOVF   FF2,W
07702:  MOVWF  00
07704:  BCF    FF2.7
07706:  MOVLB  F
07708:  MOVLW  55
0770A:  MOVWF  FA7
0770C:  MOVLW  AA
0770E:  MOVWF  FA7
07710:  BSF    FA6.1
07712:  BTFSC  FA6.1
07714:  BRA    7712
07716:  BCF    FA6.2
07718:  MOVF   00,W
0771A:  IORWF  FF2,F
....................  
.................... 	delay_ms(5); 
0771C:  MOVLW  05
0771E:  MOVLB  7
07720:  MOVWF  x2B
07722:  MOVLB  0
07724:  CALL   608E
.................... } 
07728:  GOTO   8A88 (RETURN)
....................  
.................... #include <adc.c> 
.................... // ADC 
....................  
.................... double RVC_to_dsp_value(unsigned int read_value) 
.................... { 
.................... 	return pow(10.0,(-60.0+(60.0*((read_value-30.0)/225.0)))/20.0); 
*
02A2A:  MOVLB  7
02A2C:  CLRF   xA5
02A2E:  MOVFF  76F,7A4
02A32:  MOVLB  0
02A34:  CALL   14A0
02A38:  BSF    FD8.1
02A3A:  MOVFF  03,7A7
02A3E:  MOVFF  02,7A6
02A42:  MOVFF  01,7A5
02A46:  MOVFF  00,7A4
02A4A:  MOVLB  7
02A4C:  CLRF   xAB
02A4E:  CLRF   xAA
02A50:  MOVLW  70
02A52:  MOVWF  xA9
02A54:  MOVLW  83
02A56:  MOVWF  xA8
02A58:  MOVLB  0
02A5A:  CALL   14D6
02A5E:  MOVFF  00,770
02A62:  MOVFF  01,771
02A66:  MOVFF  02,772
02A6A:  MOVFF  03,773
02A6E:  MOVFF  03,79C
02A72:  MOVFF  02,79B
02A76:  MOVFF  01,79A
02A7A:  MOVFF  00,799
02A7E:  MOVLB  7
02A80:  CLRF   xA0
02A82:  CLRF   x9F
02A84:  MOVLW  61
02A86:  MOVWF  x9E
02A88:  MOVLW  86
02A8A:  MOVWF  x9D
02A8C:  MOVLB  0
02A8E:  CALL   174E
02A92:  MOVLB  7
02A94:  CLRF   xA3
02A96:  CLRF   xA2
02A98:  MOVLW  70
02A9A:  MOVWF  xA1
02A9C:  MOVLW  84
02A9E:  MOVWF  xA0
02AA0:  MOVFF  03,7A7
02AA4:  MOVFF  02,7A6
02AA8:  MOVFF  01,7A5
02AAC:  MOVFF  00,7A4
02AB0:  MOVLB  0
02AB2:  CALL   18AC
02AB6:  BCF    FD8.1
02AB8:  MOVLB  7
02ABA:  CLRF   xA7
02ABC:  CLRF   xA6
02ABE:  MOVLW  F0
02AC0:  MOVWF  xA5
02AC2:  MOVLW  84
02AC4:  MOVWF  xA4
02AC6:  MOVFF  03,7AB
02ACA:  MOVFF  02,7AA
02ACE:  MOVFF  01,7A9
02AD2:  MOVFF  00,7A8
02AD6:  MOVLB  0
02AD8:  CALL   14D6
02ADC:  MOVFF  00,770
02AE0:  MOVFF  01,771
02AE4:  MOVFF  02,772
02AE8:  MOVFF  03,773
02AEC:  MOVFF  03,79C
02AF0:  MOVFF  02,79B
02AF4:  MOVFF  01,79A
02AF8:  MOVFF  00,799
02AFC:  MOVLB  7
02AFE:  CLRF   xA0
02B00:  CLRF   x9F
02B02:  MOVLW  20
02B04:  MOVWF  x9E
02B06:  MOVLW  83
02B08:  MOVWF  x9D
02B0A:  MOVLB  0
02B0C:  CALL   174E
02B10:  MOVFF  00,770
02B14:  MOVFF  01,771
02B18:  MOVFF  02,772
02B1C:  MOVFF  03,773
02B20:  MOVLB  7
02B22:  CLRF   x77
02B24:  CLRF   x76
02B26:  MOVLW  20
02B28:  MOVWF  x75
02B2A:  MOVLW  82
02B2C:  MOVWF  x74
02B2E:  MOVFF  03,77B
02B32:  MOVFF  02,77A
02B36:  MOVFF  01,779
02B3A:  MOVFF  00,778
02B3E:  MOVLB  0
02B40:  RCALL  271E
....................  
.................... } 
02B42:  RETURN 0
....................  
.................... double RVC_to_decibel(unsigned int read_value) 
.................... { 
*
07EBE:  CLRF   19
07EC0:  BTFSC  FF2.7
07EC2:  BSF    19.7
07EC4:  BCF    FF2.7
.................... 	return -60.0 + (60.0*((read_value-30.0)/225.0)); 
07EC6:  MOVLB  7
07EC8:  CLRF   xA5
07ECA:  MOVFF  720,7A4
07ECE:  MOVLB  0
07ED0:  CALL   14A0
07ED4:  BTFSC  19.7
07ED6:  BSF    FF2.7
07ED8:  BSF    FD8.1
07EDA:  CLRF   19
07EDC:  BTFSC  FF2.7
07EDE:  BSF    19.7
07EE0:  BCF    FF2.7
07EE2:  MOVFF  03,7A7
07EE6:  MOVFF  02,7A6
07EEA:  MOVFF  01,7A5
07EEE:  MOVFF  00,7A4
07EF2:  MOVLB  7
07EF4:  CLRF   xAB
07EF6:  CLRF   xAA
07EF8:  MOVLW  70
07EFA:  MOVWF  xA9
07EFC:  MOVLW  83
07EFE:  MOVWF  xA8
07F00:  MOVLB  0
07F02:  CALL   14D6
07F06:  BTFSC  19.7
07F08:  BSF    FF2.7
07F0A:  MOVFF  00,721
07F0E:  MOVFF  01,722
07F12:  MOVFF  02,723
07F16:  MOVFF  03,724
07F1A:  CLRF   19
07F1C:  BTFSC  FF2.7
07F1E:  BSF    19.7
07F20:  BCF    FF2.7
07F22:  MOVFF  03,79C
07F26:  MOVFF  02,79B
07F2A:  MOVFF  01,79A
07F2E:  MOVFF  00,799
07F32:  MOVLB  7
07F34:  CLRF   xA0
07F36:  CLRF   x9F
07F38:  MOVLW  61
07F3A:  MOVWF  x9E
07F3C:  MOVLW  86
07F3E:  MOVWF  x9D
07F40:  MOVLB  0
07F42:  CALL   174E
07F46:  BTFSC  19.7
07F48:  BSF    FF2.7
07F4A:  CLRF   19
07F4C:  BTFSC  FF2.7
07F4E:  BSF    19.7
07F50:  BCF    FF2.7
07F52:  MOVLB  7
07F54:  CLRF   xA3
07F56:  CLRF   xA2
07F58:  MOVLW  70
07F5A:  MOVWF  xA1
07F5C:  MOVLW  84
07F5E:  MOVWF  xA0
07F60:  MOVFF  03,7A7
07F64:  MOVFF  02,7A6
07F68:  MOVFF  01,7A5
07F6C:  MOVFF  00,7A4
07F70:  MOVLB  0
07F72:  CALL   18AC
07F76:  BTFSC  19.7
07F78:  BSF    FF2.7
07F7A:  BCF    FD8.1
07F7C:  CLRF   19
07F7E:  BTFSC  FF2.7
07F80:  BSF    19.7
07F82:  BCF    FF2.7
07F84:  MOVLB  7
07F86:  CLRF   xA7
07F88:  CLRF   xA6
07F8A:  MOVLW  F0
07F8C:  MOVWF  xA5
07F8E:  MOVLW  84
07F90:  MOVWF  xA4
07F92:  MOVFF  03,7AB
07F96:  MOVFF  02,7AA
07F9A:  MOVFF  01,7A9
07F9E:  MOVFF  00,7A8
07FA2:  MOVLB  0
07FA4:  CALL   14D6
07FA8:  BTFSC  19.7
07FAA:  BSF    FF2.7
.................... } 
07FAC:  GOTO   94B4 (RETURN)
....................  
....................  
.................... int ADC_calibrate_min(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
*
07CD0:  MOVLW  00
07CD2:  MOVWF  01
07CD4:  MOVF   FC2,W
07CD6:  ANDLW  83
07CD8:  IORWF  01,W
07CDA:  MOVWF  FC2
.................... 	delay_us(10); 
07CDC:  MOVLW  0B
07CDE:  MOVWF  00
07CE0:  DECFSZ 00,F
07CE2:  BRA    7CE0
07CE4:  BRA    7CE6
.................... 	int current_adc = read_adc(); 
07CE6:  BSF    FC2.1
07CE8:  BTFSC  FC2.1
07CEA:  BRA    7CE8
07CEC:  MOVFF  FC4,721
07CF0:  MOVLB  7
07CF2:  CLRF   19
07CF4:  BTFSC  FF2.7
07CF6:  BSF    19.7
07CF8:  BCF    FF2.7
.................... 	 
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new minimum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = (double)current_adc; 
07CFA:  CLRF   xA5
07CFC:  MOVFF  721,7A4
07D00:  MOVLB  0
07D02:  CALL   14A0
07D06:  BTFSC  19.7
07D08:  BSF    FF2.7
07D0A:  MOVFF  03,38
07D0E:  MOVFF  02,37
07D12:  MOVFF  01,36
07D16:  MOVFF  00,35
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07D1A:  MOVLB  7
07D1C:  CLRF   x23
07D1E:  MOVLW  33
07D20:  MOVWF  x22
07D22:  CLRF   x25
07D24:  MOVLW  28
07D26:  MOVWF  x24
07D28:  CLRF   x27
07D2A:  MOVLW  64
07D2C:  MOVWF  x26
07D2E:  MOVLB  0
07D30:  CALL   642C
.................... 	delay_ms(10); 
07D34:  MOVLW  0A
07D36:  MOVLB  7
07D38:  MOVWF  x2B
07D3A:  MOVLB  0
07D3C:  CALL   608E
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07D40:  MOVLB  7
07D42:  MOVFF  721,01
.................... } 
07D46:  MOVLB  0
07D48:  GOTO   8D92 (RETURN)
....................  
.................... int ADC_calibrate_max(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
07D4C:  MOVLW  00
07D4E:  MOVWF  01
07D50:  MOVF   FC2,W
07D52:  ANDLW  83
07D54:  IORWF  01,W
07D56:  MOVWF  FC2
.................... 	delay_us(10); 
07D58:  MOVLW  0B
07D5A:  MOVWF  00
07D5C:  DECFSZ 00,F
07D5E:  BRA    7D5C
07D60:  BRA    7D62
.................... 	int current_adc = read_adc(); 
07D62:  BSF    FC2.1
07D64:  BTFSC  FC2.1
07D66:  BRA    7D64
07D68:  MOVFF  FC4,721
07D6C:  MOVLB  7
07D6E:  CLRF   19
07D70:  BTFSC  FF2.7
07D72:  BSF    19.7
07D74:  BCF    FF2.7
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new maximum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX= (double)current_adc; 
07D76:  CLRF   xA5
07D78:  MOVFF  721,7A4
07D7C:  MOVLB  0
07D7E:  CALL   14A0
07D82:  BTFSC  19.7
07D84:  BSF    FF2.7
07D86:  MOVFF  03,3C
07D8A:  MOVFF  02,3B
07D8E:  MOVFF  01,3A
07D92:  MOVFF  00,39
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07D96:  MOVLB  7
07D98:  CLRF   x23
07D9A:  MOVLW  33
07D9C:  MOVWF  x22
07D9E:  CLRF   x25
07DA0:  MOVLW  28
07DA2:  MOVWF  x24
07DA4:  CLRF   x27
07DA6:  MOVLW  64
07DA8:  MOVWF  x26
07DAA:  MOVLB  0
07DAC:  CALL   642C
.................... 	delay_ms(10); 
07DB0:  MOVLW  0A
07DB2:  MOVLB  7
07DB4:  MOVWF  x2B
07DB6:  MOVLB  0
07DB8:  CALL   608E
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07DBC:  MOVLB  7
07DBE:  MOVFF  721,01
.................... } 
07DC2:  MOVLB  0
07DC4:  GOTO   8DDC (RETURN)
....................  
.................... #include <device_boot.c> 
.................... void softboot(); 
.................... void initialize_first_boot(); 
....................  
.................... void default_device_config() 
.................... { 
.................... 	for(int x = 0; x < 20; x++) { 
*
0669E:  MOVLB  6
066A0:  CLRF   xDA
066A2:  MOVF   xDA,W
066A4:  SUBLW  13
066A6:  BNC   66BC
.................... 		DEVICE_CONFIG.SERIAL[x] = 0xFF; 
066A8:  CLRF   03
066AA:  MOVF   xDA,W
066AC:  ADDLW  47
066AE:  MOVWF  FE9
066B0:  MOVLW  00
066B2:  ADDWFC 03,W
066B4:  MOVWF  FEA
066B6:  SETF   FEF
.................... 	} 
066B8:  INCF   xDA,F
066BA:  BRA    66A2
....................  
.................... 	DEVICE_CONFIG.SERIAL[0] = 'N'; 
066BC:  MOVLW  4E
066BE:  MOVWF  47
.................... 	DEVICE_CONFIG.SERIAL[1] = 'O'; 
066C0:  MOVLW  4F
066C2:  MOVWF  48
.................... 	DEVICE_CONFIG.SERIAL[2] = 'N'; 
066C4:  MOVLW  4E
066C6:  MOVWF  49
.................... 	DEVICE_CONFIG.SERIAL[3] = 'E'; 
066C8:  MOVLW  45
066CA:  MOVWF  4A
....................  
.................... 	DEVICE_CONFIG.AMP_MODE = 				DEFAULT_AMP_MODE; 
066CC:  MOVFF  27,33
.................... 	DEVICE_CONFIG.IS_70V = 					DEFAULT_IS_70V; 
066D0:  MOVFF  28,34
....................  
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = 	DEFAULT_ADC_CALIBRATION_MIN; 
066D4:  MOVFF  22,38
066D8:  MOVFF  21,37
066DC:  MOVFF  20,36
066E0:  MOVFF  1F,35
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX = 	DEFAULT_ADC_CALIBRATION_MAX; 
066E4:  MOVFF  26,3C
066E8:  MOVFF  25,3B
066EC:  MOVFF  24,3A
066F0:  MOVFF  23,39
....................  
.................... 	DEVICE_CONFIG.RVC_ENABLE = 				DEFAULT_RVC_ENABLE; 
066F4:  MOVFF  29,3D
.................... 	DEVICE_CONFIG.USBDETECT_ENABLE = 		DEFAULT_USBDETECT_ENABLE; 
066F8:  MOVFF  2A,3E
.................... 	DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = 	DEFAULT_AMPBOOT_DELAY_ENABLE; 
066FC:  MOVFF  2B,3F
.................... 	DEVICE_CONFIG.PS_PIN_ENABLE = 			DEFAULT_PS_PIN_ENABLE; 
06700:  MOVFF  2C,40
.................... 	DEVICE_CONFIG.DSP_VALUESEND_ENABLE = 	DEFAULT_DSP_VALUESEND_ENABLE; 
06704:  MOVFF  2D,41
.................... 	 
.................... 	DEVICE_CONFIG.SLEEP_ENABLE		= 		DEFAULT_SLEEP_ENABLE; 
06708:  MOVFF  2E,42
.................... 	DEVICE_CONFIG.SLEEP_SECONDS		= 		DEFAULT_SLEEP_SECONDS; 
0670C:  MOVFF  30,44
06710:  MOVFF  2F,43
.................... 	DEVICE_CONFIG.SLEEP_HOLDTIME	= 		DEFAULT_SLEEP_HOLDTIME; 
06714:  MOVFF  32,46
06718:  MOVFF  31,45
.................... 	delay_ms(10); 
0671C:  MOVLW  0A
0671E:  MOVLB  7
06720:  MOVWF  x2B
06722:  MOVLB  0
06724:  RCALL  608E
.................... 	 
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),IEEPROM_DEVICE_CONFIG_LOC); 
06726:  MOVLB  7
06728:  CLRF   x23
0672A:  MOVLW  33
0672C:  MOVWF  x22
0672E:  CLRF   x25
06730:  MOVLW  28
06732:  MOVWF  x24
06734:  CLRF   x27
06736:  MOVLW  64
06738:  MOVWF  x26
0673A:  MOVLB  0
0673C:  RCALL  642C
....................  
.................... 	 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
0673E:  MOVLB  7
06740:  CLRF   x2B
06742:  MOVLW  7A
06744:  MOVWF  x2A
06746:  MOVFF  79,72C
0674A:  MOVLW  08
0674C:  MOVWF  x2D
0674E:  MOVLB  0
06750:  RCALL  649C
.................... 	PAGE_BUFFER_A[57] = 0; 
06752:  MOVLB  1
06754:  CLRF   x61
06756:  CLRF   x60
06758:  CLRF   x5F
0675A:  CLRF   x5E
.................... 	write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
0675C:  MOVLB  7
0675E:  CLRF   x29
06760:  MOVLW  7A
06762:  MOVWF  x28
06764:  MOVFF  79,72A
06768:  MOVLW  08
0676A:  MOVWF  x2B
0676C:  MOVLB  0
0676E:  RCALL  6588
.................... 	 
.................... } 
06770:  GOTO   68A8 (RETURN)
....................  
.................... void print_device_config() 
.................... { 
.................... 	char name_buffer[20]; 
....................  
.................... 	memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
....................  
.................... 	fprintf(RS232,"[CONFIG] SERIAL = "); 
....................  
.................... 	for(int y = 0; y < 20; y++) { 
.................... 		if(name_buffer[y] == 0xFF) { 
.................... 			break; 
.................... 		} 
....................  
.................... 		fputc(name_buffer[y],RS232); 
....................  
.................... 	}  
....................  
.................... 	fprintf(RS232,"\r\n"); 
....................  
.................... 	 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 4CH\r\n"); 
.................... 	} else if(DEVICE_CONFIG.AMP_MODE == 1) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 2CH\r\n"); 
.................... 	} else { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 1CH\r\n"); 
.................... 	} 
....................  
.................... 	 
.................... 	fprintf(RS232,"[CONFIG] IS_70V = %u\r\n",DEVICE_CONFIG.IS_70V); 
....................  
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MIN = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MAX = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
....................  
.................... 	fprintf(RS232,"[CONFIG] RVC_ENABLE = %u\r\n",DEVICE_CONFIG.RVC_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] USBDETECT_ENABLE = %u\r\n",DEVICE_CONFIG.USBDETECT_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] AMPBOOT_DELAY_ENABLE = %u\r\n",DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] PS_PIN_ENABLE = %u\r\n",DEVICE_CONFIG.PS_PIN_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] DSP_VALUESEND_ENABLE = %u\r\n",DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_ENABLE = %u\r\n",DEVICE_CONFIG.SLEEP_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_SECONDS = %ld\r\n",DEVICE_CONFIG.SLEEP_SECONDS); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_HOLDTIME = %ld\r\n",DEVICE_CONFIG.SLEEP_HOLDTIME); 
....................  
.................... } 
....................  
.................... void device_boot() 
.................... { 
.................... 	/* POWER STARTUP SEQUENCE */ 
.................... 	delay_ms(POWERUP_DELAY); 
06774:  MOVLW  C8
06776:  MOVLB  7
06778:  MOVWF  x2B
0677A:  MOVLB  0
0677C:  RCALL  608E
.................... 	 
.................... 	fprintf(RS232,"Booting into main application built on "); 
0677E:  MOVLW  54
06780:  MOVWF  FF6
06782:  MOVLW  0C
06784:  MOVWF  FF7
06786:  RCALL  60B6
.................... 	fprintf(RS232,__DATE__); 
06788:  MOVLW  7C
0678A:  MOVWF  FF6
0678C:  MOVLW  0C
0678E:  MOVWF  FF7
06790:  RCALL  60B6
.................... 	fprintf(RS232," "); 
06792:  MOVLW  20
06794:  BTFSS  FA4.4
06796:  BRA    6794
06798:  MOVWF  F73
.................... 	fprintf(RS232,__TIME__); 
0679A:  MOVLW  86
0679C:  MOVWF  FF6
0679E:  MOVLW  0C
067A0:  MOVWF  FF7
067A2:  RCALL  60B6
.................... 	fprintf(RS232,"\r"); 
067A4:  MOVLW  0D
067A6:  BTFSS  FA4.4
067A8:  BRA    67A6
067AA:  MOVWF  F73
....................  
.................... 	fprintf(RS232,"Device firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
067AC:  MOVLW  90
067AE:  MOVWF  FF6
067B0:  MOVLW  0C
067B2:  MOVWF  FF7
067B4:  MOVLW  14
067B6:  MOVLB  7
067B8:  MOVWF  x2E
067BA:  MOVLB  0
067BC:  RCALL  60D8
067BE:  MOVFF  61,72E
067C2:  MOVLW  1B
067C4:  MOVLB  7
067C6:  MOVWF  x2F
067C8:  MOVLB  0
067CA:  RCALL  612E
067CC:  MOVLW  2E
067CE:  BTFSS  FA4.4
067D0:  BRA    67CE
067D2:  MOVWF  F73
067D4:  MOVFF  62,72E
067D8:  MOVLW  1B
067DA:  MOVLB  7
067DC:  MOVWF  x2F
067DE:  MOVLB  0
067E0:  RCALL  612E
067E2:  CLRF   FEA
067E4:  MOVLW  63
067E6:  MOVWF  FE9
067E8:  BRA    61AC
067EA:  MOVLW  0D
067EC:  BTFSS  FA4.4
067EE:  BRA    67EC
067F0:  MOVWF  F73
.................... 	delay_ms(10); 
067F2:  MOVLW  0A
067F4:  MOVLB  7
067F6:  MOVWF  x2B
067F8:  MOVLB  0
067FA:  RCALL  608E
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Reading DSP addresses from flash into memory... "); 
.................... 	} 
....................  
.................... 	FLASH_ADDR_READ(); 
067FC:  BRA    61D4
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Checking if EEPROM is configured... "); 
.................... 	} 
....................  
.................... 	int eeprom_preset_number = read_eeprom(IEEPROM_PRESET_LOC); 
067FE:  MOVFF  FF2,6DA
06802:  BCF    FF2.7
06804:  CLRF   FAA
06806:  MOVLW  10
06808:  MOVWF  FA9
0680A:  BCF    FA6.6
0680C:  BCF    FA6.7
0680E:  BSF    FA6.0
06810:  MOVF   FA8,W
06812:  MOVLB  6
06814:  BTFSC  xDA.7
06816:  BSF    FF2.7
06818:  MOVWF  xD8
....................  
.................... 	//TODO - Re-implement 
.................... 	if(eeprom_preset_number == 0xFF) { 
0681A:  INCFSZ xD8,W
0681C:  BRA    6852
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"NO PRESET IN EEPROM, GOING TO DEFAULT\r\n"); 
.................... 		} 
.................... 		//switch_flash_program(DEFAULT_PRESET); 
.................... 		CURRENT_FLASH_PROGRAM = DEFAULT_PRESET; 
0681E:  MOVLB  0
06820:  CLRF   x79
.................... 		write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
06822:  CLRF   FAA
06824:  MOVLW  10
06826:  MOVWF  FA9
06828:  MOVFF  79,FA8
0682C:  BCF    FA6.6
0682E:  BCF    FA6.7
06830:  BSF    FA6.2
06832:  MOVF   FF2,W
06834:  MOVWF  00
06836:  BCF    FF2.7
06838:  MOVLB  F
0683A:  MOVLW  55
0683C:  MOVWF  FA7
0683E:  MOVLW  AA
06840:  MOVWF  FA7
06842:  BSF    FA6.1
06844:  BTFSC  FA6.1
06846:  BRA    6844
06848:  BCF    FA6.2
0684A:  MOVF   00,W
0684C:  IORWF  FF2,F
.................... 	} else { 
0684E:  BRA    6856
06850:  MOVLB  6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"BOOTING FROM STORED PRESET - %U\r\n",eeprom_preset_number); 
.................... 		} 
.................... 		//switch_flash_program(eeprom_preset_number); 
.................... 		CURRENT_FLASH_PROGRAM = eeprom_preset_number; 
06852:  MOVFF  6D8,79
.................... 	} 
....................  
.................... 	delay_ms(10); 
06856:  MOVLW  0A
06858:  MOVLB  7
0685A:  MOVWF  x2B
0685C:  MOVLB  0
0685E:  RCALL  608E
....................  
.................... 	int programmed_flag = read_eeprom(IEEPROM_FLAG_LOC); 
06860:  MOVFF  FF2,6DA
06864:  BCF    FF2.7
06866:  CLRF   FAA
06868:  MOVLW  20
0686A:  MOVWF  FA9
0686C:  BCF    FA6.6
0686E:  BCF    FA6.7
06870:  BSF    FA6.0
06872:  MOVF   FA8,W
06874:  MOVLB  6
06876:  BTFSC  xDA.7
06878:  BSF    FF2.7
0687A:  MOVWF  xD9
....................  
.................... 	INTEEPROM_GET(&DEVICE_CONFIG,sizeof(device_configuration),IEEPROM_DEVICE_CONFIG_LOC); 
0687C:  CLRF   xDB
0687E:  MOVLW  33
06880:  MOVWF  xDA
06882:  CLRF   xDD
06884:  MOVLW  28
06886:  MOVWF  xDC
06888:  CLRF   xDF
0688A:  MOVLW  64
0688C:  MOVWF  xDE
0688E:  MOVLB  0
06890:  BRA    634E
....................  
.................... 	delay_ms(10); 
06892:  MOVLW  0A
06894:  MOVLB  7
06896:  MOVWF  x2B
06898:  MOVLB  0
0689A:  CALL   608E
....................  
.................... 	if(DEBUG) { 
.................... 		print_device_config(); 
.................... 	} 
....................  
.................... 	if(programmed_flag == 0xFF) { 
0689E:  MOVLB  6
068A0:  INCFSZ xD9,W
068A2:  BRA    68E2
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting first boot routine\r\n"); 
.................... 		} 
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Saving default device properties..."); 
.................... 		} 
.................... 		default_device_config(); 
068A4:  MOVLB  0
068A6:  BRA    669E
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
....................  
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] New device config below...\r\n"); 
.................... 			print_device_config(); 
.................... 		} 
.................... 		//initialize_first_boot(); 
....................  
....................  
.................... 		write_eeprom(IEEPROM_FLAG_LOC,0x01); 
068A8:  CLRF   FAA
068AA:  MOVLW  20
068AC:  MOVWF  FA9
068AE:  MOVLW  01
068B0:  MOVWF  FA8
068B2:  BCF    FA6.6
068B4:  BCF    FA6.7
068B6:  BSF    FA6.2
068B8:  MOVF   FF2,W
068BA:  MOVWF  00
068BC:  BCF    FF2.7
068BE:  MOVLB  F
068C0:  MOVLW  55
068C2:  MOVWF  FA7
068C4:  MOVLW  AA
068C6:  MOVWF  FA7
068C8:  BSF    FA6.1
068CA:  BTFSC  FA6.1
068CC:  BRA    68CA
068CE:  BCF    FA6.2
068D0:  MOVF   00,W
068D2:  IORWF  FF2,F
.................... 		delay_ms(10); 
068D4:  MOVLW  0A
068D6:  MOVLB  7
068D8:  MOVWF  x2B
068DA:  MOVLB  0
068DC:  CALL   608E
068E0:  MOVLB  6
.................... 	}	 
.................... 	/* INIT RS232 volumes and mutes */ 
....................  
....................  
.................... } 
068E2:  MOVLB  0
068E4:  GOTO   9666 (RETURN)
....................  
.................... void softboot() 
.................... { 
.................... 	delay_ms(50); 
*
06DC6:  MOVLW  32
06DC8:  MOVLB  7
06DCA:  MOVWF  x2B
06DCC:  MOVLB  0
06DCE:  CALL   608E
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP and Amp reset LOW\r\n"); 
.................... 	} 
....................  
.................... 	// TODO - Mute transistors 
....................  
.................... 	output_high(AUD_MUTE); 
06DD2:  BCF    F95.3
06DD4:  BSF    F8C.3
....................  
.................... 	output_low(PIN_DSP_nRESET); 
06DD6:  BCF    F92.4
06DD8:  BCF    F89.4
.................... 	output_low(PIN_AMP_nRESET); 
06DDA:  BCF    F92.5
06DDC:  BCF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.PS_PIN_ENABLE) { 
06DDE:  MOVF   40,F
06DE0:  BZ    6DE6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling Power Supply\r\n"); 
.................... 		}	 
....................  
.................... 		output_high(PIN_PSON); 
06DE2:  BCF    F93.4
06DE4:  BSF    F8A.4
.................... 	} 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Muting DSP Output (NOT YET IMPLEMENTED)\r\n"); 
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
06DE6:  MOVF   33,F
06DE8:  BNZ   6DF6
.................... 		//4CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 4 CH mode\r\n"); 
.................... 		} 
.................... 		output_low(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
06DEA:  BCF    F92.1
06DEC:  BCF    F89.1
.................... 		output_low(PIN_AMP_M2); // TI Chip - Mode Pin 2 
06DEE:  BCF    F92.2
06DF0:  BCF    F89.2
.................... 		output_high(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
06DF2:  BCF    F92.3
06DF4:  BSF    F89.3
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 1) { 
06DF6:  DECFSZ 33,W
06DF8:  BRA    6E06
.................... 		//2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 2 CH mode\r\n"); 
.................... 		} 
.................... 		output_low(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
06DFA:  BCF    F92.1
06DFC:  BCF    F89.1
.................... 		output_high(PIN_AMP_M2); // TI Chip - Mode Pin 2 
06DFE:  BCF    F92.2
06E00:  BSF    F89.2
.................... 		output_low(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
06E02:  BCF    F92.3
06E04:  BCF    F89.3
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 2) { 
06E06:  MOVF   33,W
06E08:  SUBLW  02
06E0A:  BNZ   6E18
.................... 		//1.2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting amplifier into 1.2 CH mode\r\n"); 
.................... 		} 
.................... 		output_high(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
06E0C:  BCF    F92.1
06E0E:  BSF    F89.1
.................... 		output_high(PIN_AMP_M2); // TI Chip - Mode Pin 2 
06E10:  BCF    F92.2
06E12:  BSF    F89.2
.................... 		output_low(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
06E14:  BCF    F92.3
06E16:  BCF    F89.3
.................... 	} 
....................  
.................... 	delay_ms(DELAY_AMP_MODE_SETTLE); 
06E18:  MOVLW  04
06E1A:  MOVLB  7
06E1C:  MOVWF  x25
06E1E:  MOVLW  FA
06E20:  MOVWF  x2B
06E22:  MOVLB  0
06E24:  CALL   608E
06E28:  MOVLB  7
06E2A:  DECFSZ x25,F
06E2C:  BRA    6E1E
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling AMP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_AMP_nRESET); 
06E2E:  BCF    F92.5
06E30:  BSF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE) { 
06E32:  MOVF   3F,F
06E34:  BZ    6E3E
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Waiting for AMP ready....\r\n"); 
.................... 		} 
.................... 		while(!input(PIN_AMP_READY)) { 
06E36:  BSF    F96.2
06E38:  BTFSC  F84.2
06E3A:  BRA    6E3E
.................... 	 
.................... 		} 
06E3C:  BRA    6E36
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] AMP is ready!\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	 
.................... 	delay_ms(50); 
06E3E:  MOVLW  32
06E40:  MOVWF  x2B
06E42:  MOVLB  0
06E44:  CALL   608E
....................  
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_DSP_nRESET);// DSP Reset 
06E48:  BCF    F92.4
06E4A:  BSF    F89.4
.................... 	 
.................... 	delay_ms(DELAY_DSP_RESET_SETTLE); 
06E4C:  MOVLW  32
06E4E:  MOVLB  7
06E50:  MOVWF  x2B
06E52:  MOVLB  0
06E54:  CALL   608E
....................  
.................... 	if(DEVICE_CONFIG.IS_70V == 0) { 
06E58:  MOVF   34,F
06E5A:  BNZ   6E7A
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Not a 70V amp. Disabling 100Hz HP Filter\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,SEVENTYVHP_BYPASS,0x00000001); 
06E5C:  MOVLW  F0
06E5E:  MOVLB  7
06E60:  MOVWF  x31
06E62:  CLRF   x30
06E64:  MOVLW  04
06E66:  MOVWF  x33
06E68:  MOVLW  44
06E6A:  MOVWF  x32
06E6C:  CLRF   x37
06E6E:  CLRF   x36
06E70:  CLRF   x35
06E72:  MOVLW  01
06E74:  MOVWF  x34
06E76:  MOVLB  0
06E78:  RCALL  68E8
.................... 	} 
.................... 		 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
06E7A:  MOVF   33,F
06E7C:  BNZ   6EF6
.................... 		//4CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 4 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
06E7E:  MOVLW  F0
06E80:  MOVLB  7
06E82:  MOVWF  x31
06E84:  CLRF   x30
06E86:  MOVLW  02
06E88:  MOVWF  x33
06E8A:  MOVLW  7E
06E8C:  MOVWF  x32
06E8E:  CLRF   x37
06E90:  CLRF   x36
06E92:  CLRF   x35
06E94:  MOVLW  01
06E96:  MOVWF  x34
06E98:  MOVLB  0
06E9A:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000002); 
06E9C:  MOVLW  F0
06E9E:  MOVLB  7
06EA0:  MOVWF  x31
06EA2:  CLRF   x30
06EA4:  MOVLW  02
06EA6:  MOVWF  x33
06EA8:  MOVLW  7F
06EAA:  MOVWF  x32
06EAC:  CLRF   x37
06EAE:  CLRF   x36
06EB0:  CLRF   x35
06EB2:  MOVLW  02
06EB4:  MOVWF  x34
06EB6:  MOVLB  0
06EB8:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
06EBA:  MOVLW  F0
06EBC:  MOVLB  7
06EBE:  MOVWF  x31
06EC0:  CLRF   x30
06EC2:  MOVLW  02
06EC4:  MOVWF  x33
06EC6:  MOVLW  80
06EC8:  MOVWF  x32
06ECA:  CLRF   x37
06ECC:  CLRF   x36
06ECE:  CLRF   x35
06ED0:  MOVLW  03
06ED2:  MOVWF  x34
06ED4:  MOVLB  0
06ED6:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000004); 
06ED8:  MOVLW  F0
06EDA:  MOVLB  7
06EDC:  MOVWF  x31
06EDE:  CLRF   x30
06EE0:  MOVLW  02
06EE2:  MOVWF  x33
06EE4:  MOVLW  81
06EE6:  MOVWF  x32
06EE8:  CLRF   x37
06EEA:  CLRF   x36
06EEC:  CLRF   x35
06EEE:  MOVLW  04
06EF0:  MOVWF  x34
06EF2:  MOVLB  0
06EF4:  RCALL  68E8
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 1) { 
06EF6:  DECFSZ 33,W
06EF8:  BRA    6F72
.................... 		//2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 2 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
06EFA:  MOVLW  F0
06EFC:  MOVLB  7
06EFE:  MOVWF  x31
06F00:  CLRF   x30
06F02:  MOVLW  02
06F04:  MOVWF  x33
06F06:  MOVLW  7E
06F08:  MOVWF  x32
06F0A:  CLRF   x37
06F0C:  CLRF   x36
06F0E:  CLRF   x35
06F10:  MOVLW  01
06F12:  MOVWF  x34
06F14:  MOVLB  0
06F16:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000001); 
06F18:  MOVLW  F0
06F1A:  MOVLB  7
06F1C:  MOVWF  x31
06F1E:  CLRF   x30
06F20:  MOVLW  02
06F22:  MOVWF  x33
06F24:  MOVLW  7F
06F26:  MOVWF  x32
06F28:  CLRF   x37
06F2A:  CLRF   x36
06F2C:  CLRF   x35
06F2E:  MOVLW  01
06F30:  MOVWF  x34
06F32:  MOVLB  0
06F34:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
06F36:  MOVLW  F0
06F38:  MOVLB  7
06F3A:  MOVWF  x31
06F3C:  CLRF   x30
06F3E:  MOVLW  02
06F40:  MOVWF  x33
06F42:  MOVLW  80
06F44:  MOVWF  x32
06F46:  CLRF   x37
06F48:  CLRF   x36
06F4A:  CLRF   x35
06F4C:  MOVLW  03
06F4E:  MOVWF  x34
06F50:  MOVLB  0
06F52:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000003); 
06F54:  MOVLW  F0
06F56:  MOVLB  7
06F58:  MOVWF  x31
06F5A:  CLRF   x30
06F5C:  MOVLW  02
06F5E:  MOVWF  x33
06F60:  MOVLW  81
06F62:  MOVWF  x32
06F64:  CLRF   x37
06F66:  CLRF   x36
06F68:  CLRF   x35
06F6A:  MOVLW  03
06F6C:  MOVWF  x34
06F6E:  MOVLB  0
06F70:  RCALL  68E8
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 2) { 
06F72:  MOVF   33,W
06F74:  SUBLW  02
06F76:  BNZ   6FF0
.................... 		//1.2CH 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Putting DSP into 1.2 CH mode\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
06F78:  MOVLW  F0
06F7A:  MOVLB  7
06F7C:  MOVWF  x31
06F7E:  CLRF   x30
06F80:  MOVLW  02
06F82:  MOVWF  x33
06F84:  MOVLW  7E
06F86:  MOVWF  x32
06F88:  CLRF   x37
06F8A:  CLRF   x36
06F8C:  CLRF   x35
06F8E:  MOVLW  01
06F90:  MOVWF  x34
06F92:  MOVLB  0
06F94:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000001); 
06F96:  MOVLW  F0
06F98:  MOVLB  7
06F9A:  MOVWF  x31
06F9C:  CLRF   x30
06F9E:  MOVLW  02
06FA0:  MOVWF  x33
06FA2:  MOVLW  7F
06FA4:  MOVWF  x32
06FA6:  CLRF   x37
06FA8:  CLRF   x36
06FAA:  CLRF   x35
06FAC:  MOVLW  01
06FAE:  MOVWF  x34
06FB0:  MOVLB  0
06FB2:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
06FB4:  MOVLW  F0
06FB6:  MOVLB  7
06FB8:  MOVWF  x31
06FBA:  CLRF   x30
06FBC:  MOVLW  02
06FBE:  MOVWF  x33
06FC0:  MOVLW  80
06FC2:  MOVWF  x32
06FC4:  CLRF   x37
06FC6:  CLRF   x36
06FC8:  CLRF   x35
06FCA:  MOVLW  03
06FCC:  MOVWF  x34
06FCE:  MOVLB  0
06FD0:  RCALL  68E8
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000004); 
06FD2:  MOVLW  F0
06FD4:  MOVLB  7
06FD6:  MOVWF  x31
06FD8:  CLRF   x30
06FDA:  MOVLW  02
06FDC:  MOVWF  x33
06FDE:  MOVLW  81
06FE0:  MOVWF  x32
06FE2:  CLRF   x37
06FE4:  CLRF   x36
06FE6:  CLRF   x35
06FE8:  MOVLW  04
06FEA:  MOVWF  x34
06FEC:  MOVLB  0
06FEE:  RCALL  68E8
.................... 	} 
....................  
.................... 	 
.................... 	if(DEVICE_CONFIG.DSP_VALUESEND_ENABLE) 
06FF0:  MOVF   41,F
06FF2:  BZ    7012
.................... 	{ 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Sending DSP values from program %u\r\n",CURRENT_FLASH_PROGRAM); 
.................... 		} 
.................... 		 
.................... 		dsp_mute_outputs(); 
06FF4:  BRA    69AA
....................  
.................... 		send_flash_program_to_dsp_buffered(CURRENT_FLASH_PROGRAM); 
06FF6:  MOVFF  79,725
06FFA:  BRA    6BB8
....................  
.................... 		// We will have an RVC value to read. Keep this muted. We'll unmute later 
.................... 		if(DEVICE_CONFIG.RVC_ENABLE != 1) { 
06FFC:  DECFSZ 3D,W
06FFE:  BRA    7002
07000:  BRA    7004
.................... 			dsp_unmute_outputs(); 
07002:  RCALL  6D32
.................... 		} 
....................  
.................... 		delay_ms(100); 
07004:  MOVLW  64
07006:  MOVLB  7
07008:  MOVWF  x2B
0700A:  MOVLB  0
0700C:  CALL   608E
....................  
.................... 	} else { 
07010:  BRA    7012
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NOT sending DSP values\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
07012:  DECFSZ 3D,W
07014:  BRA    7358
....................  
.................... 		pin_in_mute_state = !input(PIN_AMP_nMUTE); 
07016:  BSF    F94.1
07018:  MOVLB  1
0701A:  CLRF   x7D
0701C:  BTFSS  F82.1
0701E:  INCF   x7D,F
.................... 	 
.................... 		set_adc_channel(0); 
07020:  MOVLW  00
07022:  MOVWF  01
07024:  MOVF   FC2,W
07026:  ANDLW  83
07028:  IORWF  01,W
0702A:  MOVWF  FC2
.................... 		delay_us(10); 
0702C:  MOVLW  0B
0702E:  MOVWF  00
07030:  DECFSZ 00,F
07032:  BRA    7030
07034:  BRA    7036
.................... 		current_adc = read_adc(); 
07036:  BSF    FC2.1
07038:  BTFSC  FC2.1
0703A:  BRA    7038
0703C:  MOVFF  FC4,17B
.................... 		 
.................... 		if(pin_in_mute_state) { 
07040:  MOVF   x7D,F
07042:  BZ    70F6
.................... 			is_muted = true; 
07044:  MOVLW  01
07046:  MOVWF  x7C
07048:  CLRF   19
0704A:  BTFSC  FF2.7
0704C:  BSF    19.7
0704E:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
07050:  MOVLW  83
07052:  MOVLB  7
07054:  MOVWF  x76
07056:  CLRF   x75
07058:  CLRF   x74
0705A:  MOVLW  0A
0705C:  MOVWF  x73
0705E:  CLRF   x7A
07060:  CLRF   x79
07062:  CLRF   x78
07064:  CLRF   x77
07066:  MOVLB  0
07068:  CALL   142C
0706C:  BTFSC  19.7
0706E:  BSF    FF2.7
07070:  CLRF   19
07072:  BTFSC  FF2.7
07074:  BSF    19.7
07076:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
07078:  MOVLW  83
0707A:  MOVLB  7
0707C:  MOVWF  x76
0707E:  CLRF   x75
07080:  CLRF   x74
07082:  MOVLW  0B
07084:  MOVWF  x73
07086:  CLRF   x7A
07088:  CLRF   x79
0708A:  CLRF   x78
0708C:  CLRF   x77
0708E:  MOVLB  0
07090:  CALL   142C
07094:  BTFSC  19.7
07096:  BSF    FF2.7
07098:  CLRF   19
0709A:  BTFSC  FF2.7
0709C:  BSF    19.7
0709E:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
070A0:  MOVLW  83
070A2:  MOVLB  7
070A4:  MOVWF  x76
070A6:  CLRF   x75
070A8:  CLRF   x74
070AA:  MOVLW  0C
070AC:  MOVWF  x73
070AE:  CLRF   x7A
070B0:  CLRF   x79
070B2:  CLRF   x78
070B4:  CLRF   x77
070B6:  MOVLB  0
070B8:  CALL   142C
070BC:  BTFSC  19.7
070BE:  BSF    FF2.7
070C0:  CLRF   19
070C2:  BTFSC  FF2.7
070C4:  BSF    19.7
070C6:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
070C8:  MOVLW  83
070CA:  MOVLB  7
070CC:  MOVWF  x76
070CE:  CLRF   x75
070D0:  CLRF   x74
070D2:  MOVLW  0D
070D4:  MOVWF  x73
070D6:  CLRF   x7A
070D8:  CLRF   x79
070DA:  CLRF   x78
070DC:  CLRF   x77
070DE:  MOVLB  0
070E0:  CALL   142C
070E4:  BTFSC  19.7
070E6:  BSF    FF2.7
.................... 			set_timer1(15550); 
070E8:  MOVLW  3C
070EA:  MOVWF  FCF
070EC:  MOVLW  BE
070EE:  MOVWF  FCE
.................... 			clear_interrupt(INT_TIMER1); 
070F0:  BCF    F9E.0
.................... 	 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - Muted\r\n"); 
.................... 			} 
.................... 		} else { 
070F2:  BRA    7354
070F4:  MOVLB  1
070F6:  CLRF   19
070F8:  BTFSC  FF2.7
070FA:  BSF    19.7
070FC:  BCF    FF2.7
.................... 			double dsp_value = RVC_to_dsp_value(current_adc); 
070FE:  MOVFF  17B,76F
07102:  MOVLB  0
07104:  CALL   2A2A
07108:  BTFSC  19.7
0710A:  BSF    FF2.7
0710C:  MOVFF  03,724
07110:  MOVFF  02,723
07114:  MOVFF  01,722
07118:  MOVFF  00,721
0711C:  CLRF   19
0711E:  BTFSC  FF2.7
07120:  BSF    19.7
07122:  BCF    FF2.7
....................  
.................... 			send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
07124:  MOVFF  724,7A3
07128:  MOVFF  723,7A2
0712C:  MOVFF  722,7A1
07130:  MOVFF  721,7A0
07134:  MOVLB  7
07136:  CLRF   xA7
07138:  CLRF   xA6
0713A:  CLRF   xA5
0713C:  MOVLW  9E
0713E:  MOVWF  xA4
07140:  MOVLB  0
07142:  CALL   18AC
07146:  BTFSC  19.7
07148:  BSF    FF2.7
0714A:  CLRF   19
0714C:  BTFSC  FF2.7
0714E:  BSF    19.7
07150:  BCF    FF2.7
07152:  MOVFF  03,772
07156:  MOVFF  02,771
0715A:  MOVFF  01,770
0715E:  MOVFF  00,76F
07162:  CALL   2B44
07166:  BTFSC  19.7
07168:  BSF    FF2.7
0716A:  MOVFF  03,728
0716E:  MOVFF  02,727
07172:  MOVFF  01,726
07176:  MOVFF  00,725
0717A:  CLRF   19
0717C:  BTFSC  FF2.7
0717E:  BSF    19.7
07180:  BCF    FF2.7
07182:  MOVLW  83
07184:  MOVLB  7
07186:  MOVWF  x76
07188:  CLRF   x75
0718A:  CLRF   x74
0718C:  MOVLW  0A
0718E:  MOVWF  x73
07190:  MOVFF  03,77A
07194:  MOVFF  02,779
07198:  MOVFF  01,778
0719C:  MOVFF  00,777
071A0:  MOVLB  0
071A2:  CALL   142C
071A6:  BTFSC  19.7
071A8:  BSF    FF2.7
071AA:  CLRF   19
071AC:  BTFSC  FF2.7
071AE:  BSF    19.7
071B0:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
071B2:  MOVFF  724,7A3
071B6:  MOVFF  723,7A2
071BA:  MOVFF  722,7A1
071BE:  MOVFF  721,7A0
071C2:  MOVLB  7
071C4:  CLRF   xA7
071C6:  CLRF   xA6
071C8:  CLRF   xA5
071CA:  MOVLW  9E
071CC:  MOVWF  xA4
071CE:  MOVLB  0
071D0:  CALL   18AC
071D4:  BTFSC  19.7
071D6:  BSF    FF2.7
071D8:  CLRF   19
071DA:  BTFSC  FF2.7
071DC:  BSF    19.7
071DE:  BCF    FF2.7
071E0:  MOVFF  03,772
071E4:  MOVFF  02,771
071E8:  MOVFF  01,770
071EC:  MOVFF  00,76F
071F0:  CALL   2B44
071F4:  BTFSC  19.7
071F6:  BSF    FF2.7
071F8:  MOVFF  03,728
071FC:  MOVFF  02,727
07200:  MOVFF  01,726
07204:  MOVFF  00,725
07208:  CLRF   19
0720A:  BTFSC  FF2.7
0720C:  BSF    19.7
0720E:  BCF    FF2.7
07210:  MOVLW  83
07212:  MOVLB  7
07214:  MOVWF  x76
07216:  CLRF   x75
07218:  CLRF   x74
0721A:  MOVLW  0B
0721C:  MOVWF  x73
0721E:  MOVFF  03,77A
07222:  MOVFF  02,779
07226:  MOVFF  01,778
0722A:  MOVFF  00,777
0722E:  MOVLB  0
07230:  CALL   142C
07234:  BTFSC  19.7
07236:  BSF    FF2.7
07238:  CLRF   19
0723A:  BTFSC  FF2.7
0723C:  BSF    19.7
0723E:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
07240:  MOVFF  724,7A3
07244:  MOVFF  723,7A2
07248:  MOVFF  722,7A1
0724C:  MOVFF  721,7A0
07250:  MOVLB  7
07252:  CLRF   xA7
07254:  CLRF   xA6
07256:  CLRF   xA5
07258:  MOVLW  9E
0725A:  MOVWF  xA4
0725C:  MOVLB  0
0725E:  CALL   18AC
07262:  BTFSC  19.7
07264:  BSF    FF2.7
07266:  CLRF   19
07268:  BTFSC  FF2.7
0726A:  BSF    19.7
0726C:  BCF    FF2.7
0726E:  MOVFF  03,772
07272:  MOVFF  02,771
07276:  MOVFF  01,770
0727A:  MOVFF  00,76F
0727E:  CALL   2B44
07282:  BTFSC  19.7
07284:  BSF    FF2.7
07286:  MOVFF  03,728
0728A:  MOVFF  02,727
0728E:  MOVFF  01,726
07292:  MOVFF  00,725
07296:  CLRF   19
07298:  BTFSC  FF2.7
0729A:  BSF    19.7
0729C:  BCF    FF2.7
0729E:  MOVLW  83
072A0:  MOVLB  7
072A2:  MOVWF  x76
072A4:  CLRF   x75
072A6:  CLRF   x74
072A8:  MOVLW  0C
072AA:  MOVWF  x73
072AC:  MOVFF  03,77A
072B0:  MOVFF  02,779
072B4:  MOVFF  01,778
072B8:  MOVFF  00,777
072BC:  MOVLB  0
072BE:  CALL   142C
072C2:  BTFSC  19.7
072C4:  BSF    FF2.7
072C6:  CLRF   19
072C8:  BTFSC  FF2.7
072CA:  BSF    19.7
072CC:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
072CE:  MOVFF  724,7A3
072D2:  MOVFF  723,7A2
072D6:  MOVFF  722,7A1
072DA:  MOVFF  721,7A0
072DE:  MOVLB  7
072E0:  CLRF   xA7
072E2:  CLRF   xA6
072E4:  CLRF   xA5
072E6:  MOVLW  9E
072E8:  MOVWF  xA4
072EA:  MOVLB  0
072EC:  CALL   18AC
072F0:  BTFSC  19.7
072F2:  BSF    FF2.7
072F4:  CLRF   19
072F6:  BTFSC  FF2.7
072F8:  BSF    19.7
072FA:  BCF    FF2.7
072FC:  MOVFF  03,772
07300:  MOVFF  02,771
07304:  MOVFF  01,770
07308:  MOVFF  00,76F
0730C:  CALL   2B44
07310:  BTFSC  19.7
07312:  BSF    FF2.7
07314:  MOVFF  03,728
07318:  MOVFF  02,727
0731C:  MOVFF  01,726
07320:  MOVFF  00,725
07324:  CLRF   19
07326:  BTFSC  FF2.7
07328:  BSF    19.7
0732A:  BCF    FF2.7
0732C:  MOVLW  83
0732E:  MOVLB  7
07330:  MOVWF  x76
07332:  CLRF   x75
07334:  CLRF   x74
07336:  MOVLW  0D
07338:  MOVWF  x73
0733A:  MOVFF  03,77A
0733E:  MOVFF  02,779
07342:  MOVFF  01,778
07346:  MOVFF  00,777
0734A:  MOVLB  0
0734C:  CALL   142C
07350:  BTFSC  19.7
07352:  BSF    FF2.7
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		dsp_unmute_outputs(); 
07354:  RCALL  6D32
....................  
.................... 	} else { 
07356:  BRA    7358
.................... 		if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] DEVICE_CONFIG.RVC_ENABLE == 0\r\n"); 
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	output_low(AUD_MUTE); 
07358:  BCF    F95.3
0735A:  BCF    F8C.3
....................  
.................... 	update_phantom_power(); 
0735C:  RCALL  6D5C
....................  
.................... } 
0735E:  RETURN 0
....................  
.................... void setup_interrupts() 
.................... { 
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
*
02F92:  DECFSZ 3D,W
02F94:  BRA    2FA2
....................  
.................... 		set_timer1(15550); 
02F96:  MOVLW  3C
02F98:  MOVWF  FCF
02F9A:  MOVLW  BE
02F9C:  MOVWF  FCE
.................... 		enable_interrupts(INT_TIMER1);  
02F9E:  BSF    F9D.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling RVC\r\n"); 
.................... 		} 
.................... 	} else { 
02FA0:  BRA    2FA2
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Disabling RVC\r\n"); 
.................... 		} 
.................... 	} 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG]: Enabling global interrupts\r\n"); 
.................... 	} 
.................... 	enable_interrupts(GLOBAL); 
02FA2:  MOVLW  C0
02FA4:  IORWF  FF2,F
....................  
.................... 	 
.................... 	enable_interrupts(INT_RDA2); 
02FA6:  BSF    FA3.5
.................... 	 
.................... 	 
....................  
.................... 	disable_interrupts(INT_EXT);  
02FA8:  BCF    FF2.4
....................  
.................... 	if(DEVICE_CONFIG.SLEEP_ENABLE == 1) { 
02FAA:  DECFSZ 42,W
02FAC:  BRA    2FDA
.................... 		// Sleep timer enabled.. check initial state 
.................... 		if(DEBUG){ 
.................... 			fprintf(RS232,"[DEBUG] Sleep detect enabled... checking current state..."); 
.................... 		} 
....................  
.................... 		if(input(PIN_AUDIODETECT)) { 
02FAE:  BSF    F93.0
02FB0:  BTFSS  F81.0
02FB2:  BRA    2FC4
.................... 			// We currently have audio 
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will disable sleep timer and wait for audiodetect to go low\r\n"); 
.................... 			} 
....................  
.................... 				ext_int_edge(0,H_TO_L);  
02FB4:  BCF    FF1.6
.................... 				enable_interrupts(INT_EXT); 
02FB6:  BSF    FF2.4
.................... 				disable_interrupts(INT_TIMER0); 
02FB8:  BCF    FF2.5
.................... 				sleep_timer_active = 0; 
02FBA:  MOVLB  1
02FBC:  CLRF   x83
.................... 				is_in_sleep = 0; 
02FBE:  CLRF   x82
.................... 		} else { 
02FC0:  BRA    2FD8
02FC2:  MOVLB  0
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"NO AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will start sleep timer and wait for audiodetect to go high\r\n"); 
.................... 			} 
....................  
.................... 			ext_int_edge(0,L_TO_H);  
02FC4:  BSF    FF1.6
.................... 			enable_interrupts(INT_EXT); 
02FC6:  BSF    FF2.4
....................  
.................... 			set_timer0(7936); 
02FC8:  MOVLW  1F
02FCA:  MOVWF  FD7
02FCC:  CLRF   FD6
.................... 			enable_interrupts(INT_TIMER0); 
02FCE:  BSF    FF2.5
.................... 			sleep_timer_active = 1; 
02FD0:  MOVLW  01
02FD2:  MOVLB  1
02FD4:  MOVWF  x83
.................... 			is_in_sleep = 0; 
02FD6:  CLRF   x82
02FD8:  MOVLB  0
.................... 				 
.................... 		}				 
....................  
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.USBDETECT_ENABLE == 0) { 
02FDA:  MOVF   3E,F
02FDC:  BNZ   2FE6
.................... 		IS_USB_CONNECTED = true; 
02FDE:  MOVLW  01
02FE0:  MOVWF  x78
.................... 		disable_interrupts(INT_EXT1);  
02FE2:  BCF    FF0.3
.................... 	} else { 
02FE4:  BRA    2FFC
.................... 		// Check initial plug state 
.................... 		if(input(PIN_B1)) { 
02FE6:  BSF    F93.1
02FE8:  BTFSS  F81.1
02FEA:  BRA    2FF4
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is high. Setting IS_USB_CONNECTED to true\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = true; 
02FEC:  MOVLW  01
02FEE:  MOVWF  x78
.................... 			ext_int_edge(1,H_TO_L);  
02FF0:  BCF    FF1.5
.................... 		} else { 
02FF2:  BRA    2FF8
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is low. Setting IS_USB_CONNECTED to false\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = false; 
02FF4:  CLRF   x78
.................... 			ext_int_edge(1,L_TO_H);  
02FF6:  BSF    FF1.5
.................... 		} 
....................  
.................... 		clear_interrupt(INT_EXT1);  
02FF8:  BCF    FF0.0
....................    		enable_interrupts(INT_EXT1); 
02FFA:  BSF    FF0.3
.................... 	 
.................... 	} 
.................... } 
02FFC:  RETURN 0
....................  
....................  
.................... void setup_peripherals() 
.................... { 
....................  
.................... 	setup_adc( ADC_CLOCK_INTERNAL ); 
*
030CC:  MOVF   FC0,W
030CE:  ANDLW  C0
030D0:  IORLW  07
030D2:  MOVWF  FC0
030D4:  BCF    FC0.7
030D6:  BSF    FC2.0
....................  
.................... 	setup_adc_ports( sAN0 | sAN9 ); 
030D8:  MOVF   FC1,W
030DA:  ANDLW  F0
030DC:  MOVWF  FC1
030DE:  MOVLW  01
030E0:  MOVLB  F
030E2:  MOVWF  x38
030E4:  MOVLW  00
030E6:  MOVWF  x3C
030E8:  MOVLW  08
030EA:  MOVWF  x39
030EC:  MOVLW  00
030EE:  MOVWF  x3A
030F0:  MOVWF  x3B
....................  
.................... 	set_adc_channel(0); 
030F2:  MOVWF  01
030F4:  MOVF   FC2,W
030F6:  ANDLW  83
030F8:  IORWF  01,W
030FA:  MOVWF  FC2
....................  
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
030FC:  MOVLW  85
030FE:  MOVWF  FD5
....................  
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
03100:  MOVLW  37
03102:  MOVWF  FCD
03104:  CLRF   FCC
....................  
.................... 	setup_timer_3(T3_DISABLED | T3_DIV_BY_1); 
03106:  CLRF   FB4
03108:  CLRF   FB1
....................    	setup_timer_4(T4_DISABLED,0,1); 
0310A:  MOVLW  00
0310C:  MOVWF  x51
0310E:  MOVLW  00
03110:  MOVWF  x52
....................    	setup_timer_5(T5_DISABLED | T5_DIV_BY_1); 
03112:  CLRF   x4D
03114:  CLRF   x4E
....................    	setup_timer_6(T6_DISABLED,0,1); 
03116:  MOVWF  x4A
03118:  MOVLW  00
0311A:  MOVWF  x4B
....................  
.................... 	setup_wdt(WDT_OFF);  
0311C:  BCF    FD1.0
....................  
.................... } 
0311E:  MOVLB  0
03120:  GOTO   9652 (RETURN)
....................  
....................  
....................  
.................... #include <timed_getc.c> 
.................... //timed_getc.c 
.................... int timeout_error; 
....................  
.................... short data_available_usb() 
.................... { 
.................... 	return kbhit(USB); 
....................  
....................  
.................... } 
.................... char timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
0745E:  MOVLB  5
07460:  CLRF   x8C
.................... 	timeout = 0; 
07462:  MOVLB  7
07464:  CLRF   x29
07466:  CLRF   x28
....................  
.................... 	while(!kbhit(USB)&&(++timeout<50000)) { // half a second 
07468:  BTFSS  F82.4
0746A:  BRA    748C
0746C:  INCF   x28,F
0746E:  BTFSC  FD8.2
07470:  INCF   x29,F
07472:  MOVF   x29,W
07474:  SUBLW  C3
07476:  BNC   748C
07478:  BNZ   7480
0747A:  MOVF   x28,W
0747C:  SUBLW  4F
0747E:  BNC   748C
.................... 		delay_us(5); // this polls at 10x the 9600 baud rate 
07480:  MOVLW  05
07482:  MOVWF  00
07484:  DECFSZ 00,F
07486:  BRA    7484
07488:  BRA    748A
.................... 	} 
0748A:  BRA    7468
....................  
.................... 	if(kbhit()) { 
0748C:  BTFSC  F82.4
0748E:  BRA    74A0
.................... 		timeout_error = FALSE; 
07490:  MOVLB  5
07492:  CLRF   x8C
.................... 		return(fgetc(USB)); 
07494:  MOVLB  0
07496:  RCALL  7360
07498:  MOVF   01,W
0749A:  BRA    74AE
.................... 	} else { 
0749C:  BRA    74AE
0749E:  MOVLB  7
.................... 		timeout_error = TRUE; 
074A0:  MOVLW  01
074A2:  MOVLB  5
074A4:  MOVWF  x8C
.................... 		return(0); 
074A6:  MOVLW  00
074A8:  MOVWF  01
074AA:  MOVLB  0
074AC:  BRA    74AE
.................... 	} 
.................... } 
074AE:  RETURN 0
....................  
.................... char fast_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
073AA:  MOVLB  5
073AC:  CLRF   x8C
.................... 	timeout = 0; 
073AE:  MOVLB  7
073B0:  CLRF   x21
073B2:  CLRF   x20
....................  
.................... 	while(!kbhit(USB)&&(++timeout<10000)) { // tenth of a second 
073B4:  BTFSS  F82.4
073B6:  BRA    73D8
073B8:  INCF   x20,F
073BA:  BTFSC  FD8.2
073BC:  INCF   x21,F
073BE:  MOVF   x21,W
073C0:  SUBLW  27
073C2:  BNC   73D8
073C4:  BNZ   73CC
073C6:  MOVF   x20,W
073C8:  SUBLW  0F
073CA:  BNC   73D8
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
073CC:  MOVLW  0B
073CE:  MOVWF  00
073D0:  DECFSZ 00,F
073D2:  BRA    73D0
073D4:  BRA    73D6
.................... 	} 
073D6:  BRA    73B4
....................  
.................... 	if(kbhit()) { 
073D8:  BTFSC  F82.4
073DA:  BRA    73EC
.................... 		timeout_error = FALSE; 
073DC:  MOVLB  5
073DE:  CLRF   x8C
.................... 		return(getc()); 
073E0:  MOVLB  0
073E2:  RCALL  7360
073E4:  MOVF   01,W
073E6:  BRA    73FA
.................... 	} else { 
073E8:  BRA    73FA
073EA:  MOVLB  7
.................... 		timeout_error = TRUE; 
073EC:  MOVLW  01
073EE:  MOVLB  5
073F0:  MOVWF  x8C
.................... 		return(0); 
073F2:  MOVLW  00
073F4:  MOVWF  01
073F6:  MOVLB  0
073F8:  BRA    73FA
.................... 	} 
.................... } 
073FA:  RETURN 0
....................  
.................... char slow_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
.................... 	timeout = 0; 
....................  
.................... 	while(!kbhit(USB)&&(++timeout<20000)) { // fifth of a second 
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
.................... 	} 
....................  
.................... 	if(kbhit()) { 
.................... 		timeout_error = FALSE; 
.................... 		return(getc()); 
.................... 	} else { 
.................... 		timeout_error = TRUE; 
.................... 		return(0); 
.................... 	} 
.................... } 
....................  
.................... #include <streaming.c> 
.................... // streaming.c 
....................  
.................... #define NIBBLE_SIZE 32 
....................  
.................... /* VARIABLES FOR STREAMING */ 
.................... byte STREAMING_BUFFER[256]; 
....................  
.................... byte STREAM_NIBBLE_BUFFER[32]; 
....................  
.................... int16 streaming_buffer_index = 0; 
.................... int16 bytes_in_stream = 0; 
....................  
.................... int16 num_bytes_added = 0; 
....................  
.................... int stream_target_program = 0; 
.................... int stream_target_page = 0; 
....................  
.................... short is_streaming = 0; 
....................  
.................... int16 total_bytes_so_far = 0; 
....................  
.................... unsigned int nibble_crc = 0; 
....................  
.................... unsigned int verified_bytes = 0; 
.................... int nibble_index = 0; // 0-31 (local in STREAM_NIBBLE_BUFFER) 
....................  
....................  
.................... void flush_nibble_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
07B3C:  MOVLB  6
07B3E:  CLRF   xAE
07B40:  CLRF   xAD
.................... 	for(int j = 0; j < 32; j++) { 
07B42:  MOVLB  7
07B44:  CLRF   x28
07B46:  MOVF   x28,W
07B48:  SUBLW  1F
07B4A:  BNC   7B60
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
07B4C:  CLRF   03
07B4E:  MOVF   x28,W
07B50:  ADDLW  8D
07B52:  MOVWF  FE9
07B54:  MOVLW  06
07B56:  ADDWFC 03,W
07B58:  MOVWF  FEA
07B5A:  SETF   FEF
.................... 	} 
07B5C:  INCF   x28,F
07B5E:  BRA    7B46
....................  
.................... } 
07B60:  MOVLB  0
07B62:  GOTO   7C7C (RETURN)
....................  
....................  
.................... void flush_stream_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
07A00:  MOVLB  6
07A02:  CLRF   xAE
07A04:  CLRF   xAD
....................  
.................... 	for(int16 i = 0; i < 256; i++) { 
07A06:  MOVLB  7
07A08:  CLRF   x29
07A0A:  CLRF   x28
07A0C:  MOVF   x29,W
07A0E:  SUBLW  00
07A10:  BNC   7A28
.................... 		STREAMING_BUFFER[i] = 0xFF; 
07A12:  MOVLW  8D
07A14:  ADDWF  x28,W
07A16:  MOVWF  FE9
07A18:  MOVLW  05
07A1A:  ADDWFC x29,W
07A1C:  MOVWF  FEA
07A1E:  SETF   FEF
.................... 	} 
07A20:  INCF   x28,F
07A22:  BTFSC  FD8.2
07A24:  INCF   x29,F
07A26:  BRA    7A0C
....................  
.................... 	for(int j = 0; j < 32; j++) { 
07A28:  CLRF   x2A
07A2A:  MOVF   x2A,W
07A2C:  SUBLW  1F
07A2E:  BNC   7A44
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
07A30:  CLRF   03
07A32:  MOVF   x2A,W
07A34:  ADDLW  8D
07A36:  MOVWF  FE9
07A38:  MOVLW  06
07A3A:  ADDWFC 03,W
07A3C:  MOVWF  FEA
07A3E:  SETF   FEF
.................... 	} 
07A40:  INCF   x2A,F
07A42:  BRA    7A2A
....................  
.................... } 
07A44:  MOVLB  0
07A46:  RETURN 0
....................  
....................  
....................  
....................  
.................... int calc_crc_int(int *Buffer, int16 Len)  
.................... {  
*
07A92:  MOVLB  7
07A94:  SETF   x2F
07A96:  SETF   x2E
07A98:  CLRF   x30
....................    int16 x;  
....................    int16 crc = 0xFFFF;  
....................    int return_int = 0; 
....................  
....................    while(Len--)  
....................    {  
07A9A:  MOVFF  72B,03
07A9E:  MOVF   x2A,W
07AA0:  BTFSC  FD8.2
07AA2:  DECF   x2B,F
07AA4:  DECF   x2A,F
07AA6:  IORWF  03,W
07AA8:  BZ    7B2E
....................       x = make8(crc,1) ^ *Buffer++;  
07AAA:  MOVFF  729,03
07AAE:  MOVF   x28,W
07AB0:  INCF   x28,F
07AB2:  BTFSC  FD8.2
07AB4:  INCF   x29,F
07AB6:  MOVWF  FE9
07AB8:  MOVFF  03,FEA
07ABC:  MOVF   FEF,W
07ABE:  XORWF  x2F,W
07AC0:  MOVWF  x2C
07AC2:  CLRF   x2D
....................       x ^= x>>4;  
07AC4:  RRCF   x2D,W
07AC6:  MOVWF  03
07AC8:  RRCF   x2C,W
07ACA:  MOVWF  02
07ACC:  RRCF   03,F
07ACE:  RRCF   02,F
07AD0:  RRCF   03,F
07AD2:  RRCF   02,F
07AD4:  RRCF   03,F
07AD6:  RRCF   02,F
07AD8:  MOVLW  0F
07ADA:  ANDWF  03,F
07ADC:  MOVF   02,W
07ADE:  XORWF  x2C,F
07AE0:  MOVF   03,W
07AE2:  XORWF  x2D,F
....................        
....................       crc = (crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
07AE4:  MOVFF  72E,732
07AE8:  CLRF   x31
07AEA:  SWAPF  x2C,W
07AEC:  MOVWF  03
07AEE:  CLRF   02
07AF0:  MOVLW  F0
07AF2:  ANDWF  03,F
07AF4:  MOVF   02,W
07AF6:  XORWF  x31,F
07AF8:  MOVF   03,W
07AFA:  XORWF  x32,F
07AFC:  RLCF   x2C,W
07AFE:  MOVWF  02
07B00:  RLCF   x2D,W
07B02:  MOVWF  03
07B04:  RLCF   02,F
07B06:  RLCF   03,F
07B08:  RLCF   02,F
07B0A:  RLCF   03,F
07B0C:  RLCF   02,F
07B0E:  RLCF   03,F
07B10:  RLCF   02,F
07B12:  RLCF   03,F
07B14:  MOVLW  E0
07B16:  ANDWF  02,F
07B18:  MOVF   02,W
07B1A:  XORWF  x31,F
07B1C:  MOVF   03,W
07B1E:  XORWF  x32,F
07B20:  MOVF   x31,W
07B22:  XORWF  x2C,W
07B24:  MOVWF  x2E
07B26:  MOVF   x32,W
07B28:  XORWF  x2D,W
07B2A:  MOVWF  x2F
....................    }  
07B2C:  BRA    7A9A
....................  
.................... 	return_int = crc & 0xFF; 
07B2E:  MOVFF  72E,730
....................  
....................    	return return_int;  
07B32:  MOVFF  730,01
.................... }  
07B36:  MOVLB  0
07B38:  GOTO   7C1C (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... void clear_nibble() 
.................... { 
.................... 	for(int n = 0; n < NIBBLE_SIZE; n++) { 
*
07A48:  MOVLB  7
07A4A:  CLRF   x28
07A4C:  MOVF   x28,W
07A4E:  SUBLW  1F
07A50:  BNC   7A66
.................... 		STREAM_NIBBLE_BUFFER[n] = 0xFF; 
07A52:  CLRF   03
07A54:  MOVF   x28,W
07A56:  ADDLW  8D
07A58:  MOVWF  FE9
07A5A:  MOVLW  06
07A5C:  ADDWFC 03,W
07A5E:  MOVWF  FEA
07A60:  SETF   FEF
.................... 	} 
07A62:  INCF   x28,F
07A64:  BRA    7A4C
....................  
.................... 	nibble_index = 0; 
07A66:  MOVLB  6
07A68:  CLRF   xBA
.................... } 
07A6A:  MOVLB  0
07A6C:  GOTO   7A78 (RETURN)
....................  
.................... void add_nibble_to_buffer() 
.................... { 
.................... 	for(int m = 0; m < NIBBLE_SIZE; m++) { 
.................... 		STREAMING_BUFFER[verified_bytes++] = STREAM_NIBBLE_BUFFER[m]; 
.................... 	} 
....................  
.................... 	nibble_index = 0; 
.................... } 
....................  
.................... void kill_stream() 
.................... { 
.................... 	is_streaming = false; 
07A70:  MOVLB  6
07A72:  BCF    xB5.0
.................... 	clear_nibble(); 
07A74:  MOVLB  0
07A76:  BRA    7A48
.................... 	flush_stream_buffer(); 
07A78:  RCALL  7A00
.................... 	streaming_buffer_index = 0; 
07A7A:  MOVLB  6
07A7C:  CLRF   xAE
07A7E:  CLRF   xAD
.................... 	streaming_buffer_index = 0; 
07A80:  CLRF   xAE
07A82:  CLRF   xAD
.................... 	nibble_index = 0; 
07A84:  CLRF   xBA
.................... 	verified_bytes = 0; 
07A86:  CLRF   xB9
.................... 	total_bytes_so_far = 0; 
07A88:  CLRF   xB7
07A8A:  CLRF   xB6
....................  
.................... } 
07A8C:  MOVLB  0
07A8E:  GOTO   7C02 (RETURN)
....................  
.................... void print_stream_to_rs232() 
.................... { 
.................... 	for(int i = 0; i < 32; i++) { 
.................... 		fprintf(RS232,"%u ",STREAM_NIBBLE_BUFFER[i]); 
.................... 	} 
....................  
.................... 	char nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
....................  
.................... 	fprintf(RS232,"CRC = %u\r\n",nibble_crc); 
....................  
.................... 	 
....................  
.................... } 
....................  
.................... void perform_stream(int target_program, int target_page, int16 num_bytes) 
.................... { 
.................... 	 
....................  
.................... 	char streamed_char; 
....................  
.................... 	stream_target_program = target_program; 
*
07B66:  MOVFF  720,6B3
.................... 	stream_target_page = target_page; 
07B6A:  MOVFF  721,6B4
.................... 	bytes_in_stream = num_bytes; 
07B6E:  MOVFF  723,6B0
07B72:  MOVFF  722,6AF
....................  
.................... 	streaming_buffer_index = 0; 
07B76:  MOVLB  6
07B78:  CLRF   xAE
07B7A:  CLRF   xAD
.................... 	streaming_buffer_index = 0; 
07B7C:  CLRF   xAE
07B7E:  CLRF   xAD
.................... 	nibble_index = 0; 
07B80:  CLRF   xBA
.................... 	verified_bytes = 0; 
07B82:  CLRF   xB9
.................... 	total_bytes_so_far = 0; 
07B84:  CLRF   xB7
07B86:  CLRF   xB6
....................  
.................... 	num_bytes_added = 0; 
07B88:  CLRF   xB2
07B8A:  CLRF   xB1
.................... 	total_bytes_so_far = 0; 
07B8C:  CLRF   xB7
07B8E:  CLRF   xB6
....................  
....................  
.................... 	is_streaming = true; 
07B90:  BSF    xB5.0
.................... 	flush_stream_buffer(); 
07B92:  MOVLB  0
07B94:  RCALL  7A00
....................  
.................... 	fputc(0x06,USB); 
07B96:  MOVLW  06
07B98:  MOVLB  7
07B9A:  MOVWF  x29
07B9C:  MOVLB  0
07B9E:  RCALL  73FC
.................... 	fputc(target_program,USB); 
07BA0:  MOVFF  720,729
07BA4:  RCALL  73FC
.................... 	fputc(target_page,USB); 
07BA6:  MOVFF  721,729
07BAA:  RCALL  73FC
.................... 	fputc(0x03,USB); 
07BAC:  MOVLW  03
07BAE:  MOVLB  7
07BB0:  MOVWF  x29
07BB2:  MOVLB  0
07BB4:  RCALL  73FC
....................  
.................... 	int nibble_byte_counter = 0; 
07BB6:  MOVLB  7
07BB8:  CLRF   x25
....................  
.................... 	for(int nibble_counter = 0; nibble_counter <8; nibble_counter++) 
07BBA:  CLRF   x26
07BBC:  MOVF   x26,W
07BBE:  SUBLW  07
07BC0:  BNC   7C82
.................... 	{ 
.................... 		nibble_index = 0; 
07BC2:  MOVLB  6
07BC4:  CLRF   xBA
....................  
.................... 		for(nibble_byte_counter = 0; nibble_byte_counter < 32; nibble_byte_counter++) { 
07BC6:  MOVLB  7
07BC8:  CLRF   x25
07BCA:  MOVF   x25,W
07BCC:  SUBLW  1F
07BCE:  BNC   7BF8
....................  
.................... 			streamed_char = timed_getc(); 
07BD0:  MOVLB  0
07BD2:  RCALL  745E
07BD4:  MOVFF  01,724
.................... 	 
.................... 			total_bytes_so_far++; 
07BD8:  MOVLB  6
07BDA:  INCF   xB6,F
07BDC:  BTFSC  FD8.2
07BDE:  INCF   xB7,F
....................  
.................... 			STREAM_NIBBLE_BUFFER[nibble_byte_counter] = streamed_char;	 
07BE0:  CLRF   03
07BE2:  MOVLB  7
07BE4:  MOVF   x25,W
07BE6:  ADDLW  8D
07BE8:  MOVWF  FE9
07BEA:  MOVLW  06
07BEC:  ADDWFC 03,W
07BEE:  MOVWF  FEA
07BF0:  MOVFF  724,FEF
.................... 		} 
07BF4:  INCF   x25,F
07BF6:  BRA    7BCA
.................... 	 
.................... 		if(TIMEOUT_ERROR == true) { 
07BF8:  MOVLB  5
07BFA:  DECFSZ x8C,W
07BFC:  BRA    7C08
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"Timed out after having read %lu bytes\r\n",total_bytes_so_far); 
.................... 				fprintf(RS232,"So far we have received: "); 
.................... 				print_stream_to_rs232(); 
.................... 			} 
.................... 			//send_error(ERR_COMMAND_TIMEOUT); 
.................... 			kill_stream(); 
07BFE:  MOVLB  0
07C00:  BRA    7A70
.................... 			return; 
07C02:  BRA    7CCC
.................... 		} else { 
07C04:  BRA    7C7C
07C06:  MOVLB  5
.................... 			 
.................... 			nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
07C08:  MOVLW  06
07C0A:  MOVLB  7
07C0C:  MOVWF  x29
07C0E:  MOVLW  8D
07C10:  MOVWF  x28
07C12:  CLRF   x2B
07C14:  MOVLW  20
07C16:  MOVWF  x2A
07C18:  MOVLB  0
07C1A:  BRA    7A92
07C1C:  MOVFF  01,6B8
.................... 			//fprintf(RS232,"GOT FULL NIBBLE. So far %lu. Sending %u CRC\r\n",total_bytes_so_far,nibble_crc); 
.................... 			fputc(nibble_crc,USB); 
07C20:  MOVFF  6B8,729
07C24:  CALL   73FC
....................  
.................... 			for(int x = 0; x < 32; x++) { 
07C28:  MOVLB  7
07C2A:  CLRF   x27
07C2C:  MOVF   x27,W
07C2E:  SUBLW  1F
07C30:  BNC   7C78
.................... 				STREAMING_BUFFER[num_bytes_added++] = STREAM_NIBBLE_BUFFER[x]; 
07C32:  MOVLB  6
07C34:  MOVFF  6B2,03
07C38:  MOVF   xB1,W
07C3A:  INCF   xB1,F
07C3C:  BTFSC  FD8.2
07C3E:  INCF   xB2,F
07C40:  MOVLB  7
07C42:  MOVWF  x28
07C44:  MOVFF  03,729
07C48:  MOVLW  8D
07C4A:  ADDWF  x28,W
07C4C:  MOVWF  01
07C4E:  MOVLW  05
07C50:  ADDWFC 03,W
07C52:  MOVWF  03
07C54:  MOVWF  x2B
07C56:  CLRF   03
07C58:  MOVF   x27,W
07C5A:  ADDLW  8D
07C5C:  MOVWF  FE9
07C5E:  MOVLW  06
07C60:  ADDWFC 03,W
07C62:  MOVWF  FEA
07C64:  MOVFF  FEF,72C
07C68:  MOVFF  72B,FEA
07C6C:  MOVFF  01,FE9
07C70:  MOVFF  72C,FEF
.................... 			} 
07C74:  INCF   x27,F
07C76:  BRA    7C2C
....................  
.................... 			flush_nibble_buffer(); 
07C78:  MOVLB  0
07C7A:  BRA    7B3C
.................... 		} 
.................... 	} 
07C7C:  MOVLB  7
07C7E:  INCF   x26,F
07C80:  BRA    7BBC
....................  
.................... 	write_buffer_to_flash_page(&STREAMING_BUFFER,target_program, target_page); 
07C82:  MOVLW  05
07C84:  MOVWF  x29
07C86:  MOVLW  8D
07C88:  MOVWF  x28
07C8A:  MOVFF  720,72A
07C8E:  MOVFF  721,72B
07C92:  MOVLB  0
07C94:  CALL   6588
....................  
.................... 	fputc(0x06,USB); 
07C98:  MOVLW  06
07C9A:  MOVLB  7
07C9C:  MOVWF  x29
07C9E:  MOVLB  0
07CA0:  CALL   73FC
.................... 	fputc(0x01,USB); 
07CA4:  MOVLW  01
07CA6:  MOVLB  7
07CA8:  MOVWF  x29
07CAA:  MOVLB  0
07CAC:  CALL   73FC
.................... 	fputc(target_program,USB); 
07CB0:  MOVFF  720,729
07CB4:  CALL   73FC
.................... 	fputc(target_page,USB); 
07CB8:  MOVFF  721,729
07CBC:  CALL   73FC
.................... 	fputc(0x03,USB); 
07CC0:  MOVLW  03
07CC2:  MOVLB  7
07CC4:  MOVWF  x29
07CC6:  MOVLB  0
07CC8:  CALL   73FC
....................  
.................... } 
07CCC:  GOTO   8C3A (RETURN)
....................  
.................... #include <sa_usb.c> 
.................... char last_byte1,last_byte2,last_byte3,last_byte4,last_address; 
.................... int finished; 
.................... int temp_byte; 
.................... char name_buffer[20]; 
.................... int x, y; 
....................  
.................... void send_error(char error_code) 
.................... { 
.................... 	fputc(ERR_START,USB); 
*
07442:  MOVLW  15
07444:  MOVLB  7
07446:  MOVWF  x29
07448:  MOVLB  0
0744A:  RCALL  73FC
.................... 	fputc(error_code,USB); 
0744C:  MOVFF  720,729
07450:  RCALL  73FC
.................... 	fputc(0x03,USB); 
07452:  MOVLW  03
07454:  MOVLB  7
07456:  MOVWF  x29
07458:  MOVLB  0
0745A:  RCALL  73FC
.................... } 
0745C:  RETURN 0
....................  
.................... void process_usb_data()  { 
....................  
.................... 	char start_char,command_char,dummy_char,byte1,byte2,byte3,byte4,channel; 
.................... 	int16 addr_lsb, addr_msb; 
.................... 	int16 final_address, last_address; 
....................  
....................  
.................... 	/*if(is_streaming) { 
.................... 		process_stream_byte(); 
.................... 		return; 
.................... 	} 
.................... */ 
.................... 	// Wait until we get a starting char. Escapes after timeout to allow program to continue processing 
....................  
.................... 	start_char = fast_timed_getc(); 
*
07FB0:  CALL   73AA
07FB4:  MOVFF  01,6D8
....................  
.................... 	if(TIMEOUT_ERROR == true) { 
07FB8:  MOVLB  5
07FBA:  DECFSZ x8C,W
07FBC:  BRA    7FC2
.................... 		return; 
07FBE:  GOTO   955A
.................... 	} 
.................... 	 
.................... 	/* THIS LIST MUST BE UPDATED WHENEVER WE ADD A NEW START CHARACTER */ 
.................... 	if( 
.................... 		(start_char != 0x02) && // GENERAL 
.................... 		(start_char != 0x04) && // WRITE_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x05) && // GET_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x07) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x08) && // READ_DSP_VALUE 
.................... 		(start_char != 0x09) && // UTILITY 
.................... 		(start_char != 0x10) && // FLASH_PROGRAM_ACTIONS 
.................... 		(start_char != 0x14) && // SET_DEVICE_PROPERTY 
.................... 		(start_char != 0x17) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x15)    // GET_DEVICE_PROPERTY 
.................... 		) 
07FC2:  MOVLB  6
07FC4:  MOVF   xD8,W
07FC6:  SUBLW  02
07FC8:  BZ    8014
07FCA:  MOVF   xD8,W
07FCC:  SUBLW  04
07FCE:  BZ    8014
07FD0:  MOVF   xD8,W
07FD2:  SUBLW  05
07FD4:  BZ    8014
07FD6:  MOVF   xD8,W
07FD8:  SUBLW  07
07FDA:  BZ    8014
07FDC:  MOVF   xD8,W
07FDE:  SUBLW  08
07FE0:  BZ    8014
07FE2:  MOVF   xD8,W
07FE4:  SUBLW  09
07FE6:  BZ    8014
07FE8:  MOVF   xD8,W
07FEA:  SUBLW  10
07FEC:  BZ    8014
07FEE:  MOVF   xD8,W
07FF0:  SUBLW  14
07FF2:  BZ    8014
07FF4:  MOVF   xD8,W
07FF6:  SUBLW  17
07FF8:  BZ    8014
07FFA:  MOVF   xD8,W
07FFC:  SUBLW  15
07FFE:  BZ    8014
.................... 	{ 
.................... 		send_error(ERR_INVALID_START); 
08000:  MOVLW  02
08002:  MOVLB  7
08004:  MOVWF  x20
08006:  MOVLB  0
08008:  CALL   7442
.................... 		return; 
0800C:  MOVLB  5
0800E:  GOTO   955A
08012:  MOVLB  6
.................... 	} 
....................  
....................  
.................... 	if(start_char == 0x02) { 
08014:  MOVF   xD8,W
08016:  SUBLW  02
08018:  BNZ   801C
.................... 		goto GENERAL; 
0801A:  BRA    805C
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x04) { 
0801C:  MOVF   xD8,W
0801E:  SUBLW  04
08020:  BNZ   8024
.................... 		goto WRITE_DSP_CONFIG_VALUE; 
08022:  BRA    82C8
.................... 	} 
....................  
.................... 	if(start_char == 0x05) { 
08024:  MOVF   xD8,W
08026:  SUBLW  05
08028:  BNZ   802C
.................... 		goto GET_DSP_CONFIG_VALUE; 
0802A:  BRA    8552
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x07) { 
0802C:  MOVF   xD8,W
0802E:  SUBLW  07
08030:  BNZ   8034
.................... 		goto SEND_DSP_VALUE; 
08032:  BRA    86AC
.................... 	} 
....................  
.................... 	if(start_char == 0x08) { 
08034:  MOVF   xD8,W
08036:  SUBLW  08
08038:  BNZ   803E
.................... 		goto READ_DSP_VALUE; 
0803A:  GOTO   8876
.................... 	} 
....................  
.................... 	//if(start_char == 0x09) { 
.................... 		//goto UTILITY; 
.................... 	//} 
....................  
.................... 	if(start_char == 0x10) { 
0803E:  MOVF   xD8,W
08040:  SUBLW  10
08042:  BNZ   8048
.................... 		goto FLASH_PROGRAM_ACTIONS; 
08044:  GOTO   899E
.................... 	} 
.................... /* 
.................... 	if(start_char == 0x11) { 
.................... 		goto PHANTOM_POWER_ACTIONS; 
.................... 	} 
.................... */ 
....................  
.................... 	if(start_char == 0x14) { 
08048:  MOVF   xD8,W
0804A:  SUBLW  14
0804C:  BNZ   8052
.................... 		goto SET_DEVICE_PROPERTY; 
0804E:  GOTO   8C56
.................... 	} 
....................  
.................... 	if(start_char == 0x15) { 
08052:  MOVF   xD8,W
08054:  SUBLW  15
08056:  BNZ   805C
.................... 		goto GET_DEVICE_PROPERTY; 
08058:  GOTO   90D6
.................... 	} 
.................... 	 
....................  
.................... 	/* IF YOU ADD A NEW START CHARACTER, UPDATE THE VALID LIST ABOVE */ 
....................  
....................  
.................... GENERAL: 
.................... 	 
.................... 		command_char = timed_getc(); 
0805C:  MOVLB  0
0805E:  CALL   745E
08062:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
08066:  MOVLB  5
08068:  DECFSZ x8C,W
0806A:  BRA    807E
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
0806C:  MOVLW  10
0806E:  MOVLB  7
08070:  MOVWF  x20
08072:  MOVLB  0
08074:  CALL   7442
.................... 			return; 
08078:  MOVLB  5
0807A:  GOTO   955A
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
0807E:  MOVLB  0
08080:  CALL   745E
08084:  MOVFF  01,6DA
.................... 	 
.................... 		if(timeout_error == true) { 
08088:  MOVLB  5
0808A:  DECFSZ x8C,W
0808C:  BRA    80A0
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
0808E:  MOVLW  11
08090:  MOVLB  7
08092:  MOVWF  x20
08094:  MOVLB  0
08096:  CALL   7442
.................... 			return; 
0809A:  MOVLB  5
0809C:  GOTO   955A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
080A0:  MOVLB  6
080A2:  MOVF   xDA,W
080A4:  SUBLW  03
080A6:  BZ    80BC
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
080A8:  MOVLW  12
080AA:  MOVLB  7
080AC:  MOVWF  x20
080AE:  MOVLB  0
080B0:  CALL   7442
.................... 			return; 
080B4:  MOVLB  5
080B6:  GOTO   955A
080BA:  MOVLB  6
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
080BC:  MOVF   xD9,W
080BE:  XORLW  01
080C0:  MOVLB  0
080C2:  BZ    80F0
080C4:  XORLW  05
080C6:  BZ    811C
080C8:  XORLW  01
080CA:  BZ    815E
080CC:  XORLW  02
080CE:  BZ    818E
080D0:  XORLW  0F
080D2:  BTFSC  FD8.2
080D4:  BRA    81CA
080D6:  XORLW  01
080D8:  BTFSC  FD8.2
080DA:  BRA    81F2
080DC:  XORLW  19
080DE:  BTFSC  FD8.2
080E0:  BRA    821E
080E2:  XORLW  01
080E4:  BTFSC  FD8.2
080E6:  BRA    8250
080E8:  XORLW  31
080EA:  BTFSC  FD8.2
080EC:  BRA    828A
080EE:  BRA    82B4
.................... 			case 0x01 : 
.................... 				// RTS 
.................... 				fputc(0x06,USB); 
080F0:  MOVLW  06
080F2:  MOVLB  7
080F4:  MOVWF  x29
080F6:  MOVLB  0
080F8:  CALL   73FC
.................... 				fputc(0x01,USB); 
080FC:  MOVLW  01
080FE:  MOVLB  7
08100:  MOVWF  x29
08102:  MOVLB  0
08104:  CALL   73FC
.................... 				fputc(0x03,USB); 
08108:  MOVLW  03
0810A:  MOVLB  7
0810C:  MOVWF  x29
0810E:  MOVLB  0
08110:  CALL   73FC
.................... 				return; 
08114:  MOVLB  5
08116:  GOTO   955A
.................... 			break; 
0811A:  BRA    82C8
....................  
.................... 			case 0x04 : 
.................... 				// DEVICE ID 
.................... 				fputc(0x06,USB); 
0811C:  MOVLW  06
0811E:  MOVLB  7
08120:  MOVWF  x29
08122:  MOVLB  0
08124:  CALL   73FC
.................... 				fputc(0x04,USB); 
08128:  MOVLW  04
0812A:  MOVLB  7
0812C:  MOVWF  x29
0812E:  MOVLB  0
08130:  CALL   73FC
.................... 				fputc(DEVICE_ID_MSB,USB); 
08134:  MOVLB  7
08136:  CLRF   x29
08138:  MOVLB  0
0813A:  CALL   73FC
.................... 				fputc(DEVICE_ID_LSB,USB); 
0813E:  MOVLW  1E
08140:  MOVLB  7
08142:  MOVWF  x29
08144:  MOVLB  0
08146:  CALL   73FC
.................... 				fputc(0x03,USB); 
0814A:  MOVLW  03
0814C:  MOVLB  7
0814E:  MOVWF  x29
08150:  MOVLB  0
08152:  CALL   73FC
.................... 				return; 
08156:  MOVLB  5
08158:  GOTO   955A
.................... 			break; 
0815C:  BRA    82C8
....................  
.................... 			case 0x05 : 
.................... 				// SOFT REBOOT 
.................... 				softboot(); 
0815E:  CALL   6DC6
.................... 				fputc(0x06,USB); 
08162:  MOVLW  06
08164:  MOVLB  7
08166:  MOVWF  x29
08168:  MOVLB  0
0816A:  CALL   73FC
.................... 				fputc(0x05,USB); 
0816E:  MOVLW  05
08170:  MOVLB  7
08172:  MOVWF  x29
08174:  MOVLB  0
08176:  CALL   73FC
.................... 				fputc(0x03,USB); 
0817A:  MOVLW  03
0817C:  MOVLB  7
0817E:  MOVWF  x29
08180:  MOVLB  0
08182:  CALL   73FC
.................... 				return; 
08186:  MOVLB  5
08188:  GOTO   955A
.................... 			break; 
0818C:  BRA    82C8
....................  
.................... 			case 0x07 : 
.................... 				// Firmware Version 
....................  
.................... 				fputc(0x06,USB); 
0818E:  MOVLW  06
08190:  MOVLB  7
08192:  MOVWF  x29
08194:  MOVLB  0
08196:  CALL   73FC
.................... 				fputc(0x07,USB); 
0819A:  MOVLW  07
0819C:  MOVLB  7
0819E:  MOVWF  x29
081A0:  MOVLB  0
081A2:  CALL   73FC
.................... 				fputc(MAJOR_REVISION,USB); 
081A6:  MOVFF  61,729
081AA:  CALL   73FC
.................... 				fputc(MINOR_REVISION,USB); 
081AE:  MOVFF  62,729
081B2:  CALL   73FC
.................... 				fputc(0x03,USB); 
081B6:  MOVLW  03
081B8:  MOVLB  7
081BA:  MOVWF  x29
081BC:  MOVLB  0
081BE:  CALL   73FC
.................... 				return; 
081C2:  MOVLB  5
081C4:  GOTO   955A
.................... 			break; 
081C8:  BRA    82C8
....................  
.................... 			case 0x08 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				fputc(0x06,USB); 
081CA:  MOVLW  06
081CC:  MOVLB  7
081CE:  MOVWF  x29
081D0:  MOVLB  0
081D2:  CALL   73FC
.................... 				fputc(0x08,USB); 
081D6:  MOVLW  08
081D8:  MOVLB  7
081DA:  MOVWF  x29
081DC:  MOVLB  0
081DE:  CALL   73FC
.................... 				fputc(0x03,USB); 
081E2:  MOVLW  03
081E4:  MOVLB  7
081E6:  MOVWF  x29
081E8:  MOVLB  0
081EA:  CALL   73FC
.................... 			break; 
081EE:  MOVLB  5
081F0:  BRA    82C8
....................  
.................... 			case 0x09 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				update_phantom_power(); 
081F2:  CALL   6D5C
....................  
.................... 				fputc(0x06,USB); 
081F6:  MOVLW  06
081F8:  MOVLB  7
081FA:  MOVWF  x29
081FC:  MOVLB  0
081FE:  CALL   73FC
.................... 				fputc(0x09,USB); 
08202:  MOVLW  09
08204:  MOVLB  7
08206:  MOVWF  x29
08208:  MOVLB  0
0820A:  CALL   73FC
.................... 				fputc(0x03,USB); 
0820E:  MOVLW  03
08210:  MOVLB  7
08212:  MOVWF  x29
08214:  MOVLB  0
08216:  CALL   73FC
.................... 			break; 
0821A:  MOVLB  5
0821C:  BRA    82C8
....................  
....................  
.................... 			case 0x10 : 
.................... 				// DISABLE TIMERS 
....................  
.................... 				SETUP_TIMER_0(RTCC_OFF); 
0821E:  CLRF   FD5
.................... 				setup_timer_1(T1_DISABLED); 
08220:  CLRF   FCD
08222:  CLRF   FCC
....................  
.................... 				fputc(0x06,USB); 
08224:  MOVLW  06
08226:  MOVLB  7
08228:  MOVWF  x29
0822A:  MOVLB  0
0822C:  CALL   73FC
.................... 				fputc(0x10,USB); 
08230:  MOVLW  10
08232:  MOVLB  7
08234:  MOVWF  x29
08236:  MOVLB  0
08238:  CALL   73FC
.................... 				fputc(0x03,USB); 
0823C:  MOVLW  03
0823E:  MOVLB  7
08240:  MOVWF  x29
08242:  MOVLB  0
08244:  CALL   73FC
.................... 				return; 
08248:  MOVLB  5
0824A:  GOTO   955A
.................... 			break; 
0824E:  BRA    82C8
....................  
.................... 			case 0x11 : 
.................... 				// ENABLE TIMERS 
....................  
.................... 				setup_timer_0(T0_INTERNAL|T0_DIV_64); 
08250:  MOVLW  85
08252:  MOVWF  FD5
.................... 				setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
08254:  MOVLW  37
08256:  MOVWF  FCD
08258:  CLRF   FCC
....................  
.................... 				setup_interrupts(); 
0825A:  CALL   2F92
....................  
.................... 				fputc(0x06,USB); 
0825E:  MOVLW  06
08260:  MOVLB  7
08262:  MOVWF  x29
08264:  MOVLB  0
08266:  CALL   73FC
.................... 				fputc(0x11,USB); 
0826A:  MOVLW  11
0826C:  MOVLB  7
0826E:  MOVWF  x29
08270:  MOVLB  0
08272:  CALL   73FC
.................... 				fputc(0x03,USB); 
08276:  MOVLW  03
08278:  MOVLB  7
0827A:  MOVWF  x29
0827C:  MOVLB  0
0827E:  CALL   73FC
.................... 				return; 
08282:  MOVLB  5
08284:  GOTO   955A
.................... 			break; 
08288:  BRA    82C8
....................  
....................  
.................... 			case 0x20 : 
.................... 				// Reboot for firmware update 
.................... 				fputc(0x06,USB); 
0828A:  MOVLW  06
0828C:  MOVLB  7
0828E:  MOVWF  x29
08290:  MOVLB  0
08292:  CALL   73FC
.................... 				fputc(0x20,USB); 
08296:  MOVLW  20
08298:  MOVLB  7
0829A:  MOVWF  x29
0829C:  MOVLB  0
0829E:  CALL   73FC
.................... 				fputc(0x03,USB); 
082A2:  MOVLW  03
082A4:  MOVLB  7
082A6:  MOVWF  x29
082A8:  MOVLB  0
082AA:  CALL   73FC
.................... 				reset_cpu(); 
082AE:  RESET
....................  
.................... 			break; 
082B0:  MOVLB  5
082B2:  BRA    82C8
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
082B4:  MOVLW  13
082B6:  MOVLB  7
082B8:  MOVWF  x20
082BA:  MOVLB  0
082BC:  CALL   7442
.................... 				return; 
082C0:  MOVLB  5
082C2:  GOTO   955A
.................... 			break; 
082C6:  BRA    82C8
.................... 		} 
....................  
.................... WRITE_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
082C8:  MOVLB  0
082CA:  CALL   745E
082CE:  MOVLB  6
082D0:  CLRF   xE3
082D2:  MOVFF  01,6E2
....................  
.................... 		if(timeout_error == true) { 
082D6:  MOVLB  5
082D8:  DECFSZ x8C,W
082DA:  BRA    82EE
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
082DC:  MOVLW  14
082DE:  MOVLB  7
082E0:  MOVWF  x20
082E2:  MOVLB  0
082E4:  CALL   7442
.................... 			return; 
082E8:  MOVLB  5
082EA:  GOTO   955A
.................... 		} 
....................  
.................... 		addr_lsb = timed_getc(); 
082EE:  MOVLB  0
082F0:  CALL   745E
082F4:  MOVLB  6
082F6:  CLRF   xE1
082F8:  MOVFF  01,6E0
....................  
.................... 		if(timeout_error == true) { 
082FC:  MOVLB  5
082FE:  DECFSZ x8C,W
08300:  BRA    8314
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
08302:  MOVLW  14
08304:  MOVLB  7
08306:  MOVWF  x20
08308:  MOVLB  0
0830A:  CALL   7442
.................... 			return; 
0830E:  MOVLB  5
08310:  GOTO   955A
.................... 		} 
....................  
....................  
.................... 		if(addr_msb > 0) { 
08314:  MOVLB  6
08316:  MOVF   xE2,F
08318:  BNZ   831E
0831A:  MOVF   xE3,F
0831C:  BZ    833A
.................... 			final_address = 0; 
0831E:  CLRF   xE5
08320:  CLRF   xE4
.................... 			final_address = addr_msb; 
08322:  MOVFF  6E3,6E5
08326:  MOVFF  6E2,6E4
.................... 			final_address <<= 8; 
0832A:  MOVFF  6E4,6E5
0832E:  CLRF   xE4
.................... 			final_address |= addr_lsb; 
08330:  MOVF   xE0,W
08332:  IORWF  xE4,F
08334:  MOVF   xE1,W
08336:  IORWF  xE5,F
.................... 		} else { 
08338:  BRA    8342
.................... 			final_address = addr_lsb; 
0833A:  MOVFF  6E1,6E5
0833E:  MOVFF  6E0,6E4
.................... 		} 
....................  
.................... 		//if((final_address >= 0) && (final_address <= num_dsp_values)) { 
....................  
.................... 			// byte1 is MSB 
.................... 			byte1 = fast_timed_getc(); 
08342:  MOVLB  0
08344:  CALL   73AA
08348:  MOVFF  01,6DB
.................... 			byte2 = fast_timed_getc(); 
0834C:  CALL   73AA
08350:  MOVFF  01,6DC
.................... 			byte3 = fast_timed_getc(); 
08354:  CALL   73AA
08358:  MOVFF  01,6DD
.................... 			byte4 = fast_timed_getc(); 
0835C:  CALL   73AA
08360:  MOVFF  01,6DE
....................  
.................... 			if(timeout_error == true) { 
08364:  MOVLB  5
08366:  DECFSZ x8C,W
08368:  BRA    8394
.................... 				// Timed out on one of the bytes 
.................... 				fputc(0x15,USB); 
0836A:  MOVLW  15
0836C:  MOVLB  7
0836E:  MOVWF  x29
08370:  MOVLB  0
08372:  CALL   73FC
.................... 				fputc(ERR_DATA_TIMEOUT,USB); 
08376:  MOVLW  17
08378:  MOVLB  7
0837A:  MOVWF  x29
0837C:  MOVLB  0
0837E:  CALL   73FC
.................... 				fputc(0x03,USB); 
08382:  MOVLW  03
08384:  MOVLB  7
08386:  MOVWF  x29
08388:  MOVLB  0
0838A:  CALL   73FC
.................... 				return; 
0838E:  MOVLB  5
08390:  GOTO   955A
.................... 			}	 
.................... 			 
.................... 			dummy_char = timed_getc(); 
08394:  MOVLB  0
08396:  CALL   745E
0839A:  MOVFF  01,6DA
.................... 	 
.................... 			if(timeout_error == true) { 
0839E:  MOVLB  5
083A0:  DECFSZ x8C,W
083A2:  BRA    83CE
.................... 				// Timed out. No command. Start over. 
.................... 				fputc(0x15,USB); 
083A4:  MOVLW  15
083A6:  MOVLB  7
083A8:  MOVWF  x29
083AA:  MOVLB  0
083AC:  CALL   73FC
.................... 				fputc(ERR_END_TIMEOUT,USB); 
083B0:  MOVLW  11
083B2:  MOVLB  7
083B4:  MOVWF  x29
083B6:  MOVLB  0
083B8:  CALL   73FC
.................... 				fputc(0x03,USB); 
083BC:  MOVLW  03
083BE:  MOVLB  7
083C0:  MOVWF  x29
083C2:  MOVLB  0
083C4:  CALL   73FC
.................... 				return; 
083C8:  MOVLB  5
083CA:  GOTO   955A
.................... 			} 
.................... 	 
.................... 			if(dummy_char != 0x03) { 
083CE:  MOVLB  6
083D0:  MOVF   xDA,W
083D2:  SUBLW  03
083D4:  BZ    8402
.................... 				// Ending char not 0x03 
.................... 				fputc(0x15,USB); 
083D6:  MOVLW  15
083D8:  MOVLB  7
083DA:  MOVWF  x29
083DC:  MOVLB  0
083DE:  CALL   73FC
.................... 				fputc(ERR_END_INVALID,USB); 
083E2:  MOVLW  12
083E4:  MOVLB  7
083E6:  MOVWF  x29
083E8:  MOVLB  0
083EA:  CALL   73FC
.................... 				fputc(0x03,USB); 
083EE:  MOVLW  03
083F0:  MOVLB  7
083F2:  MOVWF  x29
083F4:  MOVLB  0
083F6:  CALL   73FC
.................... 				return; 
083FA:  MOVLB  5
083FC:  GOTO   955A
08400:  MOVLB  6
.................... 			} 
.................... 			 
.................... 			last_address = final_address; 
08402:  MOVFF  6E5,6E7
08406:  MOVFF  6E4,6E6
.................... 			last_byte1 = byte1; 
0840A:  MOVFF  6DB,6BB
.................... 			last_byte2 = byte2; 
0840E:  MOVFF  6DC,6BC
.................... 			last_byte3 = byte3; 
08412:  MOVFF  6DD,6BD
.................... 			last_byte4 = byte4; 
08416:  MOVFF  6DE,6BE
....................  
.................... 			read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
0841A:  MOVFF  6E5,721
0841E:  MOVFF  6E4,720
08422:  MOVLB  0
08424:  CALL   74B0
08428:  MOVFF  01,720
0842C:  MOVLB  7
0842E:  CLRF   x2B
08430:  MOVLW  7A
08432:  MOVWF  x2A
08434:  MOVFF  79,72C
08438:  MOVFF  01,72D
0843C:  MOVLB  0
0843E:  CALL   649C
....................  
.................... 			int32 new_dsp_value = 0x00000000 | byte1; 
08442:  MOVLB  6
08444:  MOVFF  6DB,6E8
08448:  CLRF   xE9
0844A:  CLRF   xEA
0844C:  CLRF   xEB
.................... 			new_dsp_value = new_dsp_value << 8; 
0844E:  MOVFF  6EA,6EB
08452:  MOVFF  6E9,6EA
08456:  MOVFF  6E8,6E9
0845A:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte2; 
0845C:  MOVF   xDC,W
0845E:  IORWF  xE8,F
.................... 			new_dsp_value = new_dsp_value << 8; 
08460:  MOVFF  6EA,6EB
08464:  MOVFF  6E9,6EA
08468:  MOVFF  6E8,6E9
0846C:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte3; 
0846E:  MOVF   xDD,W
08470:  IORWF  xE8,F
.................... 			new_dsp_value = new_dsp_value << 8; 
08472:  MOVFF  6EA,6EB
08476:  MOVFF  6E9,6EA
0847A:  MOVFF  6E8,6E9
0847E:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte4; 
08480:  MOVF   xDE,W
08482:  IORWF  xE8,F
....................  
....................  
.................... 			if(final_address < num_dsp_values) { 
08484:  MOVF   xE5,W
08486:  SUBWF  1B,W
08488:  BNC   84CE
0848A:  BNZ   8492
0848C:  MOVF   1A,W
0848E:  SUBWF  xE4,W
08490:  BC    84CE
.................... 				send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(final_address),new_dsp_value); 
08492:  MOVFF  6E5,72B
08496:  MOVFF  6E4,72A
0849A:  MOVLB  0
0849C:  CALL   69D4
084A0:  MOVFF  02,721
084A4:  MOVFF  01,720
084A8:  MOVLW  F0
084AA:  MOVLB  7
084AC:  MOVWF  x31
084AE:  CLRF   x30
084B0:  MOVFF  02,733
084B4:  MOVFF  01,732
084B8:  MOVFF  6EB,737
084BC:  MOVFF  6EA,736
084C0:  MOVFF  6E9,735
084C4:  MOVFF  6E8,734
084C8:  MOVLB  0
084CA:  CALL   68E8
.................... 			} 
.................... 			PAGE_BUFFER_A[addr_index_to_buffer_index(final_address)] = new_dsp_value; 
084CE:  MOVFF  6E5,721
084D2:  MOVFF  6E4,720
084D6:  MOVLB  0
084D8:  GOTO   74DA
084DC:  MOVF   01,W
084DE:  MULLW  04
084E0:  MOVF   FF3,W
084E2:  CLRF   03
084E4:  ADDLW  7A
084E6:  MOVWF  FE9
084E8:  MOVLW  00
084EA:  ADDWFC 03,W
084EC:  MOVWF  FEA
084EE:  MOVFF  6E8,FEF
084F2:  MOVFF  6E9,FEC
084F6:  MOVFF  6EA,FEC
084FA:  MOVFF  6EB,FEC
....................  
.................... 			write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
084FE:  MOVFF  6E5,721
08502:  MOVFF  6E4,720
08506:  CALL   74B0
0850A:  MOVFF  01,720
0850E:  MOVLB  7
08510:  CLRF   x29
08512:  MOVLW  7A
08514:  MOVWF  x28
08516:  MOVFF  79,72A
0851A:  MOVFF  01,72B
0851E:  MOVLB  0
08520:  CALL   6588
....................  
.................... 			// Send ACK 
.................... 			fputc(0x06,USB); 
08524:  MOVLW  06
08526:  MOVLB  7
08528:  MOVWF  x29
0852A:  MOVLB  0
0852C:  CALL   73FC
.................... 			fputc(addr_msb,USB); 
08530:  MOVFF  6E2,729
08534:  CALL   73FC
.................... 			fputc(addr_lsb,USB); 
08538:  MOVFF  6E0,729
0853C:  CALL   73FC
.................... 			fputc(0x03,USB);	 
08540:  MOVLW  03
08542:  MOVLB  7
08544:  MOVWF  x29
08546:  MOVLB  0
08548:  CALL   73FC
.................... 			return; 
0854C:  MOVLB  5
0854E:  GOTO   955A
....................  
.................... 		//} else { 
.................... 		//	// Invalid address 
.................... 		//	send_error(ERR_ADDR_INVALID); 
.................... 		//	return; 
.................... 		//} 
....................  
.................... GET_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
08552:  MOVLB  0
08554:  CALL   745E
08558:  MOVLB  6
0855A:  CLRF   xE3
0855C:  MOVFF  01,6E2
....................  
.................... 		if(timeout_error == true) { 
08560:  MOVLB  5
08562:  DECFSZ x8C,W
08564:  BRA    8578
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
08566:  MOVLW  14
08568:  MOVLB  7
0856A:  MOVWF  x20
0856C:  MOVLB  0
0856E:  CALL   7442
.................... 			return; 
08572:  MOVLB  5
08574:  GOTO   955A
.................... 		} 
....................  
.................... 		//printf("Got address 1 %u\r\n",addr_index); 
....................  
.................... 		addr_lsb = timed_getc(); 
08578:  MOVLB  0
0857A:  CALL   745E
0857E:  MOVLB  6
08580:  CLRF   xE1
08582:  MOVFF  01,6E0
....................  
.................... 		if(timeout_error == true) { 
08586:  MOVLB  5
08588:  DECFSZ x8C,W
0858A:  BRA    859E
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
0858C:  MOVLW  14
0858E:  MOVLB  7
08590:  MOVWF  x20
08592:  MOVLB  0
08594:  CALL   7442
.................... 			return; 
08598:  MOVLB  5
0859A:  GOTO   955A
.................... 		} 
....................  
.................... 		//printf("Got address 2 %u\r\n",addr_index); 
....................  
.................... 		if(addr_lsb == 255) { 
0859E:  MOVLB  6
085A0:  INCFSZ xE0,W
085A2:  BRA    85BE
085A4:  MOVF   xE1,F
085A6:  BNZ   85BE
.................... 			final_address = 0; 
085A8:  CLRF   xE5
085AA:  CLRF   xE4
.................... 			final_address += addr_msb; 
085AC:  MOVF   xE2,W
085AE:  ADDWF  xE4,F
085B0:  MOVF   xE3,W
085B2:  ADDWFC xE5,F
.................... 			final_address += addr_lsb; 
085B4:  MOVF   xE0,W
085B6:  ADDWF  xE4,F
085B8:  MOVF   xE1,W
085BA:  ADDWFC xE5,F
.................... 		} else { 
085BC:  BRA    85C6
.................... 			final_address = addr_lsb; 
085BE:  MOVFF  6E1,6E5
085C2:  MOVFF  6E0,6E4
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
085C6:  MOVLB  0
085C8:  CALL   745E
085CC:  MOVFF  01,6DA
....................  
....................  
.................... 		if(timeout_error == true) { 
085D0:  MOVLB  5
085D2:  DECFSZ x8C,W
085D4:  BRA    85E8
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
085D6:  MOVLW  11
085D8:  MOVLB  7
085DA:  MOVWF  x20
085DC:  MOVLB  0
085DE:  CALL   7442
.................... 			return; 
085E2:  MOVLB  5
085E4:  GOTO   955A
.................... 		} 
.................... 		 
.................... 		if(dummy_char != 0x03) { 
085E8:  MOVLB  6
085EA:  MOVF   xDA,W
085EC:  SUBLW  03
085EE:  BZ    8604
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
085F0:  MOVLW  12
085F2:  MOVLB  7
085F4:  MOVWF  x20
085F6:  MOVLB  0
085F8:  CALL   7442
.................... 			return; 
085FC:  MOVLB  5
085FE:  GOTO   955A
08602:  MOVLB  6
.................... 		} 
....................  
.................... 		if((final_address >= 0) && (final_address <= num_dsp_values)) { 
08604:  MOVF   xE5,W
08606:  SUBWF  1B,W
08608:  BNC   8698
0860A:  BNZ   8612
0860C:  MOVF   xE4,W
0860E:  SUBWF  1A,W
08610:  BNC   8698
....................  
.................... 			// TODO - Re-implement 
.................... 			//int32 value = READ_CONFIG_VALUE(final_address); 
.................... 	 
.................... 			int32 value = 0; 
....................  
.................... 			char byte4 = value & 0xFF; 
08612:  CLRF   xEF
08614:  CLRF   xEE
08616:  CLRF   xED
08618:  CLRF   xEC
0861A:  MOVFF  6EC,6F0
.................... 			value = value >> 8; 
0861E:  MOVFF  6ED,6EC
08622:  MOVFF  6EE,6ED
08626:  MOVFF  6EF,6EE
0862A:  CLRF   xEF
.................... 		 
.................... 			char byte3 = value & 0xFF; 
0862C:  MOVFF  6EC,6F1
.................... 			value = value >> 8; 
08630:  MOVFF  6ED,6EC
08634:  MOVFF  6EE,6ED
08638:  MOVFF  6EF,6EE
0863C:  CLRF   xEF
.................... 			 
.................... 			char byte2 = value & 0xFF; 
.................... 			char byte1 = value >> 8; 
0863E:  MOVFF  6EC,6F2
08642:  MOVFF  6ED,6F3
.................... 		 
.................... 			fputc(0x06,USB); 
08646:  MOVLW  06
08648:  MOVLB  7
0864A:  MOVWF  x29
0864C:  MOVLB  0
0864E:  CALL   73FC
.................... 			fputc(addr_msb,USB); 
08652:  MOVFF  6E2,729
08656:  CALL   73FC
.................... 			fputc(addr_lsb,USB); 
0865A:  MOVFF  6E0,729
0865E:  CALL   73FC
.................... 			fputc(byte1,USB); 
08662:  MOVFF  6F3,729
08666:  CALL   73FC
.................... 			fputc(byte2,USB); 
0866A:  MOVFF  6F2,729
0866E:  CALL   73FC
.................... 			fputc(byte3,USB); 
08672:  MOVFF  6F1,729
08676:  CALL   73FC
.................... 			fputc(byte4,USB); 
0867A:  MOVFF  6F0,729
0867E:  CALL   73FC
.................... 			fputc(0x03,USB); 
08682:  MOVLW  03
08684:  MOVLB  7
08686:  MOVWF  x29
08688:  MOVLB  0
0868A:  CALL   73FC
.................... 			return; 
0868E:  MOVLB  5
08690:  GOTO   955A
.................... 	 
.................... 		} else { 
08694:  BRA    86AA
08696:  MOVLB  6
.................... 			// Invalid address 
.................... 			send_error(ERR_ADDR_INVALID); 
08698:  MOVLW  16
0869A:  MOVLB  7
0869C:  MOVWF  x20
0869E:  MOVLB  0
086A0:  CALL   7442
.................... 			return; 
086A4:  MOVLB  5
086A6:  GOTO   955A
086AA:  MOVLB  6
.................... 		} 
....................  
.................... 	// END GET_VALUE label 
....................  
.................... SEND_DSP_VALUE: 
....................  
.................... 		byte addr_byte1,addr_byte2,addr_byte3,addr_byte4; 
.................... 		byte val_byte1,val_byte2,val_byte3,val_byte4; 
....................  
.................... 		addr_byte1 = fast_timed_getc(); 
086AC:  MOVLB  0
086AE:  CALL   73AA
086B2:  MOVFF  01,6F4
.................... 		addr_byte2 = fast_timed_getc(); 
086B6:  CALL   73AA
086BA:  MOVFF  01,6F5
.................... 		addr_byte3 = fast_timed_getc(); 
086BE:  CALL   73AA
086C2:  MOVFF  01,6F6
.................... 		addr_byte4 = fast_timed_getc(); 
086C6:  CALL   73AA
086CA:  MOVFF  01,6F7
....................  
.................... 		val_byte1 = fast_timed_getc(); 
086CE:  CALL   73AA
086D2:  MOVFF  01,6F8
.................... 		val_byte2 = fast_timed_getc(); 
086D6:  CALL   73AA
086DA:  MOVFF  01,6F9
.................... 		val_byte3 = fast_timed_getc(); 
086DE:  CALL   73AA
086E2:  MOVFF  01,6FA
.................... 		val_byte4 = fast_timed_getc(); 
086E6:  CALL   73AA
086EA:  MOVFF  01,6FB
....................  
.................... 		if(timeout_error == true) { 
086EE:  MOVLB  5
086F0:  DECFSZ x8C,W
086F2:  BRA    871E
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
086F4:  MOVLW  15
086F6:  MOVLB  7
086F8:  MOVWF  x29
086FA:  MOVLB  0
086FC:  CALL   73FC
.................... 			fputc(0x17,USB); 
08700:  MOVLW  17
08702:  MOVLB  7
08704:  MOVWF  x29
08706:  MOVLB  0
08708:  CALL   73FC
.................... 			fputc(0x03,USB); 
0870C:  MOVLW  03
0870E:  MOVLB  7
08710:  MOVWF  x29
08712:  MOVLB  0
08714:  CALL   73FC
.................... 			return; 
08718:  MOVLB  5
0871A:  GOTO   955A
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
0871E:  MOVLB  0
08720:  CALL   745E
08724:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
08728:  MOVLB  5
0872A:  DECFSZ x8C,W
0872C:  BRA    8758
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
0872E:  MOVLW  15
08730:  MOVLB  7
08732:  MOVWF  x29
08734:  MOVLB  0
08736:  CALL   73FC
.................... 			fputc(ERR_END_TIMEOUT,USB); 
0873A:  MOVLW  11
0873C:  MOVLB  7
0873E:  MOVWF  x29
08740:  MOVLB  0
08742:  CALL   73FC
.................... 			fputc(0x03,USB); 
08746:  MOVLW  03
08748:  MOVLB  7
0874A:  MOVWF  x29
0874C:  MOVLB  0
0874E:  CALL   73FC
.................... 			return; 
08752:  MOVLB  5
08754:  GOTO   955A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08758:  MOVLB  6
0875A:  MOVF   xDA,W
0875C:  SUBLW  03
0875E:  BZ    878C
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
08760:  MOVLW  15
08762:  MOVLB  7
08764:  MOVWF  x29
08766:  MOVLB  0
08768:  CALL   73FC
.................... 			fputc(0x13,USB); 
0876C:  MOVLW  13
0876E:  MOVLB  7
08770:  MOVWF  x29
08772:  MOVLB  0
08774:  CALL   73FC
.................... 			fputc(0x03,USB); 
08778:  MOVLW  03
0877A:  MOVLB  7
0877C:  MOVWF  x29
0877E:  MOVLB  0
08780:  CALL   73FC
.................... 			return; 
08784:  MOVLB  5
08786:  GOTO   955A
0878A:  MOVLB  6
.................... 		} 
....................  
.................... 		 
....................  
.................... 		int32 debug_address = 0x00000000 | addr_byte1; 
0878C:  MOVFF  6F4,6FC
08790:  CLRF   xFD
08792:  CLRF   xFE
08794:  CLRF   xFF
.................... 		debug_address = debug_address << 8; 
08796:  MOVFF  6FE,6FF
0879A:  MOVFF  6FD,6FE
0879E:  MOVFF  6FC,6FD
087A2:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte2; 
087A4:  MOVF   xF5,W
087A6:  IORWF  xFC,F
.................... 		debug_address = debug_address << 8; 
087A8:  MOVFF  6FE,6FF
087AC:  MOVFF  6FD,6FE
087B0:  MOVFF  6FC,6FD
087B4:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte3; 
087B6:  MOVF   xF6,W
087B8:  IORWF  xFC,F
.................... 		debug_address = debug_address << 8; 
087BA:  MOVFF  6FE,6FF
087BE:  MOVFF  6FD,6FE
087C2:  MOVFF  6FC,6FD
087C6:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte4; 
087C8:  MOVF   xF7,W
087CA:  IORWF  xFC,F
....................  
.................... 		int32 debug_value = 0x00000000 | val_byte1; 
087CC:  MOVFF  6F8,700
087D0:  MOVLB  7
087D2:  CLRF   x01
087D4:  CLRF   x02
087D6:  CLRF   x03
.................... 		debug_value = debug_value << 8; 
087D8:  MOVFF  702,703
087DC:  MOVFF  701,702
087E0:  MOVFF  700,701
087E4:  CLRF   x00
.................... 		debug_value = debug_value | val_byte2; 
087E6:  MOVLB  6
087E8:  MOVF   xF9,W
087EA:  MOVLB  7
087EC:  IORWF  x00,F
.................... 		debug_value = debug_value << 8; 
087EE:  MOVFF  702,703
087F2:  MOVFF  701,702
087F6:  MOVFF  700,701
087FA:  CLRF   x00
.................... 		debug_value = debug_value | val_byte3; 
087FC:  MOVLB  6
087FE:  MOVF   xFA,W
08800:  MOVLB  7
08802:  IORWF  x00,F
.................... 		debug_value = debug_value << 8; 
08804:  MOVFF  702,703
08808:  MOVFF  701,702
0880C:  MOVFF  700,701
08810:  CLRF   x00
.................... 		debug_value = debug_value | val_byte4; 
08812:  MOVLB  6
08814:  MOVF   xFB,W
08816:  MOVLB  7
08818:  IORWF  x00,F
0881A:  CLRF   19
0881C:  BTFSC  FF2.7
0881E:  BSF    19.7
08820:  BCF    FF2.7
.................... 			 
.................... 		send_dsp_command(debug_address,debug_value); 
08822:  MOVFF  6FF,776
08826:  MOVFF  6FE,775
0882A:  MOVFF  6FD,774
0882E:  MOVFF  6FC,773
08832:  MOVFF  703,77A
08836:  MOVFF  702,779
0883A:  MOVFF  701,778
0883E:  MOVFF  700,777
08842:  MOVLB  0
08844:  CALL   142C
08848:  BTFSC  19.7
0884A:  BSF    FF2.7
....................  
.................... 		fputc(0x06); 
0884C:  MOVLW  06
0884E:  MOVLB  7
08850:  MOVWF  x29
08852:  MOVLB  0
08854:  CALL   73FC
.................... 		fputc(0x07); 
08858:  MOVLW  07
0885A:  MOVLB  7
0885C:  MOVWF  x29
0885E:  MOVLB  0
08860:  CALL   73FC
.................... 		fputc(0x03); 
08864:  MOVLW  03
08866:  MOVLB  7
08868:  MOVWF  x29
0886A:  MOVLB  0
0886C:  CALL   73FC
....................  
....................  
.................... 		return; 
08870:  MOVLB  5
08872:  GOTO   955A
....................  
.................... READ_DSP_VALUE: 
....................  
.................... 		byte1 = fast_timed_getc(); 
08876:  MOVLB  0
08878:  CALL   73AA
0887C:  MOVFF  01,6DB
.................... 		byte2 = fast_timed_getc(); 
08880:  CALL   73AA
08884:  MOVFF  01,6DC
.................... 		byte3 = fast_timed_getc(); 
08888:  CALL   73AA
0888C:  MOVFF  01,6DD
.................... 		byte4 = fast_timed_getc(); 
08890:  CALL   73AA
08894:  MOVFF  01,6DE
....................  
.................... 		if(timeout_error == true) { 
08898:  MOVLB  5
0889A:  DECFSZ x8C,W
0889C:  BRA    88C8
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
0889E:  MOVLW  15
088A0:  MOVLB  7
088A2:  MOVWF  x29
088A4:  MOVLB  0
088A6:  CALL   73FC
.................... 			fputc(0x17,USB); 
088AA:  MOVLW  17
088AC:  MOVLB  7
088AE:  MOVWF  x29
088B0:  MOVLB  0
088B2:  CALL   73FC
.................... 			fputc(0x03,USB); 
088B6:  MOVLW  03
088B8:  MOVLB  7
088BA:  MOVWF  x29
088BC:  MOVLB  0
088BE:  CALL   73FC
.................... 			return; 
088C2:  MOVLB  5
088C4:  GOTO   955A
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
088C8:  MOVLB  0
088CA:  CALL   745E
088CE:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
088D2:  MOVLB  5
088D4:  DECFSZ x8C,W
088D6:  BRA    8902
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
088D8:  MOVLW  15
088DA:  MOVLB  7
088DC:  MOVWF  x29
088DE:  MOVLB  0
088E0:  CALL   73FC
.................... 			fputc(ERR_END_TIMEOUT,USB); 
088E4:  MOVLW  11
088E6:  MOVLB  7
088E8:  MOVWF  x29
088EA:  MOVLB  0
088EC:  CALL   73FC
.................... 			fputc(0x03,USB); 
088F0:  MOVLW  03
088F2:  MOVLB  7
088F4:  MOVWF  x29
088F6:  MOVLB  0
088F8:  CALL   73FC
.................... 			return; 
088FC:  MOVLB  5
088FE:  GOTO   955A
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08902:  MOVLB  6
08904:  MOVF   xDA,W
08906:  SUBLW  03
08908:  BZ    8934
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
0890A:  MOVLW  15
0890C:  MOVLB  7
0890E:  MOVWF  x29
08910:  MOVLB  0
08912:  CALL   73FC
.................... 			fputc(0x13,USB); 
08916:  MOVLW  13
08918:  MOVLB  7
0891A:  MOVWF  x29
0891C:  MOVLB  0
0891E:  CALL   73FC
.................... 			fputc(0x03,USB); 
08922:  MOVLW  03
08924:  MOVLB  7
08926:  MOVWF  x29
08928:  MOVLB  0
0892A:  CALL   73FC
.................... 			return; 
0892E:  MOVLB  5
08930:  GOTO   955A
.................... 		} 
....................  
.................... 		int32 address = 0x00000000 | byte1; 
08934:  MOVFF  6DB,704
08938:  MOVLB  7
0893A:  CLRF   x05
0893C:  CLRF   x06
0893E:  CLRF   x07
.................... 		address = address << 8; 
08940:  MOVFF  706,707
08944:  MOVFF  705,706
08948:  MOVFF  704,705
0894C:  CLRF   x04
.................... 		address = address | byte2; 
0894E:  MOVLB  6
08950:  MOVF   xDC,W
08952:  MOVLB  7
08954:  IORWF  x04,F
.................... 		address = address << 8; 
08956:  MOVFF  706,707
0895A:  MOVFF  705,706
0895E:  MOVFF  704,705
08962:  CLRF   x04
.................... 		address = address | byte3; 
08964:  MOVLB  6
08966:  MOVF   xDD,W
08968:  MOVLB  7
0896A:  IORWF  x04,F
.................... 		address = address << 8; 
0896C:  MOVFF  706,707
08970:  MOVFF  705,706
08974:  MOVFF  704,705
08978:  CLRF   x04
.................... 		address = address | byte4; 
0897A:  MOVLB  6
0897C:  MOVF   xDE,W
0897E:  MOVLB  7
08980:  IORWF  x04,F
.................... 			 
.................... 		read_dsp_and_send_to_usb(address); 
08982:  MOVFF  707,723
08986:  MOVFF  706,722
0898A:  MOVFF  705,721
0898E:  MOVFF  704,720
08992:  MOVLB  0
08994:  GOTO   7556
....................  
.................... 		return; 
08998:  MOVLB  5
0899A:  GOTO   955A
....................  
....................  
....................  
.................... FLASH_PROGRAM_ACTIONS: 
....................  
.................... 		command_char = timed_getc(); 
0899E:  MOVLB  0
089A0:  CALL   745E
089A4:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
089A8:  MOVLB  5
089AA:  DECFSZ x8C,W
089AC:  BRA    89C0
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
089AE:  MOVLW  10
089B0:  MOVLB  7
089B2:  MOVWF  x20
089B4:  MOVLB  0
089B6:  CALL   7442
.................... 			return; 
089BA:  MOVLB  5
089BC:  GOTO   955A
.................... 		} 
....................  
.................... 		if(command_char == 0x04 || command_char == 0x05 || command_char == 0x09 || command_char == 0x11) { 
089C0:  MOVLB  6
089C2:  MOVF   xD9,W
089C4:  SUBLW  04
089C6:  BZ    89DA
089C8:  MOVF   xD9,W
089CA:  SUBLW  05
089CC:  BZ    89DA
089CE:  MOVF   xD9,W
089D0:  SUBLW  09
089D2:  BZ    89DA
089D4:  MOVF   xD9,W
089D6:  SUBLW  11
089D8:  BNZ   89F8
.................... 			addr_msb = timed_getc(); 
089DA:  MOVLB  0
089DC:  CALL   745E
089E0:  MOVLB  6
089E2:  CLRF   xE3
089E4:  MOVFF  01,6E2
.................... 			addr_lsb = timed_getc(); 
089E8:  MOVLB  0
089EA:  CALL   745E
089EE:  MOVLB  6
089F0:  CLRF   xE1
089F2:  MOVFF  01,6E0
.................... 		} else { 
089F6:  BRA    8A02
.................... 			temp_byte = timed_getc(); 
089F8:  MOVLB  0
089FA:  CALL   745E
089FE:  MOVFF  01,6C1
....................  
.................... 		} 
.................... 	 
.................... 		if(timeout_error == true) { 
08A02:  MOVLB  5
08A04:  DECFSZ x8C,W
08A06:  BRA    8A1A
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08A08:  MOVLW  17
08A0A:  MOVLB  7
08A0C:  MOVWF  x20
08A0E:  MOVLB  0
08A10:  CALL   7442
.................... 			return; 
08A14:  MOVLB  5
08A16:  GOTO   955A
.................... 		} 
.................... 		 
.................... 	 
.................... 		 
....................  
.................... 		char stream_size_msb,stream_size_lsb; 
....................  
.................... 		if(command_char == 0x11) { 
08A1A:  MOVLB  6
08A1C:  MOVF   xD9,W
08A1E:  SUBLW  11
08A20:  BNZ   8A34
.................... 			stream_size_msb = timed_getc(); 
08A22:  MOVLB  0
08A24:  CALL   745E
08A28:  MOVFF  01,708
.................... 			stream_size_lsb = timed_getc(); 
08A2C:  CALL   745E
08A30:  MOVFF  01,709
.................... 		}	 
....................  
.................... 		dummy_char = timed_getc(); 
08A34:  MOVLB  0
08A36:  CALL   745E
08A3A:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
08A3E:  MOVLB  5
08A40:  DECFSZ x8C,W
08A42:  BRA    8A56
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08A44:  MOVLW  11
08A46:  MOVLB  7
08A48:  MOVWF  x20
08A4A:  MOVLB  0
08A4C:  CALL   7442
.................... 			return; 
08A50:  MOVLB  5
08A52:  GOTO   955A
.................... 		} 
....................  
.................... 		switch(command_char) { 
08A56:  MOVLB  6
08A58:  MOVF   xD9,W
08A5A:  XORLW  01
08A5C:  MOVLB  0
08A5E:  BZ    8A80
08A60:  XORLW  03
08A62:  BZ    8ABC
08A64:  XORLW  06
08A66:  BZ    8AF4
08A68:  XORLW  01
08A6A:  BZ    8B30
08A6C:  XORLW  0D
08A6E:  BTFSC  FD8.2
08A70:  BRA    8B78
08A72:  XORLW  01
08A74:  BTFSC  FD8.2
08A76:  BRA    8BAC
08A78:  XORLW  18
08A7A:  BTFSC  FD8.2
08A7C:  BRA    8C10
08A7E:  BRA    8C42
....................  
.................... 			case 0x01 : 
.................... 				// SWITCH ACTIVE PROGRAM 
.................... 				switch_flash_program(temp_byte); 
08A80:  MOVFF  6C1,720
08A84:  GOTO   76E8
.................... 				fputc(0x06,USB); 
08A88:  MOVLW  06
08A8A:  MOVLB  7
08A8C:  MOVWF  x29
08A8E:  MOVLB  0
08A90:  CALL   73FC
.................... 				fputc(0x01,USB); 
08A94:  MOVLW  01
08A96:  MOVLB  7
08A98:  MOVWF  x29
08A9A:  MOVLB  0
08A9C:  CALL   73FC
.................... 				fputc(temp_byte,USB); 
08AA0:  MOVFF  6C1,729
08AA4:  CALL   73FC
.................... 				fputc(0x03,USB); 
08AA8:  MOVLW  03
08AAA:  MOVLB  7
08AAC:  MOVWF  x29
08AAE:  MOVLB  0
08AB0:  CALL   73FC
.................... 				return; 
08AB4:  MOVLB  5
08AB6:  GOTO   955A
.................... 			break; 
08ABA:  BRA    8C56
....................  
.................... 			case 0x02 : 
.................... 				// SAVE ACTIVE PROGRAM 
....................  
.................... 				save_flash_program(); 
08ABC:  GOTO   772C
....................  
.................... 				fputc(0x06,USB); 
08AC0:  MOVLW  06
08AC2:  MOVLB  7
08AC4:  MOVWF  x29
08AC6:  MOVLB  0
08AC8:  CALL   73FC
.................... 				fputc(0x02,USB); 
08ACC:  MOVLW  02
08ACE:  MOVLB  7
08AD0:  MOVWF  x29
08AD2:  MOVLB  0
08AD4:  CALL   73FC
.................... 				fputc(temp_byte,USB); 
08AD8:  MOVFF  6C1,729
08ADC:  CALL   73FC
.................... 				fputc(0x03,USB); 
08AE0:  MOVLW  03
08AE2:  MOVLB  7
08AE4:  MOVWF  x29
08AE6:  MOVLB  0
08AE8:  CALL   73FC
.................... 				return; 
08AEC:  MOVLB  5
08AEE:  GOTO   955A
.................... 			break; 
08AF2:  BRA    8C56
....................  
.................... 			case 0x04 : 
....................  
.................... 				// SAVE ACTIVE SECTOR 
....................  
.................... 				fputc(0x06,USB); 
08AF4:  MOVLW  06
08AF6:  MOVLB  7
08AF8:  MOVWF  x29
08AFA:  MOVLB  0
08AFC:  CALL   73FC
.................... 				fputc(0x05,USB); 
08B00:  MOVLW  05
08B02:  MOVLB  7
08B04:  MOVWF  x29
08B06:  MOVLB  0
08B08:  CALL   73FC
.................... 				fputc(addr_msb,USB); 
08B0C:  MOVFF  6E2,729
08B10:  CALL   73FC
.................... 				fputc(addr_lsb,USB); 
08B14:  MOVFF  6E0,729
08B18:  CALL   73FC
.................... 				fputc(0x03,USB); 
08B1C:  MOVLW  03
08B1E:  MOVLB  7
08B20:  MOVWF  x29
08B22:  MOVLB  0
08B24:  CALL   73FC
.................... 				return; 
08B28:  MOVLB  5
08B2A:  GOTO   955A
.................... 			break; 
08B2E:  BRA    8C56
....................  
.................... 			case 0x05 : 
....................  
.................... 				FLASH_COPY_PROGRAM(addr_msb,addr_lsb); 
08B30:  MOVFF  6E2,720
08B34:  MOVFF  6E0,721
08B38:  GOTO   7730
....................  
.................... 				fputc(0x06,USB); 
08B3C:  MOVLW  06
08B3E:  MOVLB  7
08B40:  MOVWF  x29
08B42:  MOVLB  0
08B44:  CALL   73FC
.................... 				fputc(0x05,USB); 
08B48:  MOVLW  05
08B4A:  MOVLB  7
08B4C:  MOVWF  x29
08B4E:  MOVLB  0
08B50:  CALL   73FC
.................... 				fputc(addr_msb,USB); 
08B54:  MOVFF  6E2,729
08B58:  CALL   73FC
.................... 				fputc(addr_lsb,USB); 
08B5C:  MOVFF  6E0,729
08B60:  CALL   73FC
.................... 				fputc(0x03,USB); 
08B64:  MOVLW  03
08B66:  MOVLB  7
08B68:  MOVWF  x29
08B6A:  MOVLB  0
08B6C:  CALL   73FC
.................... 				return; 
08B70:  MOVLB  5
08B72:  GOTO   955A
.................... 			break; 
08B76:  BRA    8C56
....................  
....................  
.................... 			case 0x08 : 
....................  
.................... 				// GET ACTIVE PROGRAM INDEX 
....................  
.................... 				fputc(0x06,USB); 
08B78:  MOVLW  06
08B7A:  MOVLB  7
08B7C:  MOVWF  x29
08B7E:  MOVLB  0
08B80:  CALL   73FC
.................... 				fputc(0x08,USB); 
08B84:  MOVLW  08
08B86:  MOVLB  7
08B88:  MOVWF  x29
08B8A:  MOVLB  0
08B8C:  CALL   73FC
.................... 				fputc(CURRENT_FLASH_PROGRAM,USB); 
08B90:  MOVFF  79,729
08B94:  CALL   73FC
.................... 				fputc(0x03,USB); 
08B98:  MOVLW  03
08B9A:  MOVLB  7
08B9C:  MOVWF  x29
08B9E:  MOVLB  0
08BA0:  CALL   73FC
.................... 				return; 
08BA4:  MOVLB  5
08BA6:  GOTO   955A
.................... 			break; 
08BAA:  BRA    8C56
....................  
.................... 			case 0x09 : 
....................  
.................... 				// STREAM PROGRAM BLOCK TO USB 
....................  
.................... 				read_flash_page_into_buffer(&PAGE_BUFFER_A,addr_msb,addr_lsb); 
08BAC:  MOVLB  7
08BAE:  CLRF   x2B
08BB0:  MOVLW  7A
08BB2:  MOVWF  x2A
08BB4:  MOVFF  6E2,72C
08BB8:  MOVFF  6E0,72D
08BBC:  MOVLB  0
08BBE:  CALL   649C
....................  
.................... 				fputc(0x06,USB); 
08BC2:  MOVLW  06
08BC4:  MOVLB  7
08BC6:  MOVWF  x29
08BC8:  MOVLB  0
08BCA:  CALL   73FC
.................... 				fputc(0x09,USB); 
08BCE:  MOVLW  09
08BD0:  MOVLB  7
08BD2:  MOVWF  x29
08BD4:  MOVLB  0
08BD6:  CALL   73FC
.................... 				fputc(addr_msb,USB); 
08BDA:  MOVFF  6E2,729
08BDE:  CALL   73FC
.................... 				fputc(addr_lsb,USB); 
08BE2:  MOVFF  6E0,729
08BE6:  CALL   73FC
....................  
.................... 				write_buffer_to_stream(&PAGE_BUFFER_A); 
08BEA:  MOVLB  7
08BEC:  CLRF   x21
08BEE:  MOVLW  7A
08BF0:  MOVWF  x20
08BF2:  MOVLW  01
08BF4:  MOVWF  x22
08BF6:  MOVLB  0
08BF8:  GOTO   79AE
....................  
.................... 				fputc(0x03,USB); 
08BFC:  MOVLW  03
08BFE:  MOVLB  7
08C00:  MOVWF  x29
08C02:  MOVLB  0
08C04:  CALL   73FC
.................... 				return; 
08C08:  MOVLB  5
08C0A:  GOTO   955A
.................... 			break; 
08C0E:  BRA    8C56
....................  
.................... 			case 0x11 : 
.................... 				 
.................... 				 
.................... 				int16 stream_size = 0; 
08C10:  MOVLB  7
08C12:  CLRF   x0B
08C14:  CLRF   x0A
.................... 		 
.................... 				//fprintf(RS232,"Stream size MSB = %x, Stream size LSB = %x\r\n",stream_size_msb,stream_size_lsb); 
.................... 				stream_size = stream_size | stream_size_msb; 
08C16:  MOVF   x08,W
08C18:  IORWF  x0A,F
.................... 				stream_size <<= 8; 
08C1A:  MOVFF  70A,70B
08C1E:  CLRF   x0A
.................... 				stream_size = stream_size | stream_size_lsb; 
08C20:  MOVF   x09,W
08C22:  IORWF  x0A,F
....................  
.................... 				/*if(data_available_usb()) { 
.................... 					fprintf(RS232,"Data still available on USB...\r\n"); 
.................... 				} else { 
.................... 					fprintf(RS232,"NO data available on USB...\r\n"); 
.................... 				} 
.................... */ 
.................... 				// initiate_stream(int target_program, int target_page, int16 num_bytes) 
.................... 				//initiate_stream(addr_msb,addr_lsb,stream_size); 
.................... 				perform_stream(addr_msb,addr_lsb,stream_size); 
08C24:  MOVFF  6E2,720
08C28:  MOVFF  6E0,721
08C2C:  MOVFF  70B,723
08C30:  MOVFF  70A,722
08C34:  MOVLB  0
08C36:  GOTO   7B66
.................... 				return; 
08C3A:  MOVLB  5
08C3C:  GOTO   955A
.................... 				 
....................  
.................... 			break; 
08C40:  BRA    8C56
....................  
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
08C42:  MOVLW  13
08C44:  MOVLB  7
08C46:  MOVWF  x20
08C48:  MOVLB  0
08C4A:  CALL   7442
.................... 				return; 
08C4E:  MOVLB  5
08C50:  GOTO   955A
.................... 			break; 
08C54:  BRA    8C56
....................  
.................... 		} 
....................  
.................... SET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
08C56:  MOVLB  0
08C58:  CALL   745E
08C5C:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
08C60:  MOVLB  5
08C62:  DECFSZ x8C,W
08C64:  BRA    8C78
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08C66:  MOVLW  10
08C68:  MOVLB  7
08C6A:  MOVWF  x20
08C6C:  MOVLB  0
08C6E:  CALL   7442
.................... 			return; 
08C72:  MOVLB  5
08C74:  GOTO   955A
.................... 		} 
....................  
.................... 		unsigned int new_value = timed_getc(); 
08C78:  MOVLB  0
08C7A:  CALL   745E
08C7E:  MOVFF  01,70C
.................... 	 
.................... 		if(timeout_error == true) { 
08C82:  MOVLB  5
08C84:  DECFSZ x8C,W
08C86:  BRA    8C9A
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08C88:  MOVLW  17
08C8A:  MOVLB  7
08C8C:  MOVWF  x20
08C8E:  MOVLB  0
08C90:  CALL   7442
.................... 			return; 
08C94:  MOVLB  5
08C96:  GOTO   955A
.................... 		} 
.................... 	 
.................... 		unsigned int new_value2; 
....................  
.................... 		if(command_char == 0x11 || command_char == 0x12) { 
08C9A:  MOVLB  6
08C9C:  MOVF   xD9,W
08C9E:  SUBLW  11
08CA0:  BZ    8CA8
08CA2:  MOVF   xD9,W
08CA4:  SUBLW  12
08CA6:  BNZ   8CCA
....................  
.................... 			// SETTING SLEEP_SECONDS OR SLEEP_HOLDTIME 
.................... 			// THESE ARE 16 BIT SO WE NEED TWO CHARS 
.................... 			 
.................... 			new_value2 = timed_getc(); 
08CA8:  MOVLB  0
08CAA:  CALL   745E
08CAE:  MOVFF  01,70D
....................  
.................... 			if(timeout_error == true) { 
08CB2:  MOVLB  5
08CB4:  DECFSZ x8C,W
08CB6:  BRA    8CCA
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 				send_error(ERR_DATA_TIMEOUT); 
08CB8:  MOVLW  17
08CBA:  MOVLB  7
08CBC:  MOVWF  x20
08CBE:  MOVLB  0
08CC0:  CALL   7442
.................... 				return; 
08CC4:  MOVLB  5
08CC6:  GOTO   955A
.................... 			} 
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08CCA:  MOVLB  0
08CCC:  CALL   745E
08CD0:  MOVFF  01,6DA
.................... 		 
.................... 		if(timeout_error == true) { 
08CD4:  MOVLB  5
08CD6:  DECFSZ x8C,W
08CD8:  BRA    8CEC
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08CDA:  MOVLW  11
08CDC:  MOVLB  7
08CDE:  MOVWF  x20
08CE0:  MOVLB  0
08CE2:  CALL   7442
.................... 			return; 
08CE6:  MOVLB  5
08CE8:  GOTO   955A
.................... 		} 
.................... 		 
.................... 		int perform_eeprom_save = 0; 
.................... 		 
.................... 		int16 lsb,msb; 
08CEC:  MOVLB  7
08CEE:  CLRF   x0E
....................  
.................... 		switch(command_char) { 
08CF0:  MOVLB  6
08CF2:  MOVF   xD9,W
08CF4:  XORLW  01
08CF6:  MOVLB  0
08CF8:  BZ    8D3E
08CFA:  XORLW  03
08CFC:  BZ    8D62
08CFE:  XORLW  01
08D00:  BZ    8D86
08D02:  XORLW  07
08D04:  BZ    8DD0
08D06:  XORLW  01
08D08:  BTFSC  FD8.2
08D0A:  BRA    8E1A
08D0C:  XORLW  03
08D0E:  BTFSC  FD8.2
08D10:  BRA    8E3E
08D12:  XORLW  01
08D14:  BTFSC  FD8.2
08D16:  BRA    8E60
08D18:  XORLW  0F
08D1A:  BTFSC  FD8.2
08D1C:  BRA    8E82
08D1E:  XORLW  01
08D20:  BTFSC  FD8.2
08D22:  BRA    8EA4
08D24:  XORLW  19
08D26:  BTFSC  FD8.2
08D28:  BRA    8EC6
08D2A:  XORLW  01
08D2C:  BTFSC  FD8.2
08D2E:  BRA    8EE8
08D30:  XORLW  03
08D32:  BTFSC  FD8.2
08D34:  BRA    8F30
08D36:  XORLW  01
08D38:  BTFSC  FD8.2
08D3A:  BRA    8F78
08D3C:  BRA    906C
....................  
.................... 			case 0x01 : 
.................... 				// SETTING AMP MODE 
.................... 				 
.................... 				if(new_value>2) { 
08D3E:  MOVLB  7
08D40:  MOVF   x0C,W
08D42:  SUBLW  02
08D44:  BC    8D58
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08D46:  MOVLW  30
08D48:  MOVWF  x20
08D4A:  MOVLB  0
08D4C:  CALL   7442
.................... 					return; 
08D50:  MOVLB  5
08D52:  GOTO   955A
08D56:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMP_MODE = new_value; 
08D58:  MOVFF  70C,33
.................... 				perform_eeprom_save = 1; 
08D5C:  MOVLW  01
08D5E:  MOVWF  x0E
.................... 			break; 
08D60:  BRA    9080
.................... 			 
.................... 			case 0x02 : 
.................... 				// SETTING 70V MODE 
.................... 				 
.................... 				if(new_value>1) { 
08D62:  MOVLB  7
08D64:  MOVF   x0C,W
08D66:  SUBLW  01
08D68:  BC    8D7C
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08D6A:  MOVLW  30
08D6C:  MOVWF  x20
08D6E:  MOVLB  0
08D70:  CALL   7442
.................... 					return; 
08D74:  MOVLB  5
08D76:  GOTO   955A
08D7A:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.IS_70V = new_value; 
08D7C:  MOVFF  70C,34
.................... 				perform_eeprom_save = 1; 
08D80:  MOVLW  01
08D82:  MOVWF  x0E
.................... 			break; 
08D84:  BRA    9080
.................... 			 
.................... 			case 0x03 : 
.................... 				// CALIBRATING ADC_MIN 
.................... 				 
.................... 				int new_min = ADC_calibrate_min(1); 
08D86:  MOVLW  01
08D88:  MOVLB  7
08D8A:  MOVWF  x20
08D8C:  MOVLB  0
08D8E:  GOTO   7CD0
08D92:  MOVFF  01,713
.................... 				fputc(0x06,USB); 
08D96:  MOVLW  06
08D98:  MOVLB  7
08D9A:  MOVWF  x29
08D9C:  MOVLB  0
08D9E:  CALL   73FC
.................... 				fputc(0x03,USB); 
08DA2:  MOVLW  03
08DA4:  MOVLB  7
08DA6:  MOVWF  x29
08DA8:  MOVLB  0
08DAA:  CALL   73FC
.................... 				fputc(new_min,USB); 
08DAE:  MOVFF  713,729
08DB2:  CALL   73FC
.................... 				fputc(0x03,USB); 
08DB6:  MOVLW  03
08DB8:  MOVLB  7
08DBA:  MOVWF  x29
08DBC:  MOVLB  0
08DBE:  CALL   73FC
.................... 				perform_eeprom_save = 0; 
08DC2:  MOVLB  7
08DC4:  CLRF   x0E
.................... 				return; 
08DC6:  MOVLB  5
08DC8:  GOTO   955A
.................... 			break; 
08DCC:  MOVLB  7
08DCE:  BRA    9080
.................... 			 
.................... 			case 0x04 : 
.................... 				// CALIBRATING ADC_MAX 
.................... 				 
.................... 				int new_max = ADC_calibrate_max(1); 
08DD0:  MOVLW  01
08DD2:  MOVLB  7
08DD4:  MOVWF  x20
08DD6:  MOVLB  0
08DD8:  GOTO   7D4C
08DDC:  MOVFF  01,714
....................  
.................... 				fputc(0x06,USB); 
08DE0:  MOVLW  06
08DE2:  MOVLB  7
08DE4:  MOVWF  x29
08DE6:  MOVLB  0
08DE8:  CALL   73FC
.................... 				fputc(0x04,USB); 
08DEC:  MOVLW  04
08DEE:  MOVLB  7
08DF0:  MOVWF  x29
08DF2:  MOVLB  0
08DF4:  CALL   73FC
.................... 				fputc(new_max,USB); 
08DF8:  MOVFF  714,729
08DFC:  CALL   73FC
.................... 				fputc(0x03,USB); 
08E00:  MOVLW  03
08E02:  MOVLB  7
08E04:  MOVWF  x29
08E06:  MOVLB  0
08E08:  CALL   73FC
.................... 				perform_eeprom_save = 0; 
08E0C:  MOVLB  7
08E0E:  CLRF   x0E
.................... 				return; 
08E10:  MOVLB  5
08E12:  GOTO   955A
.................... 			break; 
08E16:  MOVLB  7
08E18:  BRA    9080
.................... 			 
.................... 			case 0x05 : 
.................... 				// SETTING RVC_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08E1A:  MOVLB  7
08E1C:  MOVF   x0C,W
08E1E:  SUBLW  01
08E20:  BC    8E34
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08E22:  MOVLW  30
08E24:  MOVWF  x20
08E26:  MOVLB  0
08E28:  CALL   7442
.................... 					return; 
08E2C:  MOVLB  5
08E2E:  GOTO   955A
08E32:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.RVC_ENABLE = new_value; 
08E34:  MOVFF  70C,3D
.................... 				perform_eeprom_save = 1; 
08E38:  MOVLW  01
08E3A:  MOVWF  x0E
.................... 			break; 
08E3C:  BRA    9080
.................... 			 
.................... 			case 0x06 : 
.................... 				// SETTING USBDETECT_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08E3E:  MOVLB  7
08E40:  MOVF   x0C,W
08E42:  SUBLW  01
08E44:  BC    8E56
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08E46:  MOVLW  30
08E48:  MOVWF  x20
08E4A:  MOVLB  0
08E4C:  CALL   7442
.................... 					return; 
08E50:  MOVLB  5
08E52:  BRA    955A
08E54:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.USBDETECT_ENABLE = new_value; 
08E56:  MOVFF  70C,3E
.................... 				perform_eeprom_save = 1; 
08E5A:  MOVLW  01
08E5C:  MOVWF  x0E
.................... 			break; 
08E5E:  BRA    9080
.................... 			 
.................... 			case 0x07 : 
.................... 				// SETTING AMPBOOT_DELAY_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08E60:  MOVLB  7
08E62:  MOVF   x0C,W
08E64:  SUBLW  01
08E66:  BC    8E78
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08E68:  MOVLW  30
08E6A:  MOVWF  x20
08E6C:  MOVLB  0
08E6E:  CALL   7442
.................... 					return; 
08E72:  MOVLB  5
08E74:  BRA    955A
08E76:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = new_value; 
08E78:  MOVFF  70C,3F
.................... 				perform_eeprom_save = 1; 
08E7C:  MOVLW  01
08E7E:  MOVWF  x0E
.................... 			break; 
08E80:  BRA    9080
.................... 			 
.................... 			case 0x08 : 
.................... 				// SETTING PS_PIN_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08E82:  MOVLB  7
08E84:  MOVF   x0C,W
08E86:  SUBLW  01
08E88:  BC    8E9A
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08E8A:  MOVLW  30
08E8C:  MOVWF  x20
08E8E:  MOVLB  0
08E90:  CALL   7442
.................... 					return; 
08E94:  MOVLB  5
08E96:  BRA    955A
08E98:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.PS_PIN_ENABLE = new_value; 
08E9A:  MOVFF  70C,40
.................... 				perform_eeprom_save = 1; 
08E9E:  MOVLW  01
08EA0:  MOVWF  x0E
.................... 			break; 
08EA2:  BRA    9080
.................... 			 
.................... 			case 0x09 : 
.................... 				// SETTING DSP_VALUESEND_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08EA4:  MOVLB  7
08EA6:  MOVF   x0C,W
08EA8:  SUBLW  01
08EAA:  BC    8EBC
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08EAC:  MOVLW  30
08EAE:  MOVWF  x20
08EB0:  MOVLB  0
08EB2:  CALL   7442
.................... 					return; 
08EB6:  MOVLB  5
08EB8:  BRA    955A
08EBA:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.DSP_VALUESEND_ENABLE = new_value; 
08EBC:  MOVFF  70C,41
.................... 				perform_eeprom_save = 1; 
08EC0:  MOVLW  01
08EC2:  MOVWF  x0E
.................... 			break; 
08EC4:  BRA    9080
....................  
.................... 			case 0x10 : 
.................... 				// SETTING SLEEP_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08EC6:  MOVLB  7
08EC8:  MOVF   x0C,W
08ECA:  SUBLW  01
08ECC:  BC    8EDE
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08ECE:  MOVLW  30
08ED0:  MOVWF  x20
08ED2:  MOVLB  0
08ED4:  CALL   7442
.................... 					return; 
08ED8:  MOVLB  5
08EDA:  BRA    955A
08EDC:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_ENABLE = new_value; 
08EDE:  MOVFF  70C,42
.................... 				perform_eeprom_save = 1; 
08EE2:  MOVLW  01
08EE4:  MOVWF  x0E
.................... 			break; 
08EE6:  BRA    9080
....................  
.................... 			case 0x11 : 
.................... 				// SETTING SLEEP_SECONDS 
.................... 				 
.................... 				lsb = (int16)new_value; 
08EE8:  MOVLB  7
08EEA:  CLRF   x10
08EEC:  MOVFF  70C,70F
.................... 				msb = (int16)new_value2; 
08EF0:  CLRF   x12
08EF2:  MOVFF  70D,711
....................  
.................... 				int16 new_sleep_seconds = (msb<<8) | (lsb); 
08EF6:  CLRF   x20
08EF8:  MOVF   x20,W
08EFA:  IORWF  x0F,W
08EFC:  MOVWF  x15
08EFE:  MOVF   x11,W
08F00:  IORWF  x10,W
08F02:  MOVWF  x16
....................  
.................... 				if(new_sleep_seconds<DEVICE_CONFIG.SLEEP_HOLDTIME) { 
08F04:  MOVF   x16,W
08F06:  SUBWF  46,W
08F08:  BNC   8F22
08F0A:  BNZ   8F12
08F0C:  MOVF   45,W
08F0E:  SUBWF  x15,W
08F10:  BC    8F22
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08F12:  MOVLW  30
08F14:  MOVWF  x20
08F16:  MOVLB  0
08F18:  CALL   7442
.................... 					return; 
08F1C:  MOVLB  5
08F1E:  BRA    955A
08F20:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_SECONDS = new_sleep_seconds; 
08F22:  MOVFF  716,44
08F26:  MOVFF  715,43
.................... 				perform_eeprom_save = 1; 
08F2A:  MOVLW  01
08F2C:  MOVWF  x0E
.................... 			break; 
08F2E:  BRA    9080
....................  
.................... 			case 0x12 : 
.................... 				// SETTING SLEEP_HOLDTIME 
.................... 				 
.................... 				lsb = (int16)new_value; 
08F30:  MOVLB  7
08F32:  CLRF   x10
08F34:  MOVFF  70C,70F
.................... 				msb = (int16)new_value2; 
08F38:  CLRF   x12
08F3A:  MOVFF  70D,711
....................  
.................... 				int16 new_sleep_holdtime = (msb<<8) | (lsb); 
08F3E:  CLRF   x20
08F40:  MOVF   x20,W
08F42:  IORWF  x0F,W
08F44:  MOVWF  x17
08F46:  MOVF   x11,W
08F48:  IORWF  x10,W
08F4A:  MOVWF  x18
.................... 				//fprintf(RS232,"LSB: %ld, MSB: %ld, INT16 %ld\r\n",lsb, msb, new_sleep_holdtime); 
....................  
.................... 				if(new_sleep_holdtime>DEVICE_CONFIG.SLEEP_SECONDS) { 
08F4C:  MOVF   44,W
08F4E:  SUBWF  x18,W
08F50:  BNC   8F6A
08F52:  BNZ   8F5A
08F54:  MOVF   x17,W
08F56:  SUBWF  43,W
08F58:  BC    8F6A
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08F5A:  MOVLW  30
08F5C:  MOVWF  x20
08F5E:  MOVLB  0
08F60:  CALL   7442
.................... 					return; 
08F64:  MOVLB  5
08F66:  BRA    955A
08F68:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_HOLDTIME = new_sleep_holdtime; 
08F6A:  MOVFF  718,46
08F6E:  MOVFF  717,45
.................... 				perform_eeprom_save = 1; 
08F72:  MOVLW  01
08F74:  MOVWF  x0E
.................... 			break; 
08F76:  BRA    9080
....................  
.................... 			case 0x13 : 
.................... 				// SETTING SERIAL NUMBER 
.................... 			 
.................... 				finished = false; 
08F78:  MOVLB  6
08F7A:  CLRF   xC0
....................  
.................... 				for(x = 0; x < 20; x++) { 
08F7C:  CLRF   xD6
08F7E:  MOVF   xD6,W
08F80:  SUBLW  13
08F82:  BNC   8F98
.................... 					DEVICE_CONFIG.SERIAL[x] = 0xFF; 
08F84:  CLRF   03
08F86:  MOVF   xD6,W
08F88:  ADDLW  47
08F8A:  MOVWF  FE9
08F8C:  MOVLW  00
08F8E:  ADDWFC 03,W
08F90:  MOVWF  FEA
08F92:  SETF   FEF
.................... 				} 
08F94:  INCF   xD6,F
08F96:  BRA    8F7E
....................  
....................  
.................... 				int16 char_receive_count = 0; 
08F98:  MOVLB  7
08F9A:  CLRF   x1A
08F9C:  CLRF   x19
....................  
.................... 				while((char_receive_count < 20)	&& (timeout_error == false)&& (finished == false)) 
.................... 				{ 
08F9E:  MOVF   x1A,F
08FA0:  BNZ   8FF4
08FA2:  MOVF   x19,W
08FA4:  SUBLW  13
08FA6:  BNC   8FF4
08FA8:  MOVLB  5
08FAA:  MOVF   x8C,F
08FAC:  BTFSC  FD8.2
08FAE:  BRA    8FB4
08FB0:  MOVLB  7
08FB2:  BRA    8FF4
08FB4:  MOVLB  6
08FB6:  MOVF   xC0,F
08FB8:  BTFSC  FD8.2
08FBA:  BRA    8FC0
08FBC:  MOVLB  7
08FBE:  BRA    8FF4
.................... 					temp_byte = timed_getc(); 
08FC0:  MOVLB  0
08FC2:  CALL   745E
08FC6:  MOVFF  01,6C1
.................... 					//temp_byte = fgetc(USB); 
.................... 					if(temp_byte == 0x0A) { 
08FCA:  MOVLB  6
08FCC:  MOVF   xC1,W
08FCE:  SUBLW  0A
08FD0:  BNZ   8FD8
.................... 						finished = true; 
08FD2:  MOVLW  01
08FD4:  MOVWF  xC0
.................... 					} else { 
08FD6:  BRA    8FEA
.................... 						DEVICE_CONFIG.SERIAL[char_receive_count] = temp_byte;	 
08FD8:  MOVLW  47
08FDA:  MOVLB  7
08FDC:  ADDWF  x19,W
08FDE:  MOVWF  FE9
08FE0:  MOVLW  00
08FE2:  ADDWFC x1A,W
08FE4:  MOVWF  FEA
08FE6:  MOVFF  6C1,FEF
....................  
.................... 					} 
.................... 					char_receive_count++; 
08FEA:  MOVLB  7
08FEC:  INCF   x19,F
08FEE:  BTFSC  FD8.2
08FF0:  INCF   x1A,F
.................... 				 
.................... 				} 
08FF2:  BRA    8F9E
....................  
.................... 				if(!finished) { 
08FF4:  MOVLB  6
08FF6:  MOVF   xC0,F
08FF8:  BNZ   9064
.................... 					dummy_char = timed_getc(); 
08FFA:  MOVLB  0
08FFC:  CALL   745E
09000:  MOVFF  01,6DA
.................... 					 
.................... 					if(timeout_error == true) { 
09004:  MOVLB  5
09006:  DECFSZ x8C,W
09008:  BRA    9032
.................... 						// Timed out. No command. Start over. 
.................... 						fputc(0x15,USB); 
0900A:  MOVLW  15
0900C:  MOVLB  7
0900E:  MOVWF  x29
09010:  MOVLB  0
09012:  CALL   73FC
.................... 						fputc(ERR_END_TIMEOUT,USB); 
09016:  MOVLW  11
09018:  MOVLB  7
0901A:  MOVWF  x29
0901C:  MOVLB  0
0901E:  CALL   73FC
.................... 						fputc(0x03,USB); 
09022:  MOVLW  03
09024:  MOVLB  7
09026:  MOVWF  x29
09028:  MOVLB  0
0902A:  CALL   73FC
.................... 						return; 
0902E:  MOVLB  5
09030:  BRA    955A
.................... 					} 
.................... 					 
.................... 					if(dummy_char != 0x03) { 
09032:  MOVLB  6
09034:  MOVF   xDA,W
09036:  SUBLW  03
09038:  BZ    9064
.................... 						// Ending char not 0x03 
.................... 						fputc(0x15,USB); 
0903A:  MOVLW  15
0903C:  MOVLB  7
0903E:  MOVWF  x29
09040:  MOVLB  0
09042:  CALL   73FC
.................... 						fputc(0x12,USB); 
09046:  MOVLW  12
09048:  MOVLB  7
0904A:  MOVWF  x29
0904C:  MOVLB  0
0904E:  CALL   73FC
.................... 						fputc(0x03,USB); 
09052:  MOVLW  03
09054:  MOVLB  7
09056:  MOVWF  x29
09058:  MOVLB  0
0905A:  CALL   73FC
.................... 						return; 
0905E:  MOVLB  5
09060:  BRA    955A
09062:  MOVLB  6
.................... 						 
.................... 					} 
.................... 				} 
....................  
.................... 				perform_eeprom_save = 1; 
09064:  MOVLW  01
09066:  MOVLB  7
09068:  MOVWF  x0E
....................  
.................... 			break; 
0906A:  BRA    9080
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
0906C:  MOVLW  13
0906E:  MOVLB  7
09070:  MOVWF  x20
09072:  MOVLB  0
09074:  CALL   7442
.................... 				return; 
09078:  MOVLB  5
0907A:  BRA    955A
.................... 			break; 
0907C:  MOVLB  7
0907E:  BRA    9080
.................... 		} 
....................  
.................... 		if(perform_eeprom_save == 1) { 
09080:  DECFSZ x0E,W
09082:  BRA    90D6
.................... 			INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
09084:  CLRF   x23
09086:  MOVLW  33
09088:  MOVWF  x22
0908A:  CLRF   x25
0908C:  MOVLW  28
0908E:  MOVWF  x24
09090:  CLRF   x27
09092:  MOVLW  64
09094:  MOVWF  x26
09096:  MOVLB  0
09098:  CALL   642C
.................... 			delay_ms(10); 
0909C:  MOVLW  0A
0909E:  MOVLB  7
090A0:  MOVWF  x2B
090A2:  MOVLB  0
090A4:  CALL   608E
....................  
.................... 			fputc(0x06,USB); 
090A8:  MOVLW  06
090AA:  MOVLB  7
090AC:  MOVWF  x29
090AE:  MOVLB  0
090B0:  CALL   73FC
.................... 			fputc(command_char,USB); 
090B4:  MOVFF  6D9,729
090B8:  CALL   73FC
.................... 			fputc(new_value,USB); 
090BC:  MOVFF  70C,729
090C0:  CALL   73FC
.................... 			fputc(0x03,USB); 
090C4:  MOVLW  03
090C6:  MOVLB  7
090C8:  MOVWF  x29
090CA:  MOVLB  0
090CC:  CALL   73FC
....................  
.................... 			return; 
090D0:  MOVLB  5
090D2:  BRA    955A
090D4:  MOVLB  7
.................... 		} 
....................  
.................... GET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
090D6:  MOVLB  0
090D8:  CALL   745E
090DC:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
090E0:  MOVLB  5
090E2:  DECFSZ x8C,W
090E4:  BRA    90F6
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
090E6:  MOVLW  10
090E8:  MOVLB  7
090EA:  MOVWF  x20
090EC:  MOVLB  0
090EE:  CALL   7442
.................... 			return; 
090F2:  MOVLB  5
090F4:  BRA    955A
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
090F6:  MOVLB  0
090F8:  CALL   745E
090FC:  MOVFF  01,6DA
.................... 		 
.................... 		if(timeout_error == true) { 
09100:  MOVLB  5
09102:  DECFSZ x8C,W
09104:  BRA    9116
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
09106:  MOVLW  11
09108:  MOVLB  7
0910A:  MOVWF  x20
0910C:  MOVLB  0
0910E:  CALL   7442
.................... 			return; 
09112:  MOVLB  5
09114:  BRA    955A
.................... 		} 
....................  
.................... 		switch(command_char) { 
09116:  MOVLB  6
09118:  MOVF   xD9,W
0911A:  XORLW  01
0911C:  MOVLB  0
0911E:  BZ    916C
09120:  XORLW  03
09122:  BZ    919E
09124:  XORLW  01
09126:  BZ    91D0
09128:  XORLW  07
0912A:  BTFSC  FD8.2
0912C:  BRA    9226
0912E:  XORLW  01
09130:  BTFSC  FD8.2
09132:  BRA    927C
09134:  XORLW  03
09136:  BTFSC  FD8.2
09138:  BRA    92AE
0913A:  XORLW  01
0913C:  BTFSC  FD8.2
0913E:  BRA    92E0
09140:  XORLW  0F
09142:  BTFSC  FD8.2
09144:  BRA    9312
09146:  XORLW  01
09148:  BTFSC  FD8.2
0914A:  BRA    9344
0914C:  XORLW  19
0914E:  BTFSC  FD8.2
09150:  BRA    9376
09152:  XORLW  01
09154:  BTFSC  FD8.2
09156:  BRA    93A8
09158:  XORLW  03
0915A:  BTFSC  FD8.2
0915C:  BRA    93E2
0915E:  XORLW  01
09160:  BTFSC  FD8.2
09162:  BRA    941C
09164:  XORLW  07
09166:  BTFSC  FD8.2
09168:  BRA    94A0
0916A:  BRA    9522
....................  
.................... 			case 0x01 : 
.................... 				// GET AMPLIFIER MODE 
....................  
.................... 				fputc(0x06); 
0916C:  MOVLW  06
0916E:  MOVLB  7
09170:  MOVWF  x29
09172:  MOVLB  0
09174:  CALL   73FC
.................... 				fputc(0x01); 
09178:  MOVLW  01
0917A:  MOVLB  7
0917C:  MOVWF  x29
0917E:  MOVLB  0
09180:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.AMP_MODE); 
09184:  MOVFF  33,729
09188:  CALL   73FC
.................... 				fputc(0x03); 
0918C:  MOVLW  03
0918E:  MOVLB  7
09190:  MOVWF  x29
09192:  MOVLB  0
09194:  CALL   73FC
.................... 				return; 
09198:  MOVLB  5
0919A:  BRA    955A
.................... 			break; 
0919C:  BRA    9534
....................  
.................... 			case 0x02 : 
.................... 				// GET 70V MODE 
.................... 				fputc(0x06); 
0919E:  MOVLW  06
091A0:  MOVLB  7
091A2:  MOVWF  x29
091A4:  MOVLB  0
091A6:  CALL   73FC
.................... 				fputc(0x02); 
091AA:  MOVLW  02
091AC:  MOVLB  7
091AE:  MOVWF  x29
091B0:  MOVLB  0
091B2:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.IS_70V); 
091B6:  MOVFF  34,729
091BA:  CALL   73FC
.................... 				fputc(0x03); 
091BE:  MOVLW  03
091C0:  MOVLB  7
091C2:  MOVWF  x29
091C4:  MOVLB  0
091C6:  CALL   73FC
.................... 				return; 
091CA:  MOVLB  5
091CC:  BRA    955A
.................... 			break; 
091CE:  BRA    9534
....................  
.................... 			case 0x03 : 
.................... 				// GET ADC_MIN 
.................... 				fputc(0x06); 
091D0:  MOVLW  06
091D2:  MOVLB  7
091D4:  MOVWF  x29
091D6:  MOVLB  0
091D8:  CALL   73FC
.................... 				fputc(0x03); 
091DC:  MOVLW  03
091DE:  MOVLB  7
091E0:  MOVWF  x29
091E2:  MOVLB  0
091E4:  CALL   73FC
091E8:  CLRF   19
091EA:  BTFSC  FF2.7
091EC:  BSF    19.7
091EE:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
091F0:  MOVFF  38,7A3
091F4:  MOVFF  37,7A2
091F8:  MOVFF  36,7A1
091FC:  MOVFF  35,7A0
09200:  CALL   1A1C
09204:  BTFSC  19.7
09206:  BSF    FF2.7
09208:  MOVFF  01,720
0920C:  MOVFF  01,729
09210:  CALL   73FC
.................... 				fputc(0x03); 
09214:  MOVLW  03
09216:  MOVLB  7
09218:  MOVWF  x29
0921A:  MOVLB  0
0921C:  CALL   73FC
.................... 				return; 
09220:  MOVLB  5
09222:  BRA    955A
.................... 			break; 
09224:  BRA    9534
....................  
.................... 			case 0x04 : 
.................... 				// GET ADC_MAX 
.................... 				fputc(0x06); 
09226:  MOVLW  06
09228:  MOVLB  7
0922A:  MOVWF  x29
0922C:  MOVLB  0
0922E:  CALL   73FC
.................... 				fputc(0x04); 
09232:  MOVLW  04
09234:  MOVLB  7
09236:  MOVWF  x29
09238:  MOVLB  0
0923A:  CALL   73FC
0923E:  CLRF   19
09240:  BTFSC  FF2.7
09242:  BSF    19.7
09244:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
09246:  MOVFF  3C,7A3
0924A:  MOVFF  3B,7A2
0924E:  MOVFF  3A,7A1
09252:  MOVFF  39,7A0
09256:  CALL   1A1C
0925A:  BTFSC  19.7
0925C:  BSF    FF2.7
0925E:  MOVFF  01,720
09262:  MOVFF  01,729
09266:  CALL   73FC
.................... 				fputc(0x03); 
0926A:  MOVLW  03
0926C:  MOVLB  7
0926E:  MOVWF  x29
09270:  MOVLB  0
09272:  CALL   73FC
.................... 				return; 
09276:  MOVLB  5
09278:  BRA    955A
.................... 			break; 
0927A:  BRA    9534
....................  
.................... 			case 0x05 : 
.................... 				// GET RVC_ENABLE 
.................... 				fputc(0x06); 
0927C:  MOVLW  06
0927E:  MOVLB  7
09280:  MOVWF  x29
09282:  MOVLB  0
09284:  CALL   73FC
.................... 				fputc(0x05); 
09288:  MOVLW  05
0928A:  MOVLB  7
0928C:  MOVWF  x29
0928E:  MOVLB  0
09290:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.RVC_ENABLE); 
09294:  MOVFF  3D,729
09298:  CALL   73FC
.................... 				fputc(0x03); 
0929C:  MOVLW  03
0929E:  MOVLB  7
092A0:  MOVWF  x29
092A2:  MOVLB  0
092A4:  CALL   73FC
.................... 				return; 
092A8:  MOVLB  5
092AA:  BRA    955A
.................... 			break; 
092AC:  BRA    9534
....................  
.................... 			case 0x06 : 
.................... 				// GET USBDETECT 
.................... 				fputc(0x06); 
092AE:  MOVLW  06
092B0:  MOVLB  7
092B2:  MOVWF  x29
092B4:  MOVLB  0
092B6:  CALL   73FC
.................... 				fputc(0x06); 
092BA:  MOVLW  06
092BC:  MOVLB  7
092BE:  MOVWF  x29
092C0:  MOVLB  0
092C2:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.USBDETECT_ENABLE); 
092C6:  MOVFF  3E,729
092CA:  CALL   73FC
.................... 				fputc(0x03); 
092CE:  MOVLW  03
092D0:  MOVLB  7
092D2:  MOVWF  x29
092D4:  MOVLB  0
092D6:  CALL   73FC
.................... 				return; 
092DA:  MOVLB  5
092DC:  BRA    955A
.................... 			break; 
092DE:  BRA    9534
....................  
.................... 			case 0x07 : 
.................... 				// GET AMPBOOT 
.................... 				fputc(0x06); 
092E0:  MOVLW  06
092E2:  MOVLB  7
092E4:  MOVWF  x29
092E6:  MOVLB  0
092E8:  CALL   73FC
.................... 				fputc(0x07); 
092EC:  MOVLW  07
092EE:  MOVLB  7
092F0:  MOVWF  x29
092F2:  MOVLB  0
092F4:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
092F8:  MOVFF  3F,729
092FC:  CALL   73FC
.................... 				fputc(0x03); 
09300:  MOVLW  03
09302:  MOVLB  7
09304:  MOVWF  x29
09306:  MOVLB  0
09308:  CALL   73FC
.................... 				return; 
0930C:  MOVLB  5
0930E:  BRA    955A
.................... 			break; 
09310:  BRA    9534
.................... 	 
.................... 			case 0x08 : 
.................... 				// GET PS_PIN 
.................... 				fputc(0x06); 
09312:  MOVLW  06
09314:  MOVLB  7
09316:  MOVWF  x29
09318:  MOVLB  0
0931A:  CALL   73FC
.................... 				fputc(0x08); 
0931E:  MOVLW  08
09320:  MOVLB  7
09322:  MOVWF  x29
09324:  MOVLB  0
09326:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.PS_PIN_ENABLE); 
0932A:  MOVFF  40,729
0932E:  CALL   73FC
.................... 				fputc(0x03); 
09332:  MOVLW  03
09334:  MOVLB  7
09336:  MOVWF  x29
09338:  MOVLB  0
0933A:  CALL   73FC
.................... 				return; 
0933E:  MOVLB  5
09340:  BRA    955A
.................... 			break; 
09342:  BRA    9534
....................  
.................... 			case 0x09 : 
.................... 				// DSP_VALUESEND 
.................... 				fputc(0x06); 
09344:  MOVLW  06
09346:  MOVLB  7
09348:  MOVWF  x29
0934A:  MOVLB  0
0934C:  CALL   73FC
.................... 				fputc(0x09); 
09350:  MOVLW  09
09352:  MOVLB  7
09354:  MOVWF  x29
09356:  MOVLB  0
09358:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
0935C:  MOVFF  41,729
09360:  CALL   73FC
.................... 				fputc(0x03); 
09364:  MOVLW  03
09366:  MOVLB  7
09368:  MOVWF  x29
0936A:  MOVLB  0
0936C:  CALL   73FC
.................... 				return; 
09370:  MOVLB  5
09372:  BRA    955A
.................... 			break; 
09374:  BRA    9534
....................  
.................... 			case 0x10 : 
.................... 				// SLEEP_ENABLE 
.................... 				fputc(0x06); 
09376:  MOVLW  06
09378:  MOVLB  7
0937A:  MOVWF  x29
0937C:  MOVLB  0
0937E:  CALL   73FC
.................... 				fputc(0x10); 
09382:  MOVLW  10
09384:  MOVLB  7
09386:  MOVWF  x29
09388:  MOVLB  0
0938A:  CALL   73FC
.................... 				fputc(DEVICE_CONFIG.SLEEP_ENABLE); 
0938E:  MOVFF  42,729
09392:  CALL   73FC
.................... 				fputc(0x03); 
09396:  MOVLW  03
09398:  MOVLB  7
0939A:  MOVWF  x29
0939C:  MOVLB  0
0939E:  CALL   73FC
.................... 				return; 
093A2:  MOVLB  5
093A4:  BRA    955A
.................... 			break; 
093A6:  BRA    9534
....................  
.................... 			case 0x11 : 
.................... 				// SLEEP_SECONDS 
.................... 				fputc(0x06); 
093A8:  MOVLW  06
093AA:  MOVLB  7
093AC:  MOVWF  x29
093AE:  MOVLB  0
093B0:  CALL   73FC
.................... 				fputc(0x11); 
093B4:  MOVLW  11
093B6:  MOVLB  7
093B8:  MOVWF  x29
093BA:  MOVLB  0
093BC:  CALL   73FC
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_SECONDS); 
093C0:  MOVLW  10
093C2:  MOVWF  FE9
093C4:  MOVFF  44,721
093C8:  MOVFF  43,720
093CC:  CALL   7DC8
.................... 				fputc(0x0A); 
093D0:  MOVLW  0A
093D2:  MOVLB  7
093D4:  MOVWF  x29
093D6:  MOVLB  0
093D8:  CALL   73FC
.................... 				return; 
093DC:  MOVLB  5
093DE:  BRA    955A
.................... 			break; 
093E0:  BRA    9534
....................  
.................... 			case 0x12 : 
.................... 				// SLEEP_HOLDTIME 
.................... 				fputc(0x06); 
093E2:  MOVLW  06
093E4:  MOVLB  7
093E6:  MOVWF  x29
093E8:  MOVLB  0
093EA:  CALL   73FC
.................... 				fputc(0x12); 
093EE:  MOVLW  12
093F0:  MOVLB  7
093F2:  MOVWF  x29
093F4:  MOVLB  0
093F6:  CALL   73FC
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_HOLDTIME); 
093FA:  MOVLW  10
093FC:  MOVWF  FE9
093FE:  MOVFF  46,721
09402:  MOVFF  45,720
09406:  CALL   7DC8
.................... 				fputc(0x03); 
0940A:  MOVLW  03
0940C:  MOVLB  7
0940E:  MOVWF  x29
09410:  MOVLB  0
09412:  CALL   73FC
.................... 				return; 
09416:  MOVLB  5
09418:  BRA    955A
.................... 			break; 
0941A:  BRA    9534
.................... 	 
.................... 			case 0x13 : 
.................... 				// SERIAL NUMBER 
.................... 				memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
0941C:  MOVLW  06
0941E:  MOVWF  FEA
09420:  MOVLW  C2
09422:  MOVWF  FE9
09424:  CLRF   FE2
09426:  MOVLW  47
09428:  MOVWF  FE1
0942A:  MOVLW  14
0942C:  MOVWF  01
0942E:  MOVFF  FE6,FEE
09432:  DECFSZ 01,F
09434:  BRA    942E
....................  
.................... 				fputc(0x06); 
09436:  MOVLW  06
09438:  MOVLB  7
0943A:  MOVWF  x29
0943C:  MOVLB  0
0943E:  CALL   73FC
.................... 				fputc(0x13); 
09442:  MOVLW  13
09444:  MOVLB  7
09446:  MOVWF  x29
09448:  MOVLB  0
0944A:  CALL   73FC
....................  
.................... 				for(y = 0; y < 20; y++) { 
0944E:  MOVLB  6
09450:  CLRF   xD7
09452:  MOVF   xD7,W
09454:  SUBLW  13
09456:  BNC   948E
.................... 					if(name_buffer[y] == 0xFF) { 
09458:  CLRF   03
0945A:  MOVF   xD7,W
0945C:  ADDLW  C2
0945E:  MOVWF  FE9
09460:  MOVLW  06
09462:  ADDWFC 03,W
09464:  MOVWF  FEA
09466:  INCFSZ FEF,W
09468:  BRA    946C
.................... 						break; 
0946A:  BRA    948E
.................... 					} 
.................... 			 
.................... 					fputc(name_buffer[y],USB); 
0946C:  CLRF   03
0946E:  MOVF   xD7,W
09470:  ADDLW  C2
09472:  MOVWF  FE9
09474:  MOVLW  06
09476:  ADDWFC 03,W
09478:  MOVWF  FEA
0947A:  MOVFF  FEF,720
0947E:  MOVFF  720,729
09482:  MOVLB  0
09484:  CALL   73FC
.................... 				} 
09488:  MOVLB  6
0948A:  INCF   xD7,F
0948C:  BRA    9452
....................  
.................... 				fputc(0x03); 
0948E:  MOVLW  03
09490:  MOVLB  7
09492:  MOVWF  x29
09494:  MOVLB  0
09496:  CALL   73FC
.................... 				return; 
0949A:  MOVLB  5
0949C:  BRA    955A
.................... 			break; 
0949E:  BRA    9534
....................  
.................... 			case 0x14 : 
.................... 				// GET CURRENT RVC 
....................  
.................... 				int current_adc = read_adc(); 
....................  
.................... 				double percentage = RVC_to_decibel(current_adc); 
094A0:  BSF    FC2.1
094A2:  BTFSC  FC2.1
094A4:  BRA    94A2
094A6:  MOVFF  FC4,71B
094AA:  MOVFF  71B,720
094AE:  MOVLB  0
094B0:  GOTO   7EBE
094B4:  MOVFF  03,71F
094B8:  MOVFF  02,71E
094BC:  MOVFF  01,71D
094C0:  MOVFF  00,71C
....................  
.................... 				fputc(0x16); 
094C4:  MOVLW  16
094C6:  MOVLB  7
094C8:  MOVWF  x29
094CA:  MOVLB  0
094CC:  CALL   73FC
.................... 				fputc(0x14); 
094D0:  MOVLW  14
094D2:  MOVLB  7
094D4:  MOVWF  x29
094D6:  MOVLB  0
094D8:  CALL   73FC
.................... 				fputc(current_adc); 
094DC:  MOVFF  71B,729
094E0:  CALL   73FC
094E4:  CLRF   19
094E6:  BTFSC  FF2.7
094E8:  BSF    19.7
094EA:  BCF    FF2.7
.................... 				fputc((int)percentage); 
094EC:  MOVFF  71F,7A3
094F0:  MOVFF  71E,7A2
094F4:  MOVFF  71D,7A1
094F8:  MOVFF  71C,7A0
094FC:  CALL   1A1C
09500:  BTFSC  19.7
09502:  BSF    FF2.7
09504:  MOVFF  01,720
09508:  MOVFF  01,729
0950C:  CALL   73FC
.................... 				fputc(0x03); 
09510:  MOVLW  03
09512:  MOVLB  7
09514:  MOVWF  x29
09516:  MOVLB  0
09518:  CALL   73FC
.................... 				return; 
0951C:  MOVLB  5
0951E:  BRA    955A
.................... 			break; 
09520:  BRA    9534
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
09522:  MOVLW  13
09524:  MOVLB  7
09526:  MOVWF  x20
09528:  MOVLB  0
0952A:  CALL   7442
.................... 				return; 
0952E:  MOVLB  5
09530:  BRA    955A
.................... 			break; 
09532:  BRA    9534
.................... 		} 
....................  
.................... 	// How did we get here? Should be impossible.. Let's send an error though... 
.................... 	// Someone probably forgot a return statement above... D'oh! 
....................  
....................  
.................... 	fputc(0x15,USB); 
09534:  MOVLW  15
09536:  MOVLB  7
09538:  MOVWF  x29
0953A:  MOVLB  0
0953C:  CALL   73FC
.................... 	fputc(ERR_UNKNOWN,USB); 
09540:  MOVLW  09
09542:  MOVLB  7
09544:  MOVWF  x29
09546:  MOVLB  0
09548:  CALL   73FC
.................... 	fputc(0x03,USB); 
0954C:  MOVLW  03
0954E:  MOVLB  7
09550:  MOVWF  x29
09552:  MOVLB  0
09554:  CALL   73FC
09558:  MOVLB  5
.................... 	return; 
.................... } 
0955A:  MOVLB  0
0955C:  GOTO   9676 (RETURN)
....................  
....................  
.................... #include <interrupts.c> 
.................... void disable_all_timers() 
.................... { 
.................... 	clear_interrupt(INT_TIMER0); 
*
02F80:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02F82:  BCF    F9E.0
.................... 	SETUP_TIMER_0(RTCC_OFF); 
02F84:  CLRF   FD5
.................... 	setup_timer_1(T1_DISABLED); 
02F86:  CLRF   FCD
02F88:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
02F8A:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02F8C:  BCF    F9E.0
.................... } 
02F8E:  GOTO   3030 (RETURN)
....................  
.................... void enable_all_timers() 
.................... { 
....................  
.................... 	clear_interrupt(INT_TIMER0); 
*
02FFE:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
03000:  BCF    F9E.0
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
03002:  MOVLW  85
03004:  MOVWF  FD5
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
03006:  MOVLW  37
03008:  MOVWF  FCD
0300A:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
0300C:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
0300E:  BCF    F9E.0
....................  
.................... 	setup_interrupts(); 
03010:  RCALL  2F92
....................  
.................... } 
03012:  GOTO   3038 (RETURN)
....................  
.................... // SLEEP TIMER is every 1 seconds 
.................... #INT_TIMER0 
.................... void SLEEPTIMER_ISR(void)  
.................... { 
....................  
.................... 	sleepseconds++; 
*
012F8:  MOVLB  1
012FA:  INCF   x7E,F
012FC:  BTFSC  FD8.2
012FE:  INCF   x7F,F
....................  
.................... 	if(sleepseconds >= sleeptimeout_seconds) { 
01300:  MOVF   x81,W
01302:  SUBWF  x7F,W
01304:  BNC   131C
01306:  BNZ   130E
01308:  MOVF   x80,W
0130A:  SUBWF  x7E,W
0130C:  BNC   131C
.................... 		sleepseconds = 0; 
0130E:  CLRF   x7F
01310:  CLRF   x7E
.................... 		// TIMEOUT ROUTINE HERE 
.................... 		is_in_sleep = 1; 
01312:  MOVLW  01
01314:  MOVWF  x82
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, AMPLIFIER NOW IN SLEEP MODE\r\n",sleeptimeout_seconds); 
.................... 		} 
....................  
.................... 		disable_interrupts(INT_TIMER0); 
01316:  BCF    FF2.5
.................... 		clear_interrupt(INT_TIMER0); 
01318:  BCF    FF2.2
.................... 		return; 
0131A:  BRA    1324
.................... 	} 
....................  
.................... 	set_timer0(7936); 
0131C:  MOVLW  1F
0131E:  MOVWF  FD7
01320:  CLRF   FD6
.................... 	clear_interrupt(INT_TIMER0); 
01322:  BCF    FF2.2
.................... } 
....................  
.................... // REMOTE VOLUME CONTROL 
01324:  BCF    FF2.2
01326:  MOVLB  0
01328:  GOTO   0884
.................... #INT_TIMER1  
.................... void RVCTIMER_ISR(void)  
.................... { 
....................  
.................... 	pin_in_mute_state = !input(PIN_AMP_nMUTE); 
*
02B86:  BSF    F94.1
02B88:  MOVLB  1
02B8A:  CLRF   x7D
02B8C:  BTFSS  F82.1
02B8E:  INCF   x7D,F
.................... 	 
.................... 	set_adc_channel(0); 
02B90:  MOVLW  00
02B92:  MOVWF  01
02B94:  MOVF   FC2,W
02B96:  ANDLW  83
02B98:  IORWF  01,W
02B9A:  MOVWF  FC2
.................... 	delay_us(10); 
02B9C:  MOVLW  0B
02B9E:  MOVWF  00
02BA0:  DECFSZ 00,F
02BA2:  BRA    2BA0
02BA4:  BRA    2BA6
.................... 	current_adc = read_adc(); 
02BA6:  BSF    FC2.1
02BA8:  BTFSC  FC2.1
02BAA:  BRA    2BA8
02BAC:  MOVFF  FC4,17B
.................... 	 
.................... 	if(pin_in_mute_state && is_muted) { 
02BB0:  MOVF   x7D,F
02BB2:  BZ    2BC2
02BB4:  MOVF   x7C,F
02BB6:  BZ    2BC2
.................... 		// Do nothing 
.................... 		set_timer1(15550); 
02BB8:  MOVLW  3C
02BBA:  MOVWF  FCF
02BBC:  MOVLW  BE
02BBE:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02BC0:  BCF    F9E.0
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(pin_in_mute_state && !is_muted) { 
02BC2:  MOVF   x7D,F
02BC4:  BZ    2C48
02BC6:  MOVF   x7C,F
02BC8:  BNZ   2C48
.................... 		is_muted = true; 
02BCA:  MOVLW  01
02BCC:  MOVWF  x7C
.................... 		send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
02BCE:  MOVLW  83
02BD0:  MOVLB  7
02BD2:  MOVWF  x76
02BD4:  CLRF   x75
02BD6:  CLRF   x74
02BD8:  MOVLW  0A
02BDA:  MOVWF  x73
02BDC:  CLRF   x7A
02BDE:  CLRF   x79
02BE0:  CLRF   x78
02BE2:  CLRF   x77
02BE4:  MOVLB  0
02BE6:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
02BEA:  MOVLW  83
02BEC:  MOVLB  7
02BEE:  MOVWF  x76
02BF0:  CLRF   x75
02BF2:  CLRF   x74
02BF4:  MOVLW  0B
02BF6:  MOVWF  x73
02BF8:  CLRF   x7A
02BFA:  CLRF   x79
02BFC:  CLRF   x78
02BFE:  CLRF   x77
02C00:  MOVLB  0
02C02:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
02C06:  MOVLW  83
02C08:  MOVLB  7
02C0A:  MOVWF  x76
02C0C:  CLRF   x75
02C0E:  CLRF   x74
02C10:  MOVLW  0C
02C12:  MOVWF  x73
02C14:  CLRF   x7A
02C16:  CLRF   x79
02C18:  CLRF   x78
02C1A:  CLRF   x77
02C1C:  MOVLB  0
02C1E:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
02C22:  MOVLW  83
02C24:  MOVLB  7
02C26:  MOVWF  x76
02C28:  CLRF   x75
02C2A:  CLRF   x74
02C2C:  MOVLW  0D
02C2E:  MOVWF  x73
02C30:  CLRF   x7A
02C32:  CLRF   x79
02C34:  CLRF   x78
02C36:  CLRF   x77
02C38:  MOVLB  0
02C3A:  CALL   142C
.................... 		set_timer1(15550); 
02C3E:  MOVLW  3C
02C40:  MOVWF  FCF
02C42:  MOVLW  BE
02C44:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02C46:  BCF    F9E.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Mute pin brought low. Muting\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	unsigned int difference = 0; 
02C48:  MOVLB  7
02C4A:  CLRF   x6A
....................  
.................... 	if(current_adc > last_adc) { 
02C4C:  MOVLB  1
02C4E:  MOVF   x7B,W
02C50:  SUBWF  x7A,W
02C52:  BC    2C60
.................... 		difference = current_adc - last_adc; 
02C54:  MOVF   x7A,W
02C56:  SUBWF  x7B,W
02C58:  MOVLB  7
02C5A:  MOVWF  x6A
.................... 	} else { 
02C5C:  BRA    2C68
02C5E:  MOVLB  1
.................... 		difference = last_adc - current_adc; 
02C60:  MOVF   x7B,W
02C62:  SUBWF  x7A,W
02C64:  MOVLB  7
02C66:  MOVWF  x6A
.................... 	} 
....................  
.................... 	if((!pin_in_mute_state && is_muted) || (difference > RVC_NOISE_FLOOR)) { 
02C68:  MOVLB  1
02C6A:  MOVF   x7D,F
02C6C:  BNZ   2C72
02C6E:  MOVF   x7C,F
02C70:  BNZ   2C7E
02C72:  MOVLB  7
02C74:  MOVF   x6A,W
02C76:  SUBWF  1E,W
02C78:  BTFSC  FD8.0
02C7A:  BRA    2E60
02C7C:  MOVLB  1
....................  
.................... 		 
.................... 		double dsp_value = RVC_to_dsp_value(current_adc); 
02C7E:  MOVFF  17B,76F
02C82:  MOVLB  0
02C84:  RCALL  2A2A
02C86:  MOVFF  03,76E
02C8A:  MOVFF  02,76D
02C8E:  MOVFF  01,76C
02C92:  MOVFF  00,76B
....................  
.................... 		 
.................... 		if(current_adc < 30) { 
02C96:  MOVLB  1
02C98:  MOVF   x7B,W
02C9A:  SUBLW  1D
02C9C:  BNC   2CAC
.................... 			dsp_value = 0; 
02C9E:  MOVLB  7
02CA0:  CLRF   x6E
02CA2:  CLRF   x6D
02CA4:  CLRF   x6C
02CA6:  CLRF   x6B
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = 0.0000\r\n",current_adc); 
.................... 			}	 
.................... 		} else { 
02CA8:  BRA    2CAA
02CAA:  MOVLB  1
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		//double percentage = ADC_to_percentage(current_adc); 
.................... 		send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
02CAC:  MOVFF  76E,7A3
02CB0:  MOVFF  76D,7A2
02CB4:  MOVFF  76C,7A1
02CB8:  MOVFF  76B,7A0
02CBC:  MOVLB  7
02CBE:  CLRF   xA7
02CC0:  CLRF   xA6
02CC2:  CLRF   xA5
02CC4:  MOVLW  9E
02CC6:  MOVWF  xA4
02CC8:  MOVLB  0
02CCA:  CALL   18AC
02CCE:  MOVFF  03,772
02CD2:  MOVFF  02,771
02CD6:  MOVFF  01,770
02CDA:  MOVFF  00,76F
02CDE:  RCALL  2B44
02CE0:  MOVFF  03,772
02CE4:  MOVFF  02,771
02CE8:  MOVFF  01,770
02CEC:  MOVFF  00,76F
02CF0:  MOVLW  83
02CF2:  MOVLB  7
02CF4:  MOVWF  x76
02CF6:  CLRF   x75
02CF8:  CLRF   x74
02CFA:  MOVLW  0A
02CFC:  MOVWF  x73
02CFE:  MOVFF  03,77A
02D02:  MOVFF  02,779
02D06:  MOVFF  01,778
02D0A:  MOVFF  00,777
02D0E:  MOVLB  0
02D10:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
02D14:  MOVFF  76E,7A3
02D18:  MOVFF  76D,7A2
02D1C:  MOVFF  76C,7A1
02D20:  MOVFF  76B,7A0
02D24:  MOVLB  7
02D26:  CLRF   xA7
02D28:  CLRF   xA6
02D2A:  CLRF   xA5
02D2C:  MOVLW  9E
02D2E:  MOVWF  xA4
02D30:  MOVLB  0
02D32:  CALL   18AC
02D36:  MOVFF  03,772
02D3A:  MOVFF  02,771
02D3E:  MOVFF  01,770
02D42:  MOVFF  00,76F
02D46:  RCALL  2B44
02D48:  MOVFF  03,772
02D4C:  MOVFF  02,771
02D50:  MOVFF  01,770
02D54:  MOVFF  00,76F
02D58:  MOVLW  83
02D5A:  MOVLB  7
02D5C:  MOVWF  x76
02D5E:  CLRF   x75
02D60:  CLRF   x74
02D62:  MOVLW  0B
02D64:  MOVWF  x73
02D66:  MOVFF  03,77A
02D6A:  MOVFF  02,779
02D6E:  MOVFF  01,778
02D72:  MOVFF  00,777
02D76:  MOVLB  0
02D78:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
02D7C:  MOVFF  76E,7A3
02D80:  MOVFF  76D,7A2
02D84:  MOVFF  76C,7A1
02D88:  MOVFF  76B,7A0
02D8C:  MOVLB  7
02D8E:  CLRF   xA7
02D90:  CLRF   xA6
02D92:  CLRF   xA5
02D94:  MOVLW  9E
02D96:  MOVWF  xA4
02D98:  MOVLB  0
02D9A:  CALL   18AC
02D9E:  MOVFF  03,772
02DA2:  MOVFF  02,771
02DA6:  MOVFF  01,770
02DAA:  MOVFF  00,76F
02DAE:  RCALL  2B44
02DB0:  MOVFF  03,772
02DB4:  MOVFF  02,771
02DB8:  MOVFF  01,770
02DBC:  MOVFF  00,76F
02DC0:  MOVLW  83
02DC2:  MOVLB  7
02DC4:  MOVWF  x76
02DC6:  CLRF   x75
02DC8:  CLRF   x74
02DCA:  MOVLW  0C
02DCC:  MOVWF  x73
02DCE:  MOVFF  03,77A
02DD2:  MOVFF  02,779
02DD6:  MOVFF  01,778
02DDA:  MOVFF  00,777
02DDE:  MOVLB  0
02DE0:  CALL   142C
.................... 		send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
02DE4:  MOVFF  76E,7A3
02DE8:  MOVFF  76D,7A2
02DEC:  MOVFF  76C,7A1
02DF0:  MOVFF  76B,7A0
02DF4:  MOVLB  7
02DF6:  CLRF   xA7
02DF8:  CLRF   xA6
02DFA:  CLRF   xA5
02DFC:  MOVLW  9E
02DFE:  MOVWF  xA4
02E00:  MOVLB  0
02E02:  CALL   18AC
02E06:  MOVFF  03,772
02E0A:  MOVFF  02,771
02E0E:  MOVFF  01,770
02E12:  MOVFF  00,76F
02E16:  RCALL  2B44
02E18:  MOVFF  03,772
02E1C:  MOVFF  02,771
02E20:  MOVFF  01,770
02E24:  MOVFF  00,76F
02E28:  MOVLW  83
02E2A:  MOVLB  7
02E2C:  MOVWF  x76
02E2E:  CLRF   x75
02E30:  CLRF   x74
02E32:  MOVLW  0D
02E34:  MOVWF  x73
02E36:  MOVFF  03,77A
02E3A:  MOVFF  02,779
02E3E:  MOVFF  01,778
02E42:  MOVFF  00,777
02E46:  MOVLB  0
02E48:  CALL   142C
....................  
.................... 		is_muted = 0; 
02E4C:  MOVLB  1
02E4E:  CLRF   x7C
.................... 		last_adc = current_adc; 
02E50:  MOVFF  17B,17A
.................... 		set_timer1(15550); 
02E54:  MOVLW  3C
02E56:  MOVWF  FCF
02E58:  MOVLW  BE
02E5A:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02E5C:  BCF    F9E.0
02E5E:  MOVLB  7
.................... 	}   
.................... } 
....................  
.................... // AUDIO DETECT FOR SLEEP MODE 
02E60:  BCF    F9E.0
02E62:  MOVLB  0
02E64:  GOTO   0884
.................... #INT_EXT 
.................... void AUDIODETECT_ISR(void)  
.................... {  
....................    	disable_interrupts (INT_EXT); 
*
02ECE:  BCF    FF2.4
....................  
.................... 	clear_interrupt(INT_EXT); 
02ED0:  BCF    FF2.1
.................... 	 
....................  
.................... 	if(input(PIN_B0)) { 
02ED2:  BSF    F93.0
02ED4:  BTFSS  F81.0
02ED6:  BRA    2EEC
....................  
.................... 		// Audio is now present 
.................... 		//if(is_in_sleep) { 
.................... 			is_in_sleep = 0; 
02ED8:  MOVLB  1
02EDA:  CLRF   x82
.................... 			sleep_timer_active = 0; 
02EDC:  CLRF   x83
.................... 			clear_interrupt(INT_TIMER0); 
02EDE:  BCF    FF2.2
.................... 			disable_interrupts(INT_TIMER0); 
02EE0:  BCF    FF2.5
.................... 			 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] AUDIO DETECTED. NO LONGER IN SLEEP MODE\r\n"); 
.................... 			} 
....................  
.................... 			// Now wait for it to go low again... 
....................  
.................... 			 
.................... 		//} 
....................  
.................... 			ext_int_edge(0,H_TO_L);  
02EE2:  BCF    FF1.6
.................... 			 
.................... 			enable_interrupts (INT_EXT); 
02EE4:  BSF    FF2.4
.................... 			return; 
02EE6:  BRA    2F0C
.................... 	} else { 
02EE8:  BRA    2F0C
02EEA:  MOVLB  0
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, STARTING SLEEP TIMER\r\n",AUDIODETECT_HOLDTIME_SECONDS); 
.................... 		} 
.................... 		// Audio not detected for 1 minute.. start timer 
.................... 		clear_interrupt(INT_TIMER0); 
02EEC:  BCF    FF2.2
....................  
.................... 		sleepseconds = AUDIODETECT_HOLDTIME_SECONDS; 
02EEE:  MOVFF  1D,17F
02EF2:  MOVFF  1C,17E
.................... 		set_timer0(7936); 
02EF6:  MOVLW  1F
02EF8:  MOVWF  FD7
02EFA:  CLRF   FD6
.................... 		enable_interrupts(INT_TIMER0); 
02EFC:  BSF    FF2.5
.................... 		sleep_timer_active = 1; 
02EFE:  MOVLW  01
02F00:  MOVLB  1
02F02:  MOVWF  x83
.................... 		is_in_sleep = 0; 
02F04:  CLRF   x82
....................  
.................... 		ext_int_edge(0,L_TO_H);  
02F06:  BSF    FF1.6
.................... 		enable_interrupts (INT_EXT); 
02F08:  BSF    FF2.4
.................... 		return; 
02F0A:  BRA    2F0C
.................... 	} 
.................... } 
....................  
.................... // USB DETECTION 
02F0C:  BCF    FF2.1
02F0E:  MOVLB  0
02F10:  GOTO   0884
.................... #INT_EXT1  
.................... void USBDETECT_ISR(void)  
.................... {  
....................  
....................    	disable_interrupts (INT_EXT1); 
*
03016:  BCF    FF0.3
....................  
.................... 	delay_us(100); 
03018:  MOVLW  7A
0301A:  MOVWF  00
0301C:  DECFSZ 00,F
0301E:  BRA    301C
03020:  NOP   
....................  
.................... 	if(input(PIN_B1)) { 
03022:  BSF    F93.1
03024:  BTFSS  F81.1
03026:  BRA    3032
.................... 		IS_USB_CONNECTED = true; 
03028:  MOVLW  01
0302A:  MOVWF  x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is high. USB CONNECT EVENT. Triggering on H_TO_L.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,H_TO_L);  
0302C:  BCF    FF1.5
....................  
.................... 		disable_all_timers(); 
0302E:  BRA    2F80
....................  
.................... 	} else { 
03030:  BRA    3038
.................... 		IS_USB_CONNECTED = false; 
03032:  CLRF   x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is low. USB DISCONNECT EVENT. Triggering on L_TO_H.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,L_TO_H);  
03034:  BSF    FF1.5
....................  
.................... 		enable_all_timers(); 
03036:  BRA    2FFE
.................... 	} 
.................... 	 
.................... 	enable_interrupts(INT_EXT1); 
03038:  BSF    FF0.3
.................... 	clear_interrupt(INT_EXT1); 
0303A:  BCF    FF0.0
.................... }  
....................  
....................  
0303C:  BCF    FF0.0
0303E:  GOTO   0884
.................... void main() 
.................... { 
*
09560:  CLRF   FF8
09562:  BCF    FD0.7
09564:  BSF    07.7
09566:  CLRF   FEA
09568:  CLRF   FE9
0956A:  MOVLW  01
0956C:  MOVWF  1B
0956E:  MOVLW  DE
09570:  MOVWF  1A
09572:  CLRF   1D
09574:  MOVLW  02
09576:  MOVWF  1C
09578:  CLRF   1E
0957A:  CLRF   22
0957C:  CLRF   21
0957E:  MOVLW  70
09580:  MOVWF  20
09582:  MOVLW  83
09584:  MOVWF  1F
09586:  CLRF   26
09588:  CLRF   25
0958A:  MOVLW  70
0958C:  MOVWF  24
0958E:  MOVLW  86
09590:  MOVWF  23
09592:  MOVLW  01
09594:  MOVWF  27
09596:  MOVWF  28
09598:  MOVWF  29
0959A:  MOVWF  2A
0959C:  MOVWF  2B
0959E:  CLRF   2C
095A0:  MOVWF  2D
095A2:  CLRF   2E
095A4:  CLRF   30
095A6:  MOVLW  41
095A8:  MOVWF  2F
095AA:  CLRF   32
095AC:  MOVLW  3C
095AE:  MOVWF  31
095B0:  MOVLW  01
095B2:  MOVWF  x61
095B4:  CLRF   x62
095B6:  BCF    F94.5
095B8:  BSF    F8B.5
095BA:  CLRF   x77
095BC:  BCF    F70.3
095BE:  MOVLW  17
095C0:  MOVWF  F75
095C2:  MOVLW  A2
095C4:  MOVWF  F72
095C6:  MOVLW  90
095C8:  MOVWF  F71
095CA:  BSF    F95.1
095CC:  BCF    F95.4
095CE:  BCF    F95.0
095D0:  BCF    F8C.0
095D2:  CLRF   x79
095D4:  MOVLB  1
095D6:  CLRF   x7A
095D8:  CLRF   x7B
095DA:  CLRF   x7C
095DC:  CLRF   x7D
095DE:  CLRF   x81
095E0:  MOVLW  0A
095E2:  MOVWF  x80
095E4:  CLRF   x82
095E6:  CLRF   x83
095E8:  MOVLB  6
095EA:  CLRF   xAE
095EC:  CLRF   xAD
095EE:  CLRF   xB0
095F0:  CLRF   xAF
095F2:  CLRF   xB2
095F4:  CLRF   xB1
095F6:  CLRF   xB3
095F8:  CLRF   xB4
095FA:  BCF    xB5.0
095FC:  CLRF   xB7
095FE:  CLRF   xB6
09600:  CLRF   xB8
09602:  CLRF   xB9
09604:  CLRF   xBA
09606:  MOVLB  1
09608:  CLRF   x88
0960A:  MOVF   FC1,W
0960C:  ANDLW  F0
0960E:  MOVWF  FC1
09610:  MOVLW  00
09612:  MOVLB  F
09614:  MOVWF  x38
09616:  MOVWF  x3C
09618:  MOVWF  x39
0961A:  MOVWF  x3A
0961C:  MOVWF  x3B
0961E:  CLRF   F77
09620:  CLRF   F78
09622:  CLRF   F79
09624:  CLRF   5B
09626:  CLRF   5C
09628:  MOVLW  2D
0962A:  MOVLB  0
0962C:  MOVWF  x63
0962E:  MOVLW  44
09630:  MOVWF  x64
09632:  MOVLW  53
09634:  MOVWF  x65
09636:  MOVLW  50
09638:  MOVWF  x66
0963A:  MOVLW  31
0963C:  MOVWF  x67
0963E:  MOVLW  30
09640:  MOVWF  x68
09642:  MOVWF  x69
09644:  MOVLW  2D
09646:  MOVWF  x6A
09648:  MOVLW  31
0964A:  MOVWF  x6B
0964C:  CLRF   x6C
.................... 	// Setup ADC's and Timers 
.................... 	setup_peripherals(); 
0964E:  GOTO   30CC
....................  
.................... 	default_addr(); 
09652:  GOTO   32F6
....................  
.................... 	FLASH_ADDR_WRITE(14); 
09656:  MOVLW  0E
09658:  MOVLB  6
0965A:  MOVWF  xD8
0965C:  MOVLB  0
0965E:  GOTO   5F48
....................  
.................... 	// Initializes and reads external EEPROM. Loads default DEVICE_CONFIG if necessary 
.................... 	device_boot(); 
09662:  GOTO   6774
.................... 	 
.................... 	// Reset amplifier and DSP then load values into DSP 
.................... 	softboot(); 
09666:  CALL   6DC6
....................  
.................... 	// Enable/disable interrupts based on DEVICE_CONFIG parameters 
.................... 	setup_interrupts(); 
0966A:  CALL   2F92
....................  
.................... 	while(true)	 
.................... 	{	 
.................... 		if(IS_USB_CONNECTED) { 
0966E:  MOVF   x78,F
09670:  BZ    9676
.................... 			process_usb_data(); 
09672:  GOTO   7FB0
.................... 		} 
.................... 	} 
09676:  BRA    966E
.................... } 
09678:  SLEEP 

Configuration Fuses:
   Word  1: E300   HSM NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
