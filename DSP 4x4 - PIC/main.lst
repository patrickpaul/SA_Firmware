CCS PCH C Compiler, Version 4.130, 13671               27-Jun-14 08:11

               Filename: C:\SOURCE\PIC\DSP 4x4 - PIC\main.lst

               ROM used: 34128 bytes (52%)
                         Largest free fragment is 29356
               RAM used: 1781 (46%) at main() level
                         1898 (49%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
00800:  GOTO   8C58
*
00808:  MOVWF  04
0080A:  MOVFF  FD8,05
0080E:  MOVFF  FE0,06
00812:  MOVLB  0
00814:  MOVFF  FE9,0C
00818:  MOVFF  FEA,07
0081C:  MOVFF  FE1,08
00820:  MOVFF  FE2,09
00824:  MOVFF  FD9,0A
00828:  MOVFF  FDA,0B
0082C:  MOVFF  FF3,12
00830:  MOVFF  FF4,13
00834:  MOVFF  FFA,14
00838:  MOVFF  FF5,15
0083C:  MOVFF  FF6,16
00840:  MOVFF  FF7,17
00844:  MOVFF  00,0E
00848:  MOVFF  01,0F
0084C:  MOVFF  02,10
00850:  MOVFF  03,11
00854:  BTFSS  FF0.3
00856:  GOTO   0860
0085A:  BTFSC  FF0.0
0085C:  GOTO   0DFE
00860:  BTFSS  FA3.5
00862:  GOTO   086C
00866:  BTFSC  FA4.5
00868:  GOTO   0DA2
0086C:  MOVFF  0E,00
00870:  MOVFF  0F,01
00874:  MOVFF  10,02
00878:  MOVFF  11,03
0087C:  MOVFF  0C,FE9
00880:  MOVFF  07,FEA
00884:  BSF    07.7
00886:  MOVFF  08,FE1
0088A:  MOVFF  09,FE2
0088E:  MOVFF  0A,FD9
00892:  MOVFF  0B,FDA
00896:  MOVFF  12,FF3
0089A:  MOVFF  13,FF4
0089E:  MOVFF  14,FFA
008A2:  MOVFF  15,FF5
008A6:  MOVFF  16,FF6
008AA:  MOVFF  17,FF7
008AE:  MOVF   04,W
008B0:  MOVFF  06,FE0
008B4:  MOVFF  05,FD8
008B8:  RETFIE 0
.................... #include <18LF46K22.h> 
.................... //////// Standard Header file for the PIC18LF46K22 device //////////////// 
.................... #device PIC18LF46K22 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSM                   	//High speed Osc, medium power 4MHz-16MHz 
.................... #FUSES NOPLLEN               	//4X HW PLL disabled, 4X PLL enabled in software 
.................... #FUSES PUT                   	//Power Up Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES WDT_SW                	//No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=14745600) 
*
00F2E:  MOVLW  07
00F30:  MOVWF  FEA
00F32:  MOVLW  37
00F34:  MOVWF  FE9
00F36:  MOVF   FEF,W
00F38:  BZ    0F54
00F3A:  MOVLW  04
00F3C:  MOVWF  01
00F3E:  CLRF   00
00F40:  DECFSZ 00,F
00F42:  BRA    0F40
00F44:  DECFSZ 01,F
00F46:  BRA    0F3E
00F48:  MOVLW  C7
00F4A:  MOVWF  00
00F4C:  DECFSZ 00,F
00F4E:  BRA    0F4C
00F50:  DECFSZ FEF,F
00F52:  BRA    0F3A
00F54:  RETURN 0
....................  
.................... #define BOOTLOADER_START        0x2A  
.................... #define BOOTLOADER_END          0x3FF + 0x400 
.................... #build (reset=BOOTLOADER_END +1  , interrupt=0x408 + 0x400 )  
.................... #org 0, BOOTLOADER_END {}  
....................  
.................... #include <DSP4x4_PINS.h> 
.................... // File DSP4x4_PINS.h 
....................  
.................... #define PIN_DSP_nRESET 		PIN_A4 
.................... #define PIN_DSP_SDA 		PIN_B0 
.................... #define PIN_DSP_SCL 		PIN_B1 
.................... #define PIN_DSP_IRQ			PIN_B2 
....................  
.................... #define PIN_USB_TX			PIN_C6 
.................... #define PIN_USB_RX			PIN_C7		 
....................  
.................... #define PIN_RS232_TX		PIN_D6 
.................... #define PIN_RS232_RX		PIN_D7 
....................  
.................... #define PIN_PHANTOM_CH1 	PIN_A5 
.................... #define PIN_PHANTOM_CH2 	PIN_E0 
.................... #define PIN_PHANTOM_CH3 	PIN_A1 
.................... #define PIN_PHANTOM_CH4 	PIN_A2 
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP4x4_CONFIG.h> 
.................... // File DSP4x4_CONFIG.h 
....................  
.................... #define POWERUP_DELAY	200 
....................  
.................... #define IEEPROM_PRESET_LOC	0x10 
.................... #define IEEPROM_DEVICE_CONFIG_LOC 0x64 
.................... #define IEEPROM_FLAG_LOC 0x20 
....................  
.................... #define FLASH_PHANTOM_LOC 0x200 
....................  
.................... #define NUM_PRESETS			10 
.................... #define DEFAULT_PRESET		0 
....................  
.................... long int num_dsp_values = 478; // Not a define since the software will automatically change this if necessary 
....................  
.................... #define NUM_PRESET_PAGES			12 
.................... #define NUM_DSP_VALUE_PAGES			8		 
.................... #define NUM_PLAIN_VALUE_PAGES		4 
.................... #define PLAIN_VALUE_PAGES_OFFSET	9	 
.................... #define NUM_ADDRESS_PAGES			4 
.................... #define IOLABEL_PAGE				11 
....................  
.................... #define DEFAULT_ADDR_BLOCK			14 
.................... #define DEFAULT_VALUE_BLOCK			15 
....................  
.................... /* store in EEPROM */ 
....................  
.................... const int DEBUG = 0; 
....................  
....................  
.................... int DEFAULT_USBDETECT_ENABLE = 1; 
.................... int DEFAULT_DSP_VALUESEND_ENABLE = 1; 
....................  
.................... #define DEVICE_ID_MSB	0 
.................... #define DEVICE_ID_LSB	0x14 
....................  
....................  
.................... typedef struct { 
.................... 	 
.................... 	int USBDETECT_ENABLE; 
.................... 	int DSP_VALUESEND_ENABLE; 
.................... 	char SERIAL[20]; 
.................... } device_configuration; 
....................  
.................... device_configuration DEVICE_CONFIG; 
.................... 	 
....................  
....................  
.................... #include <main.h> 
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // VERSION INFO 
.................... int MAJOR_REVISION = 3; 
.................... int MINOR_REVISION = 0; 
.................... char REVISION_TEXT[20] = "-DSP4x4"; 
....................  
.................... // USEFUL DEFINES 
.................... #define hi(x) (*((int8*)&x+1))  
.................... #define ON     0x00000001 
.................... #define OFF    0x00000000 
....................  
.................... // Used for eeprom.c 
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... // EEPROM DEFINES 
.................... #use I2C(MASTER, SDA=PIN_C3, SCL=PIN_C2) 
*
01AA4:  MOVLW  08
01AA6:  MOVWF  01
01AA8:  MOVLW  03
01AAA:  MOVWF  00
01AAC:  DECFSZ 00,F
01AAE:  BRA    1AAC
01AB0:  BCF    F8B.2
01AB2:  BCF    F94.2
01AB4:  MOVLW  03
01AB6:  MOVWF  00
01AB8:  DECFSZ 00,F
01ABA:  BRA    1AB8
01ABC:  MOVLB  7
01ABE:  RLCF   x4E,F
01AC0:  BCF    F8B.3
01AC2:  BTFSC  FD8.0
01AC4:  BSF    F94.3
01AC6:  BTFSS  FD8.0
01AC8:  BCF    F94.3
01ACA:  BSF    F94.2
01ACC:  BTFSS  F82.2
01ACE:  BRA    1ACC
01AD0:  DECFSZ 01,F
01AD2:  BRA    1AD6
01AD4:  BRA    1ADA
01AD6:  MOVLB  0
01AD8:  BRA    1AA8
01ADA:  MOVLW  03
01ADC:  MOVWF  00
01ADE:  DECFSZ 00,F
01AE0:  BRA    1ADE
01AE2:  BCF    F8B.2
01AE4:  BCF    F94.2
01AE6:  NOP   
01AE8:  BSF    F94.3
01AEA:  MOVLW  03
01AEC:  MOVWF  00
01AEE:  DECFSZ 00,F
01AF0:  BRA    1AEE
01AF2:  MOVLW  03
01AF4:  MOVWF  00
01AF6:  DECFSZ 00,F
01AF8:  BRA    1AF6
01AFA:  BSF    F94.2
01AFC:  BTFSS  F82.2
01AFE:  BRA    1AFC
01B00:  CLRF   01
01B02:  MOVLW  03
01B04:  MOVWF  00
01B06:  DECFSZ 00,F
01B08:  BRA    1B06
01B0A:  BTFSC  F82.3
01B0C:  BSF    01.0
01B0E:  BCF    F8B.2
01B10:  BCF    F94.2
01B12:  BCF    F8B.3
01B14:  BCF    F94.3
01B16:  MOVLB  0
01B18:  RETURN 0
*
04E8A:  MOVLW  08
04E8C:  MOVLB  7
04E8E:  MOVWF  x37
04E90:  MOVFF  00,738
04E94:  BSF    F94.3
04E96:  MOVLW  03
04E98:  MOVWF  00
04E9A:  DECFSZ 00,F
04E9C:  BRA    4E9A
04E9E:  BSF    F94.2
04EA0:  BTFSS  F82.2
04EA2:  BRA    4EA0
04EA4:  BTFSC  F82.3
04EA6:  BSF    FD8.0
04EA8:  BTFSS  F82.3
04EAA:  BCF    FD8.0
04EAC:  RLCF   01,F
04EAE:  MOVLW  03
04EB0:  MOVWF  00
04EB2:  DECFSZ 00,F
04EB4:  BRA    4EB2
04EB6:  BCF    F94.2
04EB8:  BCF    F8B.2
04EBA:  DECFSZ x37,F
04EBC:  BRA    4E94
04EBE:  BSF    F94.3
04EC0:  MOVLW  03
04EC2:  MOVWF  00
04EC4:  DECFSZ 00,F
04EC6:  BRA    4EC4
04EC8:  BCF    F8B.3
04ECA:  MOVF   x38,W
04ECC:  BTFSS  FD8.2
04ECE:  BCF    F94.3
04ED0:  NOP   
04ED2:  BSF    F94.2
04ED4:  BTFSS  F82.2
04ED6:  BRA    4ED4
04ED8:  MOVLW  03
04EDA:  MOVWF  00
04EDC:  DECFSZ 00,F
04EDE:  BRA    4EDC
04EE0:  BCF    F8B.2
04EE2:  BCF    F94.2
04EE4:  MOVLW  03
04EE6:  MOVWF  00
04EE8:  DECFSZ 00,F
04EEA:  BRA    4EE8
04EEC:  BCF    F8B.3
04EEE:  BCF    F94.3
04EF0:  MOVLB  0
04EF2:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int  
.................... #define EEPROM_SIZE   (128*8*8)  
....................  
.................... // RS232 DEFINES 
....................  
.................... #use rs232(baud=19200,parity=N,xmit=PIN_USB_TX,rcv=PIN_USB_RX,bits=8,errors,stream=USB,FORCE_SW) 
*
04CFE:  BSF    F94.7
04D00:  BTFSC  F82.7
04D02:  BRA    4D00
04D04:  MOVLW  08
04D06:  MOVWF  00
04D08:  MOVLB  7
04D0A:  CLRF   x38
04D0C:  BSF    00.7
04D0E:  BRA    4D2C
04D10:  BCF    00.7
04D12:  BRA    4D2C
04D14:  BCF    FD8.0
04D16:  BTFSC  F82.7
04D18:  BSF    FD8.0
04D1A:  RRCF   x38,F
04D1C:  BSF    00.6
04D1E:  BRA    4D2C
04D20:  BCF    00.6
04D22:  DECFSZ 00,F
04D24:  BRA    4D14
04D26:  MOVFF  738,01
04D2A:  BRA    4D44
04D2C:  MOVLW  39
04D2E:  BTFSC  00.7
04D30:  MOVLW  0F
04D32:  MOVWF  01
04D34:  DECFSZ 01,F
04D36:  BRA    4D34
04D38:  BRA    4D3A
04D3A:  BTFSC  00.7
04D3C:  BRA    4D10
04D3E:  BTFSC  00.6
04D40:  BRA    4D20
04D42:  BRA    4D14
04D44:  MOVLB  0
04D46:  RETURN 0
*
04D9A:  BCF    F94.6
04D9C:  BCF    F8B.6
04D9E:  MOVLW  08
04DA0:  MOVWF  01
04DA2:  BRA    4DA4
04DA4:  NOP   
04DA6:  BSF    01.7
04DA8:  BRA    4DCA
04DAA:  BCF    01.7
04DAC:  MOVLB  7
04DAE:  RRCF   x36,F
04DB0:  MOVLB  0
04DB2:  BTFSC  FD8.0
04DB4:  BSF    F8B.6
04DB6:  BTFSS  FD8.0
04DB8:  BCF    F8B.6
04DBA:  BSF    01.6
04DBC:  BRA    4DCA
04DBE:  BCF    01.6
04DC0:  DECFSZ 01,F
04DC2:  BRA    4DAC
04DC4:  BRA    4DC6
04DC6:  NOP   
04DC8:  BSF    F8B.6
04DCA:  MOVLW  39
04DCC:  MOVWF  FE9
04DCE:  DECFSZ FE9,F
04DD0:  BRA    4DCE
04DD2:  BRA    4DD4
04DD4:  NOP   
04DD6:  BTFSC  01.7
04DD8:  BRA    4DAA
04DDA:  BTFSC  01.6
04DDC:  BRA    4DBE
04DDE:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_RS232_TX,rcv=PIN_RS232_RX,bits=8,errors, stream=RS232) 
*
00D8A:  BTFSS  FA4.5
00D8C:  BRA    0D8A
00D8E:  MOVFF  F71,4F
00D92:  MOVFF  F74,01
00D96:  BTFSS  4F.1
00D98:  BRA    0D9E
00D9A:  BCF    F71.4
00D9C:  BSF    F71.4
00D9E:  GOTO   0DBA (RETURN)
*
05310:  BTFSS  FA4.4
05312:  BRA    5310
05314:  MOVWF  F73
05316:  RETURN 0
....................  
.................... #define FLASH_CS	PIN_D2 
....................  
.................... #use SPI(DO = PIN_D4, DI = PIN_D1, CLK = PIN_D0,BITS = 8,MSB_FIRST, SAMPLE_RISE)  
*
011A2:  MOVLB  7
011A4:  MOVF   x53,W
011A6:  SUBLW  08
011A8:  BZ    11B2
011AA:  MOVWF  x54
011AC:  RLCF   x52,F
011AE:  DECFSZ x54,F
011B0:  BRA    11AC
011B2:  BSF    F95.1
011B4:  BCF    F95.4
011B6:  BCF    F95.0
011B8:  BCF    F8C.0
011BA:  MOVFF  753,754
011BE:  BTFSS  x52.7
011C0:  BCF    F8C.4
011C2:  BTFSC  x52.7
011C4:  BSF    F8C.4
011C6:  RLCF   x52,F
011C8:  BSF    F8C.0
011CA:  RLCF   01,F
011CC:  BTFSS  F83.1
011CE:  BCF    01.0
011D0:  BTFSC  F83.1
011D2:  BSF    01.0
011D4:  BCF    F8C.0
011D6:  DECFSZ x54,F
011D8:  BRA    11BE
011DA:  MOVLB  0
011DC:  RETURN 0
....................  
.................... int IS_USB_CONNECTED; 
....................  
.................... #define RS232_BUFFER_SIZE 32 
.................... #define rs232_data_available (next_in!=next_out)  
....................  
.................... int buffer_unread = 0; 
.................... BYTE RS232_BYTE1, RS232_BYTE2, RS232_BYTE3, RS232_BYTE4; 
.................... BYTE buffer[RS232_BUFFER_SIZE]; 
.................... BYTE next_in = 0; 
.................... BYTE next_out = 0; 
....................  
.................... double rs232_premix_vol[4]; 
.................... int rs232_premix_mute[4]; 
....................  
.................... double rs232_output_vol[4]; 
.................... int rs232_output_mute[4]; 
....................  
.................... // DSP DEFINES 
.................... #define DSP_I2C_ADDRESS 0x80 
....................  
.................... // MEMORY DEFINES 
.................... int CURRENT_FLASH_PROGRAM = 0; 
....................  
.................... #define PAGE_SIZE  64  
.................... #define NUM_PAGES 9 
.................... #define TOTAL_ARRAY_SIZE (PAGE_SIZE*NUM_PAGES) 
....................  
.................... int32 PAGE_BUFFER_A[PAGE_SIZE]; 
....................  
.................... typedef struct { 
.................... 	int16 ADDRESSES_1[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_2[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_3[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_4[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_5[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_6[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_7[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_8[PAGE_SIZE]; 
.................... } dsp_addresses; 
....................  
.................... dsp_addresses DSP_ADDR; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP_mapping.h> 
.................... // This map is for FLX4CHANNEL_WITHNET_REVI 
.................... // Map generated 1-30-14 by Patrick Paul 
....................  
.................... #define DSP_ADDRESS_WRITE_PREFIX 0xF000 
.................... #define DSP_ADDRESS_READ_PREFIX 0xF0C0 
....................  
.................... /** 'AUDIO MANAGER' **/ 
.................... #define AM_MASTERGAIN		0x83000000	 
.................... #define AM_ANALOG1_TRIM		0x8300000a 
.................... #define AM_ANALOG2_TRIM		0x8300000b 
.................... #define AM_ANALOG3_TRIM		0x8300000c 
.................... #define AM_ANALOG4_TRIM		0x8300000d 
....................  
.................... #define PREGAIN_CH1 0x0373 
.................... #define PREGAIN_MUTE_CH1 0x0443 
.................... #define PREGAIN_CH2 0x03cf 
.................... #define PREGAIN_MUTE_CH2 0x0441 
.................... #define PREGAIN_CH3 0x03cb 
.................... #define PREGAIN_MUTE_CH3 0x043f 
.................... #define PREGAIN_CH4 0x03c7 
.................... #define PREGAIN_MUTE_CH4 0x043d 
.................... #define PREGAIN_CH5 0x03c3 
.................... #define PREGAIN_MUTE_CH5 0x043b 
.................... #define PREGAIN_CH6 0x03bf 
.................... #define PREGAIN_MUTE_CH6 0x0439 
.................... #define PREGAIN_CH7 0x03bb 
.................... #define PREGAIN_MUTE_CH7 0x0437 
.................... #define PREGAIN_CH8 0x03b7 
.................... #define PREGAIN_MUTE_CH8 0x0435 
.................... #define PREMIX_CH1 0x03b3 
.................... #define PREMIX_MUTE_CH1 0x0433 
.................... #define PREMIX_CH2 0x03af 
.................... #define PREMIX_MUTE_CH2 0x0431 
.................... #define PREMIX_CH3 0x03ab 
.................... #define PREMIX_MUTE_CH3 0x042f 
.................... #define PREMIX_CH4 0x03a7 
.................... #define PREMIX_MUTE_CH4 0x042d 
.................... #define PREMIX_CH5 0x03a3 
.................... #define PREMIX_MUTE_CH5 0x042b 
.................... #define PREMIX_CH6 0x039f 
.................... #define PREMIX_MUTE_CH6 0x0429 
.................... #define PREMIX_CH7 0x039b 
.................... #define PREMIX_MUTE_CH7 0x0427 
.................... #define PREMIX_CH8 0x0397 
.................... #define PREMIX_MUTE_CH8 0x0425 
.................... #define TRIM_CH1 0x0393 
.................... #define TRIM_MUTE_CH1 0x0423 
.................... #define TRIM_CH2 0x038f 
.................... #define TRIM_MUTE_CH2 0x0421 
.................... #define TRIM_CH3 0x038b 
.................... #define TRIM_MUTE_CH3 0x041f 
.................... #define TRIM_CH4 0x0387 
.................... #define TRIM_MUTE_CH4 0x041d 
.................... #define OUTPUTGAIN_CH1 0x0383 
.................... #define OUTPUT_MUTE_CH1 0x041b 
.................... #define OUTPUTGAIN_CH2 0x037f 
.................... #define OUTPUT_MUTE_CH2 0x0419 
.................... #define OUTPUTGAIN_CH3 0x037b 
.................... #define OUTPUT_MUTE_CH3 0x0417 
.................... #define OUTPUTGAIN_CH4 0x0377 
.................... #define OUTPUT_MUTE_CH4 0x0415 
.................... #define INDUCKROUTER_SELECT0 0x020e 
.................... #define INDUCKROUTER_SELECT1 0x020f 
.................... #define INDUCKROUTER_SELECT2 0x0210 
.................... #define INDUCKROUTER_SELECT3 0x0211 
.................... #define INDUCKROUTER_SELECT4 0x0212 
.................... #define INDUCKROUTER_SELECT5 0x0213 
.................... #define INDUCKROUTER_SELECT6 0x0214 
.................... #define INDUCKROUTER_SELECT7 0x0215 
.................... #define OUTDUCKROUTER_SELECT0 0x0205 
.................... #define OUTDUCKROUTER_SELECT1 0x0206 
.................... #define OUTDUCKROUTER_SELECT2 0x0207 
.................... #define OUTDUCKROUTER_SELECT3 0x0208 
.................... #define OUTDUCKROUTER_SELECT4 0x0209 
.................... #define OUTDUCKROUTER_SELECT5 0x020a 
.................... #define OUTDUCKROUTER_SELECT6 0x020b 
.................... #define OUTDUCKROUTER_SELECT7 0x020c 
.................... #define DUCKER_THRESHOLD 0x0276 
.................... #define DUCKER_HOLD 0x0277 
.................... #define DUCKER_DEPTH 0x0278 
.................... #define DUCKER_ATTACK 0x0279 
.................... #define DUCKER_RELEASE 0x027a 
.................... #define DUCKER_BYPASS 0x027b 
.................... #define IN_1_1_FILTER_B0 0x036d 
.................... #define IN_1_1_FILTER_B1 0x036e 
.................... #define IN_1_1_FILTER_B2 0x036f 
.................... #define IN_1_1_FILTER_MINUSA1 0x0370 
.................... #define IN_1_1_FILTER_MINUSA2 0x0371 
.................... #define IN_1_2_FILTER_B0 0x0368 
.................... #define IN_1_2_FILTER_B1 0x0369 
.................... #define IN_1_2_FILTER_B2 0x036a 
.................... #define IN_1_2_FILTER_MINUSA1 0x036b 
.................... #define IN_1_2_FILTER_MINUSA2 0x036c 
.................... #define IN_1_3_FILTER_B0 0x0363 
.................... #define IN_1_3_FILTER_B1 0x0364 
.................... #define IN_1_3_FILTER_B2 0x0365 
.................... #define IN_1_3_FILTER_MINUSA1 0x0366 
.................... #define IN_1_3_FILTER_MINUSA2 0x0367 
.................... #define IN_2_1_FILTER_B0 0x035e 
.................... #define IN_2_1_FILTER_B1 0x035f 
.................... #define IN_2_1_FILTER_B2 0x0360 
.................... #define IN_2_1_FILTER_MINUSA1 0x0361 
.................... #define IN_2_1_FILTER_MINUSA2 0x0362 
.................... #define IN_2_2_FILTER_B0 0x0359 
.................... #define IN_2_2_FILTER_B1 0x035a 
.................... #define IN_2_2_FILTER_B2 0x035b 
.................... #define IN_2_2_FILTER_MINUSA1 0x035c 
.................... #define IN_2_2_FILTER_MINUSA2 0x035d 
.................... #define IN_2_3_FILTER_B0 0x0354 
.................... #define IN_2_3_FILTER_B1 0x0355 
.................... #define IN_2_3_FILTER_B2 0x0356 
.................... #define IN_2_3_FILTER_MINUSA1 0x0357 
.................... #define IN_2_3_FILTER_MINUSA2 0x0358 
.................... #define IN_3_1_FILTER_B0 0x034f 
.................... #define IN_3_1_FILTER_B1 0x0350 
.................... #define IN_3_1_FILTER_B2 0x0351 
.................... #define IN_3_1_FILTER_MINUSA1 0x0352 
.................... #define IN_3_1_FILTER_MINUSA2 0x0353 
.................... #define IN_3_2_FILTER_B0 0x034a 
.................... #define IN_3_2_FILTER_B1 0x034b 
.................... #define IN_3_2_FILTER_B2 0x034c 
.................... #define IN_3_2_FILTER_MINUSA1 0x034d 
.................... #define IN_3_2_FILTER_MINUSA2 0x034e 
.................... #define IN_3_3_FILTER_B0 0x0345 
.................... #define IN_3_3_FILTER_B1 0x0346 
.................... #define IN_3_3_FILTER_B2 0x0347 
.................... #define IN_3_3_FILTER_MINUSA1 0x0348 
.................... #define IN_3_3_FILTER_MINUSA2 0x0349 
.................... #define IN_4_1_FILTER_B0 0x0340 
.................... #define IN_4_1_FILTER_B1 0x0341 
.................... #define IN_4_1_FILTER_B2 0x0342 
.................... #define IN_4_1_FILTER_MINUSA1 0x0343 
.................... #define IN_4_1_FILTER_MINUSA2 0x0344 
.................... #define IN_4_2_FILTER_B0 0x033b 
.................... #define IN_4_2_FILTER_B1 0x033c 
.................... #define IN_4_2_FILTER_B2 0x033d 
.................... #define IN_4_2_FILTER_MINUSA1 0x033e 
.................... #define IN_4_2_FILTER_MINUSA2 0x033f 
.................... #define IN_4_3_FILTER_B0 0x0336 
.................... #define IN_4_3_FILTER_B1 0x0337 
.................... #define IN_4_3_FILTER_B2 0x0338 
.................... #define IN_4_3_FILTER_MINUSA1 0x0339 
.................... #define IN_4_3_FILTER_MINUSA2 0x033a 
.................... #define IN_5_1_FILTER_B0 0x0331 
.................... #define IN_5_1_FILTER_B1 0x0332 
.................... #define IN_5_1_FILTER_B2 0x0333 
.................... #define IN_5_1_FILTER_MINUSA1 0x0334 
.................... #define IN_5_1_FILTER_MINUSA2 0x0335 
.................... #define IN_5_2_FILTER_B0 0x032c 
.................... #define IN_5_2_FILTER_B1 0x032d 
.................... #define IN_5_2_FILTER_B2 0x032e 
.................... #define IN_5_2_FILTER_MINUSA1 0x032f 
.................... #define IN_5_2_FILTER_MINUSA2 0x0330 
.................... #define IN_5_3_FILTER_B0 0x0327 
.................... #define IN_5_3_FILTER_B1 0x0328 
.................... #define IN_5_3_FILTER_B2 0x0329 
.................... #define IN_5_3_FILTER_MINUSA1 0x032a 
.................... #define IN_5_3_FILTER_MINUSA2 0x032b 
.................... #define IN_6_1_FILTER_B0 0x0322 
.................... #define IN_6_1_FILTER_B1 0x0323 
.................... #define IN_6_1_FILTER_B2 0x0324 
.................... #define IN_6_1_FILTER_MINUSA1 0x0325 
.................... #define IN_6_1_FILTER_MINUSA2 0x0326 
.................... #define IN_6_2_FILTER_B0 0x031d 
.................... #define IN_6_2_FILTER_B1 0x031e 
.................... #define IN_6_2_FILTER_B2 0x031f 
.................... #define IN_6_2_FILTER_MINUSA1 0x0320 
.................... #define IN_6_2_FILTER_MINUSA2 0x0321 
.................... #define IN_6_3_FILTER_B0 0x0318 
.................... #define IN_6_3_FILTER_B1 0x0319 
.................... #define IN_6_3_FILTER_B2 0x031a 
.................... #define IN_6_3_FILTER_MINUSA1 0x031b 
.................... #define IN_6_3_FILTER_MINUSA2 0x031c 
.................... #define IN_7_1_FILTER_B0 0x0313 
.................... #define IN_7_1_FILTER_B1 0x0314 
.................... #define IN_7_1_FILTER_B2 0x0315 
.................... #define IN_7_1_FILTER_MINUSA1 0x0316 
.................... #define IN_7_1_FILTER_MINUSA2 0x0317 
.................... #define IN_7_2_FILTER_B0 0x030e 
.................... #define IN_7_2_FILTER_B1 0x030f 
.................... #define IN_7_2_FILTER_B2 0x0310 
.................... #define IN_7_2_FILTER_MINUSA1 0x0311 
.................... #define IN_7_2_FILTER_MINUSA2 0x0312 
.................... #define IN_7_3_FILTER_B0 0x0309 
.................... #define IN_7_3_FILTER_B1 0x030a 
.................... #define IN_7_3_FILTER_B2 0x030b 
.................... #define IN_7_3_FILTER_MINUSA1 0x030c 
.................... #define IN_7_3_FILTER_MINUSA2 0x030d 
.................... #define IN_8_1_FILTER_B0 0x0304 
.................... #define IN_8_1_FILTER_B1 0x0305 
.................... #define IN_8_1_FILTER_B2 0x0306 
.................... #define IN_8_1_FILTER_MINUSA1 0x0307 
.................... #define IN_8_1_FILTER_MINUSA2 0x0308 
.................... #define IN_8_2_FILTER_B0 0x02ff 
.................... #define IN_8_2_FILTER_B1 0x0300 
.................... #define IN_8_2_FILTER_B2 0x0301 
.................... #define IN_8_2_FILTER_MINUSA1 0x0302 
.................... #define IN_8_2_FILTER_MINUSA2 0x0303 
.................... #define IN_8_3_FILTER_B0 0x02fa 
.................... #define IN_8_3_FILTER_B1 0x02fb 
.................... #define IN_8_3_FILTER_B2 0x02fc 
.................... #define IN_8_3_FILTER_MINUSA1 0x02fd 
.................... #define IN_8_3_FILTER_MINUSA2 0x02fe 
.................... #define CH1COMP_THRESHOLD 0x026e 
.................... #define CH1COMP_KNEE 0x026f 
.................... #define CH1COMP_RATIO 0x0270 
.................... #define CH1COMP_ATTACK 0x0271 
.................... #define CH1COMP_RELEASE 0x0272 
.................... #define CH1COMP_BYPASS 0x0273 
.................... #define CH2COMP_THRESHOLD 0x0266 
.................... #define CH2COMP_KNEE 0x0267 
.................... #define CH2COMP_RATIO 0x0268 
.................... #define CH2COMP_ATTACK 0x0269 
.................... #define CH2COMP_RELEASE 0x026a 
.................... #define CH2COMP_BYPASS 0x026b 
.................... #define CH3COMP_THRESHOLD 0x025e 
.................... #define CH3COMP_KNEE 0x025f 
.................... #define CH3COMP_RATIO 0x0260 
.................... #define CH3COMP_ATTACK 0x0261 
.................... #define CH3COMP_RELEASE 0x0262 
.................... #define CH3COMP_BYPASS 0x0263 
.................... #define CH4COMP_THRESHOLD 0x0256 
.................... #define CH4COMP_KNEE 0x0257 
.................... #define CH4COMP_RATIO 0x0258 
.................... #define CH4COMP_ATTACK 0x0259 
.................... #define CH4COMP_RELEASE 0x025a 
.................... #define CH4COMP_BYPASS 0x025b 
.................... #define CH5COMP_THRESHOLD 0x024e 
.................... #define CH5COMP_KNEE 0x024f 
.................... #define CH5COMP_RATIO 0x0250 
.................... #define CH5COMP_ATTACK 0x0251 
.................... #define CH5COMP_RELEASE 0x0252 
.................... #define CH5COMP_BYPASS 0x0253 
.................... #define CH6COMP_THRESHOLD 0x0246 
.................... #define CH6COMP_KNEE 0x0247 
.................... #define CH6COMP_RATIO 0x0248 
.................... #define CH6COMP_ATTACK 0x0249 
.................... #define CH6COMP_RELEASE 0x024a 
.................... #define CH6COMP_BYPASS 0x024b 
.................... #define CH7COMP_THRESHOLD 0x023e 
.................... #define CH7COMP_KNEE 0x023f 
.................... #define CH7COMP_RATIO 0x0240 
.................... #define CH7COMP_ATTACK 0x0241 
.................... #define CH7COMP_RELEASE 0x0242 
.................... #define CH7COMP_BYPASS 0x0243 
.................... #define CH8COMP_THRESHOLD 0x0236 
.................... #define CH8COMP_KNEE 0x0237 
.................... #define CH8COMP_RATIO 0x0238 
.................... #define CH8COMP_ATTACK 0x0239 
.................... #define CH8COMP_RELEASE 0x023a 
.................... #define CH8COMP_BYPASS 0x023b 
.................... #define MIXER_SELECT0 0x0003 
.................... #define MIXER_SELECT1 0x0004 
.................... #define MIXER_SELECT2 0x0005 
.................... #define MIXER_SELECT3 0x0006 
.................... #define MIXER_SELECT4 0x0007 
.................... #define MIXER_SELECT5 0x0008 
.................... #define MIXER_SELECT6 0x0009 
.................... #define MIXER_SELECT7 0x000a 
.................... #define MIXER_SELECT8 0x000b 
.................... #define MIXER_SELECT9 0x000c 
.................... #define MIXER_SELECT10 0x000d 
.................... #define MIXER_SELECT11 0x000e 
.................... #define MIXER_SELECT12 0x000f 
.................... #define MIXER_SELECT13 0x0010 
.................... #define MIXER_SELECT14 0x0011 
.................... #define MIXER_SELECT15 0x0012 
.................... #define MIXER_SELECT16 0x0013 
.................... #define MIXER_SELECT17 0x0014 
.................... #define MIXER_SELECT18 0x0015 
.................... #define MIXER_SELECT19 0x0016 
.................... #define MIXER_SELECT20 0x0017 
.................... #define MIXER_SELECT21 0x0018 
.................... #define MIXER_SELECT22 0x0019 
.................... #define MIXER_SELECT23 0x001a 
.................... #define MIXER_SELECT24 0x001b 
.................... #define MIXER_SELECT25 0x001c 
.................... #define MIXER_SELECT26 0x001d 
.................... #define MIXER_SELECT27 0x001e 
.................... #define MIXER_SELECT28 0x001f 
.................... #define MIXER_SELECT29 0x0020 
.................... #define MIXER_SELECT30 0x0021 
.................... #define MIXER_SELECT31 0x0022 
.................... #define MIXER_SELECT32 0x0023 
.................... #define MIXER_SELECT33 0x0024 
.................... #define MIXER_SELECT34 0x0025 
.................... #define MIXER_SELECT35 0x0026 
.................... #define MIXER_SELECT36 0x0027 
.................... #define MIXER_SELECT37 0x0028 
.................... #define MIXER_SELECT38 0x0029 
.................... #define MIXER_SELECT39 0x002a 
.................... #define MIXER_SELECT40 0x002b 
.................... #define MIXER_SELECT41 0x002c 
.................... #define MIXER_SELECT42 0x002d 
.................... #define MIXER_SELECT43 0x002e 
.................... #define MIXER_SELECT44 0x002f 
.................... #define MIXER_SELECT45 0x0030 
.................... #define MIXER_SELECT46 0x0031 
.................... #define MIXER_SELECT47 0x0032 
.................... #define MIXER_SELECT48 0x0033 
.................... #define MIXER_SELECT49 0x0034 
.................... #define MIXER_SELECT50 0x0035 
.................... #define MIXER_SELECT51 0x0036 
.................... #define MIXER_SELECT52 0x0037 
.................... #define MIXER_SELECT53 0x0038 
.................... #define MIXER_SELECT54 0x0039 
.................... #define MIXER_SELECT55 0x003a 
.................... #define MIXER_SELECT56 0x003b 
.................... #define MIXER_SELECT57 0x003c 
.................... #define MIXER_SELECT58 0x003d 
.................... #define MIXER_SELECT59 0x003e 
.................... #define MIXER_SELECT60 0x003f 
.................... #define MIXER_SELECT61 0x0040 
.................... #define MIXER_SELECT62 0x0041 
.................... #define MIXER_SELECT63 0x0042 
.................... #define MIXER_SELECT64 0x0043 
.................... #define MIXER_SELECT65 0x0044 
.................... #define MIXER_SELECT66 0x0045 
.................... #define MIXER_SELECT67 0x0046 
.................... #define MIXER_SELECT68 0x0047 
.................... #define MIXER_SELECT69 0x0048 
.................... #define MIXER_SELECT70 0x0049 
.................... #define MIXER_SELECT71 0x004a 
.................... #define MIXER_SELECT72 0x004b 
.................... #define MIXER_SELECT73 0x004c 
.................... #define MIXER_SELECT74 0x004d 
.................... #define MIXER_SELECT75 0x004e 
.................... #define MIXER_SELECT76 0x004f 
.................... #define MIXER_SELECT77 0x0050 
.................... #define MIXER_SELECT78 0x0051 
.................... #define MIXER_SELECT79 0x0052 
.................... #define OUT_1_1_FILTER_B0 0x02f5 
.................... #define OUT_1_1_FILTER_B1 0x02f6 
.................... #define OUT_1_1_FILTER_B2 0x02f7 
.................... #define OUT_1_1_FILTER_NEGATIVEA1 0x02f8 
.................... #define OUT_1_1_FILTER_NEGATIVEA2 0x02f9 
.................... #define OUT_1_2_FILTER_B0 0x02f0 
.................... #define OUT_1_2_FILTER_B1 0x02f1 
.................... #define OUT_1_2_FILTER_B2 0x02f2 
.................... #define OUT_1_2_FILTER_NEGATIVEA1 0x02f3 
.................... #define OUT_1_2_FILTER_NEGATIVEA2 0x02f4 
.................... #define OUT_1_3_FILTER_B0 0x02eb 
.................... #define OUT_1_3_FILTER_B1 0x02ec 
.................... #define OUT_1_3_FILTER_B2 0x02ed 
.................... #define OUT_1_3_FILTER_NEGATIVEA1 0x02ee 
.................... #define OUT_1_3_FILTER_NEGATIVEA2 0x02ef 
.................... #define OUT_1_4_FILTER_B0 0x02b9 
.................... #define OUT_1_4_FILTER_B1 0x02ba 
.................... #define OUT_1_4_FILTER_B2 0x02bb 
.................... #define OUT_1_4_FILTER_NEGATIVEA1 0x02bc 
.................... #define OUT_1_4_FILTER_NEGATIVEA2 0x02bd 
.................... #define OUT_1_5_FILTER_B0 0x02b4 
.................... #define OUT_1_5_FILTER_B1 0x02b5 
.................... #define OUT_1_5_FILTER_B2 0x02b6 
.................... #define OUT_1_5_FILTER_NEGATIVEA1 0x02b7 
.................... #define OUT_1_5_FILTER_NEGATIVEA2 0x02b8 
.................... #define OUT_1_6_FILTER_B0 0x02af 
.................... #define OUT_1_6_FILTER_B1 0x02b0 
.................... #define OUT_1_6_FILTER_B2 0x02b1 
.................... #define OUT_1_6_FILTER_NEGATIVEA1 0x02b2 
.................... #define OUT_1_6_FILTER_NEGATIVEA2 0x02b3 
.................... #define OUT_2_1_FILTER_B0 0x02e6 
.................... #define OUT_2_1_FILTER_B1 0x02e7 
.................... #define OUT_2_1_FILTER_B2 0x02e8 
.................... #define OUT_2_1_FILTER_NEGATIVEA1 0x02e9 
.................... #define OUT_2_1_FILTER_NEGATIVEA2 0x02ea 
.................... #define OUT_2_2_FILTER_B0 0x02e1 
.................... #define OUT_2_2_FILTER_B1 0x02e2 
.................... #define OUT_2_2_FILTER_B2 0x02e3 
.................... #define OUT_2_2_FILTER_NEGATIVEA1 0x02e4 
.................... #define OUT_2_2_FILTER_NEGATIVEA2 0x02e5 
.................... #define OUT_2_3_FILTER_B0 0x02dc 
.................... #define OUT_2_3_FILTER_B1 0x02dd 
.................... #define OUT_2_3_FILTER_B2 0x02de 
.................... #define OUT_2_3_FILTER_NEGATIVEA1 0x02df 
.................... #define OUT_2_3_FILTER_NEGATIVEA2 0x02e0 
.................... #define OUT_2_4_FILTER_B0 0x02aa 
.................... #define OUT_2_4_FILTER_B1 0x02ab 
.................... #define OUT_2_4_FILTER_B2 0x02ac 
.................... #define OUT_2_4_FILTER_NEGATIVEA1 0x02ad 
.................... #define OUT_2_4_FILTER_NEGATIVEA2 0x02ae 
.................... #define OUT_2_5_FILTER_B0 0x02a5 
.................... #define OUT_2_5_FILTER_B1 0x02a6 
.................... #define OUT_2_5_FILTER_B2 0x02a7 
.................... #define OUT_2_5_FILTER_NEGATIVEA1 0x02a8 
.................... #define OUT_2_5_FILTER_NEGATIVEA2 0x02a9 
.................... #define OUT_2_6_FILTER_B0 0x02a0 
.................... #define OUT_2_6_FILTER_B1 0x02a1 
.................... #define OUT_2_6_FILTER_B2 0x02a2 
.................... #define OUT_2_6_FILTER_NEGATIVEA1 0x02a3 
.................... #define OUT_2_6_FILTER_NEGATIVEA2 0x02a4 
.................... #define OUT_3_1_FILTER_B0 0x02d7 
.................... #define OUT_3_1_FILTER_B1 0x02d8 
.................... #define OUT_3_1_FILTER_B2 0x02d9 
.................... #define OUT_3_1_FILTER_NEGATIVEA1 0x02da 
.................... #define OUT_3_1_FILTER_NEGATIVEA2 0x02db 
.................... #define OUT_3_2_FILTER_B0 0x02d2 
.................... #define OUT_3_2_FILTER_B1 0x02d3 
.................... #define OUT_3_2_FILTER_B2 0x02d4 
.................... #define OUT_3_2_FILTER_NEGATIVEA1 0x02d5 
.................... #define OUT_3_2_FILTER_NEGATIVEA2 0x02d6 
.................... #define OUT_3_3_FILTER_B0 0x02cd 
.................... #define OUT_3_3_FILTER_B1 0x02ce 
.................... #define OUT_3_3_FILTER_B2 0x02cf 
.................... #define OUT_3_3_FILTER_NEGATIVEA1 0x02d0 
.................... #define OUT_3_3_FILTER_NEGATIVEA2 0x02d1 
.................... #define OUT_3_4_FILTER_B0 0x029b 
.................... #define OUT_3_4_FILTER_B1 0x029c 
.................... #define OUT_3_4_FILTER_B2 0x029d 
.................... #define OUT_3_4_FILTER_NEGATIVEA1 0x029e 
.................... #define OUT_3_4_FILTER_NEGATIVEA2 0x029f 
.................... #define OUT_3_5_FILTER_B0 0x0296 
.................... #define OUT_3_5_FILTER_B1 0x0297 
.................... #define OUT_3_5_FILTER_B2 0x0298 
.................... #define OUT_3_5_FILTER_NEGATIVEA1 0x0299 
.................... #define OUT_3_5_FILTER_NEGATIVEA2 0x029a 
.................... #define OUT_3_6_FILTER_B0 0x0291 
.................... #define OUT_3_6_FILTER_B1 0x0292 
.................... #define OUT_3_6_FILTER_B2 0x0293 
.................... #define OUT_3_6_FILTER_NEGATIVEA1 0x0294 
.................... #define OUT_3_6_FILTER_NEGATIVEA2 0x0295 
.................... #define OUT_4_1_FILTER_B0 0x02c8 
.................... #define OUT_4_1_FILTER_B1 0x02c9 
.................... #define OUT_4_1_FILTER_B2 0x02ca 
.................... #define OUT_4_1_FILTER_NEGATIVEA1 0x02cb 
.................... #define OUT_4_1_FILTER_NEGATIVEA2 0x02cc 
.................... #define OUT_4_2_FILTER_B0 0x02c3 
.................... #define OUT_4_2_FILTER_B1 0x02c4 
.................... #define OUT_4_2_FILTER_B2 0x02c5 
.................... #define OUT_4_2_FILTER_NEGATIVEA1 0x02c6 
.................... #define OUT_4_2_FILTER_NEGATIVEA2 0x02c7 
.................... #define OUT_4_3_FILTER_B0 0x02be 
.................... #define OUT_4_3_FILTER_B1 0x02bf 
.................... #define OUT_4_3_FILTER_B2 0x02c0 
.................... #define OUT_4_3_FILTER_NEGATIVEA1 0x02c1 
.................... #define OUT_4_3_FILTER_NEGATIVEA2 0x02c2 
.................... #define OUT_4_4_FILTER_B0 0x028c 
.................... #define OUT_4_4_FILTER_B1 0x028d 
.................... #define OUT_4_4_FILTER_B2 0x028e 
.................... #define OUT_4_4_FILTER_NEGATIVEA1 0x028f 
.................... #define OUT_4_4_FILTER_NEGATIVEA2 0x0290 
.................... #define OUT_4_5_FILTER_B0 0x0287 
.................... #define OUT_4_5_FILTER_B1 0x0288 
.................... #define OUT_4_5_FILTER_B2 0x0289 
.................... #define OUT_4_5_FILTER_NEGATIVEA1 0x028a 
.................... #define OUT_4_5_FILTER_NEGATIVEA2 0x028b 
.................... #define OUT_4_6_FILTER_B0 0x0282 
.................... #define OUT_4_6_FILTER_B1 0x0283 
.................... #define OUT_4_6_FILTER_B2 0x0284 
.................... #define OUT_4_6_FILTER_NEGATIVEA1 0x0285 
.................... #define OUT_4_6_FILTER_NEGATIVEA2 0x0286 
.................... #define CH1LIM_THRESHOLD 0x022e 
.................... #define CH1LIM_KNEE 0x022f 
.................... #define CH1LIM_RATIO 0x0230 
.................... #define CH1LIM_ATTACK 0x0231 
.................... #define CH1LIM_RELEASE 0x0232 
.................... #define CH1LIM_BYPASS 0x0233 
.................... #define CH2LIM_THRESHOLD 0x0226 
.................... #define CH2LIM_KNEE 0x0227 
.................... #define CH2LIM_RATIO 0x0228 
.................... #define CH2LIM_ATTACK 0x0229 
.................... #define CH2LIM_RELEASE 0x022a 
.................... #define CH2LIM_BYPASS 0x022b 
.................... #define CH3LIM_THRESHOLD 0x021e 
.................... #define CH3LIM_KNEE 0x021f 
.................... #define CH3LIM_RATIO 0x0220 
.................... #define CH3LIM_ATTACK 0x0221 
.................... #define CH3LIM_RELEASE 0x0222 
.................... #define CH3LIM_BYPASS 0x0223 
.................... #define CH4LIM_THRESHOLD 0x0216 
.................... #define CH4LIM_KNEE 0x0217 
.................... #define CH4LIM_RATIO 0x0218 
.................... #define CH4LIM_ATTACK 0x0219 
.................... #define CH4LIM_RELEASE 0x021a 
.................... #define CH4LIM_BYPASS 0x021b 
.................... #define DELAY_CH1 0x03dd 
.................... #define DELAY_CH2 0x03da 
.................... #define DELAY_CH3 0x03d7 
.................... #define DELAY_CH4 0x03d4 
.................... #define DELAY_BYPASS_CH1 0x0448 
.................... #define DELAY_BYPASS_CH2 0x0447 
.................... #define DELAY_BYPASS_CH3 0x0446 
.................... #define DELAY_BYPASS_CH4 0x0445 
.................... #define BRIDGEROUTER_SELECT0 0x027e 
.................... #define BRIDGEROUTER_SELECT1 0x027f 
.................... #define BRIDGEROUTER_SELECT2 0x0280 
.................... #define BRIDGEROUTER_SELECT3 0x0281 
.................... #define GEN_PINK_GAIN 0x0411 
.................... #define GEN_SINE_OMEGA 0x03eb 
.................... #define GEN_SINE_GAIN 0x03ec 
.................... #define SEVENTYVHP_BYPASS 0x0444 
.................... #define MUTE_OUTPUTS 0x0413 
....................  
....................  
.................... #include <memory.c> 
.................... /*void WRITE_CONFIG_BOTH(int16 index, int16 address, int32 value) 
.................... { 
.................... 	if(index > num_dsp_values) { 
.................... 		num_dsp_values = index; 
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE * 2)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
.................... 		DSP_CONFIG.VALUES_2[index - (PAGE_SIZE*1)] = value;   
....................   	}  else if(index < (PAGE_SIZE * 3)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;    
.................... 		DSP_CONFIG.VALUES_3[index - (PAGE_SIZE*2)] = value;    
....................   	}  else if(index < ((PAGE_SIZE*4))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;    
.................... 		DSP_CONFIG.VALUES_4[index - (PAGE_SIZE*3)] = value;    
....................   	} else if(index < ((PAGE_SIZE*5))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;    
.................... 		DSP_CONFIG.VALUES_5[index - (PAGE_SIZE*4)] = value;    
....................   	} else if(index < ((PAGE_SIZE*6))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;    
.................... 		DSP_CONFIG.VALUES_6[index - (PAGE_SIZE*5)] = value;    
....................   	} else if(index < ((PAGE_SIZE*7))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;    
.................... 		DSP_CONFIG.VALUES_7[index - (PAGE_SIZE*6)] = value;    
....................   	} else if(index < ((PAGE_SIZE*8))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
.................... 		//DSP_CONFIG.VALUES_8[index - (PAGE_SIZE*7)] = value;    
....................   	} 
....................  
.................... } 
.................... */ 
.................... void WRITE_CONFIG_ADDRESS(int16 index, int16 address) 
.................... { 
.................... 	if(index > num_dsp_values) { 
*
02030:  MOVF   1A,W
02032:  MOVLB  6
02034:  SUBWF  xF6,W
02036:  BNC   2048
02038:  BNZ   2040
0203A:  MOVF   xF5,W
0203C:  SUBWF  19,W
0203E:  BC    2048
.................... 		num_dsp_values = index; 
02040:  MOVFF  6F6,1A
02044:  MOVFF  6F5,19
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
02048:  MOVF   xF6,F
0204A:  BNZ   2074
0204C:  MOVF   xF5,W
0204E:  SUBLW  3F
02050:  BNC   2074
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
02052:  BCF    FD8.0
02054:  RLCF   xF5,W
02056:  MOVWF  02
02058:  RLCF   xF6,W
0205A:  MOVWF  03
0205C:  MOVF   02,W
0205E:  ADDLW  A1
02060:  MOVWF  FE9
02062:  MOVLW  01
02064:  ADDWFC 03,W
02066:  MOVWF  FEA
02068:  MOVFF  6F8,FEC
0206C:  MOVF   FED,F
0206E:  MOVFF  6F7,FEF
....................   	} else if(index < (PAGE_SIZE * 2)) 
02072:  BRA    21FE
02074:  MOVF   xF6,F
02076:  BNZ   20AC
02078:  MOVF   xF5,W
0207A:  SUBLW  7F
0207C:  BNC   20AC
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
0207E:  MOVLW  40
02080:  SUBWF  xF5,W
02082:  MOVWF  xF9
02084:  MOVLW  00
02086:  SUBWFB xF6,W
02088:  MOVWF  xFA
0208A:  BCF    FD8.0
0208C:  RLCF   xF9,W
0208E:  MOVWF  02
02090:  RLCF   xFA,W
02092:  MOVWF  03
02094:  MOVF   02,W
02096:  ADDLW  21
02098:  MOVWF  FE9
0209A:  MOVLW  02
0209C:  ADDWFC 03,W
0209E:  MOVWF  FEA
020A0:  MOVFF  6F8,FEC
020A4:  MOVF   FED,F
020A6:  MOVFF  6F7,FEF
....................   	}  else if(index < (PAGE_SIZE * 3)) 
020AA:  BRA    21FE
020AC:  MOVF   xF6,F
020AE:  BNZ   20E4
020B0:  MOVF   xF5,W
020B2:  SUBLW  BF
020B4:  BNC   20E4
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;  
020B6:  MOVLW  80
020B8:  SUBWF  xF5,W
020BA:  MOVWF  xF9
020BC:  MOVLW  00
020BE:  SUBWFB xF6,W
020C0:  MOVWF  xFA
020C2:  BCF    FD8.0
020C4:  RLCF   xF9,W
020C6:  MOVWF  02
020C8:  RLCF   xFA,W
020CA:  MOVWF  03
020CC:  MOVF   02,W
020CE:  ADDLW  A1
020D0:  MOVWF  FE9
020D2:  MOVLW  02
020D4:  ADDWFC 03,W
020D6:  MOVWF  FEA
020D8:  MOVFF  6F8,FEC
020DC:  MOVF   FED,F
020DE:  MOVFF  6F7,FEF
....................   	}  else if(index < ((PAGE_SIZE*4))) 
020E2:  BRA    21FE
020E4:  MOVF   xF6,W
020E6:  SUBLW  00
020E8:  BNC   2118
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;   
020EA:  MOVLW  C0
020EC:  SUBWF  xF5,W
020EE:  MOVWF  xF9
020F0:  MOVLW  00
020F2:  SUBWFB xF6,W
020F4:  MOVWF  xFA
020F6:  BCF    FD8.0
020F8:  RLCF   xF9,W
020FA:  MOVWF  02
020FC:  RLCF   xFA,W
020FE:  MOVWF  03
02100:  MOVF   02,W
02102:  ADDLW  21
02104:  MOVWF  FE9
02106:  MOVLW  03
02108:  ADDWFC 03,W
0210A:  MOVWF  FEA
0210C:  MOVFF  6F8,FEC
02110:  MOVF   FED,F
02112:  MOVFF  6F7,FEF
....................   	} else if(index < ((PAGE_SIZE*5))) 
02116:  BRA    21FE
02118:  MOVF   xF6,W
0211A:  SUBLW  01
0211C:  BNC   2154
0211E:  BNZ   2126
02120:  MOVF   xF5,W
02122:  SUBLW  3F
02124:  BNC   2154
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;  
02126:  MOVLW  00
02128:  SUBWF  xF5,W
0212A:  MOVWF  xF9
0212C:  MOVLW  01
0212E:  SUBWFB xF6,W
02130:  MOVWF  xFA
02132:  BCF    FD8.0
02134:  RLCF   xF9,W
02136:  MOVWF  02
02138:  RLCF   xFA,W
0213A:  MOVWF  03
0213C:  MOVF   02,W
0213E:  ADDLW  A1
02140:  MOVWF  FE9
02142:  MOVLW  03
02144:  ADDWFC 03,W
02146:  MOVWF  FEA
02148:  MOVFF  6F8,FEC
0214C:  MOVF   FED,F
0214E:  MOVFF  6F7,FEF
....................   	} else if(index < ((PAGE_SIZE*6))) 
02152:  BRA    21FE
02154:  MOVF   xF6,W
02156:  SUBLW  01
02158:  BNC   2190
0215A:  BNZ   2162
0215C:  MOVF   xF5,W
0215E:  SUBLW  7F
02160:  BNC   2190
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;  
02162:  MOVLW  40
02164:  SUBWF  xF5,W
02166:  MOVWF  xF9
02168:  MOVLW  01
0216A:  SUBWFB xF6,W
0216C:  MOVWF  xFA
0216E:  BCF    FD8.0
02170:  RLCF   xF9,W
02172:  MOVWF  02
02174:  RLCF   xFA,W
02176:  MOVWF  03
02178:  MOVF   02,W
0217A:  ADDLW  21
0217C:  MOVWF  FE9
0217E:  MOVLW  04
02180:  ADDWFC 03,W
02182:  MOVWF  FEA
02184:  MOVFF  6F8,FEC
02188:  MOVF   FED,F
0218A:  MOVFF  6F7,FEF
....................   	} else if(index < ((PAGE_SIZE*7))) 
0218E:  BRA    21FE
02190:  MOVF   xF6,W
02192:  SUBLW  01
02194:  BNC   21CC
02196:  BNZ   219E
02198:  MOVF   xF5,W
0219A:  SUBLW  BF
0219C:  BNC   21CC
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;  
0219E:  MOVLW  80
021A0:  SUBWF  xF5,W
021A2:  MOVWF  xF9
021A4:  MOVLW  01
021A6:  SUBWFB xF6,W
021A8:  MOVWF  xFA
021AA:  BCF    FD8.0
021AC:  RLCF   xF9,W
021AE:  MOVWF  02
021B0:  RLCF   xFA,W
021B2:  MOVWF  03
021B4:  MOVF   02,W
021B6:  ADDLW  A1
021B8:  MOVWF  FE9
021BA:  MOVLW  04
021BC:  ADDWFC 03,W
021BE:  MOVWF  FEA
021C0:  MOVFF  6F8,FEC
021C4:  MOVF   FED,F
021C6:  MOVFF  6F7,FEF
....................   	} else if(index < ((PAGE_SIZE*8))) 
021CA:  BRA    21FE
021CC:  MOVF   xF6,W
021CE:  SUBLW  01
021D0:  BNC   21FE
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
021D2:  MOVLW  C0
021D4:  SUBWF  xF5,W
021D6:  MOVWF  xF9
021D8:  MOVLW  01
021DA:  SUBWFB xF6,W
021DC:  MOVWF  xFA
021DE:  BCF    FD8.0
021E0:  RLCF   xF9,W
021E2:  MOVWF  02
021E4:  RLCF   xFA,W
021E6:  MOVWF  03
021E8:  MOVF   02,W
021EA:  ADDLW  21
021EC:  MOVWF  FE9
021EE:  MOVLW  05
021F0:  ADDWFC 03,W
021F2:  MOVWF  FEA
021F4:  MOVFF  6F8,FEC
021F8:  MOVF   FED,F
021FA:  MOVFF  6F7,FEF
....................   	} 
....................  
.................... } 
021FE:  MOVLB  0
02200:  RETURN 0
....................  
....................  
.................... int16 READ_CONFIG_ADDRESS(int16 index)  
.................... {  
.................... 	int16 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
*
01BF4:  MOVLB  7
01BF6:  MOVF   x35,F
01BF8:  BNZ   1C26
01BFA:  MOVF   x34,W
01BFC:  SUBLW  3F
01BFE:  BNC   1C26
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_1[index]; 
01C00:  BCF    FD8.0
01C02:  RLCF   x34,W
01C04:  MOVWF  02
01C06:  RLCF   x35,W
01C08:  MOVWF  03
01C0A:  MOVF   02,W
01C0C:  ADDLW  A1
01C0E:  MOVWF  FE9
01C10:  MOVLW  01
01C12:  ADDWFC 03,W
01C14:  MOVWF  FEA
01C16:  MOVFF  FEC,03
01C1A:  MOVF   FED,F
01C1C:  MOVFF  FEF,736
01C20:  MOVFF  03,737
....................   	} else if(index < (PAGE_SIZE * 2)) 
01C24:  BRA    1DCC
01C26:  MOVF   x35,F
01C28:  BNZ   1C62
01C2A:  MOVF   x34,W
01C2C:  SUBLW  7F
01C2E:  BNC   1C62
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)]; 
01C30:  MOVLW  40
01C32:  SUBWF  x34,W
01C34:  MOVWF  x38
01C36:  MOVLW  00
01C38:  SUBWFB x35,W
01C3A:  MOVWF  x39
01C3C:  BCF    FD8.0
01C3E:  RLCF   x38,W
01C40:  MOVWF  02
01C42:  RLCF   x39,W
01C44:  MOVWF  03
01C46:  MOVF   02,W
01C48:  ADDLW  21
01C4A:  MOVWF  FE9
01C4C:  MOVLW  02
01C4E:  ADDWFC 03,W
01C50:  MOVWF  FEA
01C52:  MOVFF  FEC,03
01C56:  MOVF   FED,F
01C58:  MOVFF  FEF,736
01C5C:  MOVFF  03,737
....................   	}  else if(index < (PAGE_SIZE * 3)) 
01C60:  BRA    1DCC
01C62:  MOVF   x35,F
01C64:  BNZ   1C9E
01C66:  MOVF   x34,W
01C68:  SUBLW  BF
01C6A:  BNC   1C9E
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)]; 
01C6C:  MOVLW  80
01C6E:  SUBWF  x34,W
01C70:  MOVWF  x38
01C72:  MOVLW  00
01C74:  SUBWFB x35,W
01C76:  MOVWF  x39
01C78:  BCF    FD8.0
01C7A:  RLCF   x38,W
01C7C:  MOVWF  02
01C7E:  RLCF   x39,W
01C80:  MOVWF  03
01C82:  MOVF   02,W
01C84:  ADDLW  A1
01C86:  MOVWF  FE9
01C88:  MOVLW  02
01C8A:  ADDWFC 03,W
01C8C:  MOVWF  FEA
01C8E:  MOVFF  FEC,03
01C92:  MOVF   FED,F
01C94:  MOVFF  FEF,736
01C98:  MOVFF  03,737
....................   	}  else if(index < ((PAGE_SIZE*4))) 
01C9C:  BRA    1DCC
01C9E:  MOVF   x35,W
01CA0:  SUBLW  00
01CA2:  BNC   1CD6
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)]; 
01CA4:  MOVLW  C0
01CA6:  SUBWF  x34,W
01CA8:  MOVWF  x38
01CAA:  MOVLW  00
01CAC:  SUBWFB x35,W
01CAE:  MOVWF  x39
01CB0:  BCF    FD8.0
01CB2:  RLCF   x38,W
01CB4:  MOVWF  02
01CB6:  RLCF   x39,W
01CB8:  MOVWF  03
01CBA:  MOVF   02,W
01CBC:  ADDLW  21
01CBE:  MOVWF  FE9
01CC0:  MOVLW  03
01CC2:  ADDWFC 03,W
01CC4:  MOVWF  FEA
01CC6:  MOVFF  FEC,03
01CCA:  MOVF   FED,F
01CCC:  MOVFF  FEF,736
01CD0:  MOVFF  03,737
....................   	} else if(index < ((PAGE_SIZE*5))) 
01CD4:  BRA    1DCC
01CD6:  MOVF   x35,W
01CD8:  SUBLW  01
01CDA:  BNC   1D16
01CDC:  BNZ   1CE4
01CDE:  MOVF   x34,W
01CE0:  SUBLW  3F
01CE2:  BNC   1D16
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)];   
01CE4:  MOVLW  00
01CE6:  SUBWF  x34,W
01CE8:  MOVWF  x38
01CEA:  MOVLW  01
01CEC:  SUBWFB x35,W
01CEE:  MOVWF  x39
01CF0:  BCF    FD8.0
01CF2:  RLCF   x38,W
01CF4:  MOVWF  02
01CF6:  RLCF   x39,W
01CF8:  MOVWF  03
01CFA:  MOVF   02,W
01CFC:  ADDLW  A1
01CFE:  MOVWF  FE9
01D00:  MOVLW  03
01D02:  ADDWFC 03,W
01D04:  MOVWF  FEA
01D06:  MOVFF  FEC,03
01D0A:  MOVF   FED,F
01D0C:  MOVFF  FEF,736
01D10:  MOVFF  03,737
....................   	} else if(index < ((PAGE_SIZE*6))) 
01D14:  BRA    1DCC
01D16:  MOVF   x35,W
01D18:  SUBLW  01
01D1A:  BNC   1D56
01D1C:  BNZ   1D24
01D1E:  MOVF   x34,W
01D20:  SUBLW  7F
01D22:  BNC   1D56
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)]; 
01D24:  MOVLW  40
01D26:  SUBWF  x34,W
01D28:  MOVWF  x38
01D2A:  MOVLW  01
01D2C:  SUBWFB x35,W
01D2E:  MOVWF  x39
01D30:  BCF    FD8.0
01D32:  RLCF   x38,W
01D34:  MOVWF  02
01D36:  RLCF   x39,W
01D38:  MOVWF  03
01D3A:  MOVF   02,W
01D3C:  ADDLW  21
01D3E:  MOVWF  FE9
01D40:  MOVLW  04
01D42:  ADDWFC 03,W
01D44:  MOVWF  FEA
01D46:  MOVFF  FEC,03
01D4A:  MOVF   FED,F
01D4C:  MOVFF  FEF,736
01D50:  MOVFF  03,737
....................   	} else if(index < ((PAGE_SIZE*7))) 
01D54:  BRA    1DCC
01D56:  MOVF   x35,W
01D58:  SUBLW  01
01D5A:  BNC   1D96
01D5C:  BNZ   1D64
01D5E:  MOVF   x34,W
01D60:  SUBLW  BF
01D62:  BNC   1D96
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)]; 
01D64:  MOVLW  80
01D66:  SUBWF  x34,W
01D68:  MOVWF  x38
01D6A:  MOVLW  01
01D6C:  SUBWFB x35,W
01D6E:  MOVWF  x39
01D70:  BCF    FD8.0
01D72:  RLCF   x38,W
01D74:  MOVWF  02
01D76:  RLCF   x39,W
01D78:  MOVWF  03
01D7A:  MOVF   02,W
01D7C:  ADDLW  A1
01D7E:  MOVWF  FE9
01D80:  MOVLW  04
01D82:  ADDWFC 03,W
01D84:  MOVWF  FEA
01D86:  MOVFF  FEC,03
01D8A:  MOVF   FED,F
01D8C:  MOVFF  FEF,736
01D90:  MOVFF  03,737
....................   	} else if(index < ((PAGE_SIZE*8))) 
01D94:  BRA    1DCC
01D96:  MOVF   x35,W
01D98:  SUBLW  01
01D9A:  BNC   1DCC
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)]; 
01D9C:  MOVLW  C0
01D9E:  SUBWF  x34,W
01DA0:  MOVWF  x38
01DA2:  MOVLW  01
01DA4:  SUBWFB x35,W
01DA6:  MOVWF  x39
01DA8:  BCF    FD8.0
01DAA:  RLCF   x38,W
01DAC:  MOVWF  02
01DAE:  RLCF   x39,W
01DB0:  MOVWF  03
01DB2:  MOVF   02,W
01DB4:  ADDLW  21
01DB6:  MOVWF  FE9
01DB8:  MOVLW  05
01DBA:  ADDWFC 03,W
01DBC:  MOVWF  FEA
01DBE:  MOVFF  FEC,03
01DC2:  MOVF   FED,F
01DC4:  MOVFF  FEF,736
01DC8:  MOVFF  03,737
....................   	} 
....................  
.................... 	return(retval);  
01DCC:  MOVFF  736,01
01DD0:  MOVFF  737,02
.................... } 
01DD4:  MOVLB  0
01DD6:  RETURN 0
....................  
.................... /* 
.................... int32 READ_CONFIG_VALUE(int16 index)  
.................... {  
.................... 	int32 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_1[index];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_2[index - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE- PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else 
....................   	{  
....................    		retval = 0;  
....................   	}  
....................  
.................... 	return(retval);  
.................... } 
....................  
.................... void WRITE_CONFIG_VALUE(int16 index, int32 value)  
.................... {  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_2[index - PAGE_SIZE] = value;   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{     
.................... 		DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} 
.................... } 
....................  
.................... */ 
....................  
....................  
.................... #include <w25q80bv.c> 
.................... #define W25Q80BV_PAGE_LEN     		256  // in bytes 
.................... #define W25Q80BV_PAGES_PER_SECTOR	16 
....................  
.................... #define W25Q80BV_SECTOR_LEN			W25Q80BV_PAGE_LEN*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_SECTORS_PER_BLOCK	16 
....................  
.................... #define W25Q80BV_BLOCK_LEN			W25Q80BV_SECTOR_LEN*W25Q80BV_SECTORS_PER_BLOCK 
....................   	 
.................... #define W25Q80BV_NUM_BLOCKS			16 
.................... #define W25Q80BV_NUM_SECTORS		W25Q80BV_NUM_BLOCKS*W25Q80BV_SECTORS_PER_BLOCK 
.................... #define W25Q80BV_NUM_PAGES    		W25Q80BV_NUM_SECTORS*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_NUM_BYTES    		W25Q80BV_NUM_BLOCKS*W25Q80BV_BLOCK_LEN 
....................  
.................... #define W25Q80BV_WRITE_ENABLE 0x06 
.................... #define W25Q80BV_CHIP_ERASE   0xC7 
.................... #define W25Q80BV_SECTOR_ERASE 0x20 
.................... #define W25Q80BV_READ_STATUS1 0x05 
.................... #define W25Q80BV_PAGE_PROGRAM 0x02 
.................... #define W25Q80BV_DEVICE_ID    0xAB 
.................... #define W25Q80BV_UNIQUE_ID    0x4B 
....................  
.................... #define W25Q80BV_STATUS_BUSY  0x01 
....................  
.................... #define W25Q80BV_READ 0x03 
....................  
.................... #define W25Q80BV_DEVICE_ID_RES  0x13 /* Expected device_id for W25Q80BV */ 
....................  
.................... unsigned int32 page_address(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
*
010CA:  MOVFF  757,760
010CE:  MOVFF  756,75F
010D2:  MOVFF  755,75E
010D6:  MOVLB  7
010D8:  CLRF   x5D
010DA:  CLRF   x61
010DC:  RLCF   x61,W
010DE:  MOVWF  00
010E0:  RLCF   x51,W
010E2:  MOVWF  01
010E4:  RLCF   x52,W
010E6:  MOVWF  02
010E8:  RLCF   x53,W
010EA:  MOVWF  03
010EC:  RLCF   00,F
010EE:  RLCF   01,F
010F0:  RLCF   02,F
010F2:  RLCF   03,F
010F4:  RLCF   00,F
010F6:  RLCF   01,F
010F8:  RLCF   02,F
010FA:  RLCF   03,F
010FC:  RLCF   00,F
010FE:  RLCF   01,F
01100:  RLCF   02,F
01102:  RLCF   03,F
01104:  MOVLW  F0
01106:  ANDWF  00,F
01108:  MOVF   00,W
0110A:  ADDWF  x5D,F
0110C:  MOVF   01,W
0110E:  ADDWFC x5E,F
01110:  MOVF   02,W
01112:  ADDWFC x5F,F
01114:  MOVF   03,W
01116:  ADDWFC x60,F
01118:  MOVFF  74F,764
0111C:  MOVFF  74E,763
01120:  MOVFF  74D,762
01124:  CLRF   x61
01126:  RLCF   x61,F
01128:  RLCF   x62,F
0112A:  RLCF   x63,F
0112C:  RLCF   x64,F
0112E:  RLCF   x61,F
01130:  RLCF   x62,F
01132:  RLCF   x63,F
01134:  RLCF   x64,F
01136:  RLCF   x61,F
01138:  RLCF   x62,F
0113A:  RLCF   x63,F
0113C:  RLCF   x64,F
0113E:  RLCF   x61,F
01140:  RLCF   x62,F
01142:  RLCF   x63,F
01144:  RLCF   x64,F
01146:  MOVLW  F0
01148:  ANDWF  x61,F
0114A:  RLCF   x61,W
0114C:  MOVWF  00
0114E:  RLCF   x62,W
01150:  MOVWF  01
01152:  RLCF   x63,W
01154:  MOVWF  02
01156:  RLCF   x64,W
01158:  MOVWF  03
0115A:  RLCF   00,F
0115C:  RLCF   01,F
0115E:  RLCF   02,F
01160:  RLCF   03,F
01162:  RLCF   00,F
01164:  RLCF   01,F
01166:  RLCF   02,F
01168:  RLCF   03,F
0116A:  RLCF   00,F
0116C:  RLCF   01,F
0116E:  RLCF   02,F
01170:  RLCF   03,F
01172:  MOVLW  F0
01174:  ANDWF  00,F
01176:  MOVF   00,W
01178:  ADDWF  x5D,W
0117A:  MOVWF  x59
0117C:  MOVF   01,W
0117E:  ADDWFC x5E,W
01180:  MOVWF  x5A
01182:  MOVF   02,W
01184:  ADDWFC x5F,W
01186:  MOVWF  x5B
01188:  MOVF   03,W
0118A:  ADDWFC x60,W
0118C:  MOVWF  x5C
.................... 	unsigned int32 return_address = (page_index*W25Q80BV_PAGE_LEN) + (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
0118E:  MOVFF  759,00
01192:  MOVFF  75A,01
01196:  MOVFF  75B,02
0119A:  MOVFF  75C,03
.................... } 
0119E:  MOVLB  0
011A0:  RETURN 0
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
.................... 	unsigned int32 return_address = (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index) 
.................... { 
.................... 	unsigned int32 return_address = (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
....................  
.................... int flash_get_device_id() 
.................... { 
*
01596:  MOVLB  7
01598:  CLRF   x4D
.................... 	int data = 0; 
....................  
....................     output_low(FLASH_CS); 
0159A:  BCF    F95.2
0159C:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_DEVICE_ID); 
0159E:  MOVLW  AB
015A0:  MOVWF  x52
015A2:  MOVLW  08
015A4:  MOVWF  x53
015A6:  MOVLB  0
015A8:  RCALL  11A2
.................... 	 
.................... 	data = spi_xfer(0x00); 
015AA:  MOVLB  7
015AC:  CLRF   x52
015AE:  MOVLW  08
015B0:  MOVWF  x53
015B2:  MOVLB  0
015B4:  RCALL  11A2
015B6:  MOVF   01,W
015B8:  MOVFF  01,74D
.................... 	data = spi_xfer(0x00); 
015BC:  MOVLB  7
015BE:  CLRF   x52
015C0:  MOVLW  08
015C2:  MOVWF  x53
015C4:  MOVLB  0
015C6:  RCALL  11A2
015C8:  MOVF   01,W
015CA:  MOVFF  01,74D
.................... 	data = spi_xfer(0x00); 
015CE:  MOVLB  7
015D0:  CLRF   x52
015D2:  MOVLW  08
015D4:  MOVWF  x53
015D6:  MOVLB  0
015D8:  RCALL  11A2
015DA:  MOVF   01,W
015DC:  MOVFF  01,74D
....................  
.................... 	data = spi_xfer(0xFF); 
015E0:  MOVLB  7
015E2:  SETF   x52
015E4:  MOVLW  08
015E6:  MOVWF  x53
015E8:  MOVLB  0
015EA:  RCALL  11A2
015EC:  MOVF   01,W
015EE:  MOVFF  01,74D
....................  
.................... 	output_high(FLASH_CS); 
015F2:  BCF    F95.2
015F4:  BSF    F8C.2
....................  
.................... 	return data; 
015F6:  MOVLB  7
015F8:  MOVFF  74D,01
.................... } 
015FC:  MOVLB  0
015FE:  GOTO   16A8 (RETURN)
....................  
.................... short verify_device_id() 
.................... { 
.................... 	if(flash_get_device_id() == W25Q80BV_DEVICE_ID_RES) { 
.................... 		return 1; 
.................... 	} else { 
.................... 		return 0; 
.................... 	} 
.................... } 
....................  
.................... int flash_get_status() 
.................... { 
01602:  MOVLB  7
01604:  CLRF   x4D
.................... 	int value = 0; 
.................... 	output_low(FLASH_CS); 
01606:  BCF    F95.2
01608:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ_STATUS1); 
0160A:  MOVLW  05
0160C:  MOVWF  x52
0160E:  MOVLW  08
01610:  MOVWF  x53
01612:  MOVLB  0
01614:  RCALL  11A2
....................     value = spi_xfer(0x00); 
01616:  MOVLB  7
01618:  CLRF   x52
0161A:  MOVLW  08
0161C:  MOVWF  x53
0161E:  MOVLB  0
01620:  RCALL  11A2
01622:  MOVF   01,W
01624:  MOVFF  01,74D
....................     output_high(FLASH_CS); 
01628:  BCF    F95.2
0162A:  BSF    F8C.2
.................... 	 
.................... 	return value; 
0162C:  MOVLB  7
0162E:  MOVFF  74D,01
.................... } 
01632:  MOVLB  0
01634:  RETURN 0
....................  
.................... void flash_wait_while_busy() 
.................... { 
.................... 	while ((flash_get_status() & W25Q80BV_STATUS_BUSY)) 
.................... 	{ 
01636:  RCALL  1602
01638:  BTFSS  01.0
0163A:  BRA    163E
.................... 	} 
0163C:  BRA    1636
.................... } 
0163E:  RETURN 0
....................  
.................... void flash_write_enable() 
.................... { 
.................... 	flash_wait_while_busy(); 
01640:  RCALL  1636
.................... 	output_low(FLASH_CS); 
01642:  BCF    F95.2
01644:  BCF    F8C.2
.................... 	spi_xfer(0x06); 
01646:  MOVLW  06
01648:  MOVLB  7
0164A:  MOVWF  x52
0164C:  MOVLW  08
0164E:  MOVWF  x53
01650:  MOVLB  0
01652:  RCALL  11A2
....................     output_high(FLASH_CS); 
01654:  BCF    F95.2
01656:  BSF    F8C.2
.................... } 
01658:  RETURN 0
....................  
.................... void flash_chip_erase() 
.................... { 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting chip erase...\r\n"); 
.................... 		} 
....................         int device_id = 0; 
....................  
....................         device_id = 0; 
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
....................                 device_id = flash_get_device_id(); 
....................         } 
....................  
....................         flash_write_enable(); 
....................         flash_wait_while_busy(); 
.................... 		output_low(PIN_C0); 
....................         output_low(FLASH_CS); 
....................         spi_xfer(W25Q80BV_CHIP_ERASE); 
....................         output_high(FLASH_CS); 
.................... 		 
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
.................... 		} 
.................... 		output_high(PIN_C0); 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
.................... } 
....................  
.................... void flash_sector_erase(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
0165A:  MOVLB  7
0165C:  CLRF   x48
0165E:  MOVFF  743,750
01662:  MOVFF  742,74F
01666:  MOVFF  741,74E
0166A:  MOVFF  740,74D
0166E:  MOVFF  747,754
01672:  MOVFF  746,753
01676:  MOVFF  745,752
0167A:  MOVFF  744,751
0167E:  CLRF   x58
01680:  CLRF   x57
01682:  CLRF   x56
01684:  CLRF   x55
01686:  MOVLB  0
01688:  RCALL  10CA
0168A:  MOVFF  03,74C
0168E:  MOVFF  02,74B
01692:  MOVFF  01,74A
01696:  MOVFF  00,749
....................         int device_id = 0; 
....................  
.................... 		unsigned int32 starting_address = page_address(block_index,sector_index,0); 
....................  
....................         device_id = 0; 
0169A:  MOVLB  7
0169C:  CLRF   x48
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
0169E:  MOVF   x48,W
016A0:  SUBLW  13
016A2:  BZ    16B0
....................                 device_id = flash_get_device_id(); 
016A4:  MOVLB  0
016A6:  BRA    1596
016A8:  MOVFF  01,748
....................         } 
016AC:  MOVLB  7
016AE:  BRA    169E
....................  
....................         flash_write_enable(); 
016B0:  MOVLB  0
016B2:  RCALL  1640
....................         flash_wait_while_busy(); 
016B4:  RCALL  1636
....................         output_low(FLASH_CS); 
016B6:  BCF    F95.2
016B8:  BCF    F8C.2
....................         spi_xfer(W25Q80BV_SECTOR_ERASE); 
016BA:  MOVLW  20
016BC:  MOVLB  7
016BE:  MOVWF  x52
016C0:  MOVLW  08
016C2:  MOVWF  x53
016C4:  MOVLB  0
016C6:  RCALL  11A2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
016C8:  MOVLB  7
016CA:  CLRF   x4D
016CC:  CLRF   x4E
016CE:  MOVFF  74B,74F
016D2:  CLRF   x50
016D4:  MOVFF  74B,74D
016D8:  MOVFF  750,74E
016DC:  CLRF   x4F
016DE:  CLRF   x50
016E0:  MOVFF  74B,752
016E4:  MOVLW  08
016E6:  MOVWF  x53
016E8:  MOVLB  0
016EA:  RCALL  11A2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
016EC:  MOVLB  7
016EE:  CLRF   x4D
016F0:  CLRF   x4F
016F2:  CLRF   x50
016F4:  MOVFF  74A,74D
016F8:  MOVFF  74F,74E
016FC:  MOVFF  750,74F
01700:  CLRF   x50
01702:  MOVFF  74A,752
01706:  MOVLW  08
01708:  MOVWF  x53
0170A:  MOVLB  0
0170C:  RCALL  11A2
.................... 		spi_xfer(starting_address & 0xFF); 
0170E:  MOVLB  7
01710:  MOVFF  749,74D
01714:  CLRF   x4E
01716:  CLRF   x4F
01718:  CLRF   x50
0171A:  MOVFF  749,752
0171E:  MOVLW  08
01720:  MOVWF  x53
01722:  MOVLB  0
01724:  RCALL  11A2
....................         output_high(FLASH_CS); 
01726:  BCF    F95.2
01728:  BSF    F8C.2
....................  
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
0172A:  RCALL  1602
0172C:  BTFSS  01.0
0172E:  BRA    1732
.................... 		} 
01730:  BRA    172A
....................  
.................... } 
01732:  RETURN 0
....................  
.................... int flash_write_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		spi_xfer(ptr[i]); 
.................... 		rolling_checksum += ptr[i]; 
.................... 	} 
.................... 	 
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void flash_read_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_read_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < number_of_bytes; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_write_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(block_index,sector_index); 
....................  
.................... 	starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
.................... 	 
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 	for (value_counter = 0; value_counter < number_of_bytes; value_counter++) 
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
....................  
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... /* DEBUG STUFF */ 
....................  
.................... void flash_print_page(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	//starting_address = 0; 
.................... 	fprintf(RS232,"\r\nPrinting flash at starting address (%u,%u,%u) %lu\r\n",block_index,sector_index,page_index,starting_address); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		printf("%x",data); 
....................  
.................... 		if((i % 4) == 3) { 
.................... 			printf(" "); 
.................... 		} 
....................  
.................... 		if((i % 32) == 31) { 
.................... 			printf("\r\n"); 
.................... 		} 
.................... 	} 
.................... 	output_high(FLASH_CS); 
.................... } 
....................  
....................  
.................... int flash_page_checksum(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		rolling_checksum += data; 
.................... 	} 
.................... 	output_high(FLASH_CS); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
.................... /* 
.................... void FLASH_PROGRAM_WRITE(int program_index) {  
....................     
....................  
....................     // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		flash_sector_erase(program_index,sector_counter); 
.................... 		//fprintf(RS232,"Status1: %x\r\n",flash_get_status()); 
.................... 		//delay_ms(40); 
.................... 		//fprintf(RS232,"Status2: %x\r\n",flash_get_status()); 
.................... 		//ptr = &DSP_CONFIG.TEST_VALUES[0]; 
.................... 		starting_address = page_address(program_index,sector_counter,0); 
.................... 		flash_write_enable(); 
.................... 		flash_wait_while_busy(); 
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			spi_xfer(ptr[value_counter]); 
.................... 			test_val++; 
.................... 			value_counter++; 
.................... 		} 
.................... 		 
.................... 		output_high(FLASH_CS); 
....................  
.................... 		flash_wait_while_busy(); 
.................... 	} 
.................... } 
.................... */ 
.................... /* 
.................... void FLASH_PROGRAM_READ(int program_index) 
.................... { 
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
....................  
.................... 		starting_address = page_address(program_index,sector_counter,0); 
....................  
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_READ); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
.................... 			ptr[value_counter] = data; 
.................... 			value_counter++; 
....................  
.................... 			//fprintf(RS232,"%x||",data); 
.................... 		} 
....................  
.................... 		output_high(FLASH_CS); 
.................... 	} 
.................... } 
.................... */ 
.................... void FLASH_ADDR_WRITE(int block_index) {  
*
04BA2:  MOVLB  6
04BA4:  CLRF   xF7
04BA6:  CLRF   xF6
....................     
....................  
....................    // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
04BA8:  MOVLW  01
04BAA:  MOVWF  xF7
04BAC:  MOVLW  A1
04BAE:  MOVWF  xF6
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
04BB0:  CLRF   xF9
04BB2:  CLRF   xF8
04BB4:  CLRF   xFD
04BB6:  CLRF   xFC
04BB8:  CLRF   xFB
04BBA:  CLRF   xFA
04BBC:  CLRF   xFF
04BBE:  CLRF   xFE
04BC0:  MOVLB  7
04BC2:  CLRF   x01
04BC4:  CLRF   x00
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
04BC6:  CLRF   x02
04BC8:  MOVF   x02,W
04BCA:  SUBLW  03
04BCC:  BTFSS  FD8.0
04BCE:  BRA    4CF8
.................... 		 
.................... 		flash_sector_erase(block_index,sector_counter); 
04BD0:  CLRF   x43
04BD2:  CLRF   x42
04BD4:  CLRF   x41
04BD6:  MOVFF  6F5,740
04BDA:  CLRF   x47
04BDC:  CLRF   x46
04BDE:  CLRF   x45
04BE0:  MOVFF  702,744
04BE4:  MOVLB  0
04BE6:  CALL   165A
.................... 		starting_address = page_address(block_index,sector_counter,0); 
04BEA:  MOVLB  7
04BEC:  CLRF   x50
04BEE:  CLRF   x4F
04BF0:  CLRF   x4E
04BF2:  MOVFF  6F5,74D
04BF6:  CLRF   x54
04BF8:  CLRF   x53
04BFA:  CLRF   x52
04BFC:  MOVFF  702,751
04C00:  CLRF   x58
04C02:  CLRF   x57
04C04:  CLRF   x56
04C06:  CLRF   x55
04C08:  MOVLB  0
04C0A:  CALL   10CA
04C0E:  MOVFF  03,6FD
04C12:  MOVFF  02,6FC
04C16:  MOVFF  01,6FB
04C1A:  MOVFF  00,6FA
.................... 		flash_write_enable(); 
04C1E:  CALL   1640
.................... 		flash_wait_while_busy(); 
04C22:  CALL   1636
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
04C26:  BCF    F95.2
04C28:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
04C2A:  MOVLW  02
04C2C:  MOVLB  7
04C2E:  MOVWF  x52
04C30:  MOVLW  08
04C32:  MOVWF  x53
04C34:  MOVLB  0
04C36:  CALL   11A2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
04C3A:  MOVLB  7
04C3C:  CLRF   x03
04C3E:  CLRF   x04
04C40:  MOVFF  6FC,705
04C44:  MOVLB  7
04C46:  CLRF   x06
04C48:  MOVFF  6FC,703
04C4C:  MOVFF  706,704
04C50:  CLRF   x05
04C52:  CLRF   x06
04C54:  MOVFF  6FC,752
04C58:  MOVLW  08
04C5A:  MOVWF  x53
04C5C:  MOVLB  0
04C5E:  CALL   11A2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
04C62:  MOVLB  7
04C64:  CLRF   x03
04C66:  MOVLB  7
04C68:  CLRF   x05
04C6A:  CLRF   x06
04C6C:  MOVFF  6FB,703
04C70:  MOVFF  705,704
04C74:  MOVFF  706,705
04C78:  CLRF   x06
04C7A:  MOVFF  6FB,752
04C7E:  MOVLW  08
04C80:  MOVWF  x53
04C82:  MOVLB  0
04C84:  CALL   11A2
.................... 		spi_xfer(starting_address & 0xFF); 
04C88:  MOVFF  6FA,703
04C8C:  MOVLB  7
04C8E:  CLRF   x04
04C90:  CLRF   x05
04C92:  CLRF   x06
04C94:  MOVFF  6FA,752
04C98:  MOVLW  08
04C9A:  MOVWF  x53
04C9C:  MOVLB  0
04C9E:  CALL   11A2
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
04CA2:  MOVLB  7
04CA4:  CLRF   x01
04CA6:  CLRF   x00
04CA8:  MOVF   x01,W
04CAA:  SUBLW  00
04CAC:  BNC   4CE8
.................... 		{ 
.................... 			//spi_xfer(value_counter); 
.................... 			spi_xfer(ptr[value_counter]); 
04CAE:  MOVLB  6
04CB0:  MOVF   xF6,W
04CB2:  ADDWF  xF8,W
04CB4:  MOVWF  FE9
04CB6:  MOVF   xF7,W
04CB8:  ADDWFC xF9,W
04CBA:  MOVWF  FEA
04CBC:  MOVFF  FEF,703
04CC0:  MOVFF  703,752
04CC4:  MOVLW  08
04CC6:  MOVLB  7
04CC8:  MOVWF  x53
04CCA:  MOVLB  0
04CCC:  CALL   11A2
.................... 			test_val++; 
04CD0:  MOVLB  6
04CD2:  INCF   xFE,F
04CD4:  BTFSC  FD8.2
04CD6:  INCF   xFF,F
.................... 			value_counter++; 
04CD8:  INCF   xF8,F
04CDA:  BTFSC  FD8.2
04CDC:  INCF   xF9,F
.................... 		} 
04CDE:  MOVLB  7
04CE0:  INCF   x00,F
04CE2:  BTFSC  FD8.2
04CE4:  INCF   x01,F
04CE6:  BRA    4CA8
.................... 		 
.................... 		output_high(FLASH_CS); 
04CE8:  BCF    F95.2
04CEA:  BSF    F8C.2
....................  
.................... 		flash_wait_while_busy(); 
04CEC:  MOVLB  0
04CEE:  CALL   1636
....................  
.................... 		//fprintf(RS232,"Wrote %lu bytes\r\n",test_val); 
.................... 		 
.................... 	} 
04CF2:  MOVLB  7
04CF4:  INCF   x02,F
04CF6:  BRA    4BC8
.................... } 
04CF8:  MOVLB  0
04CFA:  GOTO   8D24 (RETURN)
....................  
....................  
.................... void FLASH_ADDR_READ() 
.................... { 
*
011DE:  MOVLB  6
011E0:  CLRF   xF8
011E2:  CLRF   xF7
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
011E4:  MOVLW  01
011E6:  MOVWF  xF8
011E8:  MOVLW  A1
011EA:  MOVWF  xF7
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
011EC:  CLRF   xFC
011EE:  CLRF   xFB
011F0:  CLRF   xFA
011F2:  CLRF   xF9
011F4:  CLRF   xFE
011F6:  CLRF   xFD
011F8:  CLRF   xFF
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
011FA:  MOVLB  7
011FC:  CLRF   x00
011FE:  MOVF   x00,W
01200:  SUBLW  03
01202:  BTFSS  FD8.0
01204:  BRA    12F0
....................  
.................... 		starting_address = page_address(DEFAULT_ADDR_BLOCK,sector_counter,0); 
01206:  CLRF   x50
01208:  CLRF   x4F
0120A:  CLRF   x4E
0120C:  MOVLW  0E
0120E:  MOVWF  x4D
01210:  CLRF   x54
01212:  CLRF   x53
01214:  CLRF   x52
01216:  MOVFF  700,751
0121A:  CLRF   x58
0121C:  CLRF   x57
0121E:  CLRF   x56
01220:  CLRF   x55
01222:  MOVLB  0
01224:  RCALL  10CA
01226:  MOVFF  03,6FC
0122A:  MOVFF  02,6FB
0122E:  MOVFF  01,6FA
01232:  MOVFF  00,6F9
....................  
.................... 		output_low(FLASH_CS); 
01236:  BCF    F95.2
01238:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_READ); 
0123A:  MOVLW  03
0123C:  MOVLB  7
0123E:  MOVWF  x52
01240:  MOVLW  08
01242:  MOVWF  x53
01244:  MOVLB  0
01246:  RCALL  11A2
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
01248:  MOVLB  7
0124A:  CLRF   x03
0124C:  CLRF   x04
0124E:  MOVFF  6FB,705
01252:  MOVLB  7
01254:  CLRF   x06
01256:  MOVFF  6FB,703
0125A:  MOVFF  706,704
0125E:  CLRF   x05
01260:  CLRF   x06
01262:  MOVFF  6FB,752
01266:  MOVLW  08
01268:  MOVWF  x53
0126A:  MOVLB  0
0126C:  RCALL  11A2
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
0126E:  MOVLB  7
01270:  CLRF   x03
01272:  MOVLB  7
01274:  CLRF   x05
01276:  CLRF   x06
01278:  MOVFF  6FA,703
0127C:  MOVFF  705,704
01280:  MOVFF  706,705
01284:  CLRF   x06
01286:  MOVFF  6FA,752
0128A:  MOVLW  08
0128C:  MOVWF  x53
0128E:  MOVLB  0
01290:  RCALL  11A2
.................... 		spi_xfer(starting_address & 0xFF); 
01292:  MOVFF  6F9,703
01296:  MOVLB  7
01298:  CLRF   x04
0129A:  CLRF   x05
0129C:  CLRF   x06
0129E:  MOVFF  6F9,752
012A2:  MOVLW  08
012A4:  MOVWF  x53
012A6:  MOVLB  0
012A8:  RCALL  11A2
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
012AA:  MOVLB  7
012AC:  CLRF   x02
012AE:  CLRF   x01
012B0:  MOVF   x02,W
012B2:  SUBLW  00
012B4:  BNC   12E8
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
012B6:  CLRF   x52
012B8:  MOVLW  08
012BA:  MOVWF  x53
012BC:  MOVLB  0
012BE:  RCALL  11A2
012C0:  MOVF   01,W
012C2:  MOVFF  01,6FF
.................... 			ptr[value_counter] = data; 
012C6:  MOVLB  6
012C8:  MOVF   xF7,W
012CA:  ADDWF  xFD,W
012CC:  MOVWF  FE9
012CE:  MOVF   xF8,W
012D0:  ADDWFC xFE,W
012D2:  MOVWF  FEA
012D4:  MOVFF  6FF,FEF
.................... 			value_counter++; 
012D8:  INCF   xFD,F
012DA:  BTFSC  FD8.2
012DC:  INCF   xFE,F
.................... 			 
.................... 		} 
012DE:  MOVLB  7
012E0:  INCF   x01,F
012E2:  BTFSC  FD8.2
012E4:  INCF   x02,F
012E6:  BRA    12B0
....................  
.................... 		output_high(FLASH_CS); 
012E8:  BCF    F95.2
012EA:  BSF    F8C.2
.................... 	} 
012EC:  INCF   x00,F
012EE:  BRA    11FE
.................... } 
012F0:  MOVLB  0
012F2:  GOTO   1968 (RETURN)
....................  
.................... /* 
.................... void PRINT_READ_PROGRAM() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
.................... */ 
.................... void PRINT_READ_ADDR() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void FLASH_COPY_PROGRAM(int from_index, int to_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\nCopying program from %u to %u ... ",from_index,to_index); 
*
0509C:  MOVLW  1A
0509E:  MOVWF  FF6
050A0:  MOVLW  09
050A2:  MOVWF  FF7
050A4:  MOVLW  17
050A6:  MOVLB  7
050A8:  MOVWF  x3C
050AA:  MOVLB  0
050AC:  CALL   0FD0
050B0:  MOVFF  72E,73C
050B4:  MOVLW  1B
050B6:  MOVLB  7
050B8:  MOVWF  x3D
050BA:  MOVLB  0
050BC:  CALL   1026
050C0:  MOVLW  33
050C2:  MOVWF  FF6
050C4:  MOVLW  09
050C6:  MOVWF  FF7
050C8:  MOVLW  04
050CA:  MOVLB  7
050CC:  MOVWF  x3C
050CE:  MOVLB  0
050D0:  CALL   0FD0
050D4:  MOVFF  72F,73C
050D8:  MOVLW  1B
050DA:  MOVLB  7
050DC:  MOVWF  x3D
050DE:  MOVLB  0
050E0:  CALL   1026
050E4:  MOVLW  39
050E6:  MOVWF  FF6
050E8:  MOVLW  09
050EA:  MOVWF  FF7
050EC:  MOVLW  05
050EE:  MOVLB  7
050F0:  MOVWF  x3C
050F2:  MOVLB  0
050F4:  CALL   0FD0
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int32 read_starting_address = 0; 
.................... 	int32 write_starting_address = 0; 
.................... 	 
.................... 	int read_data = 0; 
050F8:  MOVLB  7
050FA:  CLRF   x33
050FC:  CLRF   x32
050FE:  CLRF   x31
05100:  CLRF   x30
05102:  CLRF   x37
05104:  CLRF   x36
05106:  CLRF   x35
05108:  CLRF   x34
0510A:  CLRF   x38
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
0510C:  CLRF   x39
0510E:  MOVF   x39,W
05110:  SUBLW  0B
05112:  BTFSS  FD8.0
05114:  BRA    52FE
....................  
.................... 		flash_sector_erase(to_index,sector_counter); 
05116:  CLRF   x43
05118:  CLRF   x42
0511A:  CLRF   x41
0511C:  MOVFF  72F,740
05120:  CLRF   x47
05122:  CLRF   x46
05124:  CLRF   x45
05126:  MOVFF  739,744
0512A:  MOVLB  0
0512C:  CALL   165A
....................  
.................... 		write_starting_address = page_address(to_index,sector_counter,0); 
05130:  MOVLB  7
05132:  CLRF   x50
05134:  CLRF   x4F
05136:  CLRF   x4E
05138:  MOVFF  72F,74D
0513C:  CLRF   x54
0513E:  CLRF   x53
05140:  CLRF   x52
05142:  MOVFF  739,751
05146:  CLRF   x58
05148:  CLRF   x57
0514A:  CLRF   x56
0514C:  CLRF   x55
0514E:  MOVLB  0
05150:  CALL   10CA
05154:  MOVFF  03,737
05158:  MOVFF  02,736
0515C:  MOVFF  01,735
05160:  MOVFF  00,734
.................... 		read_starting_address = page_address(from_index,sector_counter,0); 
05164:  MOVLB  7
05166:  CLRF   x50
05168:  CLRF   x4F
0516A:  CLRF   x4E
0516C:  MOVFF  72E,74D
05170:  CLRF   x54
05172:  CLRF   x53
05174:  CLRF   x52
05176:  MOVFF  739,751
0517A:  CLRF   x58
0517C:  CLRF   x57
0517E:  CLRF   x56
05180:  CLRF   x55
05182:  MOVLB  0
05184:  CALL   10CA
05188:  MOVFF  03,733
0518C:  MOVFF  02,732
05190:  MOVFF  01,731
05194:  MOVFF  00,730
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
05198:  MOVLB  7
0519A:  CLRF   x3B
0519C:  CLRF   x3A
0519E:  MOVF   x3B,W
051A0:  SUBLW  00
051A2:  BTFSS  FD8.0
051A4:  BRA    52FA
.................... 		{ 
.................... 			output_low(FLASH_CS); 
051A6:  BCF    F95.2
051A8:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_READ); 
051AA:  MOVLW  03
051AC:  MOVWF  x52
051AE:  MOVLW  08
051B0:  MOVWF  x53
051B2:  MOVLB  0
051B4:  CALL   11A2
.................... 			spi_xfer((read_starting_address & 0xFF0000) >> 16); 
051B8:  MOVLB  7
051BA:  CLRF   x3C
051BC:  CLRF   x3D
051BE:  MOVFF  732,73E
051C2:  CLRF   x3F
051C4:  MOVFF  732,73C
051C8:  MOVFF  73F,73D
051CC:  CLRF   x3E
051CE:  CLRF   x3F
051D0:  MOVFF  732,752
051D4:  MOVLW  08
051D6:  MOVWF  x53
051D8:  MOVLB  0
051DA:  CALL   11A2
.................... 			spi_xfer((read_starting_address & 0xFF00) >> 8); 
051DE:  MOVLB  7
051E0:  CLRF   x3C
051E2:  CLRF   x3E
051E4:  CLRF   x3F
051E6:  MOVFF  731,73C
051EA:  MOVFF  73E,73D
051EE:  MOVFF  73F,73E
051F2:  CLRF   x3F
051F4:  MOVFF  731,752
051F8:  MOVLW  08
051FA:  MOVWF  x53
051FC:  MOVLB  0
051FE:  CALL   11A2
.................... 			spi_xfer(read_starting_address & 0xFF); 
05202:  MOVLB  7
05204:  MOVFF  730,73C
05208:  CLRF   x3D
0520A:  CLRF   x3E
0520C:  CLRF   x3F
0520E:  MOVFF  730,752
05212:  MOVLW  08
05214:  MOVWF  x53
05216:  MOVLB  0
05218:  CALL   11A2
.................... 		 
.................... 			read_data = spi_xfer(0x00); 
0521C:  MOVLB  7
0521E:  CLRF   x52
05220:  MOVLW  08
05222:  MOVWF  x53
05224:  MOVLB  0
05226:  CALL   11A2
0522A:  MOVF   01,W
0522C:  MOVFF  01,738
....................  
.................... 			output_high(FLASH_CS); 
05230:  BCF    F95.2
05232:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
05234:  CALL   1636
....................  
.................... 			flash_write_enable(); 
05238:  CALL   1640
.................... 			flash_wait_while_busy(); 
0523C:  CALL   1636
....................  
.................... 			output_low(FLASH_CS); 
05240:  BCF    F95.2
05242:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_PAGE_PROGRAM); 
05244:  MOVLW  02
05246:  MOVLB  7
05248:  MOVWF  x52
0524A:  MOVLW  08
0524C:  MOVWF  x53
0524E:  MOVLB  0
05250:  CALL   11A2
.................... 			spi_xfer((write_starting_address & 0xFF0000) >> 16); 
05254:  MOVLB  7
05256:  CLRF   x3C
05258:  CLRF   x3D
0525A:  MOVFF  736,73E
0525E:  CLRF   x3F
05260:  MOVFF  736,73C
05264:  MOVFF  73F,73D
05268:  CLRF   x3E
0526A:  CLRF   x3F
0526C:  MOVFF  736,752
05270:  MOVLW  08
05272:  MOVWF  x53
05274:  MOVLB  0
05276:  CALL   11A2
.................... 			spi_xfer((write_starting_address & 0xFF00) >> 8); 
0527A:  MOVLB  7
0527C:  CLRF   x3C
0527E:  CLRF   x3E
05280:  CLRF   x3F
05282:  MOVFF  735,73C
05286:  MOVFF  73E,73D
0528A:  MOVFF  73F,73E
0528E:  CLRF   x3F
05290:  MOVFF  735,752
05294:  MOVLW  08
05296:  MOVWF  x53
05298:  MOVLB  0
0529A:  CALL   11A2
.................... 			spi_xfer(write_starting_address & 0xFF); 
0529E:  MOVLB  7
052A0:  MOVFF  734,73C
052A4:  CLRF   x3D
052A6:  CLRF   x3E
052A8:  CLRF   x3F
052AA:  MOVFF  734,752
052AE:  MOVLW  08
052B0:  MOVWF  x53
052B2:  MOVLB  0
052B4:  CALL   11A2
....................  
.................... 			spi_xfer(read_data); 
052B8:  MOVFF  738,752
052BC:  MOVLW  08
052BE:  MOVLB  7
052C0:  MOVWF  x53
052C2:  MOVLB  0
052C4:  CALL   11A2
....................  
.................... 			output_high(FLASH_CS); 
052C8:  BCF    F95.2
052CA:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
052CC:  CALL   1636
....................  
.................... 			read_starting_address++; 
052D0:  MOVLW  01
052D2:  MOVLB  7
052D4:  ADDWF  x30,F
052D6:  BTFSC  FD8.0
052D8:  INCF   x31,F
052DA:  BTFSC  FD8.2
052DC:  INCF   x32,F
052DE:  BTFSC  FD8.2
052E0:  INCF   x33,F
.................... 			write_starting_address++; 
052E2:  MOVLW  01
052E4:  ADDWF  x34,F
052E6:  BTFSC  FD8.0
052E8:  INCF   x35,F
052EA:  BTFSC  FD8.2
052EC:  INCF   x36,F
052EE:  BTFSC  FD8.2
052F0:  INCF   x37,F
....................  
.................... 			//fprintf(RS232,"%x||",read_data); 
.................... 		} 
052F2:  INCF   x3A,F
052F4:  BTFSC  FD8.2
052F6:  INCF   x3B,F
052F8:  BRA    519E
.................... 	} 
052FA:  INCF   x39,F
052FC:  BRA    510E
....................  
.................... 	fprintf(RS232,"DONE!\r\n"); 
052FE:  MOVLW  40
05300:  MOVWF  FF6
05302:  MOVLW  09
05304:  MOVWF  FF7
05306:  MOVLB  0
05308:  CALL   0FAE
.................... } 
0530C:  GOTO   69F8 (RETURN)
....................  
.................... void FLASH_COMPARE_PROGRAM(int a_index, int b_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\Comparing programs %u and %u ... ",a_index,b_index); 
....................  
.................... 	int32 compare_a_starting_address = 0; 
.................... 	int32 compare_b_starting_address = 0; 
.................... 	 
.................... 	int read_data_a = 0; 
.................... 	int read_data_b = 0; 
....................  
.................... 	int errors_found = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
....................  
....................  
.................... 		compare_a_starting_address = page_address(a_index,sector_counter,0); 
.................... 		compare_b_starting_address = page_address(b_index,sector_counter,0); 
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_a_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_a = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
....................  
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_b_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_b = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
.................... 			compare_a_starting_address++; 
.................... 			compare_b_starting_address++; 
....................  
.................... 			if(read_data_a != read_data_b) { 
.................... 				fprintf(RS232,"[ERROR] found in sector %u at address %lu. A = %x, B = %x\r\n",sector_counter,i,read_data_a,read_data_b); 
.................... 				errors_found++; 
.................... 			} else { 
.................... 				//fprintf(RS232,"%x == %x ",read_data_a,read_data_b); 
.................... 				 
.................... 			} 
.................... 		} 
....................  
.................... 		//fprintf(RS232,"Completed sector %u, %u errors found.\r\n",sector_counter,errors_in_sector); 
.................... 	} 
....................  
.................... 	fprintf(RS232,"%u errors found\r\n",errors_found); 
.................... } 
....................  
.................... int addr_index_to_page_index(int16 addr_index) { 
.................... 	return (int)(addr_index / PAGE_SIZE); 
*
04E4E:  MOVLB  7
04E50:  RRCF   x2F,W
04E52:  MOVWF  03
04E54:  RRCF   x2E,W
04E56:  MOVWF  02
04E58:  RRCF   03,F
04E5A:  RRCF   02,F
04E5C:  RRCF   03,F
04E5E:  RRCF   02,F
04E60:  RRCF   03,F
04E62:  RRCF   02,F
04E64:  RRCF   03,F
04E66:  RRCF   02,F
04E68:  RRCF   03,F
04E6A:  RRCF   02,F
04E6C:  MOVLW  03
04E6E:  ANDWF  03,F
04E70:  MOVFF  02,01
.................... } 
04E74:  MOVLB  0
04E76:  RETURN 0
....................  
.................... int addr_index_to_buffer_index(int16 addr_index) { 
.................... 	return (int)(addr_index % PAGE_SIZE); 
04E78:  MOVLB  7
04E7A:  MOVF   x2E,W
04E7C:  ANDLW  3F
04E7E:  MOVWF  00
04E80:  CLRF   03
04E82:  MOVWF  01
.................... } 
04E84:  MOVLB  0
04E86:  GOTO   63A6 (RETURN)
....................  
.................... void read_flash_page_into_buffer(int *ptr,int program_index, int page_index)  
.................... { 
*
014AC:  MOVLB  7
014AE:  CLRF   x3B
014B0:  CLRF   x3A
014B2:  CLRF   x39
014B4:  CLRF   x38
014B6:  CLRF   x3C
.................... 	int32 starting_address = 0; 
.................... 	int data = 0; 
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
014B8:  CLRF   x50
014BA:  CLRF   x4F
014BC:  CLRF   x4E
014BE:  MOVFF  736,74D
014C2:  CLRF   x54
014C4:  CLRF   x53
014C6:  CLRF   x52
014C8:  MOVFF  737,751
014CC:  CLRF   x58
014CE:  CLRF   x57
014D0:  CLRF   x56
014D2:  CLRF   x55
014D4:  MOVLB  0
014D6:  RCALL  10CA
014D8:  MOVFF  03,73B
014DC:  MOVFF  02,73A
014E0:  MOVFF  01,739
014E4:  MOVFF  00,738
....................  
.................... 	output_low(FLASH_CS); 
014E8:  BCF    F95.2
014EA:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ); 
014EC:  MOVLW  03
014EE:  MOVLB  7
014F0:  MOVWF  x52
014F2:  MOVLW  08
014F4:  MOVWF  x53
014F6:  MOVLB  0
014F8:  RCALL  11A2
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
014FA:  MOVLB  7
014FC:  CLRF   x3F
014FE:  CLRF   x40
01500:  MOVFF  73A,741
01504:  CLRF   x42
01506:  MOVFF  73A,73F
0150A:  MOVFF  742,740
0150E:  CLRF   x41
01510:  CLRF   x42
01512:  MOVFF  73A,752
01516:  MOVLW  08
01518:  MOVWF  x53
0151A:  MOVLB  0
0151C:  RCALL  11A2
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
0151E:  MOVLB  7
01520:  CLRF   x3F
01522:  CLRF   x41
01524:  CLRF   x42
01526:  MOVFF  739,73F
0152A:  MOVFF  741,740
0152E:  MOVFF  742,741
01532:  CLRF   x42
01534:  MOVFF  739,752
01538:  MOVLW  08
0153A:  MOVWF  x53
0153C:  MOVLB  0
0153E:  RCALL  11A2
.................... 	spi_xfer(starting_address & 0xFF); 
01540:  MOVLB  7
01542:  MOVFF  738,73F
01546:  CLRF   x40
01548:  CLRF   x41
0154A:  CLRF   x42
0154C:  MOVFF  738,752
01550:  MOVLW  08
01552:  MOVWF  x53
01554:  MOVLB  0
01556:  RCALL  11A2
.................... 	 
.................... 	for (int16 i = 0; i < 256; i++) 
01558:  MOVLB  7
0155A:  CLRF   x3E
0155C:  CLRF   x3D
0155E:  MOVF   x3E,W
01560:  SUBLW  00
01562:  BNC   158E
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
01564:  CLRF   x52
01566:  MOVLW  08
01568:  MOVWF  x53
0156A:  MOVLB  0
0156C:  RCALL  11A2
0156E:  MOVF   01,W
01570:  MOVFF  01,73C
.................... 		ptr[i] = data; 
01574:  MOVLB  7
01576:  MOVF   x34,W
01578:  ADDWF  x3D,W
0157A:  MOVWF  FE9
0157C:  MOVF   x35,W
0157E:  ADDWFC x3E,W
01580:  MOVWF  FEA
01582:  MOVFF  73C,FEF
.................... 	} 
01586:  INCF   x3D,F
01588:  BTFSC  FD8.2
0158A:  INCF   x3E,F
0158C:  BRA    155E
....................  
.................... 	output_high(FLASH_CS); 
0158E:  BCF    F95.2
01590:  BSF    F8C.2
.................... } 
01592:  MOVLB  0
01594:  RETURN 0
....................  
....................  
.................... void write_buffer_to_flash_page(int *ptr,int program_index, int page_index)  
.................... { 
*
01734:  MOVLB  7
01736:  CLRF   x3D
01738:  CLRF   x3C
0173A:  CLRF   x3B
0173C:  CLRF   x3A
0173E:  CLRF   x3F
01740:  CLRF   x3E
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(program_index,page_index); 
01742:  CLRF   x43
01744:  CLRF   x42
01746:  CLRF   x41
01748:  MOVFF  738,740
0174C:  CLRF   x47
0174E:  CLRF   x46
01750:  CLRF   x45
01752:  MOVFF  739,744
01756:  MOVLB  0
01758:  RCALL  165A
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
0175A:  MOVLB  7
0175C:  CLRF   x50
0175E:  CLRF   x4F
01760:  CLRF   x4E
01762:  MOVFF  738,74D
01766:  CLRF   x54
01768:  CLRF   x53
0176A:  CLRF   x52
0176C:  MOVFF  739,751
01770:  CLRF   x58
01772:  CLRF   x57
01774:  CLRF   x56
01776:  CLRF   x55
01778:  MOVLB  0
0177A:  RCALL  10CA
0177C:  MOVFF  03,73D
01780:  MOVFF  02,73C
01784:  MOVFF  01,73B
01788:  MOVFF  00,73A
....................  
.................... 	flash_write_enable(); 
0178C:  RCALL  1640
.................... 	flash_wait_while_busy(); 
0178E:  RCALL  1636
.................... 	 
.................... 	output_low(FLASH_CS); 
01790:  BCF    F95.2
01792:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
01794:  MOVLW  02
01796:  MOVLB  7
01798:  MOVWF  x52
0179A:  MOVLW  08
0179C:  MOVWF  x53
0179E:  MOVLB  0
017A0:  RCALL  11A2
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
017A2:  MOVLB  7
017A4:  CLRF   x40
017A6:  CLRF   x41
017A8:  MOVFF  73C,742
017AC:  CLRF   x43
017AE:  MOVFF  73C,740
017B2:  MOVFF  743,741
017B6:  CLRF   x42
017B8:  CLRF   x43
017BA:  MOVFF  73C,752
017BE:  MOVLW  08
017C0:  MOVWF  x53
017C2:  MOVLB  0
017C4:  RCALL  11A2
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
017C6:  MOVLB  7
017C8:  CLRF   x40
017CA:  CLRF   x42
017CC:  CLRF   x43
017CE:  MOVFF  73B,740
017D2:  MOVFF  742,741
017D6:  MOVFF  743,742
017DA:  CLRF   x43
017DC:  MOVFF  73B,752
017E0:  MOVLW  08
017E2:  MOVWF  x53
017E4:  MOVLB  0
017E6:  RCALL  11A2
.................... 	spi_xfer(starting_address & 0xFF); 
017E8:  MOVLB  7
017EA:  MOVFF  73A,740
017EE:  CLRF   x41
017F0:  CLRF   x42
017F2:  CLRF   x43
017F4:  MOVFF  73A,752
017F8:  MOVLW  08
017FA:  MOVWF  x53
017FC:  MOVLB  0
017FE:  RCALL  11A2
.................... 		 
.................... 	for (value_counter = 0; value_counter < 256; value_counter++) 
01800:  MOVLB  7
01802:  CLRF   x3F
01804:  CLRF   x3E
01806:  MOVF   x3F,W
01808:  SUBLW  00
0180A:  BNC   1832
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
0180C:  MOVF   x36,W
0180E:  ADDWF  x3E,W
01810:  MOVWF  FE9
01812:  MOVF   x37,W
01814:  ADDWFC x3F,W
01816:  MOVWF  FEA
01818:  MOVFF  FEF,740
0181C:  MOVFF  740,752
01820:  MOVLW  08
01822:  MOVWF  x53
01824:  MOVLB  0
01826:  RCALL  11A2
.................... 	} 
01828:  MOVLB  7
0182A:  INCF   x3E,F
0182C:  BTFSC  FD8.2
0182E:  INCF   x3F,F
01830:  BRA    1806
....................  
.................... 	output_high(FLASH_CS); 
01832:  BCF    F95.2
01834:  BSF    F8C.2
....................  
.................... 	flash_wait_while_busy(); 
01836:  MOVLB  0
01838:  RCALL  1636
.................... } 
0183A:  RETURN 0
....................  
.................... void write_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
*
05318:  MOVLB  7
0531A:  CLRF   x32
0531C:  CLRF   x31
0531E:  MOVF   x32,W
05320:  SUBLW  00
05322:  BNC   5364
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
05324:  DECFSZ x30,W
05326:  BRA    5344
.................... 			fputc(ptr[value_counter],USB); 
05328:  MOVF   x2E,W
0532A:  ADDWF  x31,W
0532C:  MOVWF  FE9
0532E:  MOVF   x2F,W
05330:  ADDWFC x32,W
05332:  MOVWF  FEA
05334:  MOVFF  FEF,733
05338:  MOVFF  733,736
0533C:  MOVLB  0
0533E:  RCALL  4D9A
.................... 		} else { 
05340:  BRA    535A
05342:  MOVLB  7
.................... 			fputc(ptr[value_counter],RS232); 
05344:  MOVF   x2E,W
05346:  ADDWF  x31,W
05348:  MOVWF  FE9
0534A:  MOVF   x2F,W
0534C:  ADDWFC x32,W
0534E:  MOVWF  FEA
05350:  MOVFF  FEF,733
05354:  MOVF   x33,W
05356:  MOVLB  0
05358:  RCALL  5310
.................... 		} 
.................... 	}	 
0535A:  MOVLB  7
0535C:  INCF   x31,F
0535E:  BTFSC  FD8.2
05360:  INCF   x32,F
05362:  BRA    531E
.................... } 
05364:  MOVLB  0
05366:  GOTO   6AB8 (RETURN)
....................  
.................... void print_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
.................... 			fprintf(USB,"%x",ptr[value_counter]); 
.................... 		} else { 
.................... 			fprintf(RS232,"%x",ptr[value_counter]); 
....................  
.................... 			if((value_counter % 4) == 3) { 
.................... 				fprintf(RS232," ");	 
.................... 			} 
....................  
.................... 			if((value_counter % 32) == 31) { 
.................... 				fprintf(RS232,"\r\n");	 
.................... 			} 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void print_flash_page_buffer(int *ptr) 
.................... { 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
....................  
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... } 
....................  
....................  
.................... #include <errorlist.h> 
....................  #define ERR_START 						0x15 
....................  
....................  #define ERR_INVALID_START 				0x02 
....................  
....................  #define ERR_UNKNOWN 					0x09 
....................  
....................  #define ERR_COMMAND_TIMEOUT 			0x10 
....................  #define ERR_COMMAND_INVALID			0x13 
....................  
....................  #define ERR_END_TIMEOUT 				0x11 
....................  #define ERR_END_INVALID 				0x12 
....................  
....................   
....................  #define ERR_ADDR_TIMEOUT 				0x14 
....................  #define ERR_ADDR_INVALID 				0x16 
....................  
....................  #define ERR_DATA_TIMEOUT 				0x17 
....................  #define ERR_DATA_INVALID 				0x17 
....................  
....................  #define ERR_PHANTOM_BOOL_TIMEOUT		0x18 
....................  #define ERR_PHANTOM_BOOL_INVALID 		0x19 
....................  
....................  #define ERR_PHANTOM_CH_TIMEOUT 		0x20 
....................  #define ERR_PHANTOM_CH_INVALID 		0x21 
....................  
....................  #define ERR_VOL_CH_TIMEOUT				0x22 
....................  #define ERR_VOL_CH_INVALID				0x23 
....................  
....................  #define ERR_VOL_TIMEOUT				0x24 
....................  #define ERR_VOL_INVALID				0x25 
....................  
....................  #define ERR_RS232_CH_TIMEOUT			0x26 
....................  #define ERR_RS232_CH_INVALID			0x27 
....................  
....................  #define ERR_RS232_DATA_TIMEOUT			0x28 
....................  #define ERR_RS232_DATA_INVALID			0x29 
....................  
....................  #define ERR_DEVICE_CONFIG_INVALID		0x30 
....................  
....................  
....................  
....................  
.................... #include <dsp_comm.c> 
.................... BYTE dsp_read_buffer[8]; 
....................  
.................... void i2c_write_4byte(int32 fourBytes) { 
*
01B1A:  MOVLB  7
01B1C:  MOVFF  746,74A
....................  
....................       int byte4 = fourBytes & 0xFF; 
....................       fourBytes = fourBytes >> 8; 
01B20:  MOVFF  747,746
01B24:  MOVFF  748,747
01B28:  MOVFF  749,748
01B2C:  CLRF   x49
....................     
....................       int byte3 = fourBytes & 0xFF; 
01B2E:  MOVFF  746,74B
....................       fourBytes = fourBytes >> 8; 
01B32:  MOVFF  747,746
01B36:  MOVFF  748,747
01B3A:  MOVFF  749,748
01B3E:  CLRF   x49
....................     
....................       int byte2 = fourBytes & 0xFF; 
....................     
....................       int byte1 = fourBytes >> 8; 
01B40:  MOVFF  746,74C
01B44:  MOVFF  747,74D
....................     
....................       i2c_write(byte1); 
01B48:  MOVFF  74D,74E
01B4C:  MOVLB  0
01B4E:  RCALL  1AA4
....................       i2c_write(byte2);  
01B50:  MOVFF  74C,74E
01B54:  RCALL  1AA4
....................       i2c_write(byte3); 
01B56:  MOVFF  74B,74E
01B5A:  RCALL  1AA4
....................       i2c_write(byte4); 
01B5C:  MOVFF  74A,74E
01B60:  RCALL  1AA4
....................     
.................... } 
01B62:  RETURN 0
....................  
.................... void reset_dsp() { 
....................  
.................... 	output_high(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_low(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_high(PIN_DSP_nRESET); 
.................... } 
....................  
....................  
.................... void send_dsp_command(int32 address, int32 command) { 
....................  
....................    i2c_start(); 
01B64:  BSF    F94.3
01B66:  MOVLW  03
01B68:  MOVWF  00
01B6A:  DECFSZ 00,F
01B6C:  BRA    1B6A
01B6E:  BSF    F94.2
01B70:  MOVLW  03
01B72:  MOVWF  00
01B74:  DECFSZ 00,F
01B76:  BRA    1B74
01B78:  BCF    F8B.3
01B7A:  BCF    F94.3
01B7C:  MOVLW  03
01B7E:  MOVWF  00
01B80:  DECFSZ 00,F
01B82:  BRA    1B80
01B84:  BCF    F8B.2
01B86:  BCF    F94.2
....................    i2c_write(DSP_I2C_ADDRESS); 
01B88:  MOVLW  80
01B8A:  MOVLB  7
01B8C:  MOVWF  x4E
01B8E:  MOVLB  0
01B90:  RCALL  1AA4
....................    i2c_write_4byte(address); 
01B92:  MOVFF  73C,749
01B96:  MOVFF  73B,748
01B9A:  MOVFF  73A,747
01B9E:  MOVFF  739,746
01BA2:  RCALL  1B1A
....................    i2c_write_4byte(command); 
01BA4:  MOVFF  740,749
01BA8:  MOVFF  73F,748
01BAC:  MOVFF  73E,747
01BB0:  MOVFF  73D,746
01BB4:  RCALL  1B1A
....................    i2c_stop(); 
01BB6:  BCF    F94.3
01BB8:  NOP   
01BBA:  BSF    F94.2
01BBC:  BTFSS  F82.2
01BBE:  BRA    1BBC
01BC0:  MOVLW  03
01BC2:  MOVWF  00
01BC4:  DECFSZ 00,F
01BC6:  BRA    1BC4
01BC8:  BRA    1BCA
01BCA:  NOP   
01BCC:  BSF    F94.3
01BCE:  MOVLW  03
01BD0:  MOVWF  00
01BD2:  DECFSZ 00,F
01BD4:  BRA    1BD2
....................  
.................... } 
01BD6:  RETURN 0
....................  
....................  
.................... void send_dsp_message(int32 message) { 
....................  
....................    i2c_start(); 
....................    i2c_write(DSP_I2C_ADDRESS); 
....................    i2c_write_4byte(message); 
....................    i2c_stop(); 
.................... } 
....................  
.................... void send_prefixed_dsp_command(int16 address_prefix, int16 address_suffix, int32 command) { 
....................  
....................    i2c_start(); 
*
01DD8:  BSF    F94.3
01DDA:  MOVLW  03
01DDC:  MOVWF  00
01DDE:  DECFSZ 00,F
01DE0:  BRA    1DDE
01DE2:  BSF    F94.2
01DE4:  MOVLW  03
01DE6:  MOVWF  00
01DE8:  DECFSZ 00,F
01DEA:  BRA    1DE8
01DEC:  BCF    F8B.3
01DEE:  BCF    F94.3
01DF0:  MOVLW  03
01DF2:  MOVWF  00
01DF4:  DECFSZ 00,F
01DF6:  BRA    1DF4
01DF8:  BCF    F8B.2
01DFA:  BCF    F94.2
....................    i2c_write(DSP_I2C_ADDRESS); 
01DFC:  MOVLW  80
01DFE:  MOVLB  7
01E00:  MOVWF  x4E
01E02:  MOVLB  0
01E04:  RCALL  1AA4
....................  
....................    int32 address = address_prefix; 
01E06:  MOVLB  7
01E08:  CLRF   x45
01E0A:  CLRF   x44
01E0C:  MOVFF  73B,743
01E10:  MOVFF  73A,742
....................    address <<= 16; 
01E14:  MOVFF  743,745
01E18:  MOVFF  742,744
01E1C:  CLRF   x42
01E1E:  CLRF   x43
....................    address |= address_suffix; 
01E20:  MOVF   x3C,W
01E22:  IORWF  x42,F
01E24:  MOVF   x3D,W
01E26:  IORWF  x43,F
....................    i2c_write_4byte(address); 
01E28:  MOVFF  745,749
01E2C:  MOVFF  744,748
01E30:  MOVFF  743,747
01E34:  MOVFF  742,746
01E38:  MOVLB  0
01E3A:  RCALL  1B1A
....................    i2c_write_4byte(command); 
01E3C:  MOVFF  741,749
01E40:  MOVFF  740,748
01E44:  MOVFF  73F,747
01E48:  MOVFF  73E,746
01E4C:  RCALL  1B1A
....................    i2c_stop(); 
01E4E:  BCF    F94.3
01E50:  NOP   
01E52:  BSF    F94.2
01E54:  BTFSS  F82.2
01E56:  BRA    1E54
01E58:  MOVLW  03
01E5A:  MOVWF  00
01E5C:  DECFSZ 00,F
01E5E:  BRA    1E5C
01E60:  BRA    1E62
01E62:  NOP   
01E64:  BSF    F94.3
01E66:  MOVLW  03
01E68:  MOVWF  00
01E6A:  DECFSZ 00,F
01E6C:  BRA    1E6A
....................  
.................... } 
01E6E:  RETURN 0
....................  
.................... int read_dsp_int_prefixed(int16 address_prefix,int16 address_suffix) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	int32 address = address_prefix; 
....................    	address <<= 16; 
....................    	address |= address_suffix; 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
....................  
.................... 	return dsp_read_buffer[7]; 
.................... } 
....................  
....................  
.................... void read_dsp_and_send_to_usb(int32 address) 
.................... { 
.................... 	i2c_start(); 
*
04EF4:  BSF    F94.3
04EF6:  MOVLW  03
04EF8:  MOVWF  00
04EFA:  DECFSZ 00,F
04EFC:  BRA    4EFA
04EFE:  BSF    F94.2
04F00:  MOVLW  03
04F02:  MOVWF  00
04F04:  DECFSZ 00,F
04F06:  BRA    4F04
04F08:  BCF    F8B.3
04F0A:  BCF    F94.3
04F0C:  MOVLW  03
04F0E:  MOVWF  00
04F10:  DECFSZ 00,F
04F12:  BRA    4F10
04F14:  BCF    F8B.2
04F16:  BCF    F94.2
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
04F18:  MOVLW  80
04F1A:  MOVLB  7
04F1C:  MOVWF  x4E
04F1E:  MOVLB  0
04F20:  CALL   1AA4
.................... 	i2c_write_4byte(address); 
04F24:  MOVFF  731,749
04F28:  MOVFF  730,748
04F2C:  MOVFF  72F,747
04F30:  MOVFF  72E,746
04F34:  CALL   1B1A
.................... 	i2c_stop(); 
04F38:  BCF    F94.3
04F3A:  NOP   
04F3C:  BSF    F94.2
04F3E:  BTFSS  F82.2
04F40:  BRA    4F3E
04F42:  MOVLW  03
04F44:  MOVWF  00
04F46:  DECFSZ 00,F
04F48:  BRA    4F46
04F4A:  BRA    4F4C
04F4C:  NOP   
04F4E:  BSF    F94.3
04F50:  MOVLW  03
04F52:  MOVWF  00
04F54:  DECFSZ 00,F
04F56:  BRA    4F54
....................  
.................... 	delay_ms(1); 
04F58:  MOVLW  01
04F5A:  MOVLB  7
04F5C:  MOVWF  x37
04F5E:  MOVLB  0
04F60:  CALL   0F2E
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
04F64:  BSF    F93.2
04F66:  BTFSC  F81.2
04F68:  BRA    5052
....................  
.................... 		i2c_start(); 
04F6A:  BSF    F94.3
04F6C:  MOVLW  03
04F6E:  MOVWF  00
04F70:  DECFSZ 00,F
04F72:  BRA    4F70
04F74:  BSF    F94.2
04F76:  MOVLW  03
04F78:  MOVWF  00
04F7A:  DECFSZ 00,F
04F7C:  BRA    4F7A
04F7E:  BCF    F8B.3
04F80:  BCF    F94.3
04F82:  MOVLW  03
04F84:  MOVWF  00
04F86:  DECFSZ 00,F
04F88:  BRA    4F86
04F8A:  BCF    F8B.2
04F8C:  BCF    F94.2
....................  
.................... 		if(i2c_write(0x81) == 0) { 
04F8E:  MOVLW  81
04F90:  MOVLB  7
04F92:  MOVWF  x4E
04F94:  MOVLB  0
04F96:  CALL   1AA4
04F9A:  MOVF   01,F
04F9C:  BNZ   5030
....................  
.................... 			for(int i = 0; i < 8; i++) { 
04F9E:  MOVLB  7
04FA0:  CLRF   x32
04FA2:  MOVF   x32,W
04FA4:  SUBLW  07
04FA6:  BNC   4FF4
.................... 				if(i == 7) { 
04FA8:  MOVF   x32,W
04FAA:  SUBLW  07
04FAC:  BNZ   4FCA
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
04FAE:  CLRF   03
04FB0:  MOVF   x32,W
04FB2:  ADDLW  A1
04FB4:  MOVWF  FE9
04FB6:  MOVLW  05
04FB8:  ADDWFC 03,W
04FBA:  MOVWF  FEA
04FBC:  CLRF   00
04FBE:  MOVLB  0
04FC0:  RCALL  4E8A
04FC2:  MOVFF  01,FEF
.................... 				} else { 
04FC6:  BRA    4FE4
04FC8:  MOVLB  7
.................... 					dsp_read_buffer[i] = i2c_read(); 
04FCA:  CLRF   03
04FCC:  MOVF   x32,W
04FCE:  ADDLW  A1
04FD0:  MOVWF  FE9
04FD2:  MOVLW  05
04FD4:  ADDWFC 03,W
04FD6:  MOVWF  FEA
04FD8:  MOVLW  01
04FDA:  MOVWF  00
04FDC:  MOVLB  0
04FDE:  RCALL  4E8A
04FE0:  MOVFF  01,FEF
.................... 				} 
....................  
.................... 				delay_us(100); 
04FE4:  MOVLW  7A
04FE6:  MOVWF  00
04FE8:  DECFSZ 00,F
04FEA:  BRA    4FE8
04FEC:  NOP   
.................... 			} 
04FEE:  MOVLB  7
04FF0:  INCF   x32,F
04FF2:  BRA    4FA2
.................... 	 
.................... 			fputc(0x06,USB); 
04FF4:  MOVLW  06
04FF6:  MOVWF  x36
04FF8:  MOVLB  0
04FFA:  RCALL  4D9A
.................... 			for(int x = 4; x < 8; x++) { 
04FFC:  MOVLW  04
04FFE:  MOVLB  7
05000:  MOVWF  x33
05002:  MOVF   x33,W
05004:  SUBLW  07
05006:  BNC   5028
.................... 				fputc(dsp_read_buffer[x],USB); 
05008:  CLRF   03
0500A:  MOVF   x33,W
0500C:  ADDLW  A1
0500E:  MOVWF  FE9
05010:  MOVLW  05
05012:  ADDWFC 03,W
05014:  MOVWF  FEA
05016:  MOVFF  FEF,734
0501A:  MOVFF  734,736
0501E:  MOVLB  0
05020:  RCALL  4D9A
.................... 			} 
05022:  MOVLB  7
05024:  INCF   x33,F
05026:  BRA    5002
.................... 			fputc(0x03,USB); 
05028:  MOVLW  03
0502A:  MOVWF  x36
0502C:  MOVLB  0
0502E:  RCALL  4D9A
.................... 		} 
....................  
.................... 		i2c_stop(); 
05030:  BCF    F94.3
05032:  NOP   
05034:  BSF    F94.2
05036:  BTFSS  F82.2
05038:  BRA    5036
0503A:  MOVLW  03
0503C:  MOVWF  00
0503E:  DECFSZ 00,F
05040:  BRA    503E
05042:  BRA    5044
05044:  NOP   
05046:  BSF    F94.3
05048:  MOVLW  03
0504A:  MOVWF  00
0504C:  DECFSZ 00,F
0504E:  BRA    504C
.................... 	} else { 
05050:  BRA    5052
.................... 		//fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
05052:  GOTO   6854 (RETURN)
....................  
.................... void read_dsp_and_send_to_rs232(int32 address) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 	 
.................... 			fprintf(RS232,"Read:"); 
.................... 			for(int x = 4; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
.................... void read_unsolicited_DSP_message() 
.................... { 
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_us(100); 
.................... 			} 
.................... 			for(int x = 0; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
....................  
.................... } 
....................  
.................... void load_dsp_values() { 
....................  
.................... /* 
.................... 	for(int16 i = 0; i <= num_dsp_values; i++) { 
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(i),READ_CONFIG_VALUE(i)); 
.................... 		//delay_ms(2);	 
.................... 	} 
.................... */ 
.................... } 
....................  
.................... void dsp_mute_outputs() 
.................... { 
.................... 	send_dsp_command(AM_MASTERGAIN,0x00000000); 
*
01BD8:  MOVLW  83
01BDA:  MOVLB  7
01BDC:  MOVWF  x3C
01BDE:  CLRF   x3B
01BE0:  CLRF   x3A
01BE2:  CLRF   x39
01BE4:  CLRF   x40
01BE6:  CLRF   x3F
01BE8:  CLRF   x3E
01BEA:  CLRF   x3D
01BEC:  MOVLB  0
01BEE:  RCALL  1B64
.................... } 
01BF0:  GOTO   1FEC (RETURN)
....................  
.................... void dsp_unmute_outputs() 
.................... { 
.................... 	send_dsp_command(AM_MASTERGAIN,0x08000000); 
*
01F40:  MOVLW  83
01F42:  MOVLB  7
01F44:  MOVWF  x3C
01F46:  CLRF   x3B
01F48:  CLRF   x3A
01F4A:  CLRF   x39
01F4C:  MOVLW  08
01F4E:  MOVWF  x40
01F50:  CLRF   x3F
01F52:  CLRF   x3E
01F54:  CLRF   x3D
01F56:  MOVLB  0
01F58:  RCALL  1B64
.................... } 
01F5A:  GOTO   1FF4 (RETURN)
....................  
.................... void send_flash_program_to_dsp_buffered(int prog_index) 
.................... { 
*
01E70:  MOVLB  7
01E72:  CLRF   x31
01E74:  CLRF   x30
.................... 	int16 overall_counter = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
01E76:  CLRF   x32
01E78:  MOVF   x32,W
01E7A:  SUBLW  07
01E7C:  BNC   1F3A
....................  
.................... 		read_flash_page_into_buffer(&PAGE_BUFFER_A,prog_index,sector_counter); 
01E7E:  CLRF   x35
01E80:  MOVLW  A1
01E82:  MOVWF  x34
01E84:  MOVFF  72F,736
01E88:  MOVFF  732,737
01E8C:  MOVLB  0
01E8E:  CALL   14AC
....................  
.................... 		for(int i = 0; i < 64; i++) { 
01E92:  MOVLB  7
01E94:  CLRF   x33
01E96:  MOVF   x33,W
01E98:  SUBLW  3F
01E9A:  BNC   1F36
.................... 			if(PAGE_BUFFER_A[i] == 0xFFFFFFFF) { 
01E9C:  MOVF   x33,W
01E9E:  MULLW  04
01EA0:  MOVF   FF3,W
01EA2:  CLRF   03
01EA4:  ADDLW  A1
01EA6:  MOVWF  FE9
01EA8:  MOVLW  00
01EAA:  ADDWFC 03,W
01EAC:  MOVWF  FEA
01EAE:  MOVFF  FEF,734
01EB2:  MOVFF  FEC,735
01EB6:  MOVFF  FEC,736
01EBA:  MOVFF  FEC,737
01EBE:  INCFSZ x34,W
01EC0:  BRA    1ED0
01EC2:  INCFSZ x35,W
01EC4:  BRA    1ED0
01EC6:  INCFSZ x36,W
01EC8:  BRA    1ED0
01ECA:  INCFSZ x37,W
01ECC:  BRA    1ED0
.................... 				break; 
01ECE:  BRA    1F36
.................... 			} 
....................  
.................... 			send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(overall_counter),PAGE_BUFFER_A[i]); 
01ED0:  MOVFF  731,735
01ED4:  MOVFF  730,734
01ED8:  MOVLB  0
01EDA:  RCALL  1BF4
01EDC:  MOVFF  02,735
01EE0:  MOVFF  01,734
01EE4:  MOVLB  7
01EE6:  MOVF   x33,W
01EE8:  MULLW  04
01EEA:  MOVF   FF3,W
01EEC:  CLRF   03
01EEE:  ADDLW  A1
01EF0:  MOVWF  FE9
01EF2:  MOVLW  00
01EF4:  ADDWFC 03,W
01EF6:  MOVWF  FEA
01EF8:  MOVFF  FEF,736
01EFC:  MOVFF  FEC,737
01F00:  MOVFF  FEC,738
01F04:  MOVFF  FEC,739
01F08:  MOVLW  F0
01F0A:  MOVWF  x3B
01F0C:  CLRF   x3A
01F0E:  MOVFF  02,73D
01F12:  MOVFF  01,73C
01F16:  MOVFF  739,741
01F1A:  MOVFF  738,740
01F1E:  MOVFF  737,73F
01F22:  MOVFF  736,73E
01F26:  MOVLB  0
01F28:  RCALL  1DD8
.................... 			overall_counter++; 
01F2A:  MOVLB  7
01F2C:  INCF   x30,F
01F2E:  BTFSC  FD8.2
01F30:  INCF   x31,F
.................... 		} 
01F32:  INCF   x33,F
01F34:  BRA    1E96
....................  
.................... 		 
.................... 	} 
01F36:  INCF   x32,F
01F38:  BRA    1E78
.................... } 
01F3A:  MOVLB  0
01F3C:  GOTO   1FF2 (RETURN)
....................  
....................  
.................... #include <debug.c> 
.................... // file debug.c 
....................  
.................... #include <eeprom.c> 
.................... #byte INTCON=0xFF2 //Change for a 16 chip  
.................... #bit INT_GIE=INTCON.7  
....................  
....................  
.................... void write_int16_eeprom(int16 address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
013CC:  MOVLB  7
013CE:  CLRF   x3E
013D0:  MOVF   x3E,W
013D2:  SUBLW  01
013D4:  BNC   1436
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
013D6:  MOVF   x3E,W
013D8:  ADDWF  x3A,W
013DA:  MOVWF  x3F
013DC:  MOVLW  00
013DE:  ADDWFC x3B,W
013E0:  MOVWF  x40
013E2:  MOVLW  07
013E4:  MOVWF  x42
013E6:  MOVLW  3C
013E8:  MOVWF  x41
013EA:  MOVF   x3E,W
013EC:  ADDWF  x41,W
013EE:  MOVWF  01
013F0:  MOVLW  00
013F2:  ADDWFC x42,W
013F4:  MOVWF  03
013F6:  MOVF   01,W
013F8:  MOVWF  FE9
013FA:  MOVFF  03,FEA
013FE:  MOVFF  FEF,741
01402:  MOVFF  740,FAA
01406:  MOVFF  73F,FA9
0140A:  MOVFF  741,FA8
0140E:  BCF    FA6.6
01410:  BCF    FA6.7
01412:  BSF    FA6.2
01414:  MOVF   FF2,W
01416:  MOVWF  00
01418:  BCF    FF2.7
0141A:  MOVLB  F
0141C:  MOVLW  55
0141E:  MOVWF  FA7
01420:  MOVLW  AA
01422:  MOVWF  FA7
01424:  BSF    FA6.1
01426:  BTFSC  FA6.1
01428:  BRA    1426
0142A:  BCF    FA6.2
0142C:  MOVF   00,W
0142E:  IORWF  FF2,F
....................    } 
01430:  MOVLB  7
01432:  INCF   x3E,F
01434:  BRA    13D0
.................... } 
01436:  MOVLB  0
01438:  GOTO   148C (RETURN)
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(int16 address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
012F6:  MOVLB  7
012F8:  CLRF   x06
012FA:  MOVF   x06,W
012FC:  SUBLW  01
012FE:  BNC   1346
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
01300:  MOVLW  07
01302:  MOVWF  x0A
01304:  MOVWF  x09
01306:  MOVF   x06,W
01308:  ADDWF  x09,W
0130A:  MOVWF  01
0130C:  MOVLW  00
0130E:  ADDWFC x0A,W
01310:  MOVWF  03
01312:  MOVF   01,W
01314:  MOVWF  FE9
01316:  MOVFF  03,FEA
0131A:  MOVF   x06,W
0131C:  ADDWF  x04,W
0131E:  MOVWF  x0B
01320:  MOVLW  00
01322:  ADDWFC x05,W
01324:  MOVWF  x0C
01326:  MOVFF  FF2,70D
0132A:  BCF    FF2.7
0132C:  MOVFF  70C,FAA
01330:  MOVFF  70B,FA9
01334:  BCF    FA6.6
01336:  BCF    FA6.7
01338:  BSF    FA6.0
0133A:  MOVF   FA8,W
0133C:  BTFSC  x0D.7
0133E:  BSF    FF2.7
01340:  MOVWF  FEF
....................    } 
01342:  INCF   x06,F
01344:  BRA    12FA
....................  
....................    return(data); 
01346:  MOVFF  707,01
0134A:  MOVFF  708,02
.................... } 
0134E:  MOVLB  0
01350:  GOTO   13A8 (RETURN)
....................  
....................  
.................... void INTEEPROM_GET(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
01354:  MOVLB  6
01356:  BCF    xFF.0
01358:  BTFSC  FF2.7
0135A:  BSF    xFF.0
....................    for (count=0;count<num;count++)  
0135C:  CLRF   xFE
0135E:  CLRF   xFD
01360:  MOVF   xFE,W
01362:  SUBWF  xFA,W
01364:  BNC   13C6
01366:  BNZ   136E
01368:  MOVF   xF9,W
0136A:  SUBWF  xFD,W
0136C:  BC    13C6
....................    {  
....................       disable_interrupts(global);  
0136E:  BCF    FF2.6
01370:  BCF    FF2.7
01372:  BTFSC  FF2.7
01374:  BRA    1370
....................       ptr[count]=read_int16_eeprom(addr+count);  
01376:  MOVF   xF7,W
01378:  ADDWF  xFD,W
0137A:  MOVWF  01
0137C:  MOVF   xF8,W
0137E:  ADDWFC xFE,W
01380:  MOVWF  03
01382:  MOVFF  01,700
01386:  MOVLB  7
01388:  MOVWF  x01
0138A:  MOVLB  6
0138C:  MOVF   xFD,W
0138E:  ADDWF  xFB,W
01390:  MOVLB  7
01392:  MOVWF  x02
01394:  MOVLB  6
01396:  MOVF   xFE,W
01398:  ADDWFC xFC,W
0139A:  MOVLB  7
0139C:  MOVWF  x03
0139E:  MOVWF  x05
013A0:  MOVFF  702,704
013A4:  MOVLB  0
013A6:  BRA    12F6
013A8:  MOVFF  701,FEA
013AC:  MOVFF  700,FE9
013B0:  MOVFF  01,FEF
....................       if (int_enabled) enable_interrupts(global);  
013B4:  MOVLB  6
013B6:  BTFSS  xFF.0
013B8:  BRA    13BE
013BA:  MOVLW  C0
013BC:  IORWF  FF2,F
....................    }  
013BE:  INCF   xFD,F
013C0:  BTFSC  FD8.2
013C2:  INCF   xFE,F
013C4:  BRA    1360
.................... }  
013C6:  MOVLB  0
013C8:  GOTO   19FE (RETURN)
....................  
.................... void INTEEPROM_PUT(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
*
0143C:  MOVLB  7
0143E:  BCF    x36.0
01440:  BTFSC  FF2.7
01442:  BSF    x36.0
....................    for (count=0;count<num;count++)  
01444:  CLRF   x35
01446:  CLRF   x34
01448:  MOVF   x35,W
0144A:  SUBWF  x31,W
0144C:  BNC   14A8
0144E:  BNZ   1456
01450:  MOVF   x30,W
01452:  SUBWF  x34,W
01454:  BC    14A8
....................    {  
....................       disable_interrupts(global);  
01456:  BCF    FF2.6
01458:  BCF    FF2.7
0145A:  BTFSC  FF2.7
0145C:  BRA    1458
....................       //WRITE_EEPROM  
.................... 		write_int16_eeprom(addr+count,ptr[count]); 
0145E:  MOVF   x34,W
01460:  ADDWF  x32,W
01462:  MOVWF  x37
01464:  MOVF   x35,W
01466:  ADDWFC x33,W
01468:  MOVWF  x38
0146A:  MOVF   x2E,W
0146C:  ADDWF  x34,W
0146E:  MOVWF  FE9
01470:  MOVF   x2F,W
01472:  ADDWFC x35,W
01474:  MOVWF  FEA
01476:  MOVFF  FEF,739
0147A:  MOVFF  738,73B
0147E:  MOVFF  737,73A
01482:  CLRF   x3D
01484:  MOVFF  739,73C
01488:  MOVLB  0
0148A:  BRA    13CC
.................... 		delay_ms(3); 
0148C:  MOVLW  03
0148E:  MOVLB  7
01490:  MOVWF  x37
01492:  MOVLB  0
01494:  RCALL  0F2E
....................       if (int_enabled) enable_interrupts(global);  
01496:  MOVLB  7
01498:  BTFSS  x36.0
0149A:  BRA    14A0
0149C:  MOVLW  C0
0149E:  IORWF  FF2,F
....................    } 
014A0:  INCF   x34,F
014A2:  BTFSC  FD8.2
014A4:  INCF   x35,F
014A6:  BRA    1448
.................... }  
014A8:  MOVLB  0
014AA:  RETURN 0
....................  
....................  
.................... void INTEEPROM_GET8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       ptr[count]=read_eeprom(addr+count);  
....................       if (int_enabled) enable_interrupts(global);  
....................    }  
.................... }  
....................  
.................... void INTEEPROM_PUT8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       //WRITE_EEPROM  
.................... 		write_eeprom(addr+count,ptr[count]); 
.................... 		delay_ms(3); 
....................       if (int_enabled) enable_interrupts(global);  
....................    } 
.................... }  
....................  
.................... void default_addr() 
.................... { 
.................... 	WRITE_CONFIG_ADDRESS(0, PREGAIN_CH1);     	// PREGAIN_CH1 
*
02202:  MOVLB  6
02204:  CLRF   xF6
02206:  CLRF   xF5
02208:  MOVLW  03
0220A:  MOVWF  xF8
0220C:  MOVLW  73
0220E:  MOVWF  xF7
02210:  MOVLB  0
02212:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(1, PREGAIN_MUTE_CH1);  // PREGAIN_MUTE_CH1 
02214:  MOVLB  6
02216:  CLRF   xF6
02218:  MOVLW  01
0221A:  MOVWF  xF5
0221C:  MOVLW  04
0221E:  MOVWF  xF8
02220:  MOVLW  43
02222:  MOVWF  xF7
02224:  MOVLB  0
02226:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(2, PREGAIN_CH2);     	// PREGAIN_CH2 
02228:  MOVLB  6
0222A:  CLRF   xF6
0222C:  MOVLW  02
0222E:  MOVWF  xF5
02230:  MOVLW  03
02232:  MOVWF  xF8
02234:  MOVLW  CF
02236:  MOVWF  xF7
02238:  MOVLB  0
0223A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(3, PREGAIN_MUTE_CH2);  // PREGAIN_MUTE_CH2 
0223C:  MOVLB  6
0223E:  CLRF   xF6
02240:  MOVLW  03
02242:  MOVWF  xF5
02244:  MOVLW  04
02246:  MOVWF  xF8
02248:  MOVLW  41
0224A:  MOVWF  xF7
0224C:  MOVLB  0
0224E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(4, PREGAIN_CH3);     	// PREGAIN_CH3 
02250:  MOVLB  6
02252:  CLRF   xF6
02254:  MOVLW  04
02256:  MOVWF  xF5
02258:  MOVLW  03
0225A:  MOVWF  xF8
0225C:  MOVLW  CB
0225E:  MOVWF  xF7
02260:  MOVLB  0
02262:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(5, PREGAIN_MUTE_CH3);  // PREGAIN_MUTE_CH3 
02264:  MOVLB  6
02266:  CLRF   xF6
02268:  MOVLW  05
0226A:  MOVWF  xF5
0226C:  MOVLW  04
0226E:  MOVWF  xF8
02270:  MOVLW  3F
02272:  MOVWF  xF7
02274:  MOVLB  0
02276:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(6, PREGAIN_CH4);     	// PREGAIN_CH4 
02278:  MOVLB  6
0227A:  CLRF   xF6
0227C:  MOVLW  06
0227E:  MOVWF  xF5
02280:  MOVLW  03
02282:  MOVWF  xF8
02284:  MOVLW  C7
02286:  MOVWF  xF7
02288:  MOVLB  0
0228A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(7, PREGAIN_MUTE_CH4);  // PREGAIN_MUTE_CH4 
0228C:  MOVLB  6
0228E:  CLRF   xF6
02290:  MOVLW  07
02292:  MOVWF  xF5
02294:  MOVLW  04
02296:  MOVWF  xF8
02298:  MOVLW  3D
0229A:  MOVWF  xF7
0229C:  MOVLB  0
0229E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(8, PREGAIN_CH5);     	// PREGAIN_CH5 
022A0:  MOVLB  6
022A2:  CLRF   xF6
022A4:  MOVLW  08
022A6:  MOVWF  xF5
022A8:  MOVLW  03
022AA:  MOVWF  xF8
022AC:  MOVLW  C3
022AE:  MOVWF  xF7
022B0:  MOVLB  0
022B2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(9, PREGAIN_MUTE_CH5);  // PREGAIN_MUTE_CH5 
022B4:  MOVLB  6
022B6:  CLRF   xF6
022B8:  MOVLW  09
022BA:  MOVWF  xF5
022BC:  MOVLW  04
022BE:  MOVWF  xF8
022C0:  MOVLW  3B
022C2:  MOVWF  xF7
022C4:  MOVLB  0
022C6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(10, PREGAIN_CH6);     	// PREGAIN_CH6 
022C8:  MOVLB  6
022CA:  CLRF   xF6
022CC:  MOVLW  0A
022CE:  MOVWF  xF5
022D0:  MOVLW  03
022D2:  MOVWF  xF8
022D4:  MOVLW  BF
022D6:  MOVWF  xF7
022D8:  MOVLB  0
022DA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(11, PREGAIN_MUTE_CH6); // PREGAIN_MUTE_CH6 
022DC:  MOVLB  6
022DE:  CLRF   xF6
022E0:  MOVLW  0B
022E2:  MOVWF  xF5
022E4:  MOVLW  04
022E6:  MOVWF  xF8
022E8:  MOVLW  39
022EA:  MOVWF  xF7
022EC:  MOVLB  0
022EE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(12, PREGAIN_CH7);     	// PREGAIN_CH7 
022F0:  MOVLB  6
022F2:  CLRF   xF6
022F4:  MOVLW  0C
022F6:  MOVWF  xF5
022F8:  MOVLW  03
022FA:  MOVWF  xF8
022FC:  MOVLW  BB
022FE:  MOVWF  xF7
02300:  MOVLB  0
02302:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(13, PREGAIN_MUTE_CH7); // PREGAIN_MUTE_CH7 
02304:  MOVLB  6
02306:  CLRF   xF6
02308:  MOVLW  0D
0230A:  MOVWF  xF5
0230C:  MOVLW  04
0230E:  MOVWF  xF8
02310:  MOVLW  37
02312:  MOVWF  xF7
02314:  MOVLB  0
02316:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(14, PREGAIN_CH8);     	// PREGAIN_CH8 
02318:  MOVLB  6
0231A:  CLRF   xF6
0231C:  MOVLW  0E
0231E:  MOVWF  xF5
02320:  MOVLW  03
02322:  MOVWF  xF8
02324:  MOVLW  B7
02326:  MOVWF  xF7
02328:  MOVLB  0
0232A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(15, PREGAIN_MUTE_CH8); // PREGAIN_MUTE_CH8 
0232C:  MOVLB  6
0232E:  CLRF   xF6
02330:  MOVLW  0F
02332:  MOVWF  xF5
02334:  MOVLW  04
02336:  MOVWF  xF8
02338:  MOVLW  35
0233A:  MOVWF  xF7
0233C:  MOVLB  0
0233E:  RCALL  2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(16, PREMIX_CH1);     	// PREMIX_CH1 
02340:  MOVLB  6
02342:  CLRF   xF6
02344:  MOVLW  10
02346:  MOVWF  xF5
02348:  MOVLW  03
0234A:  MOVWF  xF8
0234C:  MOVLW  B3
0234E:  MOVWF  xF7
02350:  MOVLB  0
02352:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(17, PREMIX_MUTE_CH1);  // PREMIX_MUTE_CH1 
02354:  MOVLB  6
02356:  CLRF   xF6
02358:  MOVLW  11
0235A:  MOVWF  xF5
0235C:  MOVLW  04
0235E:  MOVWF  xF8
02360:  MOVLW  33
02362:  MOVWF  xF7
02364:  MOVLB  0
02366:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(18, PREMIX_CH2);     	// PREMIX_CH2 
02368:  MOVLB  6
0236A:  CLRF   xF6
0236C:  MOVLW  12
0236E:  MOVWF  xF5
02370:  MOVLW  03
02372:  MOVWF  xF8
02374:  MOVLW  AF
02376:  MOVWF  xF7
02378:  MOVLB  0
0237A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(19, PREMIX_MUTE_CH2);  // PREMIX_MUTE_CH2 
0237C:  MOVLB  6
0237E:  CLRF   xF6
02380:  MOVLW  13
02382:  MOVWF  xF5
02384:  MOVLW  04
02386:  MOVWF  xF8
02388:  MOVLW  31
0238A:  MOVWF  xF7
0238C:  MOVLB  0
0238E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(20, PREMIX_CH3);     	// PREMIX_CH3 
02390:  MOVLB  6
02392:  CLRF   xF6
02394:  MOVLW  14
02396:  MOVWF  xF5
02398:  MOVLW  03
0239A:  MOVWF  xF8
0239C:  MOVLW  AB
0239E:  MOVWF  xF7
023A0:  MOVLB  0
023A2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(21, PREMIX_MUTE_CH3);  // PREMIX_MUTE_CH3 
023A4:  MOVLB  6
023A6:  CLRF   xF6
023A8:  MOVLW  15
023AA:  MOVWF  xF5
023AC:  MOVLW  04
023AE:  MOVWF  xF8
023B0:  MOVLW  2F
023B2:  MOVWF  xF7
023B4:  MOVLB  0
023B6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(22, PREMIX_CH4);     	// PREMIX_CH4 
023B8:  MOVLB  6
023BA:  CLRF   xF6
023BC:  MOVLW  16
023BE:  MOVWF  xF5
023C0:  MOVLW  03
023C2:  MOVWF  xF8
023C4:  MOVLW  A7
023C6:  MOVWF  xF7
023C8:  MOVLB  0
023CA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(23, PREMIX_MUTE_CH4);  // PREMIX_MUTE_CH4 
023CC:  MOVLB  6
023CE:  CLRF   xF6
023D0:  MOVLW  17
023D2:  MOVWF  xF5
023D4:  MOVLW  04
023D6:  MOVWF  xF8
023D8:  MOVLW  2D
023DA:  MOVWF  xF7
023DC:  MOVLB  0
023DE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(24, PREMIX_CH5);     	// PREMIX_CH5 
023E0:  MOVLB  6
023E2:  CLRF   xF6
023E4:  MOVLW  18
023E6:  MOVWF  xF5
023E8:  MOVLW  03
023EA:  MOVWF  xF8
023EC:  MOVLW  A3
023EE:  MOVWF  xF7
023F0:  MOVLB  0
023F2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(25, PREMIX_MUTE_CH5);  // PREMIX_MUTE_CH5 
023F4:  MOVLB  6
023F6:  CLRF   xF6
023F8:  MOVLW  19
023FA:  MOVWF  xF5
023FC:  MOVLW  04
023FE:  MOVWF  xF8
02400:  MOVLW  2B
02402:  MOVWF  xF7
02404:  MOVLB  0
02406:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(26, PREMIX_CH6);     	// PREMIX_CH6 
02408:  MOVLB  6
0240A:  CLRF   xF6
0240C:  MOVLW  1A
0240E:  MOVWF  xF5
02410:  MOVLW  03
02412:  MOVWF  xF8
02414:  MOVLW  9F
02416:  MOVWF  xF7
02418:  MOVLB  0
0241A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(27, PREMIX_MUTE_CH6);  // PREMIX_MUTE_CH6 
0241C:  MOVLB  6
0241E:  CLRF   xF6
02420:  MOVLW  1B
02422:  MOVWF  xF5
02424:  MOVLW  04
02426:  MOVWF  xF8
02428:  MOVLW  29
0242A:  MOVWF  xF7
0242C:  MOVLB  0
0242E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(28, PREMIX_CH7);     	// PREMIX_CH7 
02430:  MOVLB  6
02432:  CLRF   xF6
02434:  MOVLW  1C
02436:  MOVWF  xF5
02438:  MOVLW  03
0243A:  MOVWF  xF8
0243C:  MOVLW  9B
0243E:  MOVWF  xF7
02440:  MOVLB  0
02442:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(29, PREMIX_MUTE_CH7);  // PREMIX_MUTE_CH7 
02444:  MOVLB  6
02446:  CLRF   xF6
02448:  MOVLW  1D
0244A:  MOVWF  xF5
0244C:  MOVLW  04
0244E:  MOVWF  xF8
02450:  MOVLW  27
02452:  MOVWF  xF7
02454:  MOVLB  0
02456:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(30, PREMIX_CH8);     	// PREMIX_CH8 
02458:  MOVLB  6
0245A:  CLRF   xF6
0245C:  MOVLW  1E
0245E:  MOVWF  xF5
02460:  MOVLW  03
02462:  MOVWF  xF8
02464:  MOVLW  97
02466:  MOVWF  xF7
02468:  MOVLB  0
0246A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(31, PREMIX_MUTE_CH8);  // PREMIX_MUTE_CH8 
0246C:  MOVLB  6
0246E:  CLRF   xF6
02470:  MOVLW  1F
02472:  MOVWF  xF5
02474:  MOVLW  04
02476:  MOVWF  xF8
02478:  MOVLW  25
0247A:  MOVWF  xF7
0247C:  MOVLB  0
0247E:  RCALL  2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(32, TRIM_CH1);     	// TRIM_CH1 
02480:  MOVLB  6
02482:  CLRF   xF6
02484:  MOVLW  20
02486:  MOVWF  xF5
02488:  MOVLW  03
0248A:  MOVWF  xF8
0248C:  MOVLW  93
0248E:  MOVWF  xF7
02490:  MOVLB  0
02492:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(33, TRIM_MUTE_CH1);    // TRIM_MUTE_CH1 
02494:  MOVLB  6
02496:  CLRF   xF6
02498:  MOVLW  21
0249A:  MOVWF  xF5
0249C:  MOVLW  04
0249E:  MOVWF  xF8
024A0:  MOVLW  23
024A2:  MOVWF  xF7
024A4:  MOVLB  0
024A6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(34, TRIM_CH2);     	// TRIM_CH2 
024A8:  MOVLB  6
024AA:  CLRF   xF6
024AC:  MOVLW  22
024AE:  MOVWF  xF5
024B0:  MOVLW  03
024B2:  MOVWF  xF8
024B4:  MOVLW  8F
024B6:  MOVWF  xF7
024B8:  MOVLB  0
024BA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(35, TRIM_MUTE_CH2);    // TRIM_MUTE_CH2 
024BC:  MOVLB  6
024BE:  CLRF   xF6
024C0:  MOVLW  23
024C2:  MOVWF  xF5
024C4:  MOVLW  04
024C6:  MOVWF  xF8
024C8:  MOVLW  21
024CA:  MOVWF  xF7
024CC:  MOVLB  0
024CE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(36, TRIM_CH3);     	// TRIM_CH3 
024D0:  MOVLB  6
024D2:  CLRF   xF6
024D4:  MOVLW  24
024D6:  MOVWF  xF5
024D8:  MOVLW  03
024DA:  MOVWF  xF8
024DC:  MOVLW  8B
024DE:  MOVWF  xF7
024E0:  MOVLB  0
024E2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(37, TRIM_MUTE_CH3);    // TRIM_MUTE_CH3 
024E4:  MOVLB  6
024E6:  CLRF   xF6
024E8:  MOVLW  25
024EA:  MOVWF  xF5
024EC:  MOVLW  04
024EE:  MOVWF  xF8
024F0:  MOVLW  1F
024F2:  MOVWF  xF7
024F4:  MOVLB  0
024F6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(38, TRIM_CH4);     	// TRIM_CH4 
024F8:  MOVLB  6
024FA:  CLRF   xF6
024FC:  MOVLW  26
024FE:  MOVWF  xF5
02500:  MOVLW  03
02502:  MOVWF  xF8
02504:  MOVLW  87
02506:  MOVWF  xF7
02508:  MOVLB  0
0250A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(39, TRIM_MUTE_CH4);     // TRIM_MUTE_CH4 
0250C:  MOVLB  6
0250E:  CLRF   xF6
02510:  MOVLW  27
02512:  MOVWF  xF5
02514:  MOVLW  04
02516:  MOVWF  xF8
02518:  MOVLW  1D
0251A:  MOVWF  xF7
0251C:  MOVLB  0
0251E:  RCALL  2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(40, OUTPUTGAIN_CH1);     // OUTPUTGAIN_CH1 
02520:  MOVLB  6
02522:  CLRF   xF6
02524:  MOVLW  28
02526:  MOVWF  xF5
02528:  MOVLW  03
0252A:  MOVWF  xF8
0252C:  MOVLW  83
0252E:  MOVWF  xF7
02530:  MOVLB  0
02532:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(41, OUTPUT_MUTE_CH1);     // OUTPUT_MUTE_CH1 
02534:  MOVLB  6
02536:  CLRF   xF6
02538:  MOVLW  29
0253A:  MOVWF  xF5
0253C:  MOVLW  04
0253E:  MOVWF  xF8
02540:  MOVLW  1B
02542:  MOVWF  xF7
02544:  MOVLB  0
02546:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(42, OUTPUTGAIN_CH2);     // OUTPUTGAIN_CH2 
02548:  MOVLB  6
0254A:  CLRF   xF6
0254C:  MOVLW  2A
0254E:  MOVWF  xF5
02550:  MOVLW  03
02552:  MOVWF  xF8
02554:  MOVLW  7F
02556:  MOVWF  xF7
02558:  MOVLB  0
0255A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(43, OUTPUT_MUTE_CH2);     // OUTPUT_MUTE_CH2 
0255C:  MOVLB  6
0255E:  CLRF   xF6
02560:  MOVLW  2B
02562:  MOVWF  xF5
02564:  MOVLW  04
02566:  MOVWF  xF8
02568:  MOVLW  19
0256A:  MOVWF  xF7
0256C:  MOVLB  0
0256E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(44, OUTPUTGAIN_CH3);     // OUTPUTGAIN_CH3 
02570:  MOVLB  6
02572:  CLRF   xF6
02574:  MOVLW  2C
02576:  MOVWF  xF5
02578:  MOVLW  03
0257A:  MOVWF  xF8
0257C:  MOVLW  7B
0257E:  MOVWF  xF7
02580:  MOVLB  0
02582:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(45, OUTPUT_MUTE_CH3);     // OUTPUT_MUTE_CH3 
02584:  MOVLB  6
02586:  CLRF   xF6
02588:  MOVLW  2D
0258A:  MOVWF  xF5
0258C:  MOVLW  04
0258E:  MOVWF  xF8
02590:  MOVLW  17
02592:  MOVWF  xF7
02594:  MOVLB  0
02596:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(46, OUTPUTGAIN_CH4);     // OUTPUTGAIN_CH4 
02598:  MOVLB  6
0259A:  CLRF   xF6
0259C:  MOVLW  2E
0259E:  MOVWF  xF5
025A0:  MOVLW  03
025A2:  MOVWF  xF8
025A4:  MOVLW  77
025A6:  MOVWF  xF7
025A8:  MOVLB  0
025AA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(47, OUTPUT_MUTE_CH4);     // OUTPUT_MUTE_CH4 
025AC:  MOVLB  6
025AE:  CLRF   xF6
025B0:  MOVLW  2F
025B2:  MOVWF  xF5
025B4:  MOVLW  04
025B6:  MOVWF  xF8
025B8:  MOVLW  15
025BA:  MOVWF  xF7
025BC:  MOVLB  0
025BE:  RCALL  2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(48, INDUCKROUTER_SELECT0);     // INDUCKROUTER_SELECT0 
025C0:  MOVLB  6
025C2:  CLRF   xF6
025C4:  MOVLW  30
025C6:  MOVWF  xF5
025C8:  MOVLW  02
025CA:  MOVWF  xF8
025CC:  MOVLW  0E
025CE:  MOVWF  xF7
025D0:  MOVLB  0
025D2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(49, INDUCKROUTER_SELECT1);     // INDUCKROUTER_SELECT1 
025D4:  MOVLB  6
025D6:  CLRF   xF6
025D8:  MOVLW  31
025DA:  MOVWF  xF5
025DC:  MOVLW  02
025DE:  MOVWF  xF8
025E0:  MOVLW  0F
025E2:  MOVWF  xF7
025E4:  MOVLB  0
025E6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(50, INDUCKROUTER_SELECT2);     // INDUCKROUTER_SELECT2 
025E8:  MOVLB  6
025EA:  CLRF   xF6
025EC:  MOVLW  32
025EE:  MOVWF  xF5
025F0:  MOVLW  02
025F2:  MOVWF  xF8
025F4:  MOVLW  10
025F6:  MOVWF  xF7
025F8:  MOVLB  0
025FA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(51, INDUCKROUTER_SELECT3);     // INDUCKROUTER_SELECT3 
025FC:  MOVLB  6
025FE:  CLRF   xF6
02600:  MOVLW  33
02602:  MOVWF  xF5
02604:  MOVLW  02
02606:  MOVWF  xF8
02608:  MOVLW  11
0260A:  MOVWF  xF7
0260C:  MOVLB  0
0260E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(52, INDUCKROUTER_SELECT4);     // INDUCKROUTER_SELECT4 
02610:  MOVLB  6
02612:  CLRF   xF6
02614:  MOVLW  34
02616:  MOVWF  xF5
02618:  MOVLW  02
0261A:  MOVWF  xF8
0261C:  MOVLW  12
0261E:  MOVWF  xF7
02620:  MOVLB  0
02622:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(53, INDUCKROUTER_SELECT5);     // INDUCKROUTER_SELECT5 
02624:  MOVLB  6
02626:  CLRF   xF6
02628:  MOVLW  35
0262A:  MOVWF  xF5
0262C:  MOVLW  02
0262E:  MOVWF  xF8
02630:  MOVLW  13
02632:  MOVWF  xF7
02634:  MOVLB  0
02636:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(54, INDUCKROUTER_SELECT6);     // INDUCKROUTER_SELECT6 
02638:  MOVLB  6
0263A:  CLRF   xF6
0263C:  MOVLW  36
0263E:  MOVWF  xF5
02640:  MOVLW  02
02642:  MOVWF  xF8
02644:  MOVLW  14
02646:  MOVWF  xF7
02648:  MOVLB  0
0264A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(55, INDUCKROUTER_SELECT7);     // INDUCKROUTER_SELECT7 
0264C:  MOVLB  6
0264E:  CLRF   xF6
02650:  MOVLW  37
02652:  MOVWF  xF5
02654:  MOVLW  02
02656:  MOVWF  xF8
02658:  MOVLW  15
0265A:  MOVWF  xF7
0265C:  MOVLB  0
0265E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(56, OUTDUCKROUTER_SELECT0);     // OUTDUCKROUTER_SELECT0 
02660:  MOVLB  6
02662:  CLRF   xF6
02664:  MOVLW  38
02666:  MOVWF  xF5
02668:  MOVLW  02
0266A:  MOVWF  xF8
0266C:  MOVLW  05
0266E:  MOVWF  xF7
02670:  MOVLB  0
02672:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(57, OUTDUCKROUTER_SELECT1);     // OUTDUCKROUTER_SELECT1 
02674:  MOVLB  6
02676:  CLRF   xF6
02678:  MOVLW  39
0267A:  MOVWF  xF5
0267C:  MOVLW  02
0267E:  MOVWF  xF8
02680:  MOVLW  06
02682:  MOVWF  xF7
02684:  MOVLB  0
02686:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(58, OUTDUCKROUTER_SELECT2);     // OUTDUCKROUTER_SELECT2 
02688:  MOVLB  6
0268A:  CLRF   xF6
0268C:  MOVLW  3A
0268E:  MOVWF  xF5
02690:  MOVLW  02
02692:  MOVWF  xF8
02694:  MOVLW  07
02696:  MOVWF  xF7
02698:  MOVLB  0
0269A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(59, OUTDUCKROUTER_SELECT3);     // OUTDUCKROUTER_SELECT3 
0269C:  MOVLB  6
0269E:  CLRF   xF6
026A0:  MOVLW  3B
026A2:  MOVWF  xF5
026A4:  MOVLW  02
026A6:  MOVWF  xF8
026A8:  MOVLW  08
026AA:  MOVWF  xF7
026AC:  MOVLB  0
026AE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(60, OUTDUCKROUTER_SELECT4);     // OUTDUCKROUTER_SELECT4 
026B0:  MOVLB  6
026B2:  CLRF   xF6
026B4:  MOVLW  3C
026B6:  MOVWF  xF5
026B8:  MOVLW  02
026BA:  MOVWF  xF8
026BC:  MOVLW  09
026BE:  MOVWF  xF7
026C0:  MOVLB  0
026C2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(61, OUTDUCKROUTER_SELECT5);     // OUTDUCKROUTER_SELECT5 
026C4:  MOVLB  6
026C6:  CLRF   xF6
026C8:  MOVLW  3D
026CA:  MOVWF  xF5
026CC:  MOVLW  02
026CE:  MOVWF  xF8
026D0:  MOVLW  0A
026D2:  MOVWF  xF7
026D4:  MOVLB  0
026D6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(62, OUTDUCKROUTER_SELECT6);     // OUTDUCKROUTER_SELECT6 
026D8:  MOVLB  6
026DA:  CLRF   xF6
026DC:  MOVLW  3E
026DE:  MOVWF  xF5
026E0:  MOVLW  02
026E2:  MOVWF  xF8
026E4:  MOVLW  0B
026E6:  MOVWF  xF7
026E8:  MOVLB  0
026EA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(63, OUTDUCKROUTER_SELECT7);     // OUTDUCKROUTER_SELECT7 
026EC:  MOVLB  6
026EE:  CLRF   xF6
026F0:  MOVLW  3F
026F2:  MOVWF  xF5
026F4:  MOVLW  02
026F6:  MOVWF  xF8
026F8:  MOVLW  0C
026FA:  MOVWF  xF7
026FC:  MOVLB  0
026FE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(64, DUCKER_THRESHOLD);     // DUCKER_THRESHOLD 
02700:  MOVLB  6
02702:  CLRF   xF6
02704:  MOVLW  40
02706:  MOVWF  xF5
02708:  MOVLW  02
0270A:  MOVWF  xF8
0270C:  MOVLW  76
0270E:  MOVWF  xF7
02710:  MOVLB  0
02712:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(65, DUCKER_HOLD);     // DUCKER_HOLD 
02714:  MOVLB  6
02716:  CLRF   xF6
02718:  MOVLW  41
0271A:  MOVWF  xF5
0271C:  MOVLW  02
0271E:  MOVWF  xF8
02720:  MOVLW  77
02722:  MOVWF  xF7
02724:  MOVLB  0
02726:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(66, DUCKER_DEPTH);     // DUCKER_DEPTH 
02728:  MOVLB  6
0272A:  CLRF   xF6
0272C:  MOVLW  42
0272E:  MOVWF  xF5
02730:  MOVLW  02
02732:  MOVWF  xF8
02734:  MOVLW  78
02736:  MOVWF  xF7
02738:  MOVLB  0
0273A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(67, DUCKER_ATTACK);     // DUCKER_ATTACK 
0273C:  MOVLB  6
0273E:  CLRF   xF6
02740:  MOVLW  43
02742:  MOVWF  xF5
02744:  MOVLW  02
02746:  MOVWF  xF8
02748:  MOVLW  79
0274A:  MOVWF  xF7
0274C:  MOVLB  0
0274E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(68, DUCKER_RELEASE);     // DUCKER_RELEASE 
02750:  MOVLB  6
02752:  CLRF   xF6
02754:  MOVLW  44
02756:  MOVWF  xF5
02758:  MOVLW  02
0275A:  MOVWF  xF8
0275C:  MOVLW  7A
0275E:  MOVWF  xF7
02760:  MOVLB  0
02762:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(69, DUCKER_BYPASS);     // DUCKER_BYPASS 
02764:  MOVLB  6
02766:  CLRF   xF6
02768:  MOVLW  45
0276A:  MOVWF  xF5
0276C:  MOVLW  02
0276E:  MOVWF  xF8
02770:  MOVLW  7B
02772:  MOVWF  xF7
02774:  MOVLB  0
02776:  RCALL  2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(70, IN_1_1_FILTER_B0);     // IN_1_1_FILTER_B0 
02778:  MOVLB  6
0277A:  CLRF   xF6
0277C:  MOVLW  46
0277E:  MOVWF  xF5
02780:  MOVLW  03
02782:  MOVWF  xF8
02784:  MOVLW  6D
02786:  MOVWF  xF7
02788:  MOVLB  0
0278A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(71, IN_1_1_FILTER_B1);     // IN_1_1_FILTER_B1 
0278C:  MOVLB  6
0278E:  CLRF   xF6
02790:  MOVLW  47
02792:  MOVWF  xF5
02794:  MOVLW  03
02796:  MOVWF  xF8
02798:  MOVLW  6E
0279A:  MOVWF  xF7
0279C:  MOVLB  0
0279E:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(72, IN_1_1_FILTER_B2);     // IN_1_1_FILTER_B2 
027A0:  MOVLB  6
027A2:  CLRF   xF6
027A4:  MOVLW  48
027A6:  MOVWF  xF5
027A8:  MOVLW  03
027AA:  MOVWF  xF8
027AC:  MOVLW  6F
027AE:  MOVWF  xF7
027B0:  MOVLB  0
027B2:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(73, IN_1_1_FILTER_MINUSA1);     // IN_1_1_FILTER_MINUSA1 
027B4:  MOVLB  6
027B6:  CLRF   xF6
027B8:  MOVLW  49
027BA:  MOVWF  xF5
027BC:  MOVLW  03
027BE:  MOVWF  xF8
027C0:  MOVLW  70
027C2:  MOVWF  xF7
027C4:  MOVLB  0
027C6:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(74, IN_1_1_FILTER_MINUSA2);     // IN_1_1_FILTER_MINUSA2 
027C8:  MOVLB  6
027CA:  CLRF   xF6
027CC:  MOVLW  4A
027CE:  MOVWF  xF5
027D0:  MOVLW  03
027D2:  MOVWF  xF8
027D4:  MOVLW  71
027D6:  MOVWF  xF7
027D8:  MOVLB  0
027DA:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(75, IN_1_2_FILTER_B0);     // IN_1_2_FILTER_B0 
027DC:  MOVLB  6
027DE:  CLRF   xF6
027E0:  MOVLW  4B
027E2:  MOVWF  xF5
027E4:  MOVLW  03
027E6:  MOVWF  xF8
027E8:  MOVLW  68
027EA:  MOVWF  xF7
027EC:  MOVLB  0
027EE:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(76, IN_1_2_FILTER_B1);     // IN_1_2_FILTER_B1 
027F0:  MOVLB  6
027F2:  CLRF   xF6
027F4:  MOVLW  4C
027F6:  MOVWF  xF5
027F8:  MOVLW  03
027FA:  MOVWF  xF8
027FC:  MOVLW  69
027FE:  MOVWF  xF7
02800:  MOVLB  0
02802:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(77, IN_1_2_FILTER_B2);     // IN_1_2_FILTER_B2 
02804:  MOVLB  6
02806:  CLRF   xF6
02808:  MOVLW  4D
0280A:  MOVWF  xF5
0280C:  MOVLW  03
0280E:  MOVWF  xF8
02810:  MOVLW  6A
02812:  MOVWF  xF7
02814:  MOVLB  0
02816:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(78, IN_1_2_FILTER_MINUSA1);     // IN_1_2_FILTER_MINUSA1 
02818:  MOVLB  6
0281A:  CLRF   xF6
0281C:  MOVLW  4E
0281E:  MOVWF  xF5
02820:  MOVLW  03
02822:  MOVWF  xF8
02824:  MOVLW  6B
02826:  MOVWF  xF7
02828:  MOVLB  0
0282A:  RCALL  2030
.................... 	WRITE_CONFIG_ADDRESS(79, IN_1_2_FILTER_MINUSA2);     // IN_1_2_FILTER_MINUSA2 
0282C:  MOVLB  6
0282E:  CLRF   xF6
02830:  MOVLW  4F
02832:  MOVWF  xF5
02834:  MOVLW  03
02836:  MOVWF  xF8
02838:  MOVLW  6C
0283A:  MOVWF  xF7
0283C:  MOVLB  0
0283E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(80, IN_1_3_FILTER_B0);     // IN_1_3_FILTER_B0 
02842:  MOVLB  6
02844:  CLRF   xF6
02846:  MOVLW  50
02848:  MOVWF  xF5
0284A:  MOVLW  03
0284C:  MOVWF  xF8
0284E:  MOVLW  63
02850:  MOVWF  xF7
02852:  MOVLB  0
02854:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(81, IN_1_3_FILTER_B1);     // IN_1_3_FILTER_B1 
02858:  MOVLB  6
0285A:  CLRF   xF6
0285C:  MOVLW  51
0285E:  MOVWF  xF5
02860:  MOVLW  03
02862:  MOVWF  xF8
02864:  MOVLW  64
02866:  MOVWF  xF7
02868:  MOVLB  0
0286A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(82, IN_1_3_FILTER_B2);     // IN_1_3_FILTER_B2 
0286E:  MOVLB  6
02870:  CLRF   xF6
02872:  MOVLW  52
02874:  MOVWF  xF5
02876:  MOVLW  03
02878:  MOVWF  xF8
0287A:  MOVLW  65
0287C:  MOVWF  xF7
0287E:  MOVLB  0
02880:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(83, IN_1_3_FILTER_MINUSA1);     // IN_1_3_FILTER_MINUSA1 
02884:  MOVLB  6
02886:  CLRF   xF6
02888:  MOVLW  53
0288A:  MOVWF  xF5
0288C:  MOVLW  03
0288E:  MOVWF  xF8
02890:  MOVLW  66
02892:  MOVWF  xF7
02894:  MOVLB  0
02896:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(84, IN_1_3_FILTER_MINUSA2);     // IN_1_3_FILTER_MINUSA2 
0289A:  MOVLB  6
0289C:  CLRF   xF6
0289E:  MOVLW  54
028A0:  MOVWF  xF5
028A2:  MOVLW  03
028A4:  MOVWF  xF8
028A6:  MOVLW  67
028A8:  MOVWF  xF7
028AA:  MOVLB  0
028AC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(85, IN_2_1_FILTER_B0);     // IN_2_1_FILTER_B0 
028B0:  MOVLB  6
028B2:  CLRF   xF6
028B4:  MOVLW  55
028B6:  MOVWF  xF5
028B8:  MOVLW  03
028BA:  MOVWF  xF8
028BC:  MOVLW  5E
028BE:  MOVWF  xF7
028C0:  MOVLB  0
028C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(86, IN_2_1_FILTER_B1);     // IN_2_1_FILTER_B1 
028C6:  MOVLB  6
028C8:  CLRF   xF6
028CA:  MOVLW  56
028CC:  MOVWF  xF5
028CE:  MOVLW  03
028D0:  MOVWF  xF8
028D2:  MOVLW  5F
028D4:  MOVWF  xF7
028D6:  MOVLB  0
028D8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(87, IN_2_1_FILTER_B2);     // IN_2_1_FILTER_B2 
028DC:  MOVLB  6
028DE:  CLRF   xF6
028E0:  MOVLW  57
028E2:  MOVWF  xF5
028E4:  MOVLW  03
028E6:  MOVWF  xF8
028E8:  MOVLW  60
028EA:  MOVWF  xF7
028EC:  MOVLB  0
028EE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(88, IN_2_1_FILTER_MINUSA1);     // IN_2_1_FILTER_MINUSA1 
028F2:  MOVLB  6
028F4:  CLRF   xF6
028F6:  MOVLW  58
028F8:  MOVWF  xF5
028FA:  MOVLW  03
028FC:  MOVWF  xF8
028FE:  MOVLW  61
02900:  MOVWF  xF7
02902:  MOVLB  0
02904:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(89, IN_2_1_FILTER_MINUSA2);     // IN_2_1_FILTER_MINUSA2 
02908:  MOVLB  6
0290A:  CLRF   xF6
0290C:  MOVLW  59
0290E:  MOVWF  xF5
02910:  MOVLW  03
02912:  MOVWF  xF8
02914:  MOVLW  62
02916:  MOVWF  xF7
02918:  MOVLB  0
0291A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(90, IN_2_2_FILTER_B0);     // IN_2_2_FILTER_B0 
0291E:  MOVLB  6
02920:  CLRF   xF6
02922:  MOVLW  5A
02924:  MOVWF  xF5
02926:  MOVLW  03
02928:  MOVWF  xF8
0292A:  MOVLW  59
0292C:  MOVWF  xF7
0292E:  MOVLB  0
02930:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(91, IN_2_2_FILTER_B1);     // IN_2_2_FILTER_B1 
02934:  MOVLB  6
02936:  CLRF   xF6
02938:  MOVLW  5B
0293A:  MOVWF  xF5
0293C:  MOVLW  03
0293E:  MOVWF  xF8
02940:  MOVLW  5A
02942:  MOVWF  xF7
02944:  MOVLB  0
02946:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(92, IN_2_2_FILTER_B2);     // IN_2_2_FILTER_B2 
0294A:  MOVLB  6
0294C:  CLRF   xF6
0294E:  MOVLW  5C
02950:  MOVWF  xF5
02952:  MOVLW  03
02954:  MOVWF  xF8
02956:  MOVLW  5B
02958:  MOVWF  xF7
0295A:  MOVLB  0
0295C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(93, IN_2_2_FILTER_MINUSA1);     // IN_2_2_FILTER_MINUSA1 
02960:  MOVLB  6
02962:  CLRF   xF6
02964:  MOVLW  5D
02966:  MOVWF  xF5
02968:  MOVLW  03
0296A:  MOVWF  xF8
0296C:  MOVLW  5C
0296E:  MOVWF  xF7
02970:  MOVLB  0
02972:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(94, IN_2_2_FILTER_MINUSA2);     // IN_2_2_FILTER_MINUSA2 
02976:  MOVLB  6
02978:  CLRF   xF6
0297A:  MOVLW  5E
0297C:  MOVWF  xF5
0297E:  MOVLW  03
02980:  MOVWF  xF8
02982:  MOVLW  5D
02984:  MOVWF  xF7
02986:  MOVLB  0
02988:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(95, IN_2_3_FILTER_B0);     // IN_2_3_FILTER_B0 
0298C:  MOVLB  6
0298E:  CLRF   xF6
02990:  MOVLW  5F
02992:  MOVWF  xF5
02994:  MOVLW  03
02996:  MOVWF  xF8
02998:  MOVLW  54
0299A:  MOVWF  xF7
0299C:  MOVLB  0
0299E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(96, IN_2_3_FILTER_B1);     // IN_2_3_FILTER_B1 
029A2:  MOVLB  6
029A4:  CLRF   xF6
029A6:  MOVLW  60
029A8:  MOVWF  xF5
029AA:  MOVLW  03
029AC:  MOVWF  xF8
029AE:  MOVLW  55
029B0:  MOVWF  xF7
029B2:  MOVLB  0
029B4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(97, IN_2_3_FILTER_B2);     // IN_2_3_FILTER_B2 
029B8:  MOVLB  6
029BA:  CLRF   xF6
029BC:  MOVLW  61
029BE:  MOVWF  xF5
029C0:  MOVLW  03
029C2:  MOVWF  xF8
029C4:  MOVLW  56
029C6:  MOVWF  xF7
029C8:  MOVLB  0
029CA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(98, IN_2_3_FILTER_MINUSA1);     // IN_2_3_FILTER_MINUSA1 
029CE:  MOVLB  6
029D0:  CLRF   xF6
029D2:  MOVLW  62
029D4:  MOVWF  xF5
029D6:  MOVLW  03
029D8:  MOVWF  xF8
029DA:  MOVLW  57
029DC:  MOVWF  xF7
029DE:  MOVLB  0
029E0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(99, IN_2_3_FILTER_MINUSA2);     // IN_2_3_FILTER_MINUSA2 
029E4:  MOVLB  6
029E6:  CLRF   xF6
029E8:  MOVLW  63
029EA:  MOVWF  xF5
029EC:  MOVLW  03
029EE:  MOVWF  xF8
029F0:  MOVLW  58
029F2:  MOVWF  xF7
029F4:  MOVLB  0
029F6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(100, IN_3_1_FILTER_B0);     // IN_3_1_FILTER_B0 
029FA:  MOVLB  6
029FC:  CLRF   xF6
029FE:  MOVLW  64
02A00:  MOVWF  xF5
02A02:  MOVLW  03
02A04:  MOVWF  xF8
02A06:  MOVLW  4F
02A08:  MOVWF  xF7
02A0A:  MOVLB  0
02A0C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(101, IN_3_1_FILTER_B1);     // IN_3_1_FILTER_B1 
02A10:  MOVLB  6
02A12:  CLRF   xF6
02A14:  MOVLW  65
02A16:  MOVWF  xF5
02A18:  MOVLW  03
02A1A:  MOVWF  xF8
02A1C:  MOVLW  50
02A1E:  MOVWF  xF7
02A20:  MOVLB  0
02A22:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(102, IN_3_1_FILTER_B2);     // IN_3_1_FILTER_B2 
02A26:  MOVLB  6
02A28:  CLRF   xF6
02A2A:  MOVLW  66
02A2C:  MOVWF  xF5
02A2E:  MOVLW  03
02A30:  MOVWF  xF8
02A32:  MOVLW  51
02A34:  MOVWF  xF7
02A36:  MOVLB  0
02A38:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(103, IN_3_1_FILTER_MINUSA1);     // IN_3_1_FILTER_MINUSA1 
02A3C:  MOVLB  6
02A3E:  CLRF   xF6
02A40:  MOVLW  67
02A42:  MOVWF  xF5
02A44:  MOVLW  03
02A46:  MOVWF  xF8
02A48:  MOVLW  52
02A4A:  MOVWF  xF7
02A4C:  MOVLB  0
02A4E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(104, IN_3_1_FILTER_MINUSA2);     // IN_3_1_FILTER_MINUSA2 
02A52:  MOVLB  6
02A54:  CLRF   xF6
02A56:  MOVLW  68
02A58:  MOVWF  xF5
02A5A:  MOVLW  03
02A5C:  MOVWF  xF8
02A5E:  MOVLW  53
02A60:  MOVWF  xF7
02A62:  MOVLB  0
02A64:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(105, IN_3_2_FILTER_B0);     // IN_3_2_FILTER_B0 
02A68:  MOVLB  6
02A6A:  CLRF   xF6
02A6C:  MOVLW  69
02A6E:  MOVWF  xF5
02A70:  MOVLW  03
02A72:  MOVWF  xF8
02A74:  MOVLW  4A
02A76:  MOVWF  xF7
02A78:  MOVLB  0
02A7A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(106, IN_3_2_FILTER_B1);     // IN_3_2_FILTER_B1 
02A7E:  MOVLB  6
02A80:  CLRF   xF6
02A82:  MOVLW  6A
02A84:  MOVWF  xF5
02A86:  MOVLW  03
02A88:  MOVWF  xF8
02A8A:  MOVLW  4B
02A8C:  MOVWF  xF7
02A8E:  MOVLB  0
02A90:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(107, IN_3_2_FILTER_B2);     // IN_3_2_FILTER_B2 
02A94:  MOVLB  6
02A96:  CLRF   xF6
02A98:  MOVLW  6B
02A9A:  MOVWF  xF5
02A9C:  MOVLW  03
02A9E:  MOVWF  xF8
02AA0:  MOVLW  4C
02AA2:  MOVWF  xF7
02AA4:  MOVLB  0
02AA6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(108, IN_3_2_FILTER_MINUSA1);     // IN_3_2_FILTER_MINUSA1 
02AAA:  MOVLB  6
02AAC:  CLRF   xF6
02AAE:  MOVLW  6C
02AB0:  MOVWF  xF5
02AB2:  MOVLW  03
02AB4:  MOVWF  xF8
02AB6:  MOVLW  4D
02AB8:  MOVWF  xF7
02ABA:  MOVLB  0
02ABC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(109, IN_3_2_FILTER_MINUSA2);     // IN_3_2_FILTER_MINUSA2 
02AC0:  MOVLB  6
02AC2:  CLRF   xF6
02AC4:  MOVLW  6D
02AC6:  MOVWF  xF5
02AC8:  MOVLW  03
02ACA:  MOVWF  xF8
02ACC:  MOVLW  4E
02ACE:  MOVWF  xF7
02AD0:  MOVLB  0
02AD2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(110, IN_3_3_FILTER_B0);     // IN_3_3_FILTER_B0 
02AD6:  MOVLB  6
02AD8:  CLRF   xF6
02ADA:  MOVLW  6E
02ADC:  MOVWF  xF5
02ADE:  MOVLW  03
02AE0:  MOVWF  xF8
02AE2:  MOVLW  45
02AE4:  MOVWF  xF7
02AE6:  MOVLB  0
02AE8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(111, IN_3_3_FILTER_B1);     // IN_3_3_FILTER_B1 
02AEC:  MOVLB  6
02AEE:  CLRF   xF6
02AF0:  MOVLW  6F
02AF2:  MOVWF  xF5
02AF4:  MOVLW  03
02AF6:  MOVWF  xF8
02AF8:  MOVLW  46
02AFA:  MOVWF  xF7
02AFC:  MOVLB  0
02AFE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(112, IN_3_3_FILTER_B2);     // IN_3_3_FILTER_B2 
02B02:  MOVLB  6
02B04:  CLRF   xF6
02B06:  MOVLW  70
02B08:  MOVWF  xF5
02B0A:  MOVLW  03
02B0C:  MOVWF  xF8
02B0E:  MOVLW  47
02B10:  MOVWF  xF7
02B12:  MOVLB  0
02B14:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(113, IN_3_3_FILTER_MINUSA1);     // IN_3_3_FILTER_MINUSA1 
02B18:  MOVLB  6
02B1A:  CLRF   xF6
02B1C:  MOVLW  71
02B1E:  MOVWF  xF5
02B20:  MOVLW  03
02B22:  MOVWF  xF8
02B24:  MOVLW  48
02B26:  MOVWF  xF7
02B28:  MOVLB  0
02B2A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(114, IN_3_3_FILTER_MINUSA2);     // IN_3_3_FILTER_MINUSA2 
02B2E:  MOVLB  6
02B30:  CLRF   xF6
02B32:  MOVLW  72
02B34:  MOVWF  xF5
02B36:  MOVLW  03
02B38:  MOVWF  xF8
02B3A:  MOVLW  49
02B3C:  MOVWF  xF7
02B3E:  MOVLB  0
02B40:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(115, IN_4_1_FILTER_B0);     // IN_4_1_FILTER_B0 
02B44:  MOVLB  6
02B46:  CLRF   xF6
02B48:  MOVLW  73
02B4A:  MOVWF  xF5
02B4C:  MOVLW  03
02B4E:  MOVWF  xF8
02B50:  MOVLW  40
02B52:  MOVWF  xF7
02B54:  MOVLB  0
02B56:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(116, IN_4_1_FILTER_B1);     // IN_4_1_FILTER_B1 
02B5A:  MOVLB  6
02B5C:  CLRF   xF6
02B5E:  MOVLW  74
02B60:  MOVWF  xF5
02B62:  MOVLW  03
02B64:  MOVWF  xF8
02B66:  MOVLW  41
02B68:  MOVWF  xF7
02B6A:  MOVLB  0
02B6C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(117, IN_4_1_FILTER_B2);     // IN_4_1_FILTER_B2 
02B70:  MOVLB  6
02B72:  CLRF   xF6
02B74:  MOVLW  75
02B76:  MOVWF  xF5
02B78:  MOVLW  03
02B7A:  MOVWF  xF8
02B7C:  MOVLW  42
02B7E:  MOVWF  xF7
02B80:  MOVLB  0
02B82:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(118, IN_4_1_FILTER_MINUSA1);     // IN_4_1_FILTER_MINUSA1 
02B86:  MOVLB  6
02B88:  CLRF   xF6
02B8A:  MOVLW  76
02B8C:  MOVWF  xF5
02B8E:  MOVLW  03
02B90:  MOVWF  xF8
02B92:  MOVLW  43
02B94:  MOVWF  xF7
02B96:  MOVLB  0
02B98:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(119, IN_4_1_FILTER_MINUSA2);     // IN_4_1_FILTER_MINUSA2 
02B9C:  MOVLB  6
02B9E:  CLRF   xF6
02BA0:  MOVLW  77
02BA2:  MOVWF  xF5
02BA4:  MOVLW  03
02BA6:  MOVWF  xF8
02BA8:  MOVLW  44
02BAA:  MOVWF  xF7
02BAC:  MOVLB  0
02BAE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(120, IN_4_2_FILTER_B0);     // IN_4_2_FILTER_B0 
02BB2:  MOVLB  6
02BB4:  CLRF   xF6
02BB6:  MOVLW  78
02BB8:  MOVWF  xF5
02BBA:  MOVLW  03
02BBC:  MOVWF  xF8
02BBE:  MOVLW  3B
02BC0:  MOVWF  xF7
02BC2:  MOVLB  0
02BC4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(121, IN_4_2_FILTER_B1);     // IN_4_2_FILTER_B1 
02BC8:  MOVLB  6
02BCA:  CLRF   xF6
02BCC:  MOVLW  79
02BCE:  MOVWF  xF5
02BD0:  MOVLW  03
02BD2:  MOVWF  xF8
02BD4:  MOVLW  3C
02BD6:  MOVWF  xF7
02BD8:  MOVLB  0
02BDA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(122, IN_4_2_FILTER_B2);     // IN_4_2_FILTER_B2 
02BDE:  MOVLB  6
02BE0:  CLRF   xF6
02BE2:  MOVLW  7A
02BE4:  MOVWF  xF5
02BE6:  MOVLW  03
02BE8:  MOVWF  xF8
02BEA:  MOVLW  3D
02BEC:  MOVWF  xF7
02BEE:  MOVLB  0
02BF0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(123, IN_4_2_FILTER_MINUSA1);     // IN_4_2_FILTER_MINUSA1 
02BF4:  MOVLB  6
02BF6:  CLRF   xF6
02BF8:  MOVLW  7B
02BFA:  MOVWF  xF5
02BFC:  MOVLW  03
02BFE:  MOVWF  xF8
02C00:  MOVLW  3E
02C02:  MOVWF  xF7
02C04:  MOVLB  0
02C06:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(124, IN_4_2_FILTER_MINUSA2);     // IN_4_2_FILTER_MINUSA2 
02C0A:  MOVLB  6
02C0C:  CLRF   xF6
02C0E:  MOVLW  7C
02C10:  MOVWF  xF5
02C12:  MOVLW  03
02C14:  MOVWF  xF8
02C16:  MOVLW  3F
02C18:  MOVWF  xF7
02C1A:  MOVLB  0
02C1C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(125, IN_4_3_FILTER_B0);     // IN_4_3_FILTER_B0 
02C20:  MOVLB  6
02C22:  CLRF   xF6
02C24:  MOVLW  7D
02C26:  MOVWF  xF5
02C28:  MOVLW  03
02C2A:  MOVWF  xF8
02C2C:  MOVLW  36
02C2E:  MOVWF  xF7
02C30:  MOVLB  0
02C32:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(126, IN_4_3_FILTER_B1);     // IN_4_3_FILTER_B1 
02C36:  MOVLB  6
02C38:  CLRF   xF6
02C3A:  MOVLW  7E
02C3C:  MOVWF  xF5
02C3E:  MOVLW  03
02C40:  MOVWF  xF8
02C42:  MOVLW  37
02C44:  MOVWF  xF7
02C46:  MOVLB  0
02C48:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(127, IN_4_3_FILTER_B2);     // IN_4_3_FILTER_B2 
02C4C:  MOVLB  6
02C4E:  CLRF   xF6
02C50:  MOVLW  7F
02C52:  MOVWF  xF5
02C54:  MOVLW  03
02C56:  MOVWF  xF8
02C58:  MOVLW  38
02C5A:  MOVWF  xF7
02C5C:  MOVLB  0
02C5E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(128, IN_4_3_FILTER_MINUSA1);     // IN_4_3_FILTER_MINUSA1 
02C62:  MOVLB  6
02C64:  CLRF   xF6
02C66:  MOVLW  80
02C68:  MOVWF  xF5
02C6A:  MOVLW  03
02C6C:  MOVWF  xF8
02C6E:  MOVLW  39
02C70:  MOVWF  xF7
02C72:  MOVLB  0
02C74:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(129, IN_4_3_FILTER_MINUSA2);     // IN_4_3_FILTER_MINUSA2 
02C78:  MOVLB  6
02C7A:  CLRF   xF6
02C7C:  MOVLW  81
02C7E:  MOVWF  xF5
02C80:  MOVLW  03
02C82:  MOVWF  xF8
02C84:  MOVLW  3A
02C86:  MOVWF  xF7
02C88:  MOVLB  0
02C8A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(130, IN_5_1_FILTER_B0);     // IN_5_1_FILTER_B0 
02C8E:  MOVLB  6
02C90:  CLRF   xF6
02C92:  MOVLW  82
02C94:  MOVWF  xF5
02C96:  MOVLW  03
02C98:  MOVWF  xF8
02C9A:  MOVLW  31
02C9C:  MOVWF  xF7
02C9E:  MOVLB  0
02CA0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(131, IN_5_1_FILTER_B1);     // IN_5_1_FILTER_B1 
02CA4:  MOVLB  6
02CA6:  CLRF   xF6
02CA8:  MOVLW  83
02CAA:  MOVWF  xF5
02CAC:  MOVLW  03
02CAE:  MOVWF  xF8
02CB0:  MOVLW  32
02CB2:  MOVWF  xF7
02CB4:  MOVLB  0
02CB6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(132, IN_5_1_FILTER_B2);     // IN_5_1_FILTER_B2 
02CBA:  MOVLB  6
02CBC:  CLRF   xF6
02CBE:  MOVLW  84
02CC0:  MOVWF  xF5
02CC2:  MOVLW  03
02CC4:  MOVWF  xF8
02CC6:  MOVLW  33
02CC8:  MOVWF  xF7
02CCA:  MOVLB  0
02CCC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(133, IN_5_1_FILTER_MINUSA1);     // IN_5_1_FILTER_MINUSA1 
02CD0:  MOVLB  6
02CD2:  CLRF   xF6
02CD4:  MOVLW  85
02CD6:  MOVWF  xF5
02CD8:  MOVLW  03
02CDA:  MOVWF  xF8
02CDC:  MOVLW  34
02CDE:  MOVWF  xF7
02CE0:  MOVLB  0
02CE2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(134, IN_5_1_FILTER_MINUSA2);     // IN_5_1_FILTER_MINUSA2 
02CE6:  MOVLB  6
02CE8:  CLRF   xF6
02CEA:  MOVLW  86
02CEC:  MOVWF  xF5
02CEE:  MOVLW  03
02CF0:  MOVWF  xF8
02CF2:  MOVLW  35
02CF4:  MOVWF  xF7
02CF6:  MOVLB  0
02CF8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(135, IN_5_2_FILTER_B0);     // IN_5_2_FILTER_B0 
02CFC:  MOVLB  6
02CFE:  CLRF   xF6
02D00:  MOVLW  87
02D02:  MOVWF  xF5
02D04:  MOVLW  03
02D06:  MOVWF  xF8
02D08:  MOVLW  2C
02D0A:  MOVWF  xF7
02D0C:  MOVLB  0
02D0E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(136, IN_5_2_FILTER_B1);     // IN_5_2_FILTER_B1 
02D12:  MOVLB  6
02D14:  CLRF   xF6
02D16:  MOVLW  88
02D18:  MOVWF  xF5
02D1A:  MOVLW  03
02D1C:  MOVWF  xF8
02D1E:  MOVLW  2D
02D20:  MOVWF  xF7
02D22:  MOVLB  0
02D24:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(137, IN_5_2_FILTER_B2);     // IN_5_2_FILTER_B2 
02D28:  MOVLB  6
02D2A:  CLRF   xF6
02D2C:  MOVLW  89
02D2E:  MOVWF  xF5
02D30:  MOVLW  03
02D32:  MOVWF  xF8
02D34:  MOVLW  2E
02D36:  MOVWF  xF7
02D38:  MOVLB  0
02D3A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(138, IN_5_2_FILTER_MINUSA1);     // IN_5_2_FILTER_MINUSA1 
02D3E:  MOVLB  6
02D40:  CLRF   xF6
02D42:  MOVLW  8A
02D44:  MOVWF  xF5
02D46:  MOVLW  03
02D48:  MOVWF  xF8
02D4A:  MOVLW  2F
02D4C:  MOVWF  xF7
02D4E:  MOVLB  0
02D50:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(139, IN_5_2_FILTER_MINUSA2);     // IN_5_2_FILTER_MINUSA2 
02D54:  MOVLB  6
02D56:  CLRF   xF6
02D58:  MOVLW  8B
02D5A:  MOVWF  xF5
02D5C:  MOVLW  03
02D5E:  MOVWF  xF8
02D60:  MOVLW  30
02D62:  MOVWF  xF7
02D64:  MOVLB  0
02D66:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(140, IN_5_3_FILTER_B0);     // IN_5_3_FILTER_B0 
02D6A:  MOVLB  6
02D6C:  CLRF   xF6
02D6E:  MOVLW  8C
02D70:  MOVWF  xF5
02D72:  MOVLW  03
02D74:  MOVWF  xF8
02D76:  MOVLW  27
02D78:  MOVWF  xF7
02D7A:  MOVLB  0
02D7C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(141, IN_5_3_FILTER_B1);     // IN_5_3_FILTER_B1 
02D80:  MOVLB  6
02D82:  CLRF   xF6
02D84:  MOVLW  8D
02D86:  MOVWF  xF5
02D88:  MOVLW  03
02D8A:  MOVWF  xF8
02D8C:  MOVLW  28
02D8E:  MOVWF  xF7
02D90:  MOVLB  0
02D92:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(142, IN_5_3_FILTER_B2);     // IN_5_3_FILTER_B2 
02D96:  MOVLB  6
02D98:  CLRF   xF6
02D9A:  MOVLW  8E
02D9C:  MOVWF  xF5
02D9E:  MOVLW  03
02DA0:  MOVWF  xF8
02DA2:  MOVLW  29
02DA4:  MOVWF  xF7
02DA6:  MOVLB  0
02DA8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(143, IN_5_3_FILTER_MINUSA1);     // IN_5_3_FILTER_MINUSA1 
02DAC:  MOVLB  6
02DAE:  CLRF   xF6
02DB0:  MOVLW  8F
02DB2:  MOVWF  xF5
02DB4:  MOVLW  03
02DB6:  MOVWF  xF8
02DB8:  MOVLW  2A
02DBA:  MOVWF  xF7
02DBC:  MOVLB  0
02DBE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(144, IN_5_3_FILTER_MINUSA2);     // IN_5_3_FILTER_MINUSA2 
02DC2:  MOVLB  6
02DC4:  CLRF   xF6
02DC6:  MOVLW  90
02DC8:  MOVWF  xF5
02DCA:  MOVLW  03
02DCC:  MOVWF  xF8
02DCE:  MOVLW  2B
02DD0:  MOVWF  xF7
02DD2:  MOVLB  0
02DD4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(145, IN_6_1_FILTER_B0);     // IN_6_1_FILTER_B0 
02DD8:  MOVLB  6
02DDA:  CLRF   xF6
02DDC:  MOVLW  91
02DDE:  MOVWF  xF5
02DE0:  MOVLW  03
02DE2:  MOVWF  xF8
02DE4:  MOVLW  22
02DE6:  MOVWF  xF7
02DE8:  MOVLB  0
02DEA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(146, IN_6_1_FILTER_B1);     // IN_6_1_FILTER_B1 
02DEE:  MOVLB  6
02DF0:  CLRF   xF6
02DF2:  MOVLW  92
02DF4:  MOVWF  xF5
02DF6:  MOVLW  03
02DF8:  MOVWF  xF8
02DFA:  MOVLW  23
02DFC:  MOVWF  xF7
02DFE:  MOVLB  0
02E00:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(147, IN_6_1_FILTER_B2);     // IN_6_1_FILTER_B2 
02E04:  MOVLB  6
02E06:  CLRF   xF6
02E08:  MOVLW  93
02E0A:  MOVWF  xF5
02E0C:  MOVLW  03
02E0E:  MOVWF  xF8
02E10:  MOVLW  24
02E12:  MOVWF  xF7
02E14:  MOVLB  0
02E16:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(148, IN_6_1_FILTER_MINUSA1);     // IN_6_1_FILTER_MINUSA1 
02E1A:  MOVLB  6
02E1C:  CLRF   xF6
02E1E:  MOVLW  94
02E20:  MOVWF  xF5
02E22:  MOVLW  03
02E24:  MOVWF  xF8
02E26:  MOVLW  25
02E28:  MOVWF  xF7
02E2A:  MOVLB  0
02E2C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(149, IN_6_1_FILTER_MINUSA2);     // IN_6_1_FILTER_MINUSA2 
02E30:  MOVLB  6
02E32:  CLRF   xF6
02E34:  MOVLW  95
02E36:  MOVWF  xF5
02E38:  MOVLW  03
02E3A:  MOVWF  xF8
02E3C:  MOVLW  26
02E3E:  MOVWF  xF7
02E40:  MOVLB  0
02E42:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(150, IN_6_2_FILTER_B0);     // IN_6_2_FILTER_B0 
02E46:  MOVLB  6
02E48:  CLRF   xF6
02E4A:  MOVLW  96
02E4C:  MOVWF  xF5
02E4E:  MOVLW  03
02E50:  MOVWF  xF8
02E52:  MOVLW  1D
02E54:  MOVWF  xF7
02E56:  MOVLB  0
02E58:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(151, IN_6_2_FILTER_B1);     // IN_6_2_FILTER_B1 
02E5C:  MOVLB  6
02E5E:  CLRF   xF6
02E60:  MOVLW  97
02E62:  MOVWF  xF5
02E64:  MOVLW  03
02E66:  MOVWF  xF8
02E68:  MOVLW  1E
02E6A:  MOVWF  xF7
02E6C:  MOVLB  0
02E6E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(152, IN_6_2_FILTER_B2);     // IN_6_2_FILTER_B2 
02E72:  MOVLB  6
02E74:  CLRF   xF6
02E76:  MOVLW  98
02E78:  MOVWF  xF5
02E7A:  MOVLW  03
02E7C:  MOVWF  xF8
02E7E:  MOVLW  1F
02E80:  MOVWF  xF7
02E82:  MOVLB  0
02E84:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(153, IN_6_2_FILTER_MINUSA1);     // IN_6_2_FILTER_MINUSA1 
02E88:  MOVLB  6
02E8A:  CLRF   xF6
02E8C:  MOVLW  99
02E8E:  MOVWF  xF5
02E90:  MOVLW  03
02E92:  MOVWF  xF8
02E94:  MOVLW  20
02E96:  MOVWF  xF7
02E98:  MOVLB  0
02E9A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(154, IN_6_2_FILTER_MINUSA2);     // IN_6_2_FILTER_MINUSA2 
02E9E:  MOVLB  6
02EA0:  CLRF   xF6
02EA2:  MOVLW  9A
02EA4:  MOVWF  xF5
02EA6:  MOVLW  03
02EA8:  MOVWF  xF8
02EAA:  MOVLW  21
02EAC:  MOVWF  xF7
02EAE:  MOVLB  0
02EB0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(155, IN_6_3_FILTER_B0);     // IN_6_3_FILTER_B0 
02EB4:  MOVLB  6
02EB6:  CLRF   xF6
02EB8:  MOVLW  9B
02EBA:  MOVWF  xF5
02EBC:  MOVLW  03
02EBE:  MOVWF  xF8
02EC0:  MOVLW  18
02EC2:  MOVWF  xF7
02EC4:  MOVLB  0
02EC6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(156, IN_6_3_FILTER_B1);     // IN_6_3_FILTER_B1 
02ECA:  MOVLB  6
02ECC:  CLRF   xF6
02ECE:  MOVLW  9C
02ED0:  MOVWF  xF5
02ED2:  MOVLW  03
02ED4:  MOVWF  xF8
02ED6:  MOVLW  19
02ED8:  MOVWF  xF7
02EDA:  MOVLB  0
02EDC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(157, IN_6_3_FILTER_B2);     // IN_6_3_FILTER_B2 
02EE0:  MOVLB  6
02EE2:  CLRF   xF6
02EE4:  MOVLW  9D
02EE6:  MOVWF  xF5
02EE8:  MOVLW  03
02EEA:  MOVWF  xF8
02EEC:  MOVLW  1A
02EEE:  MOVWF  xF7
02EF0:  MOVLB  0
02EF2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(158, IN_6_3_FILTER_MINUSA1);     // IN_6_3_FILTER_MINUSA1 
02EF6:  MOVLB  6
02EF8:  CLRF   xF6
02EFA:  MOVLW  9E
02EFC:  MOVWF  xF5
02EFE:  MOVLW  03
02F00:  MOVWF  xF8
02F02:  MOVLW  1B
02F04:  MOVWF  xF7
02F06:  MOVLB  0
02F08:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(159, IN_6_3_FILTER_MINUSA2);     // IN_6_3_FILTER_MINUSA2 
02F0C:  MOVLB  6
02F0E:  CLRF   xF6
02F10:  MOVLW  9F
02F12:  MOVWF  xF5
02F14:  MOVLW  03
02F16:  MOVWF  xF8
02F18:  MOVLW  1C
02F1A:  MOVWF  xF7
02F1C:  MOVLB  0
02F1E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(160, IN_7_1_FILTER_B0);     // IN_7_1_FILTER_B0 
02F22:  MOVLB  6
02F24:  CLRF   xF6
02F26:  MOVLW  A0
02F28:  MOVWF  xF5
02F2A:  MOVLW  03
02F2C:  MOVWF  xF8
02F2E:  MOVLW  13
02F30:  MOVWF  xF7
02F32:  MOVLB  0
02F34:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(161, IN_7_1_FILTER_B1);     // IN_7_1_FILTER_B1 
02F38:  MOVLB  6
02F3A:  CLRF   xF6
02F3C:  MOVLW  A1
02F3E:  MOVWF  xF5
02F40:  MOVLW  03
02F42:  MOVWF  xF8
02F44:  MOVLW  14
02F46:  MOVWF  xF7
02F48:  MOVLB  0
02F4A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(162, IN_7_1_FILTER_B2);     // IN_7_1_FILTER_B2 
02F4E:  MOVLB  6
02F50:  CLRF   xF6
02F52:  MOVLW  A2
02F54:  MOVWF  xF5
02F56:  MOVLW  03
02F58:  MOVWF  xF8
02F5A:  MOVLW  15
02F5C:  MOVWF  xF7
02F5E:  MOVLB  0
02F60:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(163, IN_7_1_FILTER_MINUSA1);     // IN_7_1_FILTER_MINUSA1 
02F64:  MOVLB  6
02F66:  CLRF   xF6
02F68:  MOVLW  A3
02F6A:  MOVWF  xF5
02F6C:  MOVLW  03
02F6E:  MOVWF  xF8
02F70:  MOVLW  16
02F72:  MOVWF  xF7
02F74:  MOVLB  0
02F76:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(164, IN_7_1_FILTER_MINUSA2);     // IN_7_1_FILTER_MINUSA2 
02F7A:  MOVLB  6
02F7C:  CLRF   xF6
02F7E:  MOVLW  A4
02F80:  MOVWF  xF5
02F82:  MOVLW  03
02F84:  MOVWF  xF8
02F86:  MOVLW  17
02F88:  MOVWF  xF7
02F8A:  MOVLB  0
02F8C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(165, IN_7_2_FILTER_B0);     // IN_7_2_FILTER_B0 
02F90:  MOVLB  6
02F92:  CLRF   xF6
02F94:  MOVLW  A5
02F96:  MOVWF  xF5
02F98:  MOVLW  03
02F9A:  MOVWF  xF8
02F9C:  MOVLW  0E
02F9E:  MOVWF  xF7
02FA0:  MOVLB  0
02FA2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(166, IN_7_2_FILTER_B1);     // IN_7_2_FILTER_B1 
02FA6:  MOVLB  6
02FA8:  CLRF   xF6
02FAA:  MOVLW  A6
02FAC:  MOVWF  xF5
02FAE:  MOVLW  03
02FB0:  MOVWF  xF8
02FB2:  MOVLW  0F
02FB4:  MOVWF  xF7
02FB6:  MOVLB  0
02FB8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(167, IN_7_2_FILTER_B2);     // IN_7_2_FILTER_B2 
02FBC:  MOVLB  6
02FBE:  CLRF   xF6
02FC0:  MOVLW  A7
02FC2:  MOVWF  xF5
02FC4:  MOVLW  03
02FC6:  MOVWF  xF8
02FC8:  MOVLW  10
02FCA:  MOVWF  xF7
02FCC:  MOVLB  0
02FCE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(168, IN_7_2_FILTER_MINUSA1);     // IN_7_2_FILTER_MINUSA1 
02FD2:  MOVLB  6
02FD4:  CLRF   xF6
02FD6:  MOVLW  A8
02FD8:  MOVWF  xF5
02FDA:  MOVLW  03
02FDC:  MOVWF  xF8
02FDE:  MOVLW  11
02FE0:  MOVWF  xF7
02FE2:  MOVLB  0
02FE4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(169, IN_7_2_FILTER_MINUSA2);     // IN_7_2_FILTER_MINUSA2 
02FE8:  MOVLB  6
02FEA:  CLRF   xF6
02FEC:  MOVLW  A9
02FEE:  MOVWF  xF5
02FF0:  MOVLW  03
02FF2:  MOVWF  xF8
02FF4:  MOVLW  12
02FF6:  MOVWF  xF7
02FF8:  MOVLB  0
02FFA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(170, IN_7_3_FILTER_B0);     // IN_7_3_FILTER_B0 
02FFE:  MOVLB  6
03000:  CLRF   xF6
03002:  MOVLW  AA
03004:  MOVWF  xF5
03006:  MOVLW  03
03008:  MOVWF  xF8
0300A:  MOVLW  09
0300C:  MOVWF  xF7
0300E:  MOVLB  0
03010:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(171, IN_7_3_FILTER_B1);     // IN_7_3_FILTER_B1 
03014:  MOVLB  6
03016:  CLRF   xF6
03018:  MOVLW  AB
0301A:  MOVWF  xF5
0301C:  MOVLW  03
0301E:  MOVWF  xF8
03020:  MOVLW  0A
03022:  MOVWF  xF7
03024:  MOVLB  0
03026:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(172, IN_7_3_FILTER_B2);     // IN_7_3_FILTER_B2 
0302A:  MOVLB  6
0302C:  CLRF   xF6
0302E:  MOVLW  AC
03030:  MOVWF  xF5
03032:  MOVLW  03
03034:  MOVWF  xF8
03036:  MOVLW  0B
03038:  MOVWF  xF7
0303A:  MOVLB  0
0303C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(173, IN_7_3_FILTER_MINUSA1);     // IN_7_3_FILTER_MINUSA1 
03040:  MOVLB  6
03042:  CLRF   xF6
03044:  MOVLW  AD
03046:  MOVWF  xF5
03048:  MOVLW  03
0304A:  MOVWF  xF8
0304C:  MOVLW  0C
0304E:  MOVWF  xF7
03050:  MOVLB  0
03052:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(174, IN_7_3_FILTER_MINUSA2);     // IN_7_3_FILTER_MINUSA2 
03056:  MOVLB  6
03058:  CLRF   xF6
0305A:  MOVLW  AE
0305C:  MOVWF  xF5
0305E:  MOVLW  03
03060:  MOVWF  xF8
03062:  MOVLW  0D
03064:  MOVWF  xF7
03066:  MOVLB  0
03068:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(175, IN_8_1_FILTER_B0);     // IN_8_1_FILTER_B0 
0306C:  MOVLB  6
0306E:  CLRF   xF6
03070:  MOVLW  AF
03072:  MOVWF  xF5
03074:  MOVLW  03
03076:  MOVWF  xF8
03078:  MOVLW  04
0307A:  MOVWF  xF7
0307C:  MOVLB  0
0307E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(176, IN_8_1_FILTER_B1);     // IN_8_1_FILTER_B1 
03082:  MOVLB  6
03084:  CLRF   xF6
03086:  MOVLW  B0
03088:  MOVWF  xF5
0308A:  MOVLW  03
0308C:  MOVWF  xF8
0308E:  MOVLW  05
03090:  MOVWF  xF7
03092:  MOVLB  0
03094:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(177, IN_8_1_FILTER_B2);     // IN_8_1_FILTER_B2 
03098:  MOVLB  6
0309A:  CLRF   xF6
0309C:  MOVLW  B1
0309E:  MOVWF  xF5
030A0:  MOVLW  03
030A2:  MOVWF  xF8
030A4:  MOVLW  06
030A6:  MOVWF  xF7
030A8:  MOVLB  0
030AA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(178, IN_8_1_FILTER_MINUSA1);     // IN_8_1_FILTER_MINUSA1 
030AE:  MOVLB  6
030B0:  CLRF   xF6
030B2:  MOVLW  B2
030B4:  MOVWF  xF5
030B6:  MOVLW  03
030B8:  MOVWF  xF8
030BA:  MOVLW  07
030BC:  MOVWF  xF7
030BE:  MOVLB  0
030C0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(179, IN_8_1_FILTER_MINUSA2);     // IN_8_1_FILTER_MINUSA2 
030C4:  MOVLB  6
030C6:  CLRF   xF6
030C8:  MOVLW  B3
030CA:  MOVWF  xF5
030CC:  MOVLW  03
030CE:  MOVWF  xF8
030D0:  MOVLW  08
030D2:  MOVWF  xF7
030D4:  MOVLB  0
030D6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(180, IN_8_2_FILTER_B0);     // IN_8_2_FILTER_B0 
030DA:  MOVLB  6
030DC:  CLRF   xF6
030DE:  MOVLW  B4
030E0:  MOVWF  xF5
030E2:  MOVLW  02
030E4:  MOVWF  xF8
030E6:  SETF   xF7
030E8:  MOVLB  0
030EA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(181, IN_8_2_FILTER_B1);     // IN_8_2_FILTER_B1 
030EE:  MOVLB  6
030F0:  CLRF   xF6
030F2:  MOVLW  B5
030F4:  MOVWF  xF5
030F6:  MOVLW  03
030F8:  MOVWF  xF8
030FA:  CLRF   xF7
030FC:  MOVLB  0
030FE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(182, IN_8_2_FILTER_B2);     // IN_8_2_FILTER_B2 
03102:  MOVLB  6
03104:  CLRF   xF6
03106:  MOVLW  B6
03108:  MOVWF  xF5
0310A:  MOVLW  03
0310C:  MOVWF  xF8
0310E:  MOVLW  01
03110:  MOVWF  xF7
03112:  MOVLB  0
03114:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(183, IN_8_2_FILTER_MINUSA1);     // IN_8_2_FILTER_MINUSA1 
03118:  MOVLB  6
0311A:  CLRF   xF6
0311C:  MOVLW  B7
0311E:  MOVWF  xF5
03120:  MOVLW  03
03122:  MOVWF  xF8
03124:  MOVLW  02
03126:  MOVWF  xF7
03128:  MOVLB  0
0312A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(184, IN_8_2_FILTER_MINUSA2);     // IN_8_2_FILTER_MINUSA2 
0312E:  MOVLB  6
03130:  CLRF   xF6
03132:  MOVLW  B8
03134:  MOVWF  xF5
03136:  MOVLW  03
03138:  MOVWF  xF8
0313A:  MOVWF  xF7
0313C:  MOVLB  0
0313E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(185, IN_8_3_FILTER_B0);     // IN_8_3_FILTER_B0 
03142:  MOVLB  6
03144:  CLRF   xF6
03146:  MOVLW  B9
03148:  MOVWF  xF5
0314A:  MOVLW  02
0314C:  MOVWF  xF8
0314E:  MOVLW  FA
03150:  MOVWF  xF7
03152:  MOVLB  0
03154:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(186, IN_8_3_FILTER_B1);     // IN_8_3_FILTER_B1 
03158:  MOVLB  6
0315A:  CLRF   xF6
0315C:  MOVLW  BA
0315E:  MOVWF  xF5
03160:  MOVLW  02
03162:  MOVWF  xF8
03164:  MOVLW  FB
03166:  MOVWF  xF7
03168:  MOVLB  0
0316A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(187, IN_8_3_FILTER_B2);     // IN_8_3_FILTER_B2 
0316E:  MOVLB  6
03170:  CLRF   xF6
03172:  MOVLW  BB
03174:  MOVWF  xF5
03176:  MOVLW  02
03178:  MOVWF  xF8
0317A:  MOVLW  FC
0317C:  MOVWF  xF7
0317E:  MOVLB  0
03180:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(188, IN_8_3_FILTER_MINUSA1);     // IN_8_3_FILTER_MINUSA1 
03184:  MOVLB  6
03186:  CLRF   xF6
03188:  MOVLW  BC
0318A:  MOVWF  xF5
0318C:  MOVLW  02
0318E:  MOVWF  xF8
03190:  MOVLW  FD
03192:  MOVWF  xF7
03194:  MOVLB  0
03196:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(189, IN_8_3_FILTER_MINUSA2);     // IN_8_3_FILTER_MINUSA2 
0319A:  MOVLB  6
0319C:  CLRF   xF6
0319E:  MOVLW  BD
031A0:  MOVWF  xF5
031A2:  MOVLW  02
031A4:  MOVWF  xF8
031A6:  MOVLW  FE
031A8:  MOVWF  xF7
031AA:  MOVLB  0
031AC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(190, CH1COMP_THRESHOLD);     // CH1COMP_THRESHOLD 
031B0:  MOVLB  6
031B2:  CLRF   xF6
031B4:  MOVLW  BE
031B6:  MOVWF  xF5
031B8:  MOVLW  02
031BA:  MOVWF  xF8
031BC:  MOVLW  6E
031BE:  MOVWF  xF7
031C0:  MOVLB  0
031C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(191, CH1COMP_KNEE);     // CH1COMP_KNEE 
031C6:  MOVLB  6
031C8:  CLRF   xF6
031CA:  MOVLW  BF
031CC:  MOVWF  xF5
031CE:  MOVLW  02
031D0:  MOVWF  xF8
031D2:  MOVLW  6F
031D4:  MOVWF  xF7
031D6:  MOVLB  0
031D8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(192, CH1COMP_RATIO);     // CH1COMP_RATIO 
031DC:  MOVLB  6
031DE:  CLRF   xF6
031E0:  MOVLW  C0
031E2:  MOVWF  xF5
031E4:  MOVLW  02
031E6:  MOVWF  xF8
031E8:  MOVLW  70
031EA:  MOVWF  xF7
031EC:  MOVLB  0
031EE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(193, CH1COMP_ATTACK);     // CH1COMP_ATTACK 
031F2:  MOVLB  6
031F4:  CLRF   xF6
031F6:  MOVLW  C1
031F8:  MOVWF  xF5
031FA:  MOVLW  02
031FC:  MOVWF  xF8
031FE:  MOVLW  71
03200:  MOVWF  xF7
03202:  MOVLB  0
03204:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(194, CH1COMP_RELEASE);     // CH1COMP_RELEASE 
03208:  MOVLB  6
0320A:  CLRF   xF6
0320C:  MOVLW  C2
0320E:  MOVWF  xF5
03210:  MOVLW  02
03212:  MOVWF  xF8
03214:  MOVLW  72
03216:  MOVWF  xF7
03218:  MOVLB  0
0321A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(195, CH1COMP_BYPASS);     // CH1COMP_BYPASS 
0321E:  MOVLB  6
03220:  CLRF   xF6
03222:  MOVLW  C3
03224:  MOVWF  xF5
03226:  MOVLW  02
03228:  MOVWF  xF8
0322A:  MOVLW  73
0322C:  MOVWF  xF7
0322E:  MOVLB  0
03230:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(196, CH2COMP_THRESHOLD);     // CH2COMP_THRESHOLD 
03234:  MOVLB  6
03236:  CLRF   xF6
03238:  MOVLW  C4
0323A:  MOVWF  xF5
0323C:  MOVLW  02
0323E:  MOVWF  xF8
03240:  MOVLW  66
03242:  MOVWF  xF7
03244:  MOVLB  0
03246:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(197, CH2COMP_KNEE);     // CH2COMP_KNEE 
0324A:  MOVLB  6
0324C:  CLRF   xF6
0324E:  MOVLW  C5
03250:  MOVWF  xF5
03252:  MOVLW  02
03254:  MOVWF  xF8
03256:  MOVLW  67
03258:  MOVWF  xF7
0325A:  MOVLB  0
0325C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(198, CH2COMP_RATIO);     // CH2COMP_RATIO 
03260:  MOVLB  6
03262:  CLRF   xF6
03264:  MOVLW  C6
03266:  MOVWF  xF5
03268:  MOVLW  02
0326A:  MOVWF  xF8
0326C:  MOVLW  68
0326E:  MOVWF  xF7
03270:  MOVLB  0
03272:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(199, CH2COMP_ATTACK);     // CH2COMP_ATTACK 
03276:  MOVLB  6
03278:  CLRF   xF6
0327A:  MOVLW  C7
0327C:  MOVWF  xF5
0327E:  MOVLW  02
03280:  MOVWF  xF8
03282:  MOVLW  69
03284:  MOVWF  xF7
03286:  MOVLB  0
03288:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(200, CH2COMP_RELEASE);     // CH2COMP_RELEASE 
0328C:  MOVLB  6
0328E:  CLRF   xF6
03290:  MOVLW  C8
03292:  MOVWF  xF5
03294:  MOVLW  02
03296:  MOVWF  xF8
03298:  MOVLW  6A
0329A:  MOVWF  xF7
0329C:  MOVLB  0
0329E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(201, CH2COMP_BYPASS);     // CH2COMP_BYPASS 
032A2:  MOVLB  6
032A4:  CLRF   xF6
032A6:  MOVLW  C9
032A8:  MOVWF  xF5
032AA:  MOVLW  02
032AC:  MOVWF  xF8
032AE:  MOVLW  6B
032B0:  MOVWF  xF7
032B2:  MOVLB  0
032B4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(202, CH3COMP_THRESHOLD);     // CH3COMP_THRESHOLD 
032B8:  MOVLB  6
032BA:  CLRF   xF6
032BC:  MOVLW  CA
032BE:  MOVWF  xF5
032C0:  MOVLW  02
032C2:  MOVWF  xF8
032C4:  MOVLW  5E
032C6:  MOVWF  xF7
032C8:  MOVLB  0
032CA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(203, CH3COMP_KNEE);     // CH3COMP_KNEE 
032CE:  MOVLB  6
032D0:  CLRF   xF6
032D2:  MOVLW  CB
032D4:  MOVWF  xF5
032D6:  MOVLW  02
032D8:  MOVWF  xF8
032DA:  MOVLW  5F
032DC:  MOVWF  xF7
032DE:  MOVLB  0
032E0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(204, CH3COMP_RATIO);     // CH3COMP_RATIO 
032E4:  MOVLB  6
032E6:  CLRF   xF6
032E8:  MOVLW  CC
032EA:  MOVWF  xF5
032EC:  MOVLW  02
032EE:  MOVWF  xF8
032F0:  MOVLW  60
032F2:  MOVWF  xF7
032F4:  MOVLB  0
032F6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(205, CH3COMP_ATTACK);     // CH3COMP_ATTACK 
032FA:  MOVLB  6
032FC:  CLRF   xF6
032FE:  MOVLW  CD
03300:  MOVWF  xF5
03302:  MOVLW  02
03304:  MOVWF  xF8
03306:  MOVLW  61
03308:  MOVWF  xF7
0330A:  MOVLB  0
0330C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(206, CH3COMP_RELEASE);     // CH3COMP_RELEASE 
03310:  MOVLB  6
03312:  CLRF   xF6
03314:  MOVLW  CE
03316:  MOVWF  xF5
03318:  MOVLW  02
0331A:  MOVWF  xF8
0331C:  MOVLW  62
0331E:  MOVWF  xF7
03320:  MOVLB  0
03322:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(207, CH3COMP_BYPASS);     // CH3COMP_BYPASS 
03326:  MOVLB  6
03328:  CLRF   xF6
0332A:  MOVLW  CF
0332C:  MOVWF  xF5
0332E:  MOVLW  02
03330:  MOVWF  xF8
03332:  MOVLW  63
03334:  MOVWF  xF7
03336:  MOVLB  0
03338:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(208, CH4COMP_THRESHOLD);     // CH4COMP_THRESHOLD 
0333C:  MOVLB  6
0333E:  CLRF   xF6
03340:  MOVLW  D0
03342:  MOVWF  xF5
03344:  MOVLW  02
03346:  MOVWF  xF8
03348:  MOVLW  56
0334A:  MOVWF  xF7
0334C:  MOVLB  0
0334E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(209, CH4COMP_KNEE);     // CH4COMP_KNEE 
03352:  MOVLB  6
03354:  CLRF   xF6
03356:  MOVLW  D1
03358:  MOVWF  xF5
0335A:  MOVLW  02
0335C:  MOVWF  xF8
0335E:  MOVLW  57
03360:  MOVWF  xF7
03362:  MOVLB  0
03364:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(210, CH4COMP_RATIO);     // CH4COMP_RATIO 
03368:  MOVLB  6
0336A:  CLRF   xF6
0336C:  MOVLW  D2
0336E:  MOVWF  xF5
03370:  MOVLW  02
03372:  MOVWF  xF8
03374:  MOVLW  58
03376:  MOVWF  xF7
03378:  MOVLB  0
0337A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(211, CH4COMP_ATTACK);     // CH4COMP_ATTACK 
0337E:  MOVLB  6
03380:  CLRF   xF6
03382:  MOVLW  D3
03384:  MOVWF  xF5
03386:  MOVLW  02
03388:  MOVWF  xF8
0338A:  MOVLW  59
0338C:  MOVWF  xF7
0338E:  MOVLB  0
03390:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(212, CH4COMP_RELEASE);     // CH4COMP_RELEASE 
03394:  MOVLB  6
03396:  CLRF   xF6
03398:  MOVLW  D4
0339A:  MOVWF  xF5
0339C:  MOVLW  02
0339E:  MOVWF  xF8
033A0:  MOVLW  5A
033A2:  MOVWF  xF7
033A4:  MOVLB  0
033A6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(213, CH4COMP_BYPASS);     // CH4COMP_BYPASS 
033AA:  MOVLB  6
033AC:  CLRF   xF6
033AE:  MOVLW  D5
033B0:  MOVWF  xF5
033B2:  MOVLW  02
033B4:  MOVWF  xF8
033B6:  MOVLW  5B
033B8:  MOVWF  xF7
033BA:  MOVLB  0
033BC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(214, CH5COMP_THRESHOLD);     // CH5COMP_THRESHOLD 
033C0:  MOVLB  6
033C2:  CLRF   xF6
033C4:  MOVLW  D6
033C6:  MOVWF  xF5
033C8:  MOVLW  02
033CA:  MOVWF  xF8
033CC:  MOVLW  4E
033CE:  MOVWF  xF7
033D0:  MOVLB  0
033D2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(215, CH5COMP_KNEE);     // CH5COMP_KNEE 
033D6:  MOVLB  6
033D8:  CLRF   xF6
033DA:  MOVLW  D7
033DC:  MOVWF  xF5
033DE:  MOVLW  02
033E0:  MOVWF  xF8
033E2:  MOVLW  4F
033E4:  MOVWF  xF7
033E6:  MOVLB  0
033E8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(216, CH5COMP_RATIO);     // CH5COMP_RATIO 
033EC:  MOVLB  6
033EE:  CLRF   xF6
033F0:  MOVLW  D8
033F2:  MOVWF  xF5
033F4:  MOVLW  02
033F6:  MOVWF  xF8
033F8:  MOVLW  50
033FA:  MOVWF  xF7
033FC:  MOVLB  0
033FE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(217, CH5COMP_ATTACK);     // CH5COMP_ATTACK 
03402:  MOVLB  6
03404:  CLRF   xF6
03406:  MOVLW  D9
03408:  MOVWF  xF5
0340A:  MOVLW  02
0340C:  MOVWF  xF8
0340E:  MOVLW  51
03410:  MOVWF  xF7
03412:  MOVLB  0
03414:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(218, CH5COMP_RELEASE);     // CH5COMP_RELEASE 
03418:  MOVLB  6
0341A:  CLRF   xF6
0341C:  MOVLW  DA
0341E:  MOVWF  xF5
03420:  MOVLW  02
03422:  MOVWF  xF8
03424:  MOVLW  52
03426:  MOVWF  xF7
03428:  MOVLB  0
0342A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(219, CH5COMP_BYPASS);     // CH5COMP_BYPASS 
0342E:  MOVLB  6
03430:  CLRF   xF6
03432:  MOVLW  DB
03434:  MOVWF  xF5
03436:  MOVLW  02
03438:  MOVWF  xF8
0343A:  MOVLW  53
0343C:  MOVWF  xF7
0343E:  MOVLB  0
03440:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(220, CH6COMP_THRESHOLD);     // CH6COMP_THRESHOLD 
03444:  MOVLB  6
03446:  CLRF   xF6
03448:  MOVLW  DC
0344A:  MOVWF  xF5
0344C:  MOVLW  02
0344E:  MOVWF  xF8
03450:  MOVLW  46
03452:  MOVWF  xF7
03454:  MOVLB  0
03456:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(221, CH6COMP_KNEE);     // CH6COMP_KNEE 
0345A:  MOVLB  6
0345C:  CLRF   xF6
0345E:  MOVLW  DD
03460:  MOVWF  xF5
03462:  MOVLW  02
03464:  MOVWF  xF8
03466:  MOVLW  47
03468:  MOVWF  xF7
0346A:  MOVLB  0
0346C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(222, CH6COMP_RATIO);     // CH6COMP_RATIO 
03470:  MOVLB  6
03472:  CLRF   xF6
03474:  MOVLW  DE
03476:  MOVWF  xF5
03478:  MOVLW  02
0347A:  MOVWF  xF8
0347C:  MOVLW  48
0347E:  MOVWF  xF7
03480:  MOVLB  0
03482:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(223, CH6COMP_ATTACK);     // CH6COMP_ATTACK 
03486:  MOVLB  6
03488:  CLRF   xF6
0348A:  MOVLW  DF
0348C:  MOVWF  xF5
0348E:  MOVLW  02
03490:  MOVWF  xF8
03492:  MOVLW  49
03494:  MOVWF  xF7
03496:  MOVLB  0
03498:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(224, CH6COMP_RELEASE);     // CH6COMP_RELEASE 
0349C:  MOVLB  6
0349E:  CLRF   xF6
034A0:  MOVLW  E0
034A2:  MOVWF  xF5
034A4:  MOVLW  02
034A6:  MOVWF  xF8
034A8:  MOVLW  4A
034AA:  MOVWF  xF7
034AC:  MOVLB  0
034AE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(225, CH6COMP_BYPASS);     // CH6COMP_BYPASS 
034B2:  MOVLB  6
034B4:  CLRF   xF6
034B6:  MOVLW  E1
034B8:  MOVWF  xF5
034BA:  MOVLW  02
034BC:  MOVWF  xF8
034BE:  MOVLW  4B
034C0:  MOVWF  xF7
034C2:  MOVLB  0
034C4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(226, CH7COMP_THRESHOLD);     // CH7COMP_THRESHOLD 
034C8:  MOVLB  6
034CA:  CLRF   xF6
034CC:  MOVLW  E2
034CE:  MOVWF  xF5
034D0:  MOVLW  02
034D2:  MOVWF  xF8
034D4:  MOVLW  3E
034D6:  MOVWF  xF7
034D8:  MOVLB  0
034DA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(227, CH7COMP_KNEE);     // CH7COMP_KNEE 
034DE:  MOVLB  6
034E0:  CLRF   xF6
034E2:  MOVLW  E3
034E4:  MOVWF  xF5
034E6:  MOVLW  02
034E8:  MOVWF  xF8
034EA:  MOVLW  3F
034EC:  MOVWF  xF7
034EE:  MOVLB  0
034F0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(228, CH7COMP_RATIO);     // CH7COMP_RATIO 
034F4:  MOVLB  6
034F6:  CLRF   xF6
034F8:  MOVLW  E4
034FA:  MOVWF  xF5
034FC:  MOVLW  02
034FE:  MOVWF  xF8
03500:  MOVLW  40
03502:  MOVWF  xF7
03504:  MOVLB  0
03506:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(229, CH7COMP_ATTACK);     // CH7COMP_ATTACK 
0350A:  MOVLB  6
0350C:  CLRF   xF6
0350E:  MOVLW  E5
03510:  MOVWF  xF5
03512:  MOVLW  02
03514:  MOVWF  xF8
03516:  MOVLW  41
03518:  MOVWF  xF7
0351A:  MOVLB  0
0351C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(230, CH7COMP_RELEASE);     // CH7COMP_RELEASE 
03520:  MOVLB  6
03522:  CLRF   xF6
03524:  MOVLW  E6
03526:  MOVWF  xF5
03528:  MOVLW  02
0352A:  MOVWF  xF8
0352C:  MOVLW  42
0352E:  MOVWF  xF7
03530:  MOVLB  0
03532:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(231, CH7COMP_BYPASS);     // CH7COMP_BYPASS 
03536:  MOVLB  6
03538:  CLRF   xF6
0353A:  MOVLW  E7
0353C:  MOVWF  xF5
0353E:  MOVLW  02
03540:  MOVWF  xF8
03542:  MOVLW  43
03544:  MOVWF  xF7
03546:  MOVLB  0
03548:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(232, CH8COMP_THRESHOLD);     // CH8COMP_THRESHOLD 
0354C:  MOVLB  6
0354E:  CLRF   xF6
03550:  MOVLW  E8
03552:  MOVWF  xF5
03554:  MOVLW  02
03556:  MOVWF  xF8
03558:  MOVLW  36
0355A:  MOVWF  xF7
0355C:  MOVLB  0
0355E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(233, CH8COMP_KNEE);     // CH8COMP_KNEE 
03562:  MOVLB  6
03564:  CLRF   xF6
03566:  MOVLW  E9
03568:  MOVWF  xF5
0356A:  MOVLW  02
0356C:  MOVWF  xF8
0356E:  MOVLW  37
03570:  MOVWF  xF7
03572:  MOVLB  0
03574:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(234, CH8COMP_RATIO);     // CH8COMP_RATIO 
03578:  MOVLB  6
0357A:  CLRF   xF6
0357C:  MOVLW  EA
0357E:  MOVWF  xF5
03580:  MOVLW  02
03582:  MOVWF  xF8
03584:  MOVLW  38
03586:  MOVWF  xF7
03588:  MOVLB  0
0358A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(235, CH8COMP_ATTACK);     // CH8COMP_ATTACK 
0358E:  MOVLB  6
03590:  CLRF   xF6
03592:  MOVLW  EB
03594:  MOVWF  xF5
03596:  MOVLW  02
03598:  MOVWF  xF8
0359A:  MOVLW  39
0359C:  MOVWF  xF7
0359E:  MOVLB  0
035A0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(236, CH8COMP_RELEASE);     // CH8COMP_RELEASE 
035A4:  MOVLB  6
035A6:  CLRF   xF6
035A8:  MOVLW  EC
035AA:  MOVWF  xF5
035AC:  MOVLW  02
035AE:  MOVWF  xF8
035B0:  MOVLW  3A
035B2:  MOVWF  xF7
035B4:  MOVLB  0
035B6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(237, CH8COMP_BYPASS);     // CH8COMP_BYPASS 
035BA:  MOVLB  6
035BC:  CLRF   xF6
035BE:  MOVLW  ED
035C0:  MOVWF  xF5
035C2:  MOVLW  02
035C4:  MOVWF  xF8
035C6:  MOVLW  3B
035C8:  MOVWF  xF7
035CA:  MOVLB  0
035CC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(238, MIXER_SELECT0);     // MIXER_SELECT0 
035D0:  MOVLB  6
035D2:  CLRF   xF6
035D4:  MOVLW  EE
035D6:  MOVWF  xF5
035D8:  CLRF   xF8
035DA:  MOVLW  03
035DC:  MOVWF  xF7
035DE:  MOVLB  0
035E0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(239, MIXER_SELECT1);     // MIXER_SELECT1 
035E4:  MOVLB  6
035E6:  CLRF   xF6
035E8:  MOVLW  EF
035EA:  MOVWF  xF5
035EC:  CLRF   xF8
035EE:  MOVLW  04
035F0:  MOVWF  xF7
035F2:  MOVLB  0
035F4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(240, MIXER_SELECT2);     // MIXER_SELECT2 
035F8:  MOVLB  6
035FA:  CLRF   xF6
035FC:  MOVLW  F0
035FE:  MOVWF  xF5
03600:  CLRF   xF8
03602:  MOVLW  05
03604:  MOVWF  xF7
03606:  MOVLB  0
03608:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(241, MIXER_SELECT3);     // MIXER_SELECT3 
0360C:  MOVLB  6
0360E:  CLRF   xF6
03610:  MOVLW  F1
03612:  MOVWF  xF5
03614:  CLRF   xF8
03616:  MOVLW  06
03618:  MOVWF  xF7
0361A:  MOVLB  0
0361C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(242, MIXER_SELECT4);     // MIXER_SELECT4 
03620:  MOVLB  6
03622:  CLRF   xF6
03624:  MOVLW  F2
03626:  MOVWF  xF5
03628:  CLRF   xF8
0362A:  MOVLW  07
0362C:  MOVWF  xF7
0362E:  MOVLB  0
03630:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(243, MIXER_SELECT5);     // MIXER_SELECT5 
03634:  MOVLB  6
03636:  CLRF   xF6
03638:  MOVLW  F3
0363A:  MOVWF  xF5
0363C:  CLRF   xF8
0363E:  MOVLW  08
03640:  MOVWF  xF7
03642:  MOVLB  0
03644:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(244, MIXER_SELECT6);     // MIXER_SELECT6 
03648:  MOVLB  6
0364A:  CLRF   xF6
0364C:  MOVLW  F4
0364E:  MOVWF  xF5
03650:  CLRF   xF8
03652:  MOVLW  09
03654:  MOVWF  xF7
03656:  MOVLB  0
03658:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(245, MIXER_SELECT7);     // MIXER_SELECT7 
0365C:  MOVLB  6
0365E:  CLRF   xF6
03660:  MOVLW  F5
03662:  MOVWF  xF5
03664:  CLRF   xF8
03666:  MOVLW  0A
03668:  MOVWF  xF7
0366A:  MOVLB  0
0366C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(246, MIXER_SELECT8);     // MIXER_SELECT8 
03670:  MOVLB  6
03672:  CLRF   xF6
03674:  MOVLW  F6
03676:  MOVWF  xF5
03678:  CLRF   xF8
0367A:  MOVLW  0B
0367C:  MOVWF  xF7
0367E:  MOVLB  0
03680:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(247, MIXER_SELECT9);     // MIXER_SELECT9 
03684:  MOVLB  6
03686:  CLRF   xF6
03688:  MOVLW  F7
0368A:  MOVWF  xF5
0368C:  CLRF   xF8
0368E:  MOVLW  0C
03690:  MOVWF  xF7
03692:  MOVLB  0
03694:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(248, MIXER_SELECT10);     // MIXER_SELECT10 
03698:  MOVLB  6
0369A:  CLRF   xF6
0369C:  MOVLW  F8
0369E:  MOVWF  xF5
036A0:  CLRF   xF8
036A2:  MOVLW  0D
036A4:  MOVWF  xF7
036A6:  MOVLB  0
036A8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(249, MIXER_SELECT11);     // MIXER_SELECT11 
036AC:  MOVLB  6
036AE:  CLRF   xF6
036B0:  MOVLW  F9
036B2:  MOVWF  xF5
036B4:  CLRF   xF8
036B6:  MOVLW  0E
036B8:  MOVWF  xF7
036BA:  MOVLB  0
036BC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(250, MIXER_SELECT12);     // MIXER_SELECT12 
036C0:  MOVLB  6
036C2:  CLRF   xF6
036C4:  MOVLW  FA
036C6:  MOVWF  xF5
036C8:  CLRF   xF8
036CA:  MOVLW  0F
036CC:  MOVWF  xF7
036CE:  MOVLB  0
036D0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(251, MIXER_SELECT13);     // MIXER_SELECT13 
036D4:  MOVLB  6
036D6:  CLRF   xF6
036D8:  MOVLW  FB
036DA:  MOVWF  xF5
036DC:  CLRF   xF8
036DE:  MOVLW  10
036E0:  MOVWF  xF7
036E2:  MOVLB  0
036E4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(252, MIXER_SELECT14);     // MIXER_SELECT14 
036E8:  MOVLB  6
036EA:  CLRF   xF6
036EC:  MOVLW  FC
036EE:  MOVWF  xF5
036F0:  CLRF   xF8
036F2:  MOVLW  11
036F4:  MOVWF  xF7
036F6:  MOVLB  0
036F8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(253, MIXER_SELECT15);     // MIXER_SELECT15 
036FC:  MOVLB  6
036FE:  CLRF   xF6
03700:  MOVLW  FD
03702:  MOVWF  xF5
03704:  CLRF   xF8
03706:  MOVLW  12
03708:  MOVWF  xF7
0370A:  MOVLB  0
0370C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(254, MIXER_SELECT16);     // MIXER_SELECT16 
03710:  MOVLB  6
03712:  CLRF   xF6
03714:  MOVLW  FE
03716:  MOVWF  xF5
03718:  CLRF   xF8
0371A:  MOVLW  13
0371C:  MOVWF  xF7
0371E:  MOVLB  0
03720:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(255, MIXER_SELECT17);     // MIXER_SELECT17 
03724:  MOVLB  6
03726:  CLRF   xF6
03728:  SETF   xF5
0372A:  CLRF   xF8
0372C:  MOVLW  14
0372E:  MOVWF  xF7
03730:  MOVLB  0
03732:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(256, MIXER_SELECT18);     // MIXER_SELECT18 
03736:  MOVLW  01
03738:  MOVLB  6
0373A:  MOVWF  xF6
0373C:  CLRF   xF5
0373E:  CLRF   xF8
03740:  MOVLW  15
03742:  MOVWF  xF7
03744:  MOVLB  0
03746:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(257, MIXER_SELECT19);     // MIXER_SELECT19 
0374A:  MOVLW  01
0374C:  MOVLB  6
0374E:  MOVWF  xF6
03750:  MOVWF  xF5
03752:  CLRF   xF8
03754:  MOVLW  16
03756:  MOVWF  xF7
03758:  MOVLB  0
0375A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(258, MIXER_SELECT20);     // MIXER_SELECT20 
0375E:  MOVLW  01
03760:  MOVLB  6
03762:  MOVWF  xF6
03764:  MOVLW  02
03766:  MOVWF  xF5
03768:  CLRF   xF8
0376A:  MOVLW  17
0376C:  MOVWF  xF7
0376E:  MOVLB  0
03770:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(259, MIXER_SELECT21);     // MIXER_SELECT21 
03774:  MOVLW  01
03776:  MOVLB  6
03778:  MOVWF  xF6
0377A:  MOVLW  03
0377C:  MOVWF  xF5
0377E:  CLRF   xF8
03780:  MOVLW  18
03782:  MOVWF  xF7
03784:  MOVLB  0
03786:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(260, MIXER_SELECT22);     // MIXER_SELECT22 
0378A:  MOVLW  01
0378C:  MOVLB  6
0378E:  MOVWF  xF6
03790:  MOVLW  04
03792:  MOVWF  xF5
03794:  CLRF   xF8
03796:  MOVLW  19
03798:  MOVWF  xF7
0379A:  MOVLB  0
0379C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(261, MIXER_SELECT23);     // MIXER_SELECT23 
037A0:  MOVLW  01
037A2:  MOVLB  6
037A4:  MOVWF  xF6
037A6:  MOVLW  05
037A8:  MOVWF  xF5
037AA:  CLRF   xF8
037AC:  MOVLW  1A
037AE:  MOVWF  xF7
037B0:  MOVLB  0
037B2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(262, MIXER_SELECT24);     // MIXER_SELECT24 
037B6:  MOVLW  01
037B8:  MOVLB  6
037BA:  MOVWF  xF6
037BC:  MOVLW  06
037BE:  MOVWF  xF5
037C0:  CLRF   xF8
037C2:  MOVLW  1B
037C4:  MOVWF  xF7
037C6:  MOVLB  0
037C8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(263, MIXER_SELECT25);     // MIXER_SELECT25 
037CC:  MOVLW  01
037CE:  MOVLB  6
037D0:  MOVWF  xF6
037D2:  MOVLW  07
037D4:  MOVWF  xF5
037D6:  CLRF   xF8
037D8:  MOVLW  1C
037DA:  MOVWF  xF7
037DC:  MOVLB  0
037DE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(264, MIXER_SELECT26);     // MIXER_SELECT26 
037E2:  MOVLW  01
037E4:  MOVLB  6
037E6:  MOVWF  xF6
037E8:  MOVLW  08
037EA:  MOVWF  xF5
037EC:  CLRF   xF8
037EE:  MOVLW  1D
037F0:  MOVWF  xF7
037F2:  MOVLB  0
037F4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(265, MIXER_SELECT27);     // MIXER_SELECT27 
037F8:  MOVLW  01
037FA:  MOVLB  6
037FC:  MOVWF  xF6
037FE:  MOVLW  09
03800:  MOVWF  xF5
03802:  CLRF   xF8
03804:  MOVLW  1E
03806:  MOVWF  xF7
03808:  MOVLB  0
0380A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(266, MIXER_SELECT28);     // MIXER_SELECT28 
0380E:  MOVLW  01
03810:  MOVLB  6
03812:  MOVWF  xF6
03814:  MOVLW  0A
03816:  MOVWF  xF5
03818:  CLRF   xF8
0381A:  MOVLW  1F
0381C:  MOVWF  xF7
0381E:  MOVLB  0
03820:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(267, MIXER_SELECT29);     // MIXER_SELECT29 
03824:  MOVLW  01
03826:  MOVLB  6
03828:  MOVWF  xF6
0382A:  MOVLW  0B
0382C:  MOVWF  xF5
0382E:  CLRF   xF8
03830:  MOVLW  20
03832:  MOVWF  xF7
03834:  MOVLB  0
03836:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(268, MIXER_SELECT30);     // MIXER_SELECT30 
0383A:  MOVLW  01
0383C:  MOVLB  6
0383E:  MOVWF  xF6
03840:  MOVLW  0C
03842:  MOVWF  xF5
03844:  CLRF   xF8
03846:  MOVLW  21
03848:  MOVWF  xF7
0384A:  MOVLB  0
0384C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(269, MIXER_SELECT31);     // MIXER_SELECT31 
03850:  MOVLW  01
03852:  MOVLB  6
03854:  MOVWF  xF6
03856:  MOVLW  0D
03858:  MOVWF  xF5
0385A:  CLRF   xF8
0385C:  MOVLW  22
0385E:  MOVWF  xF7
03860:  MOVLB  0
03862:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(270, MIXER_SELECT32);     // MIXER_SELECT32 
03866:  MOVLW  01
03868:  MOVLB  6
0386A:  MOVWF  xF6
0386C:  MOVLW  0E
0386E:  MOVWF  xF5
03870:  CLRF   xF8
03872:  MOVLW  23
03874:  MOVWF  xF7
03876:  MOVLB  0
03878:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(271, MIXER_SELECT33);     // MIXER_SELECT33 
0387C:  MOVLW  01
0387E:  MOVLB  6
03880:  MOVWF  xF6
03882:  MOVLW  0F
03884:  MOVWF  xF5
03886:  CLRF   xF8
03888:  MOVLW  24
0388A:  MOVWF  xF7
0388C:  MOVLB  0
0388E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(272, MIXER_SELECT34);     // MIXER_SELECT34 
03892:  MOVLW  01
03894:  MOVLB  6
03896:  MOVWF  xF6
03898:  MOVLW  10
0389A:  MOVWF  xF5
0389C:  CLRF   xF8
0389E:  MOVLW  25
038A0:  MOVWF  xF7
038A2:  MOVLB  0
038A4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(273, MIXER_SELECT35);     // MIXER_SELECT35 
038A8:  MOVLW  01
038AA:  MOVLB  6
038AC:  MOVWF  xF6
038AE:  MOVLW  11
038B0:  MOVWF  xF5
038B2:  CLRF   xF8
038B4:  MOVLW  26
038B6:  MOVWF  xF7
038B8:  MOVLB  0
038BA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(274, MIXER_SELECT36);     // MIXER_SELECT36 
038BE:  MOVLW  01
038C0:  MOVLB  6
038C2:  MOVWF  xF6
038C4:  MOVLW  12
038C6:  MOVWF  xF5
038C8:  CLRF   xF8
038CA:  MOVLW  27
038CC:  MOVWF  xF7
038CE:  MOVLB  0
038D0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(275, MIXER_SELECT37);     // MIXER_SELECT37 
038D4:  MOVLW  01
038D6:  MOVLB  6
038D8:  MOVWF  xF6
038DA:  MOVLW  13
038DC:  MOVWF  xF5
038DE:  CLRF   xF8
038E0:  MOVLW  28
038E2:  MOVWF  xF7
038E4:  MOVLB  0
038E6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(276, MIXER_SELECT38);     // MIXER_SELECT38 
038EA:  MOVLW  01
038EC:  MOVLB  6
038EE:  MOVWF  xF6
038F0:  MOVLW  14
038F2:  MOVWF  xF5
038F4:  CLRF   xF8
038F6:  MOVLW  29
038F8:  MOVWF  xF7
038FA:  MOVLB  0
038FC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(277, MIXER_SELECT39);     // MIXER_SELECT39 
03900:  MOVLW  01
03902:  MOVLB  6
03904:  MOVWF  xF6
03906:  MOVLW  15
03908:  MOVWF  xF5
0390A:  CLRF   xF8
0390C:  MOVLW  2A
0390E:  MOVWF  xF7
03910:  MOVLB  0
03912:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(278, MIXER_SELECT40);     // MIXER_SELECT40 
03916:  MOVLW  01
03918:  MOVLB  6
0391A:  MOVWF  xF6
0391C:  MOVLW  16
0391E:  MOVWF  xF5
03920:  CLRF   xF8
03922:  MOVLW  2B
03924:  MOVWF  xF7
03926:  MOVLB  0
03928:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(279, MIXER_SELECT41);     // MIXER_SELECT41 
0392C:  MOVLW  01
0392E:  MOVLB  6
03930:  MOVWF  xF6
03932:  MOVLW  17
03934:  MOVWF  xF5
03936:  CLRF   xF8
03938:  MOVLW  2C
0393A:  MOVWF  xF7
0393C:  MOVLB  0
0393E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(280, MIXER_SELECT42);     // MIXER_SELECT42 
03942:  MOVLW  01
03944:  MOVLB  6
03946:  MOVWF  xF6
03948:  MOVLW  18
0394A:  MOVWF  xF5
0394C:  CLRF   xF8
0394E:  MOVLW  2D
03950:  MOVWF  xF7
03952:  MOVLB  0
03954:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(281, MIXER_SELECT43);     // MIXER_SELECT43 
03958:  MOVLW  01
0395A:  MOVLB  6
0395C:  MOVWF  xF6
0395E:  MOVLW  19
03960:  MOVWF  xF5
03962:  CLRF   xF8
03964:  MOVLW  2E
03966:  MOVWF  xF7
03968:  MOVLB  0
0396A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(282, MIXER_SELECT44);     // MIXER_SELECT44 
0396E:  MOVLW  01
03970:  MOVLB  6
03972:  MOVWF  xF6
03974:  MOVLW  1A
03976:  MOVWF  xF5
03978:  CLRF   xF8
0397A:  MOVLW  2F
0397C:  MOVWF  xF7
0397E:  MOVLB  0
03980:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(283, MIXER_SELECT45);     // MIXER_SELECT45 
03984:  MOVLW  01
03986:  MOVLB  6
03988:  MOVWF  xF6
0398A:  MOVLW  1B
0398C:  MOVWF  xF5
0398E:  CLRF   xF8
03990:  MOVLW  30
03992:  MOVWF  xF7
03994:  MOVLB  0
03996:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(284, MIXER_SELECT46);     // MIXER_SELECT46 
0399A:  MOVLW  01
0399C:  MOVLB  6
0399E:  MOVWF  xF6
039A0:  MOVLW  1C
039A2:  MOVWF  xF5
039A4:  CLRF   xF8
039A6:  MOVLW  31
039A8:  MOVWF  xF7
039AA:  MOVLB  0
039AC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(285, MIXER_SELECT47);     // MIXER_SELECT47 
039B0:  MOVLW  01
039B2:  MOVLB  6
039B4:  MOVWF  xF6
039B6:  MOVLW  1D
039B8:  MOVWF  xF5
039BA:  CLRF   xF8
039BC:  MOVLW  32
039BE:  MOVWF  xF7
039C0:  MOVLB  0
039C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(286, MIXER_SELECT48);     // MIXER_SELECT48 
039C6:  MOVLW  01
039C8:  MOVLB  6
039CA:  MOVWF  xF6
039CC:  MOVLW  1E
039CE:  MOVWF  xF5
039D0:  CLRF   xF8
039D2:  MOVLW  33
039D4:  MOVWF  xF7
039D6:  MOVLB  0
039D8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(287, MIXER_SELECT49);     // MIXER_SELECT49 
039DC:  MOVLW  01
039DE:  MOVLB  6
039E0:  MOVWF  xF6
039E2:  MOVLW  1F
039E4:  MOVWF  xF5
039E6:  CLRF   xF8
039E8:  MOVLW  34
039EA:  MOVWF  xF7
039EC:  MOVLB  0
039EE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(288, MIXER_SELECT50);     // MIXER_SELECT50 
039F2:  MOVLW  01
039F4:  MOVLB  6
039F6:  MOVWF  xF6
039F8:  MOVLW  20
039FA:  MOVWF  xF5
039FC:  CLRF   xF8
039FE:  MOVLW  35
03A00:  MOVWF  xF7
03A02:  MOVLB  0
03A04:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(289, MIXER_SELECT51);     // MIXER_SELECT51 
03A08:  MOVLW  01
03A0A:  MOVLB  6
03A0C:  MOVWF  xF6
03A0E:  MOVLW  21
03A10:  MOVWF  xF5
03A12:  CLRF   xF8
03A14:  MOVLW  36
03A16:  MOVWF  xF7
03A18:  MOVLB  0
03A1A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(290, MIXER_SELECT52);     // MIXER_SELECT52 
03A1E:  MOVLW  01
03A20:  MOVLB  6
03A22:  MOVWF  xF6
03A24:  MOVLW  22
03A26:  MOVWF  xF5
03A28:  CLRF   xF8
03A2A:  MOVLW  37
03A2C:  MOVWF  xF7
03A2E:  MOVLB  0
03A30:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(291, MIXER_SELECT53);     // MIXER_SELECT53 
03A34:  MOVLW  01
03A36:  MOVLB  6
03A38:  MOVWF  xF6
03A3A:  MOVLW  23
03A3C:  MOVWF  xF5
03A3E:  CLRF   xF8
03A40:  MOVLW  38
03A42:  MOVWF  xF7
03A44:  MOVLB  0
03A46:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(292, MIXER_SELECT54);     // MIXER_SELECT54 
03A4A:  MOVLW  01
03A4C:  MOVLB  6
03A4E:  MOVWF  xF6
03A50:  MOVLW  24
03A52:  MOVWF  xF5
03A54:  CLRF   xF8
03A56:  MOVLW  39
03A58:  MOVWF  xF7
03A5A:  MOVLB  0
03A5C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(293, MIXER_SELECT55);     // MIXER_SELECT55 
03A60:  MOVLW  01
03A62:  MOVLB  6
03A64:  MOVWF  xF6
03A66:  MOVLW  25
03A68:  MOVWF  xF5
03A6A:  CLRF   xF8
03A6C:  MOVLW  3A
03A6E:  MOVWF  xF7
03A70:  MOVLB  0
03A72:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(294, MIXER_SELECT56);     // MIXER_SELECT56 
03A76:  MOVLW  01
03A78:  MOVLB  6
03A7A:  MOVWF  xF6
03A7C:  MOVLW  26
03A7E:  MOVWF  xF5
03A80:  CLRF   xF8
03A82:  MOVLW  3B
03A84:  MOVWF  xF7
03A86:  MOVLB  0
03A88:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(295, MIXER_SELECT57);     // MIXER_SELECT57 
03A8C:  MOVLW  01
03A8E:  MOVLB  6
03A90:  MOVWF  xF6
03A92:  MOVLW  27
03A94:  MOVWF  xF5
03A96:  CLRF   xF8
03A98:  MOVLW  3C
03A9A:  MOVWF  xF7
03A9C:  MOVLB  0
03A9E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(296, MIXER_SELECT58);     // MIXER_SELECT58 
03AA2:  MOVLW  01
03AA4:  MOVLB  6
03AA6:  MOVWF  xF6
03AA8:  MOVLW  28
03AAA:  MOVWF  xF5
03AAC:  CLRF   xF8
03AAE:  MOVLW  3D
03AB0:  MOVWF  xF7
03AB2:  MOVLB  0
03AB4:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(297, MIXER_SELECT59);     // MIXER_SELECT59 
03AB8:  MOVLW  01
03ABA:  MOVLB  6
03ABC:  MOVWF  xF6
03ABE:  MOVLW  29
03AC0:  MOVWF  xF5
03AC2:  CLRF   xF8
03AC4:  MOVLW  3E
03AC6:  MOVWF  xF7
03AC8:  MOVLB  0
03ACA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(298, MIXER_SELECT60);     // MIXER_SELECT60 
03ACE:  MOVLW  01
03AD0:  MOVLB  6
03AD2:  MOVWF  xF6
03AD4:  MOVLW  2A
03AD6:  MOVWF  xF5
03AD8:  CLRF   xF8
03ADA:  MOVLW  3F
03ADC:  MOVWF  xF7
03ADE:  MOVLB  0
03AE0:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(299, MIXER_SELECT61);     // MIXER_SELECT61 
03AE4:  MOVLW  01
03AE6:  MOVLB  6
03AE8:  MOVWF  xF6
03AEA:  MOVLW  2B
03AEC:  MOVWF  xF5
03AEE:  CLRF   xF8
03AF0:  MOVLW  40
03AF2:  MOVWF  xF7
03AF4:  MOVLB  0
03AF6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(300, MIXER_SELECT62);     // MIXER_SELECT62 
03AFA:  MOVLW  01
03AFC:  MOVLB  6
03AFE:  MOVWF  xF6
03B00:  MOVLW  2C
03B02:  MOVWF  xF5
03B04:  CLRF   xF8
03B06:  MOVLW  41
03B08:  MOVWF  xF7
03B0A:  MOVLB  0
03B0C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(301, MIXER_SELECT63);     // MIXER_SELECT63 
03B10:  MOVLW  01
03B12:  MOVLB  6
03B14:  MOVWF  xF6
03B16:  MOVLW  2D
03B18:  MOVWF  xF5
03B1A:  CLRF   xF8
03B1C:  MOVLW  42
03B1E:  MOVWF  xF7
03B20:  MOVLB  0
03B22:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(302, MIXER_SELECT64);     // MIXER_SELECT64 
03B26:  MOVLW  01
03B28:  MOVLB  6
03B2A:  MOVWF  xF6
03B2C:  MOVLW  2E
03B2E:  MOVWF  xF5
03B30:  CLRF   xF8
03B32:  MOVLW  43
03B34:  MOVWF  xF7
03B36:  MOVLB  0
03B38:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(303, MIXER_SELECT65);     // MIXER_SELECT65 
03B3C:  MOVLW  01
03B3E:  MOVLB  6
03B40:  MOVWF  xF6
03B42:  MOVLW  2F
03B44:  MOVWF  xF5
03B46:  CLRF   xF8
03B48:  MOVLW  44
03B4A:  MOVWF  xF7
03B4C:  MOVLB  0
03B4E:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(304, MIXER_SELECT66);     // MIXER_SELECT66 
03B52:  MOVLW  01
03B54:  MOVLB  6
03B56:  MOVWF  xF6
03B58:  MOVLW  30
03B5A:  MOVWF  xF5
03B5C:  CLRF   xF8
03B5E:  MOVLW  45
03B60:  MOVWF  xF7
03B62:  MOVLB  0
03B64:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(305, MIXER_SELECT67);     // MIXER_SELECT67 
03B68:  MOVLW  01
03B6A:  MOVLB  6
03B6C:  MOVWF  xF6
03B6E:  MOVLW  31
03B70:  MOVWF  xF5
03B72:  CLRF   xF8
03B74:  MOVLW  46
03B76:  MOVWF  xF7
03B78:  MOVLB  0
03B7A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(306, MIXER_SELECT68);     // MIXER_SELECT68 
03B7E:  MOVLW  01
03B80:  MOVLB  6
03B82:  MOVWF  xF6
03B84:  MOVLW  32
03B86:  MOVWF  xF5
03B88:  CLRF   xF8
03B8A:  MOVLW  47
03B8C:  MOVWF  xF7
03B8E:  MOVLB  0
03B90:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(307, MIXER_SELECT69);     // MIXER_SELECT69 
03B94:  MOVLW  01
03B96:  MOVLB  6
03B98:  MOVWF  xF6
03B9A:  MOVLW  33
03B9C:  MOVWF  xF5
03B9E:  CLRF   xF8
03BA0:  MOVLW  48
03BA2:  MOVWF  xF7
03BA4:  MOVLB  0
03BA6:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(308, MIXER_SELECT70);     // MIXER_SELECT70 
03BAA:  MOVLW  01
03BAC:  MOVLB  6
03BAE:  MOVWF  xF6
03BB0:  MOVLW  34
03BB2:  MOVWF  xF5
03BB4:  CLRF   xF8
03BB6:  MOVLW  49
03BB8:  MOVWF  xF7
03BBA:  MOVLB  0
03BBC:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(309, MIXER_SELECT71);     // MIXER_SELECT71 
03BC0:  MOVLW  01
03BC2:  MOVLB  6
03BC4:  MOVWF  xF6
03BC6:  MOVLW  35
03BC8:  MOVWF  xF5
03BCA:  CLRF   xF8
03BCC:  MOVLW  4A
03BCE:  MOVWF  xF7
03BD0:  MOVLB  0
03BD2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(310, MIXER_SELECT72);     // MIXER_SELECT72 
03BD6:  MOVLW  01
03BD8:  MOVLB  6
03BDA:  MOVWF  xF6
03BDC:  MOVLW  36
03BDE:  MOVWF  xF5
03BE0:  CLRF   xF8
03BE2:  MOVLW  4B
03BE4:  MOVWF  xF7
03BE6:  MOVLB  0
03BE8:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(311, MIXER_SELECT73);     // MIXER_SELECT73 
03BEC:  MOVLW  01
03BEE:  MOVLB  6
03BF0:  MOVWF  xF6
03BF2:  MOVLW  37
03BF4:  MOVWF  xF5
03BF6:  CLRF   xF8
03BF8:  MOVLW  4C
03BFA:  MOVWF  xF7
03BFC:  MOVLB  0
03BFE:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(312, MIXER_SELECT74);     // MIXER_SELECT74 
03C02:  MOVLW  01
03C04:  MOVLB  6
03C06:  MOVWF  xF6
03C08:  MOVLW  38
03C0A:  MOVWF  xF5
03C0C:  CLRF   xF8
03C0E:  MOVLW  4D
03C10:  MOVWF  xF7
03C12:  MOVLB  0
03C14:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(313, MIXER_SELECT75);     // MIXER_SELECT75 
03C18:  MOVLW  01
03C1A:  MOVLB  6
03C1C:  MOVWF  xF6
03C1E:  MOVLW  39
03C20:  MOVWF  xF5
03C22:  CLRF   xF8
03C24:  MOVLW  4E
03C26:  MOVWF  xF7
03C28:  MOVLB  0
03C2A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(314, MIXER_SELECT76);     // MIXER_SELECT76 
03C2E:  MOVLW  01
03C30:  MOVLB  6
03C32:  MOVWF  xF6
03C34:  MOVLW  3A
03C36:  MOVWF  xF5
03C38:  CLRF   xF8
03C3A:  MOVLW  4F
03C3C:  MOVWF  xF7
03C3E:  MOVLB  0
03C40:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(315, MIXER_SELECT77);     // MIXER_SELECT77 
03C44:  MOVLW  01
03C46:  MOVLB  6
03C48:  MOVWF  xF6
03C4A:  MOVLW  3B
03C4C:  MOVWF  xF5
03C4E:  CLRF   xF8
03C50:  MOVLW  50
03C52:  MOVWF  xF7
03C54:  MOVLB  0
03C56:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(316, MIXER_SELECT78);     // MIXER_SELECT78 
03C5A:  MOVLW  01
03C5C:  MOVLB  6
03C5E:  MOVWF  xF6
03C60:  MOVLW  3C
03C62:  MOVWF  xF5
03C64:  CLRF   xF8
03C66:  MOVLW  51
03C68:  MOVWF  xF7
03C6A:  MOVLB  0
03C6C:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(317, MIXER_SELECT79);     // MIXER_SELECT79 
03C70:  MOVLW  01
03C72:  MOVLB  6
03C74:  MOVWF  xF6
03C76:  MOVLW  3D
03C78:  MOVWF  xF5
03C7A:  CLRF   xF8
03C7C:  MOVLW  52
03C7E:  MOVWF  xF7
03C80:  MOVLB  0
03C82:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(318, OUT_1_1_FILTER_B0);     // OUT_1_1_FILTER_B0 
03C86:  MOVLW  01
03C88:  MOVLB  6
03C8A:  MOVWF  xF6
03C8C:  MOVLW  3E
03C8E:  MOVWF  xF5
03C90:  MOVLW  02
03C92:  MOVWF  xF8
03C94:  MOVLW  F5
03C96:  MOVWF  xF7
03C98:  MOVLB  0
03C9A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(319, OUT_1_1_FILTER_B1);     // OUT_1_1_FILTER_B1 
03C9E:  MOVLW  01
03CA0:  MOVLB  6
03CA2:  MOVWF  xF6
03CA4:  MOVLW  3F
03CA6:  MOVWF  xF5
03CA8:  MOVLW  02
03CAA:  MOVWF  xF8
03CAC:  MOVLW  F6
03CAE:  MOVWF  xF7
03CB0:  MOVLB  0
03CB2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(320, OUT_1_1_FILTER_B2);     // OUT_1_1_FILTER_B2 
03CB6:  MOVLW  01
03CB8:  MOVLB  6
03CBA:  MOVWF  xF6
03CBC:  MOVLW  40
03CBE:  MOVWF  xF5
03CC0:  MOVLW  02
03CC2:  MOVWF  xF8
03CC4:  MOVLW  F7
03CC6:  MOVWF  xF7
03CC8:  MOVLB  0
03CCA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(321, OUT_1_1_FILTER_NEGATIVEA1);     // OUT_1_1_FILTER_NEGATIVEA1 
03CCE:  MOVLW  01
03CD0:  MOVLB  6
03CD2:  MOVWF  xF6
03CD4:  MOVLW  41
03CD6:  MOVWF  xF5
03CD8:  MOVLW  02
03CDA:  MOVWF  xF8
03CDC:  MOVLW  F8
03CDE:  MOVWF  xF7
03CE0:  MOVLB  0
03CE2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(322, OUT_1_1_FILTER_NEGATIVEA2);     // OUT_1_1_FILTER_NEGATIVEA2 
03CE6:  MOVLW  01
03CE8:  MOVLB  6
03CEA:  MOVWF  xF6
03CEC:  MOVLW  42
03CEE:  MOVWF  xF5
03CF0:  MOVLW  02
03CF2:  MOVWF  xF8
03CF4:  MOVLW  F9
03CF6:  MOVWF  xF7
03CF8:  MOVLB  0
03CFA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(323, OUT_1_2_FILTER_B0);     // OUT_1_2_FILTER_B0 
03CFE:  MOVLW  01
03D00:  MOVLB  6
03D02:  MOVWF  xF6
03D04:  MOVLW  43
03D06:  MOVWF  xF5
03D08:  MOVLW  02
03D0A:  MOVWF  xF8
03D0C:  MOVLW  F0
03D0E:  MOVWF  xF7
03D10:  MOVLB  0
03D12:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(324, OUT_1_2_FILTER_B1);     // OUT_1_2_FILTER_B1 
03D16:  MOVLW  01
03D18:  MOVLB  6
03D1A:  MOVWF  xF6
03D1C:  MOVLW  44
03D1E:  MOVWF  xF5
03D20:  MOVLW  02
03D22:  MOVWF  xF8
03D24:  MOVLW  F1
03D26:  MOVWF  xF7
03D28:  MOVLB  0
03D2A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(325, OUT_1_2_FILTER_B2);     // OUT_1_2_FILTER_B2 
03D2E:  MOVLW  01
03D30:  MOVLB  6
03D32:  MOVWF  xF6
03D34:  MOVLW  45
03D36:  MOVWF  xF5
03D38:  MOVLW  02
03D3A:  MOVWF  xF8
03D3C:  MOVLW  F2
03D3E:  MOVWF  xF7
03D40:  MOVLB  0
03D42:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(326, OUT_1_2_FILTER_NEGATIVEA1);     // OUT_1_2_FILTER_NEGATIVEA1 
03D46:  MOVLW  01
03D48:  MOVLB  6
03D4A:  MOVWF  xF6
03D4C:  MOVLW  46
03D4E:  MOVWF  xF5
03D50:  MOVLW  02
03D52:  MOVWF  xF8
03D54:  MOVLW  F3
03D56:  MOVWF  xF7
03D58:  MOVLB  0
03D5A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(327, OUT_1_2_FILTER_NEGATIVEA2);     // OUT_1_2_FILTER_NEGATIVEA2 
03D5E:  MOVLW  01
03D60:  MOVLB  6
03D62:  MOVWF  xF6
03D64:  MOVLW  47
03D66:  MOVWF  xF5
03D68:  MOVLW  02
03D6A:  MOVWF  xF8
03D6C:  MOVLW  F4
03D6E:  MOVWF  xF7
03D70:  MOVLB  0
03D72:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(328, OUT_1_3_FILTER_B0);     // OUT_1_3_FILTER_B0 
03D76:  MOVLW  01
03D78:  MOVLB  6
03D7A:  MOVWF  xF6
03D7C:  MOVLW  48
03D7E:  MOVWF  xF5
03D80:  MOVLW  02
03D82:  MOVWF  xF8
03D84:  MOVLW  EB
03D86:  MOVWF  xF7
03D88:  MOVLB  0
03D8A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(329, OUT_1_3_FILTER_B1);     // OUT_1_3_FILTER_B1 
03D8E:  MOVLW  01
03D90:  MOVLB  6
03D92:  MOVWF  xF6
03D94:  MOVLW  49
03D96:  MOVWF  xF5
03D98:  MOVLW  02
03D9A:  MOVWF  xF8
03D9C:  MOVLW  EC
03D9E:  MOVWF  xF7
03DA0:  MOVLB  0
03DA2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(330, OUT_1_3_FILTER_B2);     // OUT_1_3_FILTER_B2 
03DA6:  MOVLW  01
03DA8:  MOVLB  6
03DAA:  MOVWF  xF6
03DAC:  MOVLW  4A
03DAE:  MOVWF  xF5
03DB0:  MOVLW  02
03DB2:  MOVWF  xF8
03DB4:  MOVLW  ED
03DB6:  MOVWF  xF7
03DB8:  MOVLB  0
03DBA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(331, OUT_1_3_FILTER_NEGATIVEA1);     // OUT_1_3_FILTER_NEGATIVEA1 
03DBE:  MOVLW  01
03DC0:  MOVLB  6
03DC2:  MOVWF  xF6
03DC4:  MOVLW  4B
03DC6:  MOVWF  xF5
03DC8:  MOVLW  02
03DCA:  MOVWF  xF8
03DCC:  MOVLW  EE
03DCE:  MOVWF  xF7
03DD0:  MOVLB  0
03DD2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(332, OUT_1_3_FILTER_NEGATIVEA2);     // OUT_1_3_FILTER_NEGATIVEA2 
03DD6:  MOVLW  01
03DD8:  MOVLB  6
03DDA:  MOVWF  xF6
03DDC:  MOVLW  4C
03DDE:  MOVWF  xF5
03DE0:  MOVLW  02
03DE2:  MOVWF  xF8
03DE4:  MOVLW  EF
03DE6:  MOVWF  xF7
03DE8:  MOVLB  0
03DEA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(333, OUT_1_4_FILTER_B0);     // OUT_1_4_FILTER_B0 
03DEE:  MOVLW  01
03DF0:  MOVLB  6
03DF2:  MOVWF  xF6
03DF4:  MOVLW  4D
03DF6:  MOVWF  xF5
03DF8:  MOVLW  02
03DFA:  MOVWF  xF8
03DFC:  MOVLW  B9
03DFE:  MOVWF  xF7
03E00:  MOVLB  0
03E02:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(334, OUT_1_4_FILTER_B1);     // OUT_1_4_FILTER_B1 
03E06:  MOVLW  01
03E08:  MOVLB  6
03E0A:  MOVWF  xF6
03E0C:  MOVLW  4E
03E0E:  MOVWF  xF5
03E10:  MOVLW  02
03E12:  MOVWF  xF8
03E14:  MOVLW  BA
03E16:  MOVWF  xF7
03E18:  MOVLB  0
03E1A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(335, OUT_1_4_FILTER_B2);     // OUT_1_4_FILTER_B2 
03E1E:  MOVLW  01
03E20:  MOVLB  6
03E22:  MOVWF  xF6
03E24:  MOVLW  4F
03E26:  MOVWF  xF5
03E28:  MOVLW  02
03E2A:  MOVWF  xF8
03E2C:  MOVLW  BB
03E2E:  MOVWF  xF7
03E30:  MOVLB  0
03E32:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(336, OUT_1_4_FILTER_NEGATIVEA1);     // OUT_1_4_FILTER_NEGATIVEA1 
03E36:  MOVLW  01
03E38:  MOVLB  6
03E3A:  MOVWF  xF6
03E3C:  MOVLW  50
03E3E:  MOVWF  xF5
03E40:  MOVLW  02
03E42:  MOVWF  xF8
03E44:  MOVLW  BC
03E46:  MOVWF  xF7
03E48:  MOVLB  0
03E4A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(337, OUT_1_4_FILTER_NEGATIVEA2);     // OUT_1_4_FILTER_NEGATIVEA2 
03E4E:  MOVLW  01
03E50:  MOVLB  6
03E52:  MOVWF  xF6
03E54:  MOVLW  51
03E56:  MOVWF  xF5
03E58:  MOVLW  02
03E5A:  MOVWF  xF8
03E5C:  MOVLW  BD
03E5E:  MOVWF  xF7
03E60:  MOVLB  0
03E62:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(338, OUT_1_5_FILTER_B0);     // OUT_1_5_FILTER_B0 
03E66:  MOVLW  01
03E68:  MOVLB  6
03E6A:  MOVWF  xF6
03E6C:  MOVLW  52
03E6E:  MOVWF  xF5
03E70:  MOVLW  02
03E72:  MOVWF  xF8
03E74:  MOVLW  B4
03E76:  MOVWF  xF7
03E78:  MOVLB  0
03E7A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(339, OUT_1_5_FILTER_B1);     // OUT_1_5_FILTER_B1 
03E7E:  MOVLW  01
03E80:  MOVLB  6
03E82:  MOVWF  xF6
03E84:  MOVLW  53
03E86:  MOVWF  xF5
03E88:  MOVLW  02
03E8A:  MOVWF  xF8
03E8C:  MOVLW  B5
03E8E:  MOVWF  xF7
03E90:  MOVLB  0
03E92:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(340, OUT_1_5_FILTER_B2);     // OUT_1_5_FILTER_B2 
03E96:  MOVLW  01
03E98:  MOVLB  6
03E9A:  MOVWF  xF6
03E9C:  MOVLW  54
03E9E:  MOVWF  xF5
03EA0:  MOVLW  02
03EA2:  MOVWF  xF8
03EA4:  MOVLW  B6
03EA6:  MOVWF  xF7
03EA8:  MOVLB  0
03EAA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(341, OUT_1_5_FILTER_NEGATIVEA1);     // OUT_1_5_FILTER_NEGATIVEA1 
03EAE:  MOVLW  01
03EB0:  MOVLB  6
03EB2:  MOVWF  xF6
03EB4:  MOVLW  55
03EB6:  MOVWF  xF5
03EB8:  MOVLW  02
03EBA:  MOVWF  xF8
03EBC:  MOVLW  B7
03EBE:  MOVWF  xF7
03EC0:  MOVLB  0
03EC2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(342, OUT_1_5_FILTER_NEGATIVEA2);     // OUT_1_5_FILTER_NEGATIVEA2 
03EC6:  MOVLW  01
03EC8:  MOVLB  6
03ECA:  MOVWF  xF6
03ECC:  MOVLW  56
03ECE:  MOVWF  xF5
03ED0:  MOVLW  02
03ED2:  MOVWF  xF8
03ED4:  MOVLW  B8
03ED6:  MOVWF  xF7
03ED8:  MOVLB  0
03EDA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(343, OUT_1_6_FILTER_B0);     // OUT_1_6_FILTER_B0 
03EDE:  MOVLW  01
03EE0:  MOVLB  6
03EE2:  MOVWF  xF6
03EE4:  MOVLW  57
03EE6:  MOVWF  xF5
03EE8:  MOVLW  02
03EEA:  MOVWF  xF8
03EEC:  MOVLW  AF
03EEE:  MOVWF  xF7
03EF0:  MOVLB  0
03EF2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(344, OUT_1_6_FILTER_B1);     // OUT_1_6_FILTER_B1 
03EF6:  MOVLW  01
03EF8:  MOVLB  6
03EFA:  MOVWF  xF6
03EFC:  MOVLW  58
03EFE:  MOVWF  xF5
03F00:  MOVLW  02
03F02:  MOVWF  xF8
03F04:  MOVLW  B0
03F06:  MOVWF  xF7
03F08:  MOVLB  0
03F0A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(345, OUT_1_6_FILTER_B2);     // OUT_1_6_FILTER_B2 
03F0E:  MOVLW  01
03F10:  MOVLB  6
03F12:  MOVWF  xF6
03F14:  MOVLW  59
03F16:  MOVWF  xF5
03F18:  MOVLW  02
03F1A:  MOVWF  xF8
03F1C:  MOVLW  B1
03F1E:  MOVWF  xF7
03F20:  MOVLB  0
03F22:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(346, OUT_1_6_FILTER_NEGATIVEA1);     // OUT_1_6_FILTER_NEGATIVEA1 
03F26:  MOVLW  01
03F28:  MOVLB  6
03F2A:  MOVWF  xF6
03F2C:  MOVLW  5A
03F2E:  MOVWF  xF5
03F30:  MOVLW  02
03F32:  MOVWF  xF8
03F34:  MOVLW  B2
03F36:  MOVWF  xF7
03F38:  MOVLB  0
03F3A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(347, OUT_1_6_FILTER_NEGATIVEA2);     // OUT_1_6_FILTER_NEGATIVEA2 
03F3E:  MOVLW  01
03F40:  MOVLB  6
03F42:  MOVWF  xF6
03F44:  MOVLW  5B
03F46:  MOVWF  xF5
03F48:  MOVLW  02
03F4A:  MOVWF  xF8
03F4C:  MOVLW  B3
03F4E:  MOVWF  xF7
03F50:  MOVLB  0
03F52:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(348, OUT_2_1_FILTER_B0);     // OUT_2_1_FILTER_B0 
03F56:  MOVLW  01
03F58:  MOVLB  6
03F5A:  MOVWF  xF6
03F5C:  MOVLW  5C
03F5E:  MOVWF  xF5
03F60:  MOVLW  02
03F62:  MOVWF  xF8
03F64:  MOVLW  E6
03F66:  MOVWF  xF7
03F68:  MOVLB  0
03F6A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(349, OUT_2_1_FILTER_B1);     // OUT_2_1_FILTER_B1 
03F6E:  MOVLW  01
03F70:  MOVLB  6
03F72:  MOVWF  xF6
03F74:  MOVLW  5D
03F76:  MOVWF  xF5
03F78:  MOVLW  02
03F7A:  MOVWF  xF8
03F7C:  MOVLW  E7
03F7E:  MOVWF  xF7
03F80:  MOVLB  0
03F82:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(350, OUT_2_1_FILTER_B2);     // OUT_2_1_FILTER_B2 
03F86:  MOVLW  01
03F88:  MOVLB  6
03F8A:  MOVWF  xF6
03F8C:  MOVLW  5E
03F8E:  MOVWF  xF5
03F90:  MOVLW  02
03F92:  MOVWF  xF8
03F94:  MOVLW  E8
03F96:  MOVWF  xF7
03F98:  MOVLB  0
03F9A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(351, OUT_2_1_FILTER_NEGATIVEA1);     // OUT_2_1_FILTER_NEGATIVEA1 
03F9E:  MOVLW  01
03FA0:  MOVLB  6
03FA2:  MOVWF  xF6
03FA4:  MOVLW  5F
03FA6:  MOVWF  xF5
03FA8:  MOVLW  02
03FAA:  MOVWF  xF8
03FAC:  MOVLW  E9
03FAE:  MOVWF  xF7
03FB0:  MOVLB  0
03FB2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(352, OUT_2_1_FILTER_NEGATIVEA2);     // OUT_2_1_FILTER_NEGATIVEA2 
03FB6:  MOVLW  01
03FB8:  MOVLB  6
03FBA:  MOVWF  xF6
03FBC:  MOVLW  60
03FBE:  MOVWF  xF5
03FC0:  MOVLW  02
03FC2:  MOVWF  xF8
03FC4:  MOVLW  EA
03FC6:  MOVWF  xF7
03FC8:  MOVLB  0
03FCA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(353, OUT_2_2_FILTER_B0);     // OUT_2_2_FILTER_B0 
03FCE:  MOVLW  01
03FD0:  MOVLB  6
03FD2:  MOVWF  xF6
03FD4:  MOVLW  61
03FD6:  MOVWF  xF5
03FD8:  MOVLW  02
03FDA:  MOVWF  xF8
03FDC:  MOVLW  E1
03FDE:  MOVWF  xF7
03FE0:  MOVLB  0
03FE2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(354, OUT_2_2_FILTER_B1);     // OUT_2_2_FILTER_B1 
03FE6:  MOVLW  01
03FE8:  MOVLB  6
03FEA:  MOVWF  xF6
03FEC:  MOVLW  62
03FEE:  MOVWF  xF5
03FF0:  MOVLW  02
03FF2:  MOVWF  xF8
03FF4:  MOVLW  E2
03FF6:  MOVWF  xF7
03FF8:  MOVLB  0
03FFA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(355, OUT_2_2_FILTER_B2);     // OUT_2_2_FILTER_B2 
03FFE:  MOVLW  01
04000:  MOVLB  6
04002:  MOVWF  xF6
04004:  MOVLW  63
04006:  MOVWF  xF5
04008:  MOVLW  02
0400A:  MOVWF  xF8
0400C:  MOVLW  E3
0400E:  MOVWF  xF7
04010:  MOVLB  0
04012:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(356, OUT_2_2_FILTER_NEGATIVEA1);     // OUT_2_2_FILTER_NEGATIVEA1 
04016:  MOVLW  01
04018:  MOVLB  6
0401A:  MOVWF  xF6
0401C:  MOVLW  64
0401E:  MOVWF  xF5
04020:  MOVLW  02
04022:  MOVWF  xF8
04024:  MOVLW  E4
04026:  MOVWF  xF7
04028:  MOVLB  0
0402A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(357, OUT_2_2_FILTER_NEGATIVEA2);     // OUT_2_2_FILTER_NEGATIVEA2 
0402E:  MOVLW  01
04030:  MOVLB  6
04032:  MOVWF  xF6
04034:  MOVLW  65
04036:  MOVWF  xF5
04038:  MOVLW  02
0403A:  MOVWF  xF8
0403C:  MOVLW  E5
0403E:  MOVWF  xF7
04040:  MOVLB  0
04042:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(358, OUT_2_3_FILTER_B0);     // OUT_2_3_FILTER_B0 
04046:  MOVLW  01
04048:  MOVLB  6
0404A:  MOVWF  xF6
0404C:  MOVLW  66
0404E:  MOVWF  xF5
04050:  MOVLW  02
04052:  MOVWF  xF8
04054:  MOVLW  DC
04056:  MOVWF  xF7
04058:  MOVLB  0
0405A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(359, OUT_2_3_FILTER_B1);     // OUT_2_3_FILTER_B1 
0405E:  MOVLW  01
04060:  MOVLB  6
04062:  MOVWF  xF6
04064:  MOVLW  67
04066:  MOVWF  xF5
04068:  MOVLW  02
0406A:  MOVWF  xF8
0406C:  MOVLW  DD
0406E:  MOVWF  xF7
04070:  MOVLB  0
04072:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(360, OUT_2_3_FILTER_B2);     // OUT_2_3_FILTER_B2 
04076:  MOVLW  01
04078:  MOVLB  6
0407A:  MOVWF  xF6
0407C:  MOVLW  68
0407E:  MOVWF  xF5
04080:  MOVLW  02
04082:  MOVWF  xF8
04084:  MOVLW  DE
04086:  MOVWF  xF7
04088:  MOVLB  0
0408A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(361, OUT_2_3_FILTER_NEGATIVEA1);     // OUT_2_3_FILTER_NEGATIVEA1 
0408E:  MOVLW  01
04090:  MOVLB  6
04092:  MOVWF  xF6
04094:  MOVLW  69
04096:  MOVWF  xF5
04098:  MOVLW  02
0409A:  MOVWF  xF8
0409C:  MOVLW  DF
0409E:  MOVWF  xF7
040A0:  MOVLB  0
040A2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(362, OUT_2_3_FILTER_NEGATIVEA2);     // OUT_2_3_FILTER_NEGATIVEA2 
040A6:  MOVLW  01
040A8:  MOVLB  6
040AA:  MOVWF  xF6
040AC:  MOVLW  6A
040AE:  MOVWF  xF5
040B0:  MOVLW  02
040B2:  MOVWF  xF8
040B4:  MOVLW  E0
040B6:  MOVWF  xF7
040B8:  MOVLB  0
040BA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(363, OUT_2_4_FILTER_B0);     // OUT_2_4_FILTER_B0 
040BE:  MOVLW  01
040C0:  MOVLB  6
040C2:  MOVWF  xF6
040C4:  MOVLW  6B
040C6:  MOVWF  xF5
040C8:  MOVLW  02
040CA:  MOVWF  xF8
040CC:  MOVLW  AA
040CE:  MOVWF  xF7
040D0:  MOVLB  0
040D2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(364, OUT_2_4_FILTER_B1);     // OUT_2_4_FILTER_B1 
040D6:  MOVLW  01
040D8:  MOVLB  6
040DA:  MOVWF  xF6
040DC:  MOVLW  6C
040DE:  MOVWF  xF5
040E0:  MOVLW  02
040E2:  MOVWF  xF8
040E4:  MOVLW  AB
040E6:  MOVWF  xF7
040E8:  MOVLB  0
040EA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(365, OUT_2_4_FILTER_B2);     // OUT_2_4_FILTER_B2 
040EE:  MOVLW  01
040F0:  MOVLB  6
040F2:  MOVWF  xF6
040F4:  MOVLW  6D
040F6:  MOVWF  xF5
040F8:  MOVLW  02
040FA:  MOVWF  xF8
040FC:  MOVLW  AC
040FE:  MOVWF  xF7
04100:  MOVLB  0
04102:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(366, OUT_2_4_FILTER_NEGATIVEA1);     // OUT_2_4_FILTER_NEGATIVEA1 
04106:  MOVLW  01
04108:  MOVLB  6
0410A:  MOVWF  xF6
0410C:  MOVLW  6E
0410E:  MOVWF  xF5
04110:  MOVLW  02
04112:  MOVWF  xF8
04114:  MOVLW  AD
04116:  MOVWF  xF7
04118:  MOVLB  0
0411A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(367, OUT_2_4_FILTER_NEGATIVEA2);     // OUT_2_4_FILTER_NEGATIVEA2 
0411E:  MOVLW  01
04120:  MOVLB  6
04122:  MOVWF  xF6
04124:  MOVLW  6F
04126:  MOVWF  xF5
04128:  MOVLW  02
0412A:  MOVWF  xF8
0412C:  MOVLW  AE
0412E:  MOVWF  xF7
04130:  MOVLB  0
04132:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(368, OUT_2_5_FILTER_B0);     // OUT_2_5_FILTER_B0 
04136:  MOVLW  01
04138:  MOVLB  6
0413A:  MOVWF  xF6
0413C:  MOVLW  70
0413E:  MOVWF  xF5
04140:  MOVLW  02
04142:  MOVWF  xF8
04144:  MOVLW  A5
04146:  MOVWF  xF7
04148:  MOVLB  0
0414A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(369, OUT_2_5_FILTER_B1);     // OUT_2_5_FILTER_B1 
0414E:  MOVLW  01
04150:  MOVLB  6
04152:  MOVWF  xF6
04154:  MOVLW  71
04156:  MOVWF  xF5
04158:  MOVLW  02
0415A:  MOVWF  xF8
0415C:  MOVLW  A6
0415E:  MOVWF  xF7
04160:  MOVLB  0
04162:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(370, OUT_2_5_FILTER_B2);     // OUT_2_5_FILTER_B2 
04166:  MOVLW  01
04168:  MOVLB  6
0416A:  MOVWF  xF6
0416C:  MOVLW  72
0416E:  MOVWF  xF5
04170:  MOVLW  02
04172:  MOVWF  xF8
04174:  MOVLW  A7
04176:  MOVWF  xF7
04178:  MOVLB  0
0417A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(371, OUT_2_5_FILTER_NEGATIVEA1);     // OUT_2_5_FILTER_NEGATIVEA1 
0417E:  MOVLW  01
04180:  MOVLB  6
04182:  MOVWF  xF6
04184:  MOVLW  73
04186:  MOVWF  xF5
04188:  MOVLW  02
0418A:  MOVWF  xF8
0418C:  MOVLW  A8
0418E:  MOVWF  xF7
04190:  MOVLB  0
04192:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(372, OUT_2_5_FILTER_NEGATIVEA2);     // OUT_2_5_FILTER_NEGATIVEA2 
04196:  MOVLW  01
04198:  MOVLB  6
0419A:  MOVWF  xF6
0419C:  MOVLW  74
0419E:  MOVWF  xF5
041A0:  MOVLW  02
041A2:  MOVWF  xF8
041A4:  MOVLW  A9
041A6:  MOVWF  xF7
041A8:  MOVLB  0
041AA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(373, OUT_2_6_FILTER_B0);     // OUT_2_6_FILTER_B0 
041AE:  MOVLW  01
041B0:  MOVLB  6
041B2:  MOVWF  xF6
041B4:  MOVLW  75
041B6:  MOVWF  xF5
041B8:  MOVLW  02
041BA:  MOVWF  xF8
041BC:  MOVLW  A0
041BE:  MOVWF  xF7
041C0:  MOVLB  0
041C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(374, OUT_2_6_FILTER_B1);     // OUT_2_6_FILTER_B1 
041C6:  MOVLW  01
041C8:  MOVLB  6
041CA:  MOVWF  xF6
041CC:  MOVLW  76
041CE:  MOVWF  xF5
041D0:  MOVLW  02
041D2:  MOVWF  xF8
041D4:  MOVLW  A1
041D6:  MOVWF  xF7
041D8:  MOVLB  0
041DA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(375, OUT_2_6_FILTER_B2);     // OUT_2_6_FILTER_B2 
041DE:  MOVLW  01
041E0:  MOVLB  6
041E2:  MOVWF  xF6
041E4:  MOVLW  77
041E6:  MOVWF  xF5
041E8:  MOVLW  02
041EA:  MOVWF  xF8
041EC:  MOVLW  A2
041EE:  MOVWF  xF7
041F0:  MOVLB  0
041F2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(376, OUT_2_6_FILTER_NEGATIVEA1);     // OUT_2_6_FILTER_NEGATIVEA1 
041F6:  MOVLW  01
041F8:  MOVLB  6
041FA:  MOVWF  xF6
041FC:  MOVLW  78
041FE:  MOVWF  xF5
04200:  MOVLW  02
04202:  MOVWF  xF8
04204:  MOVLW  A3
04206:  MOVWF  xF7
04208:  MOVLB  0
0420A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(377, OUT_2_6_FILTER_NEGATIVEA2);     // OUT_2_6_FILTER_NEGATIVEA2 
0420E:  MOVLW  01
04210:  MOVLB  6
04212:  MOVWF  xF6
04214:  MOVLW  79
04216:  MOVWF  xF5
04218:  MOVLW  02
0421A:  MOVWF  xF8
0421C:  MOVLW  A4
0421E:  MOVWF  xF7
04220:  MOVLB  0
04222:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(378, OUT_3_1_FILTER_B0);     // OUT_3_1_FILTER_B0 
04226:  MOVLW  01
04228:  MOVLB  6
0422A:  MOVWF  xF6
0422C:  MOVLW  7A
0422E:  MOVWF  xF5
04230:  MOVLW  02
04232:  MOVWF  xF8
04234:  MOVLW  D7
04236:  MOVWF  xF7
04238:  MOVLB  0
0423A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(379, OUT_3_1_FILTER_B1);     // OUT_3_1_FILTER_B1 
0423E:  MOVLW  01
04240:  MOVLB  6
04242:  MOVWF  xF6
04244:  MOVLW  7B
04246:  MOVWF  xF5
04248:  MOVLW  02
0424A:  MOVWF  xF8
0424C:  MOVLW  D8
0424E:  MOVWF  xF7
04250:  MOVLB  0
04252:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(380, OUT_3_1_FILTER_B2);     // OUT_3_1_FILTER_B2 
04256:  MOVLW  01
04258:  MOVLB  6
0425A:  MOVWF  xF6
0425C:  MOVLW  7C
0425E:  MOVWF  xF5
04260:  MOVLW  02
04262:  MOVWF  xF8
04264:  MOVLW  D9
04266:  MOVWF  xF7
04268:  MOVLB  0
0426A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(381, OUT_3_1_FILTER_NEGATIVEA1);     // OUT_3_1_FILTER_NEGATIVEA1 
0426E:  MOVLW  01
04270:  MOVLB  6
04272:  MOVWF  xF6
04274:  MOVLW  7D
04276:  MOVWF  xF5
04278:  MOVLW  02
0427A:  MOVWF  xF8
0427C:  MOVLW  DA
0427E:  MOVWF  xF7
04280:  MOVLB  0
04282:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(382, OUT_3_1_FILTER_NEGATIVEA2);     // OUT_3_1_FILTER_NEGATIVEA2 
04286:  MOVLW  01
04288:  MOVLB  6
0428A:  MOVWF  xF6
0428C:  MOVLW  7E
0428E:  MOVWF  xF5
04290:  MOVLW  02
04292:  MOVWF  xF8
04294:  MOVLW  DB
04296:  MOVWF  xF7
04298:  MOVLB  0
0429A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(383, OUT_3_2_FILTER_B0);     // OUT_3_2_FILTER_B0 
0429E:  MOVLW  01
042A0:  MOVLB  6
042A2:  MOVWF  xF6
042A4:  MOVLW  7F
042A6:  MOVWF  xF5
042A8:  MOVLW  02
042AA:  MOVWF  xF8
042AC:  MOVLW  D2
042AE:  MOVWF  xF7
042B0:  MOVLB  0
042B2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(384, OUT_3_2_FILTER_B1);     // OUT_3_2_FILTER_B1 
042B6:  MOVLW  01
042B8:  MOVLB  6
042BA:  MOVWF  xF6
042BC:  MOVLW  80
042BE:  MOVWF  xF5
042C0:  MOVLW  02
042C2:  MOVWF  xF8
042C4:  MOVLW  D3
042C6:  MOVWF  xF7
042C8:  MOVLB  0
042CA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(385, OUT_3_2_FILTER_B2);     // OUT_3_2_FILTER_B2 
042CE:  MOVLW  01
042D0:  MOVLB  6
042D2:  MOVWF  xF6
042D4:  MOVLW  81
042D6:  MOVWF  xF5
042D8:  MOVLW  02
042DA:  MOVWF  xF8
042DC:  MOVLW  D4
042DE:  MOVWF  xF7
042E0:  MOVLB  0
042E2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(386, OUT_3_2_FILTER_NEGATIVEA1);     // OUT_3_2_FILTER_NEGATIVEA1 
042E6:  MOVLW  01
042E8:  MOVLB  6
042EA:  MOVWF  xF6
042EC:  MOVLW  82
042EE:  MOVWF  xF5
042F0:  MOVLW  02
042F2:  MOVWF  xF8
042F4:  MOVLW  D5
042F6:  MOVWF  xF7
042F8:  MOVLB  0
042FA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(387, OUT_3_2_FILTER_NEGATIVEA2);     // OUT_3_2_FILTER_NEGATIVEA2 
042FE:  MOVLW  01
04300:  MOVLB  6
04302:  MOVWF  xF6
04304:  MOVLW  83
04306:  MOVWF  xF5
04308:  MOVLW  02
0430A:  MOVWF  xF8
0430C:  MOVLW  D6
0430E:  MOVWF  xF7
04310:  MOVLB  0
04312:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(388, OUT_3_3_FILTER_B0);     // OUT_3_3_FILTER_B0 
04316:  MOVLW  01
04318:  MOVLB  6
0431A:  MOVWF  xF6
0431C:  MOVLW  84
0431E:  MOVWF  xF5
04320:  MOVLW  02
04322:  MOVWF  xF8
04324:  MOVLW  CD
04326:  MOVWF  xF7
04328:  MOVLB  0
0432A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(389, OUT_3_3_FILTER_B1);     // OUT_3_3_FILTER_B1 
0432E:  MOVLW  01
04330:  MOVLB  6
04332:  MOVWF  xF6
04334:  MOVLW  85
04336:  MOVWF  xF5
04338:  MOVLW  02
0433A:  MOVWF  xF8
0433C:  MOVLW  CE
0433E:  MOVWF  xF7
04340:  MOVLB  0
04342:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(390, OUT_3_3_FILTER_B2);     // OUT_3_3_FILTER_B2 
04346:  MOVLW  01
04348:  MOVLB  6
0434A:  MOVWF  xF6
0434C:  MOVLW  86
0434E:  MOVWF  xF5
04350:  MOVLW  02
04352:  MOVWF  xF8
04354:  MOVLW  CF
04356:  MOVWF  xF7
04358:  MOVLB  0
0435A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(391, OUT_3_3_FILTER_NEGATIVEA1);     // OUT_3_3_FILTER_NEGATIVEA1 
0435E:  MOVLW  01
04360:  MOVLB  6
04362:  MOVWF  xF6
04364:  MOVLW  87
04366:  MOVWF  xF5
04368:  MOVLW  02
0436A:  MOVWF  xF8
0436C:  MOVLW  D0
0436E:  MOVWF  xF7
04370:  MOVLB  0
04372:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(392, OUT_3_3_FILTER_NEGATIVEA2);     // OUT_3_3_FILTER_NEGATIVEA2 
04376:  MOVLW  01
04378:  MOVLB  6
0437A:  MOVWF  xF6
0437C:  MOVLW  88
0437E:  MOVWF  xF5
04380:  MOVLW  02
04382:  MOVWF  xF8
04384:  MOVLW  D1
04386:  MOVWF  xF7
04388:  MOVLB  0
0438A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(393, OUT_3_4_FILTER_B0);     // OUT_3_4_FILTER_B0 
0438E:  MOVLW  01
04390:  MOVLB  6
04392:  MOVWF  xF6
04394:  MOVLW  89
04396:  MOVWF  xF5
04398:  MOVLW  02
0439A:  MOVWF  xF8
0439C:  MOVLW  9B
0439E:  MOVWF  xF7
043A0:  MOVLB  0
043A2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(394, OUT_3_4_FILTER_B1);     // OUT_3_4_FILTER_B1 
043A6:  MOVLW  01
043A8:  MOVLB  6
043AA:  MOVWF  xF6
043AC:  MOVLW  8A
043AE:  MOVWF  xF5
043B0:  MOVLW  02
043B2:  MOVWF  xF8
043B4:  MOVLW  9C
043B6:  MOVWF  xF7
043B8:  MOVLB  0
043BA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(395, OUT_3_4_FILTER_B2);     // OUT_3_4_FILTER_B2 
043BE:  MOVLW  01
043C0:  MOVLB  6
043C2:  MOVWF  xF6
043C4:  MOVLW  8B
043C6:  MOVWF  xF5
043C8:  MOVLW  02
043CA:  MOVWF  xF8
043CC:  MOVLW  9D
043CE:  MOVWF  xF7
043D0:  MOVLB  0
043D2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(396, OUT_3_4_FILTER_NEGATIVEA1);     // OUT_3_4_FILTER_NEGATIVEA1 
043D6:  MOVLW  01
043D8:  MOVLB  6
043DA:  MOVWF  xF6
043DC:  MOVLW  8C
043DE:  MOVWF  xF5
043E0:  MOVLW  02
043E2:  MOVWF  xF8
043E4:  MOVLW  9E
043E6:  MOVWF  xF7
043E8:  MOVLB  0
043EA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(397, OUT_3_4_FILTER_NEGATIVEA2);     // OUT_3_4_FILTER_NEGATIVEA2 
043EE:  MOVLW  01
043F0:  MOVLB  6
043F2:  MOVWF  xF6
043F4:  MOVLW  8D
043F6:  MOVWF  xF5
043F8:  MOVLW  02
043FA:  MOVWF  xF8
043FC:  MOVLW  9F
043FE:  MOVWF  xF7
04400:  MOVLB  0
04402:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(398, OUT_3_5_FILTER_B0);     // OUT_3_5_FILTER_B0 
04406:  MOVLW  01
04408:  MOVLB  6
0440A:  MOVWF  xF6
0440C:  MOVLW  8E
0440E:  MOVWF  xF5
04410:  MOVLW  02
04412:  MOVWF  xF8
04414:  MOVLW  96
04416:  MOVWF  xF7
04418:  MOVLB  0
0441A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(399, OUT_3_5_FILTER_B1);     // OUT_3_5_FILTER_B1 
0441E:  MOVLW  01
04420:  MOVLB  6
04422:  MOVWF  xF6
04424:  MOVLW  8F
04426:  MOVWF  xF5
04428:  MOVLW  02
0442A:  MOVWF  xF8
0442C:  MOVLW  97
0442E:  MOVWF  xF7
04430:  MOVLB  0
04432:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(400, OUT_3_5_FILTER_B2);     // OUT_3_5_FILTER_B2 
04436:  MOVLW  01
04438:  MOVLB  6
0443A:  MOVWF  xF6
0443C:  MOVLW  90
0443E:  MOVWF  xF5
04440:  MOVLW  02
04442:  MOVWF  xF8
04444:  MOVLW  98
04446:  MOVWF  xF7
04448:  MOVLB  0
0444A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(401, OUT_3_5_FILTER_NEGATIVEA1);     // OUT_3_5_FILTER_NEGATIVEA1 
0444E:  MOVLW  01
04450:  MOVLB  6
04452:  MOVWF  xF6
04454:  MOVLW  91
04456:  MOVWF  xF5
04458:  MOVLW  02
0445A:  MOVWF  xF8
0445C:  MOVLW  99
0445E:  MOVWF  xF7
04460:  MOVLB  0
04462:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(402, OUT_3_5_FILTER_NEGATIVEA2);     // OUT_3_5_FILTER_NEGATIVEA2 
04466:  MOVLW  01
04468:  MOVLB  6
0446A:  MOVWF  xF6
0446C:  MOVLW  92
0446E:  MOVWF  xF5
04470:  MOVLW  02
04472:  MOVWF  xF8
04474:  MOVLW  9A
04476:  MOVWF  xF7
04478:  MOVLB  0
0447A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(403, OUT_3_6_FILTER_B0);     // OUT_3_6_FILTER_B0 
0447E:  MOVLW  01
04480:  MOVLB  6
04482:  MOVWF  xF6
04484:  MOVLW  93
04486:  MOVWF  xF5
04488:  MOVLW  02
0448A:  MOVWF  xF8
0448C:  MOVLW  91
0448E:  MOVWF  xF7
04490:  MOVLB  0
04492:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(404, OUT_3_6_FILTER_B1);     // OUT_3_6_FILTER_B1 
04496:  MOVLW  01
04498:  MOVLB  6
0449A:  MOVWF  xF6
0449C:  MOVLW  94
0449E:  MOVWF  xF5
044A0:  MOVLW  02
044A2:  MOVWF  xF8
044A4:  MOVLW  92
044A6:  MOVWF  xF7
044A8:  MOVLB  0
044AA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(405, OUT_3_6_FILTER_B2);     // OUT_3_6_FILTER_B2 
044AE:  MOVLW  01
044B0:  MOVLB  6
044B2:  MOVWF  xF6
044B4:  MOVLW  95
044B6:  MOVWF  xF5
044B8:  MOVLW  02
044BA:  MOVWF  xF8
044BC:  MOVLW  93
044BE:  MOVWF  xF7
044C0:  MOVLB  0
044C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(406, OUT_3_6_FILTER_NEGATIVEA1);     // OUT_3_6_FILTER_NEGATIVEA1 
044C6:  MOVLW  01
044C8:  MOVLB  6
044CA:  MOVWF  xF6
044CC:  MOVLW  96
044CE:  MOVWF  xF5
044D0:  MOVLW  02
044D2:  MOVWF  xF8
044D4:  MOVLW  94
044D6:  MOVWF  xF7
044D8:  MOVLB  0
044DA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(407, OUT_3_6_FILTER_NEGATIVEA2);     // OUT_3_6_FILTER_NEGATIVEA2 
044DE:  MOVLW  01
044E0:  MOVLB  6
044E2:  MOVWF  xF6
044E4:  MOVLW  97
044E6:  MOVWF  xF5
044E8:  MOVLW  02
044EA:  MOVWF  xF8
044EC:  MOVLW  95
044EE:  MOVWF  xF7
044F0:  MOVLB  0
044F2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(408, OUT_4_1_FILTER_B0);     // OUT_4_1_FILTER_B0 
044F6:  MOVLW  01
044F8:  MOVLB  6
044FA:  MOVWF  xF6
044FC:  MOVLW  98
044FE:  MOVWF  xF5
04500:  MOVLW  02
04502:  MOVWF  xF8
04504:  MOVLW  C8
04506:  MOVWF  xF7
04508:  MOVLB  0
0450A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(409, OUT_4_1_FILTER_B1);     // OUT_4_1_FILTER_B1 
0450E:  MOVLW  01
04510:  MOVLB  6
04512:  MOVWF  xF6
04514:  MOVLW  99
04516:  MOVWF  xF5
04518:  MOVLW  02
0451A:  MOVWF  xF8
0451C:  MOVLW  C9
0451E:  MOVWF  xF7
04520:  MOVLB  0
04522:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(410, OUT_4_1_FILTER_B2);     // OUT_4_1_FILTER_B2 
04526:  MOVLW  01
04528:  MOVLB  6
0452A:  MOVWF  xF6
0452C:  MOVLW  9A
0452E:  MOVWF  xF5
04530:  MOVLW  02
04532:  MOVWF  xF8
04534:  MOVLW  CA
04536:  MOVWF  xF7
04538:  MOVLB  0
0453A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(411, OUT_4_1_FILTER_NEGATIVEA1);     // OUT_4_1_FILTER_NEGATIVEA1 
0453E:  MOVLW  01
04540:  MOVLB  6
04542:  MOVWF  xF6
04544:  MOVLW  9B
04546:  MOVWF  xF5
04548:  MOVLW  02
0454A:  MOVWF  xF8
0454C:  MOVLW  CB
0454E:  MOVWF  xF7
04550:  MOVLB  0
04552:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(412, OUT_4_1_FILTER_NEGATIVEA2);     // OUT_4_1_FILTER_NEGATIVEA2 
04556:  MOVLW  01
04558:  MOVLB  6
0455A:  MOVWF  xF6
0455C:  MOVLW  9C
0455E:  MOVWF  xF5
04560:  MOVLW  02
04562:  MOVWF  xF8
04564:  MOVLW  CC
04566:  MOVWF  xF7
04568:  MOVLB  0
0456A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(413, OUT_4_2_FILTER_B0);     // OUT_4_2_FILTER_B0 
0456E:  MOVLW  01
04570:  MOVLB  6
04572:  MOVWF  xF6
04574:  MOVLW  9D
04576:  MOVWF  xF5
04578:  MOVLW  02
0457A:  MOVWF  xF8
0457C:  MOVLW  C3
0457E:  MOVWF  xF7
04580:  MOVLB  0
04582:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(414, OUT_4_2_FILTER_B1);     // OUT_4_2_FILTER_B1 
04586:  MOVLW  01
04588:  MOVLB  6
0458A:  MOVWF  xF6
0458C:  MOVLW  9E
0458E:  MOVWF  xF5
04590:  MOVLW  02
04592:  MOVWF  xF8
04594:  MOVLW  C4
04596:  MOVWF  xF7
04598:  MOVLB  0
0459A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(415, OUT_4_2_FILTER_B2);     // OUT_4_2_FILTER_B2 
0459E:  MOVLW  01
045A0:  MOVLB  6
045A2:  MOVWF  xF6
045A4:  MOVLW  9F
045A6:  MOVWF  xF5
045A8:  MOVLW  02
045AA:  MOVWF  xF8
045AC:  MOVLW  C5
045AE:  MOVWF  xF7
045B0:  MOVLB  0
045B2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(416, OUT_4_2_FILTER_NEGATIVEA1);     // OUT_4_2_FILTER_NEGATIVEA1 
045B6:  MOVLW  01
045B8:  MOVLB  6
045BA:  MOVWF  xF6
045BC:  MOVLW  A0
045BE:  MOVWF  xF5
045C0:  MOVLW  02
045C2:  MOVWF  xF8
045C4:  MOVLW  C6
045C6:  MOVWF  xF7
045C8:  MOVLB  0
045CA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(417, OUT_4_2_FILTER_NEGATIVEA2);     // OUT_4_2_FILTER_NEGATIVEA2 
045CE:  MOVLW  01
045D0:  MOVLB  6
045D2:  MOVWF  xF6
045D4:  MOVLW  A1
045D6:  MOVWF  xF5
045D8:  MOVLW  02
045DA:  MOVWF  xF8
045DC:  MOVLW  C7
045DE:  MOVWF  xF7
045E0:  MOVLB  0
045E2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(418, OUT_4_3_FILTER_B0);     // OUT_4_3_FILTER_B0 
045E6:  MOVLW  01
045E8:  MOVLB  6
045EA:  MOVWF  xF6
045EC:  MOVLW  A2
045EE:  MOVWF  xF5
045F0:  MOVLW  02
045F2:  MOVWF  xF8
045F4:  MOVLW  BE
045F6:  MOVWF  xF7
045F8:  MOVLB  0
045FA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(419, OUT_4_3_FILTER_B1);     // OUT_4_3_FILTER_B1 
045FE:  MOVLW  01
04600:  MOVLB  6
04602:  MOVWF  xF6
04604:  MOVLW  A3
04606:  MOVWF  xF5
04608:  MOVLW  02
0460A:  MOVWF  xF8
0460C:  MOVLW  BF
0460E:  MOVWF  xF7
04610:  MOVLB  0
04612:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(420, OUT_4_3_FILTER_B2);     // OUT_4_3_FILTER_B2 
04616:  MOVLW  01
04618:  MOVLB  6
0461A:  MOVWF  xF6
0461C:  MOVLW  A4
0461E:  MOVWF  xF5
04620:  MOVLW  02
04622:  MOVWF  xF8
04624:  MOVLW  C0
04626:  MOVWF  xF7
04628:  MOVLB  0
0462A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(421, OUT_4_3_FILTER_NEGATIVEA1);     // OUT_4_3_FILTER_NEGATIVEA1 
0462E:  MOVLW  01
04630:  MOVLB  6
04632:  MOVWF  xF6
04634:  MOVLW  A5
04636:  MOVWF  xF5
04638:  MOVLW  02
0463A:  MOVWF  xF8
0463C:  MOVLW  C1
0463E:  MOVWF  xF7
04640:  MOVLB  0
04642:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(422, OUT_4_3_FILTER_NEGATIVEA2);     // OUT_4_3_FILTER_NEGATIVEA2 
04646:  MOVLW  01
04648:  MOVLB  6
0464A:  MOVWF  xF6
0464C:  MOVLW  A6
0464E:  MOVWF  xF5
04650:  MOVLW  02
04652:  MOVWF  xF8
04654:  MOVLW  C2
04656:  MOVWF  xF7
04658:  MOVLB  0
0465A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(423, OUT_4_4_FILTER_B0);     // OUT_4_4_FILTER_B0 
0465E:  MOVLW  01
04660:  MOVLB  6
04662:  MOVWF  xF6
04664:  MOVLW  A7
04666:  MOVWF  xF5
04668:  MOVLW  02
0466A:  MOVWF  xF8
0466C:  MOVLW  8C
0466E:  MOVWF  xF7
04670:  MOVLB  0
04672:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(424, OUT_4_4_FILTER_B1);     // OUT_4_4_FILTER_B1 
04676:  MOVLW  01
04678:  MOVLB  6
0467A:  MOVWF  xF6
0467C:  MOVLW  A8
0467E:  MOVWF  xF5
04680:  MOVLW  02
04682:  MOVWF  xF8
04684:  MOVLW  8D
04686:  MOVWF  xF7
04688:  MOVLB  0
0468A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(425, OUT_4_4_FILTER_B2);     // OUT_4_4_FILTER_B2 
0468E:  MOVLW  01
04690:  MOVLB  6
04692:  MOVWF  xF6
04694:  MOVLW  A9
04696:  MOVWF  xF5
04698:  MOVLW  02
0469A:  MOVWF  xF8
0469C:  MOVLW  8E
0469E:  MOVWF  xF7
046A0:  MOVLB  0
046A2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(426, OUT_4_4_FILTER_NEGATIVEA1);     // OUT_4_4_FILTER_NEGATIVEA1 
046A6:  MOVLW  01
046A8:  MOVLB  6
046AA:  MOVWF  xF6
046AC:  MOVLW  AA
046AE:  MOVWF  xF5
046B0:  MOVLW  02
046B2:  MOVWF  xF8
046B4:  MOVLW  8F
046B6:  MOVWF  xF7
046B8:  MOVLB  0
046BA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(427, OUT_4_4_FILTER_NEGATIVEA2);     // OUT_4_4_FILTER_NEGATIVEA2 
046BE:  MOVLW  01
046C0:  MOVLB  6
046C2:  MOVWF  xF6
046C4:  MOVLW  AB
046C6:  MOVWF  xF5
046C8:  MOVLW  02
046CA:  MOVWF  xF8
046CC:  MOVLW  90
046CE:  MOVWF  xF7
046D0:  MOVLB  0
046D2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(428, OUT_4_5_FILTER_B0);     // OUT_4_5_FILTER_B0 
046D6:  MOVLW  01
046D8:  MOVLB  6
046DA:  MOVWF  xF6
046DC:  MOVLW  AC
046DE:  MOVWF  xF5
046E0:  MOVLW  02
046E2:  MOVWF  xF8
046E4:  MOVLW  87
046E6:  MOVWF  xF7
046E8:  MOVLB  0
046EA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(429, OUT_4_5_FILTER_B1);     // OUT_4_5_FILTER_B1 
046EE:  MOVLW  01
046F0:  MOVLB  6
046F2:  MOVWF  xF6
046F4:  MOVLW  AD
046F6:  MOVWF  xF5
046F8:  MOVLW  02
046FA:  MOVWF  xF8
046FC:  MOVLW  88
046FE:  MOVWF  xF7
04700:  MOVLB  0
04702:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(430, OUT_4_5_FILTER_B2);     // OUT_4_5_FILTER_B2 
04706:  MOVLW  01
04708:  MOVLB  6
0470A:  MOVWF  xF6
0470C:  MOVLW  AE
0470E:  MOVWF  xF5
04710:  MOVLW  02
04712:  MOVWF  xF8
04714:  MOVLW  89
04716:  MOVWF  xF7
04718:  MOVLB  0
0471A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(431, OUT_4_5_FILTER_NEGATIVEA1);     // OUT_4_5_FILTER_NEGATIVEA1 
0471E:  MOVLW  01
04720:  MOVLB  6
04722:  MOVWF  xF6
04724:  MOVLW  AF
04726:  MOVWF  xF5
04728:  MOVLW  02
0472A:  MOVWF  xF8
0472C:  MOVLW  8A
0472E:  MOVWF  xF7
04730:  MOVLB  0
04732:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(432, OUT_4_5_FILTER_NEGATIVEA2);     // OUT_4_5_FILTER_NEGATIVEA2 
04736:  MOVLW  01
04738:  MOVLB  6
0473A:  MOVWF  xF6
0473C:  MOVLW  B0
0473E:  MOVWF  xF5
04740:  MOVLW  02
04742:  MOVWF  xF8
04744:  MOVLW  8B
04746:  MOVWF  xF7
04748:  MOVLB  0
0474A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(433, OUT_4_6_FILTER_B0);     // OUT_4_6_FILTER_B0 
0474E:  MOVLW  01
04750:  MOVLB  6
04752:  MOVWF  xF6
04754:  MOVLW  B1
04756:  MOVWF  xF5
04758:  MOVLW  02
0475A:  MOVWF  xF8
0475C:  MOVLW  82
0475E:  MOVWF  xF7
04760:  MOVLB  0
04762:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(434, OUT_4_6_FILTER_B1);     // OUT_4_6_FILTER_B1 
04766:  MOVLW  01
04768:  MOVLB  6
0476A:  MOVWF  xF6
0476C:  MOVLW  B2
0476E:  MOVWF  xF5
04770:  MOVLW  02
04772:  MOVWF  xF8
04774:  MOVLW  83
04776:  MOVWF  xF7
04778:  MOVLB  0
0477A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(435, OUT_4_6_FILTER_B2);     // OUT_4_6_FILTER_B2 
0477E:  MOVLW  01
04780:  MOVLB  6
04782:  MOVWF  xF6
04784:  MOVLW  B3
04786:  MOVWF  xF5
04788:  MOVLW  02
0478A:  MOVWF  xF8
0478C:  MOVLW  84
0478E:  MOVWF  xF7
04790:  MOVLB  0
04792:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(436, OUT_4_6_FILTER_NEGATIVEA1);     // OUT_4_6_FILTER_NEGATIVEA1 
04796:  MOVLW  01
04798:  MOVLB  6
0479A:  MOVWF  xF6
0479C:  MOVLW  B4
0479E:  MOVWF  xF5
047A0:  MOVLW  02
047A2:  MOVWF  xF8
047A4:  MOVLW  85
047A6:  MOVWF  xF7
047A8:  MOVLB  0
047AA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(437, OUT_4_6_FILTER_NEGATIVEA2);     // OUT_4_6_FILTER_NEGATIVEA2 
047AE:  MOVLW  01
047B0:  MOVLB  6
047B2:  MOVWF  xF6
047B4:  MOVLW  B5
047B6:  MOVWF  xF5
047B8:  MOVLW  02
047BA:  MOVWF  xF8
047BC:  MOVLW  86
047BE:  MOVWF  xF7
047C0:  MOVLB  0
047C2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(438, CH1LIM_THRESHOLD);     // CH1LIM_THRESHOLD 
047C6:  MOVLW  01
047C8:  MOVLB  6
047CA:  MOVWF  xF6
047CC:  MOVLW  B6
047CE:  MOVWF  xF5
047D0:  MOVLW  02
047D2:  MOVWF  xF8
047D4:  MOVLW  2E
047D6:  MOVWF  xF7
047D8:  MOVLB  0
047DA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(439, CH1LIM_KNEE);     // CH1LIM_KNEE 
047DE:  MOVLW  01
047E0:  MOVLB  6
047E2:  MOVWF  xF6
047E4:  MOVLW  B7
047E6:  MOVWF  xF5
047E8:  MOVLW  02
047EA:  MOVWF  xF8
047EC:  MOVLW  2F
047EE:  MOVWF  xF7
047F0:  MOVLB  0
047F2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(440, CH1LIM_RATIO);     // CH1LIM_RATIO 
047F6:  MOVLW  01
047F8:  MOVLB  6
047FA:  MOVWF  xF6
047FC:  MOVLW  B8
047FE:  MOVWF  xF5
04800:  MOVLW  02
04802:  MOVWF  xF8
04804:  MOVLW  30
04806:  MOVWF  xF7
04808:  MOVLB  0
0480A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(441, CH1LIM_ATTACK);     // CH1LIM_ATTACK 
0480E:  MOVLW  01
04810:  MOVLB  6
04812:  MOVWF  xF6
04814:  MOVLW  B9
04816:  MOVWF  xF5
04818:  MOVLW  02
0481A:  MOVWF  xF8
0481C:  MOVLW  31
0481E:  MOVWF  xF7
04820:  MOVLB  0
04822:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(442, CH1LIM_RELEASE);     // CH1LIM_RELEASE 
04826:  MOVLW  01
04828:  MOVLB  6
0482A:  MOVWF  xF6
0482C:  MOVLW  BA
0482E:  MOVWF  xF5
04830:  MOVLW  02
04832:  MOVWF  xF8
04834:  MOVLW  32
04836:  MOVWF  xF7
04838:  MOVLB  0
0483A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(443, CH1LIM_BYPASS);     // CH1LIM_BYPASS 
0483E:  MOVLW  01
04840:  MOVLB  6
04842:  MOVWF  xF6
04844:  MOVLW  BB
04846:  MOVWF  xF5
04848:  MOVLW  02
0484A:  MOVWF  xF8
0484C:  MOVLW  33
0484E:  MOVWF  xF7
04850:  MOVLB  0
04852:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(444, CH2LIM_THRESHOLD);     // CH2LIM_THRESHOLD 
04856:  MOVLW  01
04858:  MOVLB  6
0485A:  MOVWF  xF6
0485C:  MOVLW  BC
0485E:  MOVWF  xF5
04860:  MOVLW  02
04862:  MOVWF  xF8
04864:  MOVLW  26
04866:  MOVWF  xF7
04868:  MOVLB  0
0486A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(445, CH2LIM_KNEE);     // CH2LIM_KNEE 
0486E:  MOVLW  01
04870:  MOVLB  6
04872:  MOVWF  xF6
04874:  MOVLW  BD
04876:  MOVWF  xF5
04878:  MOVLW  02
0487A:  MOVWF  xF8
0487C:  MOVLW  27
0487E:  MOVWF  xF7
04880:  MOVLB  0
04882:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(446, CH2LIM_RATIO);     // CH2LIM_RATIO 
04886:  MOVLW  01
04888:  MOVLB  6
0488A:  MOVWF  xF6
0488C:  MOVLW  BE
0488E:  MOVWF  xF5
04890:  MOVLW  02
04892:  MOVWF  xF8
04894:  MOVLW  28
04896:  MOVWF  xF7
04898:  MOVLB  0
0489A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(447, CH2LIM_ATTACK);     // CH2LIM_ATTACK 
0489E:  MOVLW  01
048A0:  MOVLB  6
048A2:  MOVWF  xF6
048A4:  MOVLW  BF
048A6:  MOVWF  xF5
048A8:  MOVLW  02
048AA:  MOVWF  xF8
048AC:  MOVLW  29
048AE:  MOVWF  xF7
048B0:  MOVLB  0
048B2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(448, CH2LIM_RELEASE);     // CH2LIM_RELEASE 
048B6:  MOVLW  01
048B8:  MOVLB  6
048BA:  MOVWF  xF6
048BC:  MOVLW  C0
048BE:  MOVWF  xF5
048C0:  MOVLW  02
048C2:  MOVWF  xF8
048C4:  MOVLW  2A
048C6:  MOVWF  xF7
048C8:  MOVLB  0
048CA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(449, CH2LIM_BYPASS);     // CH2LIM_BYPASS 
048CE:  MOVLW  01
048D0:  MOVLB  6
048D2:  MOVWF  xF6
048D4:  MOVLW  C1
048D6:  MOVWF  xF5
048D8:  MOVLW  02
048DA:  MOVWF  xF8
048DC:  MOVLW  2B
048DE:  MOVWF  xF7
048E0:  MOVLB  0
048E2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(450, CH3LIM_THRESHOLD);     // CH3LIM_THRESHOLD 
048E6:  MOVLW  01
048E8:  MOVLB  6
048EA:  MOVWF  xF6
048EC:  MOVLW  C2
048EE:  MOVWF  xF5
048F0:  MOVLW  02
048F2:  MOVWF  xF8
048F4:  MOVLW  1E
048F6:  MOVWF  xF7
048F8:  MOVLB  0
048FA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(451, CH3LIM_KNEE);     // CH3LIM_KNEE 
048FE:  MOVLW  01
04900:  MOVLB  6
04902:  MOVWF  xF6
04904:  MOVLW  C3
04906:  MOVWF  xF5
04908:  MOVLW  02
0490A:  MOVWF  xF8
0490C:  MOVLW  1F
0490E:  MOVWF  xF7
04910:  MOVLB  0
04912:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(452, CH3LIM_RATIO);     // CH3LIM_RATIO 
04916:  MOVLW  01
04918:  MOVLB  6
0491A:  MOVWF  xF6
0491C:  MOVLW  C4
0491E:  MOVWF  xF5
04920:  MOVLW  02
04922:  MOVWF  xF8
04924:  MOVLW  20
04926:  MOVWF  xF7
04928:  MOVLB  0
0492A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(453, CH3LIM_ATTACK);     // CH3LIM_ATTACK 
0492E:  MOVLW  01
04930:  MOVLB  6
04932:  MOVWF  xF6
04934:  MOVLW  C5
04936:  MOVWF  xF5
04938:  MOVLW  02
0493A:  MOVWF  xF8
0493C:  MOVLW  21
0493E:  MOVWF  xF7
04940:  MOVLB  0
04942:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(454, CH3LIM_RELEASE);     // CH3LIM_RELEASE 
04946:  MOVLW  01
04948:  MOVLB  6
0494A:  MOVWF  xF6
0494C:  MOVLW  C6
0494E:  MOVWF  xF5
04950:  MOVLW  02
04952:  MOVWF  xF8
04954:  MOVLW  22
04956:  MOVWF  xF7
04958:  MOVLB  0
0495A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(455, CH3LIM_BYPASS);     // CH3LIM_BYPASS 
0495E:  MOVLW  01
04960:  MOVLB  6
04962:  MOVWF  xF6
04964:  MOVLW  C7
04966:  MOVWF  xF5
04968:  MOVLW  02
0496A:  MOVWF  xF8
0496C:  MOVLW  23
0496E:  MOVWF  xF7
04970:  MOVLB  0
04972:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(456, CH4LIM_THRESHOLD);     // CH4LIM_THRESHOLD 
04976:  MOVLW  01
04978:  MOVLB  6
0497A:  MOVWF  xF6
0497C:  MOVLW  C8
0497E:  MOVWF  xF5
04980:  MOVLW  02
04982:  MOVWF  xF8
04984:  MOVLW  16
04986:  MOVWF  xF7
04988:  MOVLB  0
0498A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(457, CH4LIM_KNEE);     // CH4LIM_KNEE 
0498E:  MOVLW  01
04990:  MOVLB  6
04992:  MOVWF  xF6
04994:  MOVLW  C9
04996:  MOVWF  xF5
04998:  MOVLW  02
0499A:  MOVWF  xF8
0499C:  MOVLW  17
0499E:  MOVWF  xF7
049A0:  MOVLB  0
049A2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(458, CH4LIM_RATIO);     // CH4LIM_RATIO 
049A6:  MOVLW  01
049A8:  MOVLB  6
049AA:  MOVWF  xF6
049AC:  MOVLW  CA
049AE:  MOVWF  xF5
049B0:  MOVLW  02
049B2:  MOVWF  xF8
049B4:  MOVLW  18
049B6:  MOVWF  xF7
049B8:  MOVLB  0
049BA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(459, CH4LIM_ATTACK);     // CH4LIM_ATTACK 
049BE:  MOVLW  01
049C0:  MOVLB  6
049C2:  MOVWF  xF6
049C4:  MOVLW  CB
049C6:  MOVWF  xF5
049C8:  MOVLW  02
049CA:  MOVWF  xF8
049CC:  MOVLW  19
049CE:  MOVWF  xF7
049D0:  MOVLB  0
049D2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(460, CH4LIM_RELEASE);     // CH4LIM_RELEASE 
049D6:  MOVLW  01
049D8:  MOVLB  6
049DA:  MOVWF  xF6
049DC:  MOVLW  CC
049DE:  MOVWF  xF5
049E0:  MOVLW  02
049E2:  MOVWF  xF8
049E4:  MOVLW  1A
049E6:  MOVWF  xF7
049E8:  MOVLB  0
049EA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(461, CH4LIM_BYPASS);     // CH4LIM_BYPASS 
049EE:  MOVLW  01
049F0:  MOVLB  6
049F2:  MOVWF  xF6
049F4:  MOVLW  CD
049F6:  MOVWF  xF5
049F8:  MOVLW  02
049FA:  MOVWF  xF8
049FC:  MOVLW  1B
049FE:  MOVWF  xF7
04A00:  MOVLB  0
04A02:  CALL   2030
....................  
.................... 	WRITE_CONFIG_ADDRESS(462, DELAY_CH1);     // DELAY_CH1 
04A06:  MOVLW  01
04A08:  MOVLB  6
04A0A:  MOVWF  xF6
04A0C:  MOVLW  CE
04A0E:  MOVWF  xF5
04A10:  MOVLW  03
04A12:  MOVWF  xF8
04A14:  MOVLW  DD
04A16:  MOVWF  xF7
04A18:  MOVLB  0
04A1A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(463, DELAY_BYPASS_CH1);     // DELAY_BYPASS_CH1 
04A1E:  MOVLW  01
04A20:  MOVLB  6
04A22:  MOVWF  xF6
04A24:  MOVLW  CF
04A26:  MOVWF  xF5
04A28:  MOVLW  04
04A2A:  MOVWF  xF8
04A2C:  MOVLW  48
04A2E:  MOVWF  xF7
04A30:  MOVLB  0
04A32:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(464, DELAY_CH2);     // DELAY_CH2 
04A36:  MOVLW  01
04A38:  MOVLB  6
04A3A:  MOVWF  xF6
04A3C:  MOVLW  D0
04A3E:  MOVWF  xF5
04A40:  MOVLW  03
04A42:  MOVWF  xF8
04A44:  MOVLW  DA
04A46:  MOVWF  xF7
04A48:  MOVLB  0
04A4A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(465, DELAY_BYPASS_CH2);     // DELAY_BYPASS_CH2 
04A4E:  MOVLW  01
04A50:  MOVLB  6
04A52:  MOVWF  xF6
04A54:  MOVLW  D1
04A56:  MOVWF  xF5
04A58:  MOVLW  04
04A5A:  MOVWF  xF8
04A5C:  MOVLW  47
04A5E:  MOVWF  xF7
04A60:  MOVLB  0
04A62:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(466, DELAY_CH3);     // DELAY_CH3 
04A66:  MOVLW  01
04A68:  MOVLB  6
04A6A:  MOVWF  xF6
04A6C:  MOVLW  D2
04A6E:  MOVWF  xF5
04A70:  MOVLW  03
04A72:  MOVWF  xF8
04A74:  MOVLW  D7
04A76:  MOVWF  xF7
04A78:  MOVLB  0
04A7A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(467, DELAY_BYPASS_CH3);     // DELAY_BYPASS_CH3 
04A7E:  MOVLW  01
04A80:  MOVLB  6
04A82:  MOVWF  xF6
04A84:  MOVLW  D3
04A86:  MOVWF  xF5
04A88:  MOVLW  04
04A8A:  MOVWF  xF8
04A8C:  MOVLW  46
04A8E:  MOVWF  xF7
04A90:  MOVLB  0
04A92:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(468, DELAY_CH4);     // DELAY_CH4 
04A96:  MOVLW  01
04A98:  MOVLB  6
04A9A:  MOVWF  xF6
04A9C:  MOVLW  D4
04A9E:  MOVWF  xF5
04AA0:  MOVLW  03
04AA2:  MOVWF  xF8
04AA4:  MOVLW  D4
04AA6:  MOVWF  xF7
04AA8:  MOVLB  0
04AAA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(469, DELAY_BYPASS_CH4);     // DELAY_BYPASS_CH4 
04AAE:  MOVLW  01
04AB0:  MOVLB  6
04AB2:  MOVWF  xF6
04AB4:  MOVLW  D5
04AB6:  MOVWF  xF5
04AB8:  MOVLW  04
04ABA:  MOVWF  xF8
04ABC:  MOVLW  45
04ABE:  MOVWF  xF7
04AC0:  MOVLB  0
04AC2:  CALL   2030
.................... 	 
.................... 	WRITE_CONFIG_ADDRESS(470, BRIDGEROUTER_SELECT0);     // BRIDGEROUTER_SELECT0 
04AC6:  MOVLW  01
04AC8:  MOVLB  6
04ACA:  MOVWF  xF6
04ACC:  MOVLW  D6
04ACE:  MOVWF  xF5
04AD0:  MOVLW  02
04AD2:  MOVWF  xF8
04AD4:  MOVLW  7E
04AD6:  MOVWF  xF7
04AD8:  MOVLB  0
04ADA:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(471, BRIDGEROUTER_SELECT1);     // BRIDGEROUTER_SELECT1 
04ADE:  MOVLW  01
04AE0:  MOVLB  6
04AE2:  MOVWF  xF6
04AE4:  MOVLW  D7
04AE6:  MOVWF  xF5
04AE8:  MOVLW  02
04AEA:  MOVWF  xF8
04AEC:  MOVLW  7F
04AEE:  MOVWF  xF7
04AF0:  MOVLB  0
04AF2:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(472, BRIDGEROUTER_SELECT2);     // BRIDGEROUTER_SELECT2 
04AF6:  MOVLW  01
04AF8:  MOVLB  6
04AFA:  MOVWF  xF6
04AFC:  MOVLW  D8
04AFE:  MOVWF  xF5
04B00:  MOVLW  02
04B02:  MOVWF  xF8
04B04:  MOVLW  80
04B06:  MOVWF  xF7
04B08:  MOVLB  0
04B0A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(473, BRIDGEROUTER_SELECT3);     // BRIDGEROUTER_SELECT3 
04B0E:  MOVLW  01
04B10:  MOVLB  6
04B12:  MOVWF  xF6
04B14:  MOVLW  D9
04B16:  MOVWF  xF5
04B18:  MOVLW  02
04B1A:  MOVWF  xF8
04B1C:  MOVLW  81
04B1E:  MOVWF  xF7
04B20:  MOVLB  0
04B22:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(474, GEN_PINK_GAIN);     // GEN_PINK_GAIN 
04B26:  MOVLW  01
04B28:  MOVLB  6
04B2A:  MOVWF  xF6
04B2C:  MOVLW  DA
04B2E:  MOVWF  xF5
04B30:  MOVLW  04
04B32:  MOVWF  xF8
04B34:  MOVLW  11
04B36:  MOVWF  xF7
04B38:  MOVLB  0
04B3A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(475, GEN_SINE_OMEGA);     // GEN_SINE_OMEGA 
04B3E:  MOVLW  01
04B40:  MOVLB  6
04B42:  MOVWF  xF6
04B44:  MOVLW  DB
04B46:  MOVWF  xF5
04B48:  MOVLW  03
04B4A:  MOVWF  xF8
04B4C:  MOVLW  EB
04B4E:  MOVWF  xF7
04B50:  MOVLB  0
04B52:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(476, GEN_SINE_GAIN);     // GEN_SINE_GAIN 
04B56:  MOVLW  01
04B58:  MOVLB  6
04B5A:  MOVWF  xF6
04B5C:  MOVLW  DC
04B5E:  MOVWF  xF5
04B60:  MOVLW  03
04B62:  MOVWF  xF8
04B64:  MOVLW  EC
04B66:  MOVWF  xF7
04B68:  MOVLB  0
04B6A:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(477, SEVENTYVHP_BYPASS);     // 70VHP_BYPASS 
04B6E:  MOVLW  01
04B70:  MOVLB  6
04B72:  MOVWF  xF6
04B74:  MOVLW  DD
04B76:  MOVWF  xF5
04B78:  MOVLW  04
04B7A:  MOVWF  xF8
04B7C:  MOVLW  44
04B7E:  MOVWF  xF7
04B80:  MOVLB  0
04B82:  CALL   2030
.................... 	WRITE_CONFIG_ADDRESS(478, MUTE_OUTPUTS);     // MUTE_OUTPUTS 
04B86:  MOVLW  01
04B88:  MOVLB  6
04B8A:  MOVWF  xF6
04B8C:  MOVLW  DE
04B8E:  MOVWF  xF5
04B90:  MOVLW  04
04B92:  MOVWF  xF8
04B94:  MOVLW  13
04B96:  MOVWF  xF7
04B98:  MOVLB  0
04B9A:  CALL   2030
....................  
.................... } 
04B9E:  GOTO   8D18 (RETURN)
....................  
.................... #include <phantom.c> 
.................... void update_phantom_power() 
.................... { 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
*
01F5E:  MOVLB  7
01F60:  CLRF   x35
01F62:  MOVLW  A1
01F64:  MOVWF  x34
01F66:  MOVFF  A0,736
01F6A:  MOVLW  08
01F6C:  MOVWF  x37
01F6E:  MOVLB  0
01F70:  CALL   14AC
....................  
.................... 	int32 phantom_mask = PAGE_BUFFER_A[54]; 
01F74:  MOVFF  17C,732
01F78:  MOVFF  17B,731
01F7C:  MOVFF  17A,730
01F80:  MOVFF  179,72F
....................  
.................... 	output_bit(PIN_PHANTOM_CH1,bit_test(phantom_mask,0)); 
01F84:  MOVLB  7
01F86:  BTFSC  x2F.0
01F88:  BRA    1F8E
01F8A:  BCF    F89.5
01F8C:  BRA    1F90
01F8E:  BSF    F89.5
01F90:  BCF    F92.5
.................... 	output_bit(PIN_PHANTOM_CH2,bit_test(phantom_mask,1)); 
01F92:  BTFSC  x2F.1
01F94:  BRA    1F9A
01F96:  BCF    F8D.0
01F98:  BRA    1F9C
01F9A:  BSF    F8D.0
01F9C:  BCF    F96.0
.................... 	output_bit(PIN_PHANTOM_CH3,bit_test(phantom_mask,2)); 
01F9E:  BTFSC  x2F.2
01FA0:  BRA    1FA6
01FA2:  BCF    F89.1
01FA4:  BRA    1FA8
01FA6:  BSF    F89.1
01FA8:  BCF    F92.1
.................... 	output_bit(PIN_PHANTOM_CH4,bit_test(phantom_mask,3)); 
01FAA:  BTFSC  x2F.3
01FAC:  BRA    1FB2
01FAE:  BCF    F89.2
01FB0:  BRA    1FB4
01FB2:  BSF    F89.2
01FB4:  BCF    F92.2
....................  
.................... } 
01FB6:  MOVLB  0
01FB8:  RETURN 0
....................  
.................... #include <presets.c> 
.................... // presets.c 
....................  
.................... void softboot(); 
....................  
.................... void save_flash_program() 
.................... { 
.................... 	//FLASH_PROGRAM_WRITE(CURRENT_PRESET); 
.................... } 
*
05098:  GOTO   697C (RETURN)
....................  
.................... void switch_flash_program(int new_index) 
.................... { 
.................... 	CURRENT_FLASH_PROGRAM = new_index; 
*
05056:  MOVFF  72E,A0
....................  
.................... 	softboot(); 
0505A:  CALL   1FBA
....................  
.................... 	write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
0505E:  CLRF   FAA
05060:  MOVLW  10
05062:  MOVWF  FA9
05064:  MOVFF  A0,FA8
05068:  BCF    FA6.6
0506A:  BCF    FA6.7
0506C:  BSF    FA6.2
0506E:  MOVF   FF2,W
05070:  MOVWF  00
05072:  BCF    FF2.7
05074:  MOVLB  F
05076:  MOVLW  55
05078:  MOVWF  FA7
0507A:  MOVLW  AA
0507C:  MOVWF  FA7
0507E:  BSF    FA6.1
05080:  BTFSC  FA6.1
05082:  BRA    5080
05084:  BCF    FA6.2
05086:  MOVF   00,W
05088:  IORWF  FF2,F
....................  
.................... 	delay_ms(5); 
0508A:  MOVLW  05
0508C:  MOVLB  7
0508E:  MOVWF  x37
05090:  MOVLB  0
05092:  CALL   0F2E
.................... } 
05096:  RETURN 0
....................  
.................... #include <device_boot.c> 
.................... void softboot(); 
.................... void initialize_first_boot(); 
....................  
.................... void default_device_config() 
.................... { 
.................... 	for(int x = 0; x < 20; x++) { 
*
0183C:  MOVLB  6
0183E:  CLRF   xF7
01840:  MOVF   xF7,W
01842:  SUBLW  13
01844:  BNC   185A
.................... 		DEVICE_CONFIG.SERIAL[x] = 0xFF; 
01846:  CLRF   03
01848:  MOVF   xF7,W
0184A:  ADDLW  1F
0184C:  MOVWF  FE9
0184E:  MOVLW  00
01850:  ADDWFC 03,W
01852:  MOVWF  FEA
01854:  SETF   FEF
.................... 	} 
01856:  INCF   xF7,F
01858:  BRA    1840
....................  
.................... 	DEVICE_CONFIG.SERIAL[0] = 'N'; 
0185A:  MOVLW  4E
0185C:  MOVWF  1F
.................... 	DEVICE_CONFIG.SERIAL[1] = 'O'; 
0185E:  MOVLW  4F
01860:  MOVWF  20
.................... 	DEVICE_CONFIG.SERIAL[2] = 'N'; 
01862:  MOVLW  4E
01864:  MOVWF  21
.................... 	DEVICE_CONFIG.SERIAL[3] = 'E'; 
01866:  MOVLW  45
01868:  MOVWF  22
....................  
.................... 	DEVICE_CONFIG.USBDETECT_ENABLE = 		DEFAULT_USBDETECT_ENABLE; 
0186A:  MOVFF  1B,1D
.................... 	DEVICE_CONFIG.DSP_VALUESEND_ENABLE = 	DEFAULT_DSP_VALUESEND_ENABLE; 
0186E:  MOVFF  1C,1E
.................... 	 
.................... 	delay_ms(10); 
01872:  MOVLW  0A
01874:  MOVLB  7
01876:  MOVWF  x37
01878:  MOVLB  0
0187A:  CALL   0F2E
.................... 	 
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),IEEPROM_DEVICE_CONFIG_LOC); 
0187E:  MOVLB  7
01880:  CLRF   x2F
01882:  MOVLW  1D
01884:  MOVWF  x2E
01886:  CLRF   x31
01888:  MOVLW  16
0188A:  MOVWF  x30
0188C:  CLRF   x33
0188E:  MOVLW  64
01890:  MOVWF  x32
01892:  MOVLB  0
01894:  RCALL  143C
....................  
....................  
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
01896:  MOVLB  7
01898:  CLRF   x35
0189A:  MOVLW  A1
0189C:  MOVWF  x34
0189E:  MOVFF  A0,736
018A2:  MOVLW  08
018A4:  MOVWF  x37
018A6:  MOVLB  0
018A8:  RCALL  14AC
.................... 	PAGE_BUFFER_A[57] = 0; 
018AA:  MOVLB  1
018AC:  CLRF   x88
018AE:  CLRF   x87
018B0:  CLRF   x86
018B2:  CLRF   x85
.................... 	write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
018B4:  MOVLB  7
018B6:  CLRF   x37
018B8:  MOVLW  A1
018BA:  MOVWF  x36
018BC:  MOVFF  A0,738
018C0:  MOVLW  08
018C2:  MOVWF  x39
018C4:  MOVLB  0
018C6:  RCALL  1734
....................  
.................... } 
018C8:  GOTO   1A14 (RETURN)
....................  
.................... void print_device_config() 
.................... { 
.................... 	char name_buffer[20]; 
....................  
.................... 	memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
....................  
.................... 	fprintf(RS232,"[CONFIG] SERIAL = "); 
....................  
.................... 	for(int y = 0; y < 20; y++) { 
.................... 		if(name_buffer[y] == 0xFF) { 
.................... 			break; 
.................... 		} 
....................  
.................... 		fputc(name_buffer[y],RS232); 
....................  
.................... 	}  
....................  
.................... 	fprintf(RS232,"\r\n"); 
.................... 	fprintf(RS232,"[CONFIG] DSP_VALUESEND_ENABLE = %u\r\n",DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
.................... } 
....................  
.................... void device_boot() 
.................... { 
.................... 	/* POWER STARTUP SEQUENCE */ 
.................... 	delay_ms(POWERUP_DELAY); 
018CC:  MOVLW  C8
018CE:  MOVLB  7
018D0:  MOVWF  x37
018D2:  MOVLB  0
018D4:  CALL   0F2E
.................... 	 
.................... 	fprintf(RS232,"Booting into main application built on "); 
018D8:  MOVLW  22
018DA:  MOVWF  FF6
018DC:  MOVLW  0A
018DE:  MOVWF  FF7
018E0:  CALL   0FAE
.................... 	fprintf(RS232,__DATE__); 
018E4:  MOVLW  4A
018E6:  MOVWF  FF6
018E8:  MOVLW  0A
018EA:  MOVWF  FF7
018EC:  CALL   0FAE
.................... 	fprintf(RS232," "); 
018F0:  MOVLW  20
018F2:  BTFSS  FA4.4
018F4:  BRA    18F2
018F6:  MOVWF  F73
.................... 	fprintf(RS232,__TIME__); 
018F8:  MOVLW  54
018FA:  MOVWF  FF6
018FC:  MOVLW  0A
018FE:  MOVWF  FF7
01900:  CALL   0FAE
.................... 	fprintf(RS232,"\r"); 
01904:  MOVLW  0D
01906:  BTFSS  FA4.4
01908:  BRA    1906
0190A:  MOVWF  F73
....................  
.................... 	fprintf(RS232,"Device firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
0190C:  MOVLW  5E
0190E:  MOVWF  FF6
01910:  MOVLW  0A
01912:  MOVWF  FF7
01914:  MOVLW  14
01916:  MOVLB  7
01918:  MOVWF  x3C
0191A:  MOVLB  0
0191C:  CALL   0FD0
01920:  MOVFF  39,73C
01924:  MOVLW  1B
01926:  MOVLB  7
01928:  MOVWF  x3D
0192A:  MOVLB  0
0192C:  CALL   1026
01930:  MOVLW  2E
01932:  BTFSS  FA4.4
01934:  BRA    1932
01936:  MOVWF  F73
01938:  MOVFF  3A,73C
0193C:  MOVLW  1B
0193E:  MOVLB  7
01940:  MOVWF  x3D
01942:  MOVLB  0
01944:  CALL   1026
01948:  CLRF   FEA
0194A:  MOVLW  3B
0194C:  MOVWF  FE9
0194E:  CALL   10A4
01952:  MOVLW  0D
01954:  BTFSS  FA4.4
01956:  BRA    1954
01958:  MOVWF  F73
.................... 	delay_ms(10); 
0195A:  MOVLW  0A
0195C:  MOVLB  7
0195E:  MOVWF  x37
01960:  MOVLB  0
01962:  CALL   0F2E
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Reading DSP addresses from flash into memory... "); 
.................... 	} 
....................  
.................... 	FLASH_ADDR_READ(); 
01966:  BRA    11DE
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Checking if EEPROM is configured... "); 
.................... 	} 
....................  
.................... 	int eeprom_preset_number = read_eeprom(IEEPROM_PRESET_LOC); 
01968:  MOVFF  FF2,6F7
0196C:  BCF    FF2.7
0196E:  CLRF   FAA
01970:  MOVLW  10
01972:  MOVWF  FA9
01974:  BCF    FA6.6
01976:  BCF    FA6.7
01978:  BSF    FA6.0
0197A:  MOVF   FA8,W
0197C:  MOVLB  6
0197E:  BTFSC  xF7.7
01980:  BSF    FF2.7
01982:  MOVWF  xF5
....................  
.................... 	//TODO - Re-implement 
.................... 	if(eeprom_preset_number == 0xFF) { 
01984:  INCFSZ xF5,W
01986:  BRA    19BC
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"NO PRESET IN EEPROM, GOING TO DEFAULT\r\n"); 
.................... 		} 
.................... 		//switch_flash_program(DEFAULT_PRESET); 
.................... 		CURRENT_FLASH_PROGRAM = DEFAULT_PRESET; 
01988:  MOVLB  0
0198A:  CLRF   xA0
.................... 		write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
0198C:  CLRF   FAA
0198E:  MOVLW  10
01990:  MOVWF  FA9
01992:  MOVFF  A0,FA8
01996:  BCF    FA6.6
01998:  BCF    FA6.7
0199A:  BSF    FA6.2
0199C:  MOVF   FF2,W
0199E:  MOVWF  00
019A0:  BCF    FF2.7
019A2:  MOVLB  F
019A4:  MOVLW  55
019A6:  MOVWF  FA7
019A8:  MOVLW  AA
019AA:  MOVWF  FA7
019AC:  BSF    FA6.1
019AE:  BTFSC  FA6.1
019B0:  BRA    19AE
019B2:  BCF    FA6.2
019B4:  MOVF   00,W
019B6:  IORWF  FF2,F
.................... 	} else { 
019B8:  BRA    19C0
019BA:  MOVLB  6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"BOOTING FROM STORED PRESET - %U\r\n",eeprom_preset_number); 
.................... 		} 
.................... 		//switch_flash_program(eeprom_preset_number); 
.................... 		CURRENT_FLASH_PROGRAM = eeprom_preset_number; 
019BC:  MOVFF  6F5,A0
.................... 	} 
....................  
.................... 	delay_ms(10); 
019C0:  MOVLW  0A
019C2:  MOVLB  7
019C4:  MOVWF  x37
019C6:  MOVLB  0
019C8:  CALL   0F2E
....................  
.................... 	int programmed_flag = read_eeprom(IEEPROM_FLAG_LOC); 
019CC:  MOVFF  FF2,6F7
019D0:  BCF    FF2.7
019D2:  CLRF   FAA
019D4:  MOVLW  20
019D6:  MOVWF  FA9
019D8:  BCF    FA6.6
019DA:  BCF    FA6.7
019DC:  BSF    FA6.0
019DE:  MOVF   FA8,W
019E0:  MOVLB  6
019E2:  BTFSC  xF7.7
019E4:  BSF    FF2.7
019E6:  MOVWF  xF6
....................  
.................... 	INTEEPROM_GET(&DEVICE_CONFIG,sizeof(device_configuration),IEEPROM_DEVICE_CONFIG_LOC); 
019E8:  CLRF   xF8
019EA:  MOVLW  1D
019EC:  MOVWF  xF7
019EE:  CLRF   xFA
019F0:  MOVLW  16
019F2:  MOVWF  xF9
019F4:  CLRF   xFC
019F6:  MOVLW  64
019F8:  MOVWF  xFB
019FA:  MOVLB  0
019FC:  BRA    1354
.................... 	delay_ms(10); 
019FE:  MOVLW  0A
01A00:  MOVLB  7
01A02:  MOVWF  x37
01A04:  MOVLB  0
01A06:  CALL   0F2E
....................  
.................... 	if(DEBUG) { 
.................... 		print_device_config(); 
.................... 	} 
.................... 	if(programmed_flag == 0xFF) { 
01A0A:  MOVLB  6
01A0C:  INCFSZ xF6,W
01A0E:  BRA    1A4C
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting first boot routine\r\n"); 
.................... 		} 
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Saving default device properties..."); 
.................... 		} 
.................... 		default_device_config(); 
01A10:  MOVLB  0
01A12:  BRA    183C
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
....................  
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] New device config below...\r\n"); 
.................... 			print_device_config(); 
.................... 		} 
.................... 		write_eeprom(IEEPROM_FLAG_LOC,0x01); 
01A14:  CLRF   FAA
01A16:  MOVLW  20
01A18:  MOVWF  FA9
01A1A:  MOVLW  01
01A1C:  MOVWF  FA8
01A1E:  BCF    FA6.6
01A20:  BCF    FA6.7
01A22:  BSF    FA6.2
01A24:  MOVF   FF2,W
01A26:  MOVWF  00
01A28:  BCF    FF2.7
01A2A:  MOVLB  F
01A2C:  MOVLW  55
01A2E:  MOVWF  FA7
01A30:  MOVLW  AA
01A32:  MOVWF  FA7
01A34:  BSF    FA6.1
01A36:  BTFSC  FA6.1
01A38:  BRA    1A36
01A3A:  BCF    FA6.2
01A3C:  MOVF   00,W
01A3E:  IORWF  FF2,F
.................... 		delay_ms(10); 
01A40:  MOVLW  0A
01A42:  MOVLB  7
01A44:  MOVWF  x37
01A46:  MOVLB  0
01A48:  CALL   0F2E
.................... 	} 
....................  
.................... 	 
.................... 	 
.................... 	 
.................... 	/* INIT RS232 volumes and mutes */ 
....................  
.................... 	rs232_premix_vol[0] = 1; 
01A4C:  MOVLB  0
01A4E:  CLRF   x7B
01A50:  CLRF   x7A
01A52:  CLRF   x79
01A54:  MOVLW  7F
01A56:  MOVWF  x78
.................... 	rs232_premix_vol[1] = 1; 
01A58:  CLRF   x7F
01A5A:  CLRF   x7E
01A5C:  CLRF   x7D
01A5E:  MOVWF  x7C
.................... 	rs232_premix_vol[2] = 1; 
01A60:  CLRF   x83
01A62:  CLRF   x82
01A64:  CLRF   x81
01A66:  MOVWF  x80
.................... 	rs232_premix_vol[3] = 1; 
01A68:  CLRF   x87
01A6A:  CLRF   x86
01A6C:  CLRF   x85
01A6E:  MOVWF  x84
....................  
.................... 	rs232_premix_mute[0] = 0; 
01A70:  CLRF   x88
.................... 	rs232_premix_mute[1] = 0; 
01A72:  CLRF   x89
.................... 	rs232_premix_mute[2] = 0; 
01A74:  CLRF   x8A
.................... 	rs232_premix_mute[3] = 0; 
01A76:  CLRF   x8B
....................  
.................... 	rs232_output_vol[0] = 1; 
01A78:  CLRF   x8F
01A7A:  CLRF   x8E
01A7C:  CLRF   x8D
01A7E:  MOVWF  x8C
.................... 	rs232_output_vol[1] = 1; 
01A80:  CLRF   x93
01A82:  CLRF   x92
01A84:  CLRF   x91
01A86:  MOVWF  x90
.................... 	rs232_output_vol[2] = 1; 
01A88:  CLRF   x97
01A8A:  CLRF   x96
01A8C:  CLRF   x95
01A8E:  MOVWF  x94
.................... 	rs232_output_vol[3] = 1; 
01A90:  CLRF   x9B
01A92:  CLRF   x9A
01A94:  CLRF   x99
01A96:  MOVWF  x98
....................  
.................... 	rs232_output_mute[0] = 0; 
01A98:  CLRF   x9C
.................... 	rs232_output_mute[1] = 0; 
01A9A:  CLRF   x9D
.................... 	rs232_output_mute[2] = 0; 
01A9C:  CLRF   x9E
.................... 	rs232_output_mute[3] = 0; 
01A9E:  CLRF   x9F
....................  
....................  
.................... } 
01AA0:  GOTO   8D0C (RETURN)
....................  
.................... void softboot() 
.................... { 
.................... 	delay_ms(50); 
*
01FBA:  MOVLW  32
01FBC:  MOVLB  7
01FBE:  MOVWF  x37
01FC0:  MOVLB  0
01FC2:  CALL   0F2E
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP reset LOW\r\n"); 
.................... 	} 
....................  
.................... 	output_low(PIN_DSP_nRESET); 
01FC6:  BCF    F92.4
01FC8:  BCF    F89.4
....................  
.................... 	delay_ms(50); 
01FCA:  MOVLW  32
01FCC:  MOVLB  7
01FCE:  MOVWF  x37
01FD0:  MOVLB  0
01FD2:  CALL   0F2E
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_DSP_nRESET);// DSP Reset 
01FD6:  BCF    F92.4
01FD8:  BSF    F89.4
.................... 	 
.................... 	delay_ms(50); 
01FDA:  MOVLW  32
01FDC:  MOVLB  7
01FDE:  MOVWF  x37
01FE0:  MOVLB  0
01FE2:  CALL   0F2E
.................... 	 
.................... 	if(DEVICE_CONFIG.DSP_VALUESEND_ENABLE) 
01FE6:  MOVF   1E,F
01FE8:  BZ    2002
.................... 	{ 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Sending DSP values from program %u\r\n",CURRENT_FLASH_PROGRAM); 
.................... 		} 
.................... 		 
.................... 		dsp_mute_outputs(); 
01FEA:  BRA    1BD8
....................  
.................... 		send_flash_program_to_dsp_buffered(CURRENT_FLASH_PROGRAM); 
01FEC:  MOVFF  A0,72F
01FF0:  BRA    1E70
....................  
.................... 		dsp_unmute_outputs(); 
01FF2:  BRA    1F40
.................... 		 
....................  
.................... 		delay_ms(100); 
01FF4:  MOVLW  64
01FF6:  MOVLB  7
01FF8:  MOVWF  x37
01FFA:  MOVLB  0
01FFC:  CALL   0F2E
....................  
.................... 	} else { 
02000:  BRA    2002
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NOT sending DSP values\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	update_phantom_power(); 
02002:  RCALL  1F5E
....................  
.................... 	 
....................  
....................  
.................... } 
02004:  RETURN 0
....................  
.................... void setup_interrupts() 
.................... { 
.................... 	enable_interrupts(GLOBAL); 
02006:  MOVLW  C0
02008:  IORWF  FF2,F
.................... 	enable_interrupts(INT_RDA2); 
0200A:  BSF    FA3.5
....................  
.................... 	if(DEVICE_CONFIG.USBDETECT_ENABLE == 0) { 
0200C:  MOVF   1D,F
0200E:  BNZ   2018
.................... 		IS_USB_CONNECTED = true; 
02010:  MOVLW  01
02012:  MOVWF  50
.................... 		disable_interrupts(INT_EXT1);  
02014:  BCF    FF0.3
.................... 	} else { 
02016:  BRA    202C
.................... 		// Check initial plug state 
.................... 		if(input(PIN_B1)) { 
02018:  BSF    F93.1
0201A:  BTFSS  F81.1
0201C:  BRA    2026
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is high. Setting IS_USB_CONNECTED to true\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = true; 
0201E:  MOVLW  01
02020:  MOVWF  50
.................... 			ext_int_edge(1,H_TO_L);  
02022:  BCF    FF1.5
.................... 		} else { 
02024:  BRA    2028
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is low. Setting IS_USB_CONNECTED to false\r\n"); 
.................... 			} 
.................... 			ext_int_edge(1,L_TO_H);  
02026:  BSF    FF1.5
.................... 		} 
....................  
.................... 		clear_interrupt(INT_EXT1);  
02028:  BCF    FF0.0
....................    		enable_interrupts(INT_EXT1); 
0202A:  BSF    FF0.3
....................  
.................... 	 
.................... 	} 
.................... } 
0202C:  GOTO   8D14 (RETURN)
....................  
....................  
.................... void setup_peripherals() 
.................... { 
....................  
.................... 	setup_adc( ADC_CLOCK_INTERNAL ); 
*
00F56:  MOVF   FC0,W
00F58:  ANDLW  C0
00F5A:  IORLW  07
00F5C:  MOVWF  FC0
00F5E:  BCF    FC0.7
00F60:  BSF    FC2.0
....................  
.................... 	setup_adc_ports( sAN0 | sAN9 ); 
00F62:  MOVF   FC1,W
00F64:  ANDLW  F0
00F66:  MOVWF  FC1
00F68:  MOVLW  01
00F6A:  MOVLB  F
00F6C:  MOVWF  x38
00F6E:  MOVLW  00
00F70:  MOVWF  x3C
00F72:  MOVLW  08
00F74:  MOVWF  x39
00F76:  MOVLW  00
00F78:  MOVWF  x3A
00F7A:  MOVWF  x3B
....................  
.................... 	set_adc_channel(0); 
00F7C:  MOVWF  01
00F7E:  MOVF   FC2,W
00F80:  ANDLW  83
00F82:  IORWF  01,W
00F84:  MOVWF  FC2
....................  
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
00F86:  MOVLW  85
00F88:  MOVWF  FD5
....................  
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
00F8A:  MOVLW  37
00F8C:  MOVWF  FCD
00F8E:  CLRF   FCC
....................  
.................... 	setup_timer_3(T3_DISABLED | T3_DIV_BY_1); 
00F90:  CLRF   FB4
00F92:  CLRF   FB1
....................    	setup_timer_4(T4_DISABLED,0,1); 
00F94:  MOVLW  00
00F96:  MOVWF  x51
00F98:  MOVLW  00
00F9A:  MOVWF  x52
....................    	setup_timer_5(T5_DISABLED | T5_DIV_BY_1); 
00F9C:  CLRF   x4D
00F9E:  CLRF   x4E
....................    	setup_timer_6(T6_DISABLED,0,1); 
00FA0:  MOVWF  x4A
00FA2:  MOVLW  00
00FA4:  MOVWF  x4B
....................  
.................... 	setup_wdt(WDT_OFF);  
00FA6:  BCF    FD1.0
....................  
.................... } 
00FA8:  MOVLB  0
00FAA:  GOTO   8D08 (RETURN)
....................  
....................  
....................  
.................... #include <remote_volume.c> 
.................... int32 get_AM_trim_channel(int ch) 
.................... { 
.................... 	switch(ch) { 
*
0576A:  MOVLB  7
0576C:  MOVF   x32,W
0576E:  XORLW  00
05770:  MOVLB  0
05772:  BZ    5782
05774:  XORLW  01
05776:  BZ    5792
05778:  XORLW  03
0577A:  BZ    57A2
0577C:  XORLW  01
0577E:  BZ    57B2
05780:  BRA    57C2
.................... 		case 0 : 
.................... 			return AM_ANALOG1_TRIM; 
05782:  MOVLW  0A
05784:  MOVWF  00
05786:  CLRF   01
05788:  CLRF   02
0578A:  MOVLW  83
0578C:  MOVWF  03
0578E:  BRA    57CE
.................... 		break; 
05790:  BRA    57CE
....................  
.................... 		case 1 : 
.................... 			return AM_ANALOG2_TRIM; 
05792:  MOVLW  0B
05794:  MOVWF  00
05796:  CLRF   01
05798:  CLRF   02
0579A:  MOVLW  83
0579C:  MOVWF  03
0579E:  BRA    57CE
.................... 		break; 
057A0:  BRA    57CE
....................  
.................... 		case 2 :  
.................... 			return AM_ANALOG3_TRIM; 
057A2:  MOVLW  0C
057A4:  MOVWF  00
057A6:  CLRF   01
057A8:  CLRF   02
057AA:  MOVLW  83
057AC:  MOVWF  03
057AE:  BRA    57CE
.................... 		break; 
057B0:  BRA    57CE
.................... 		 
.................... 		case 3 : 
.................... 			return AM_ANALOG4_TRIM; 
057B2:  MOVLW  0D
057B4:  MOVWF  00
057B6:  CLRF   01
057B8:  CLRF   02
057BA:  MOVLW  83
057BC:  MOVWF  03
057BE:  BRA    57CE
.................... 		break; 
057C0:  BRA    57CE
....................  
.................... 		default : 
.................... 			return 0; 
057C2:  CLRF   00
057C4:  CLRF   01
057C6:  CLRF   02
057C8:  CLRF   03
057CA:  BRA    57CE
.................... 		break; 
057CC:  BRA    57CE
.................... 	} 
.................... } 
057CE:  RETURN 0
....................  
.................... double discrete_vol_output(int ch,int new_vol) 
.................... { 
.................... 	 
....................  
.................... 	if(ch == 0) { 
*
05C3E:  MOVLB  7
05C40:  MOVF   x2E,F
05C42:  BTFSS  FD8.2
05C44:  BRA    5D76
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
05C46:  CLRF   x30
05C48:  MOVF   x30,W
05C4A:  SUBLW  03
05C4C:  BTFSS  FD8.0
05C4E:  BRA    5D62
.................... 			rs232_output_mute[i] = 0; 
05C50:  CLRF   03
05C52:  MOVF   x30,W
05C54:  ADDLW  9C
05C56:  MOVWF  FE9
05C58:  MOVLW  00
05C5A:  ADDWFC 03,W
05C5C:  MOVWF  FEA
05C5E:  CLRF   FEF
.................... 			rs232_output_vol[i] = ((double)new_vol/100.0); 
05C60:  MOVF   x30,W
05C62:  MULLW  04
05C64:  MOVF   FF3,W
05C66:  CLRF   03
05C68:  ADDLW  8C
05C6A:  MOVWF  FE9
05C6C:  MOVLW  00
05C6E:  ADDWFC 03,W
05C70:  MOVWF  FEA
05C72:  CLRF   x34
05C74:  MOVFF  72F,733
05C78:  MOVLB  0
05C7A:  RCALL  5AAA
05C7C:  MOVFF  00,733
05C80:  MOVFF  01,734
05C84:  MOVFF  02,735
05C88:  MOVFF  03,736
05C8C:  MOVFF  03,73A
05C90:  MOVFF  02,739
05C94:  MOVFF  01,738
05C98:  MOVFF  00,737
05C9C:  MOVLB  7
05C9E:  CLRF   x3E
05CA0:  CLRF   x3D
05CA2:  MOVLW  48
05CA4:  MOVWF  x3C
05CA6:  MOVLW  85
05CA8:  MOVWF  x3B
05CAA:  MOVLB  0
05CAC:  RCALL  5AE0
05CAE:  MOVFF  00,FEF
05CB2:  MOVFF  01,FEC
05CB6:  MOVFF  02,FEC
05CBA:  MOVFF  03,FEC
.................... 		 
.................... 			 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
05CBE:  MOVFF  730,732
05CC2:  RCALL  576A
05CC4:  MOVFF  03,734
05CC8:  MOVFF  02,733
05CCC:  MOVFF  01,732
05CD0:  MOVFF  00,731
05CD4:  MOVLB  7
05CD6:  MOVF   x30,W
05CD8:  MULLW  04
05CDA:  MOVF   FF3,W
05CDC:  CLRF   03
05CDE:  ADDLW  8C
05CE0:  MOVWF  FE9
05CE2:  MOVLW  00
05CE4:  ADDWFC 03,W
05CE6:  MOVWF  FEA
05CE8:  MOVFF  FEF,735
05CEC:  MOVFF  FEC,736
05CF0:  MOVFF  FEC,737
05CF4:  MOVFF  FEC,738
05CF8:  MOVFF  738,73C
05CFC:  MOVFF  737,73B
05D00:  MOVFF  736,73A
05D04:  MOVFF  735,739
05D08:  CLRF   x40
05D0A:  CLRF   x3F
05D0C:  CLRF   x3E
05D0E:  MOVLW  9E
05D10:  MOVWF  x3D
05D12:  MOVLB  0
05D14:  RCALL  5638
05D16:  MOVFF  03,738
05D1A:  MOVFF  02,737
05D1E:  MOVFF  01,736
05D22:  MOVFF  00,735
05D26:  RCALL  57D0
05D28:  MOVFF  03,738
05D2C:  MOVFF  02,737
05D30:  MOVFF  01,736
05D34:  MOVFF  00,735
05D38:  MOVFF  734,73C
05D3C:  MOVFF  733,73B
05D40:  MOVFF  732,73A
05D44:  MOVFF  731,739
05D48:  MOVFF  03,740
05D4C:  MOVFF  02,73F
05D50:  MOVFF  01,73E
05D54:  MOVFF  00,73D
05D58:  CALL   1B64
.................... 		} 
05D5C:  MOVLB  7
05D5E:  INCF   x30,F
05D60:  BRA    5C48
....................  
.................... 		return rs232_output_vol[0]; // They will all be the same. So just return the volume of CH1 
05D62:  MOVFF  8C,00
05D66:  MOVFF  8D,01
05D6A:  MOVFF  8E,02
05D6E:  MOVFF  8F,03
05D72:  BRA    5EBA
.................... 	} else { 
05D74:  BRA    5EBA
....................  
.................... 		rs232_output_mute[ch-1] = 0; 
05D76:  MOVLW  01
05D78:  SUBWF  x2E,W
05D7A:  CLRF   03
05D7C:  ADDLW  9C
05D7E:  MOVWF  FE9
05D80:  MOVLW  00
05D82:  ADDWFC 03,W
05D84:  MOVWF  FEA
05D86:  CLRF   FEF
.................... 		rs232_output_vol[ch-1] = ((double)new_vol/100.0); 
05D88:  MOVLW  01
05D8A:  SUBWF  x2E,W
05D8C:  MULLW  04
05D8E:  MOVF   FF3,W
05D90:  CLRF   03
05D92:  ADDLW  8C
05D94:  MOVWF  FE9
05D96:  MOVLW  00
05D98:  ADDWFC 03,W
05D9A:  MOVWF  FEA
05D9C:  CLRF   x34
05D9E:  MOVFF  72F,733
05DA2:  MOVLB  0
05DA4:  RCALL  5AAA
05DA6:  MOVFF  00,733
05DAA:  MOVFF  01,734
05DAE:  MOVFF  02,735
05DB2:  MOVFF  03,736
05DB6:  MOVFF  03,73A
05DBA:  MOVFF  02,739
05DBE:  MOVFF  01,738
05DC2:  MOVFF  00,737
05DC6:  MOVLB  7
05DC8:  CLRF   x3E
05DCA:  CLRF   x3D
05DCC:  MOVLW  48
05DCE:  MOVWF  x3C
05DD0:  MOVLW  85
05DD2:  MOVWF  x3B
05DD4:  MOVLB  0
05DD6:  RCALL  5AE0
05DD8:  MOVFF  00,FEF
05DDC:  MOVFF  01,FEC
05DE0:  MOVFF  02,FEC
05DE4:  MOVFF  03,FEC
.................... 	 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
05DE8:  MOVLW  01
05DEA:  MOVLB  7
05DEC:  SUBWF  x2E,W
05DEE:  MOVWF  x31
05DF0:  MOVWF  x32
05DF2:  MOVLB  0
05DF4:  RCALL  576A
05DF6:  MOVFF  03,734
05DFA:  MOVFF  02,733
05DFE:  MOVFF  01,732
05E02:  MOVFF  00,731
05E06:  MOVLW  01
05E08:  MOVLB  7
05E0A:  SUBWF  x2E,W
05E0C:  MULLW  04
05E0E:  MOVF   FF3,W
05E10:  CLRF   03
05E12:  ADDLW  8C
05E14:  MOVWF  FE9
05E16:  MOVLW  00
05E18:  ADDWFC 03,W
05E1A:  MOVWF  FEA
05E1C:  MOVFF  FEF,735
05E20:  MOVFF  FEC,736
05E24:  MOVFF  FEC,737
05E28:  MOVFF  FEC,738
05E2C:  MOVFF  738,73C
05E30:  MOVFF  737,73B
05E34:  MOVFF  736,73A
05E38:  MOVFF  735,739
05E3C:  CLRF   x40
05E3E:  CLRF   x3F
05E40:  CLRF   x3E
05E42:  MOVLW  9E
05E44:  MOVWF  x3D
05E46:  MOVLB  0
05E48:  CALL   5638
05E4C:  MOVFF  03,738
05E50:  MOVFF  02,737
05E54:  MOVFF  01,736
05E58:  MOVFF  00,735
05E5C:  RCALL  57D0
05E5E:  MOVFF  03,738
05E62:  MOVFF  02,737
05E66:  MOVFF  01,736
05E6A:  MOVFF  00,735
05E6E:  MOVFF  734,73C
05E72:  MOVFF  733,73B
05E76:  MOVFF  732,73A
05E7A:  MOVFF  731,739
05E7E:  MOVFF  03,740
05E82:  MOVFF  02,73F
05E86:  MOVFF  01,73E
05E8A:  MOVFF  00,73D
05E8E:  CALL   1B64
....................  
.................... 		return rs232_output_vol[ch-1]; // They will all be the same. So just return the volume of CH1 
05E92:  MOVLW  01
05E94:  MOVLB  7
05E96:  SUBWF  x2E,W
05E98:  MULLW  04
05E9A:  MOVF   FF3,W
05E9C:  CLRF   03
05E9E:  ADDLW  8C
05EA0:  MOVWF  FE9
05EA2:  MOVLW  00
05EA4:  ADDWFC 03,W
05EA6:  MOVWF  FEA
05EA8:  MOVFF  FEF,00
05EAC:  MOVFF  FEC,01
05EB0:  MOVFF  FEC,02
05EB4:  MOVFF  FEC,03
05EB8:  BRA    5EBA
.................... 	} 
.................... 	 
.................... } 
05EBA:  MOVLB  0
05EBC:  RETURN 0
....................  
.................... double vol_big_up_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
*
0757A:  MOVLB  6
0757C:  MOVF   xF7,F
0757E:  BTFSS  FD8.2
07580:  BRA    771E
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
07582:  CLRF   xF8
07584:  MOVF   xF8,W
07586:  SUBLW  03
07588:  BTFSS  FD8.0
0758A:  BRA    770A
.................... 			rs232_output_mute[i] = 0; 
0758C:  CLRF   03
0758E:  MOVF   xF8,W
07590:  ADDLW  9C
07592:  MOVWF  FE9
07594:  MOVLW  00
07596:  ADDWFC 03,W
07598:  MOVWF  FEA
0759A:  CLRF   FEF
.................... 			rs232_output_vol[i] += 0.1; 
0759C:  MOVF   xF8,W
0759E:  MULLW  04
075A0:  MOVF   FF3,W
075A2:  CLRF   03
075A4:  ADDLW  8C
075A6:  MOVWF  FE9
075A8:  MOVLW  00
075AA:  ADDWFC 03,W
075AC:  MOVWF  FEA
075AE:  MOVFF  FEA,700
075B2:  MOVFF  FE9,6FF
075B6:  BCF    FD8.1
075B8:  MOVFF  FEF,701
075BC:  MOVFF  FEC,702
075C0:  MOVFF  FEC,703
075C4:  MOVFF  FEC,704
075C8:  MOVLW  CD
075CA:  MOVLB  7
075CC:  MOVWF  x08
075CE:  MOVLW  CC
075D0:  MOVWF  x07
075D2:  MOVLW  4C
075D4:  MOVWF  x06
075D6:  MOVLW  7B
075D8:  MOVWF  x05
075DA:  MOVLB  0
075DC:  RCALL  725C
075DE:  MOVFF  700,FEA
075E2:  MOVFF  6FF,FE9
075E6:  MOVFF  00,FEF
075EA:  MOVFF  01,FEC
075EE:  MOVFF  02,FEC
075F2:  MOVFF  03,FEC
.................... 			if(rs232_output_vol[i] > 1) { 
075F6:  MOVLB  6
075F8:  MOVF   xF8,W
075FA:  MULLW  04
075FC:  MOVF   FF3,W
075FE:  CLRF   03
07600:  ADDLW  8C
07602:  MOVWF  FE9
07604:  MOVLW  00
07606:  ADDWFC 03,W
07608:  MOVWF  FEA
0760A:  MOVFF  FEF,6F9
0760E:  MOVFF  FEC,6FA
07612:  MOVFF  FEC,6FB
07616:  MOVFF  FEC,6FC
0761A:  MOVLB  7
0761C:  CLRF   x00
0761E:  MOVLB  6
07620:  CLRF   xFF
07622:  CLRF   xFE
07624:  MOVLW  7F
07626:  MOVWF  xFD
07628:  MOVFF  6FC,704
0762C:  MOVFF  6FB,703
07630:  MOVFF  6FA,702
07634:  MOVFF  6F9,701
07638:  MOVLB  0
0763A:  RCALL  74D4
0763C:  BNC   765E
.................... 				rs232_output_vol[i] = 1; 
0763E:  MOVLB  6
07640:  MOVF   xF8,W
07642:  MULLW  04
07644:  MOVF   FF3,W
07646:  CLRF   03
07648:  ADDLW  8C
0764A:  MOVWF  FE9
0764C:  MOVLW  00
0764E:  ADDWFC 03,W
07650:  MOVWF  FEA
07652:  MOVLW  7F
07654:  MOVWF  FEF
07656:  CLRF   FEC
07658:  CLRF   FEC
0765A:  CLRF   FEC
0765C:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
0765E:  MOVFF  6F8,732
07662:  CALL   576A
07666:  MOVFF  03,6FC
0766A:  MOVFF  02,6FB
0766E:  MOVFF  01,6FA
07672:  MOVFF  00,6F9
07676:  MOVLB  6
07678:  MOVF   xF8,W
0767A:  MULLW  04
0767C:  MOVF   FF3,W
0767E:  CLRF   03
07680:  ADDLW  8C
07682:  MOVWF  FE9
07684:  MOVLW  00
07686:  ADDWFC 03,W
07688:  MOVWF  FEA
0768A:  MOVFF  FEF,6FD
0768E:  MOVFF  FEC,6FE
07692:  MOVFF  FEC,6FF
07696:  MOVFF  FEC,700
0769A:  MOVFF  700,73C
0769E:  MOVFF  6FF,73B
076A2:  MOVFF  6FE,73A
076A6:  MOVFF  6FD,739
076AA:  MOVLB  7
076AC:  CLRF   x40
076AE:  CLRF   x3F
076B0:  CLRF   x3E
076B2:  MOVLW  9E
076B4:  MOVWF  x3D
076B6:  MOVLB  0
076B8:  CALL   5638
076BC:  MOVFF  03,738
076C0:  MOVFF  02,737
076C4:  MOVFF  01,736
076C8:  MOVFF  00,735
076CC:  CALL   57D0
076D0:  MOVFF  03,700
076D4:  MOVFF  02,6FF
076D8:  MOVFF  01,6FE
076DC:  MOVFF  00,6FD
076E0:  MOVFF  6FC,73C
076E4:  MOVFF  6FB,73B
076E8:  MOVFF  6FA,73A
076EC:  MOVFF  6F9,739
076F0:  MOVFF  03,740
076F4:  MOVFF  02,73F
076F8:  MOVFF  01,73E
076FC:  MOVFF  00,73D
07700:  CALL   1B64
.................... 		} 
07704:  MOVLB  6
07706:  INCF   xF8,F
07708:  BRA    7584
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
0770A:  MOVFF  8C,00
0770E:  MOVFF  8D,01
07712:  MOVFF  8E,02
07716:  MOVFF  8F,03
0771A:  BRA    78D2
....................  
.................... 	} else { 
0771C:  BRA    78D2
.................... 		rs232_output_mute[(ch-1)] = 0; 
0771E:  MOVLW  01
07720:  SUBWF  xF7,W
07722:  CLRF   03
07724:  ADDLW  9C
07726:  MOVWF  FE9
07728:  MOVLW  00
0772A:  ADDWFC 03,W
0772C:  MOVWF  FEA
0772E:  CLRF   FEF
.................... 		rs232_output_vol[(ch-1)] += 0.1; // TODO - Change this to be a variable 
07730:  MOVLW  01
07732:  SUBWF  xF7,W
07734:  MULLW  04
07736:  MOVF   FF3,W
07738:  CLRF   03
0773A:  ADDLW  8C
0773C:  MOVWF  FE9
0773E:  MOVLW  00
07740:  ADDWFC 03,W
07742:  MOVWF  FEA
07744:  MOVFF  FEA,700
07748:  MOVFF  FE9,6FF
0774C:  BCF    FD8.1
0774E:  MOVFF  FEF,701
07752:  MOVFF  FEC,702
07756:  MOVFF  FEC,703
0775A:  MOVFF  FEC,704
0775E:  MOVLW  CD
07760:  MOVLB  7
07762:  MOVWF  x08
07764:  MOVLW  CC
07766:  MOVWF  x07
07768:  MOVLW  4C
0776A:  MOVWF  x06
0776C:  MOVLW  7B
0776E:  MOVWF  x05
07770:  MOVLB  0
07772:  RCALL  725C
07774:  MOVFF  700,FEA
07778:  MOVFF  6FF,FE9
0777C:  MOVFF  00,FEF
07780:  MOVFF  01,FEC
07784:  MOVFF  02,FEC
07788:  MOVFF  03,FEC
.................... 		if(rs232_output_vol[(ch-1)] > 1) { 
0778C:  MOVLW  01
0778E:  MOVLB  6
07790:  SUBWF  xF7,W
07792:  MULLW  04
07794:  MOVF   FF3,W
07796:  CLRF   03
07798:  ADDLW  8C
0779A:  MOVWF  FE9
0779C:  MOVLW  00
0779E:  ADDWFC 03,W
077A0:  MOVWF  FEA
077A2:  MOVFF  FEF,6F9
077A6:  MOVFF  FEC,6FA
077AA:  MOVFF  FEC,6FB
077AE:  MOVFF  FEC,6FC
077B2:  MOVLB  7
077B4:  CLRF   x00
077B6:  MOVLB  6
077B8:  CLRF   xFF
077BA:  CLRF   xFE
077BC:  MOVLW  7F
077BE:  MOVWF  xFD
077C0:  MOVFF  6FC,704
077C4:  MOVFF  6FB,703
077C8:  MOVFF  6FA,702
077CC:  MOVFF  6F9,701
077D0:  MOVLB  0
077D2:  RCALL  74D4
077D4:  BNC   77F8
.................... 			rs232_output_vol[(ch-1)] = 1; 
077D6:  MOVLW  01
077D8:  MOVLB  6
077DA:  SUBWF  xF7,W
077DC:  MULLW  04
077DE:  MOVF   FF3,W
077E0:  CLRF   03
077E2:  ADDLW  8C
077E4:  MOVWF  FE9
077E6:  MOVLW  00
077E8:  ADDWFC 03,W
077EA:  MOVWF  FEA
077EC:  MOVLW  7F
077EE:  MOVWF  FEF
077F0:  CLRF   FEC
077F2:  CLRF   FEC
077F4:  CLRF   FEC
077F6:  MOVLB  0
.................... 		} 
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
077F8:  MOVLW  01
077FA:  MOVLB  6
077FC:  SUBWF  xF7,W
077FE:  MOVWF  xF9
07800:  MOVFF  FE8,732
07804:  MOVLB  0
07806:  CALL   576A
0780A:  MOVFF  03,6FC
0780E:  MOVFF  02,6FB
07812:  MOVFF  01,6FA
07816:  MOVFF  00,6F9
0781A:  MOVLW  01
0781C:  MOVLB  6
0781E:  SUBWF  xF7,W
07820:  MULLW  04
07822:  MOVF   FF3,W
07824:  CLRF   03
07826:  ADDLW  8C
07828:  MOVWF  FE9
0782A:  MOVLW  00
0782C:  ADDWFC 03,W
0782E:  MOVWF  FEA
07830:  MOVFF  FEF,6FD
07834:  MOVFF  FEC,6FE
07838:  MOVFF  FEC,6FF
0783C:  MOVFF  FEC,700
07840:  MOVFF  700,73C
07844:  MOVFF  6FF,73B
07848:  MOVFF  6FE,73A
0784C:  MOVFF  6FD,739
07850:  MOVLB  7
07852:  CLRF   x40
07854:  CLRF   x3F
07856:  CLRF   x3E
07858:  MOVLW  9E
0785A:  MOVWF  x3D
0785C:  MOVLB  0
0785E:  CALL   5638
07862:  MOVFF  03,738
07866:  MOVFF  02,737
0786A:  MOVFF  01,736
0786E:  MOVFF  00,735
07872:  CALL   57D0
07876:  MOVFF  03,700
0787A:  MOVFF  02,6FF
0787E:  MOVFF  01,6FE
07882:  MOVFF  00,6FD
07886:  MOVFF  6FC,73C
0788A:  MOVFF  6FB,73B
0788E:  MOVFF  6FA,73A
07892:  MOVFF  6F9,739
07896:  MOVFF  03,740
0789A:  MOVFF  02,73F
0789E:  MOVFF  01,73E
078A2:  MOVFF  00,73D
078A6:  CALL   1B64
....................  
.................... 		return rs232_output_vol[(ch-1)]; 
078AA:  MOVLW  01
078AC:  MOVLB  6
078AE:  SUBWF  xF7,W
078B0:  MULLW  04
078B2:  MOVF   FF3,W
078B4:  CLRF   03
078B6:  ADDLW  8C
078B8:  MOVWF  FE9
078BA:  MOVLW  00
078BC:  ADDWFC 03,W
078BE:  MOVWF  FEA
078C0:  MOVFF  FEF,00
078C4:  MOVFF  FEC,01
078C8:  MOVFF  FEC,02
078CC:  MOVFF  FEC,03
078D0:  BRA    78D2
.................... 	} 
.................... } 
078D2:  MOVLB  0
078D4:  GOTO   866C (RETURN)
....................  
.................... double vol_small_up_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
078D8:  MOVLB  6
078DA:  MOVF   xF7,F
078DC:  BTFSS  FD8.2
078DE:  BRA    7A7C
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
078E0:  CLRF   xF8
078E2:  MOVF   xF8,W
078E4:  SUBLW  03
078E6:  BTFSS  FD8.0
078E8:  BRA    7A68
.................... 			rs232_output_mute[i] = 0; 
078EA:  CLRF   03
078EC:  MOVF   xF8,W
078EE:  ADDLW  9C
078F0:  MOVWF  FE9
078F2:  MOVLW  00
078F4:  ADDWFC 03,W
078F6:  MOVWF  FEA
078F8:  CLRF   FEF
.................... 			rs232_output_vol[i] += 0.05; // TODO - Change this to be a variable 
078FA:  MOVF   xF8,W
078FC:  MULLW  04
078FE:  MOVF   FF3,W
07900:  CLRF   03
07902:  ADDLW  8C
07904:  MOVWF  FE9
07906:  MOVLW  00
07908:  ADDWFC 03,W
0790A:  MOVWF  FEA
0790C:  MOVFF  FEA,700
07910:  MOVFF  FE9,6FF
07914:  BCF    FD8.1
07916:  MOVFF  FEF,701
0791A:  MOVFF  FEC,702
0791E:  MOVFF  FEC,703
07922:  MOVFF  FEC,704
07926:  MOVLW  CD
07928:  MOVLB  7
0792A:  MOVWF  x08
0792C:  MOVLW  CC
0792E:  MOVWF  x07
07930:  MOVLW  4C
07932:  MOVWF  x06
07934:  MOVLW  7A
07936:  MOVWF  x05
07938:  MOVLB  0
0793A:  RCALL  725C
0793C:  MOVFF  700,FEA
07940:  MOVFF  6FF,FE9
07944:  MOVFF  00,FEF
07948:  MOVFF  01,FEC
0794C:  MOVFF  02,FEC
07950:  MOVFF  03,FEC
.................... 			if(rs232_output_vol[i] > 1) { 
07954:  MOVLB  6
07956:  MOVF   xF8,W
07958:  MULLW  04
0795A:  MOVF   FF3,W
0795C:  CLRF   03
0795E:  ADDLW  8C
07960:  MOVWF  FE9
07962:  MOVLW  00
07964:  ADDWFC 03,W
07966:  MOVWF  FEA
07968:  MOVFF  FEF,6F9
0796C:  MOVFF  FEC,6FA
07970:  MOVFF  FEC,6FB
07974:  MOVFF  FEC,6FC
07978:  MOVLB  7
0797A:  CLRF   x00
0797C:  MOVLB  6
0797E:  CLRF   xFF
07980:  CLRF   xFE
07982:  MOVLW  7F
07984:  MOVWF  xFD
07986:  MOVFF  6FC,704
0798A:  MOVFF  6FB,703
0798E:  MOVFF  6FA,702
07992:  MOVFF  6F9,701
07996:  MOVLB  0
07998:  RCALL  74D4
0799A:  BNC   79BC
.................... 				rs232_output_vol[i] = 1; 
0799C:  MOVLB  6
0799E:  MOVF   xF8,W
079A0:  MULLW  04
079A2:  MOVF   FF3,W
079A4:  CLRF   03
079A6:  ADDLW  8C
079A8:  MOVWF  FE9
079AA:  MOVLW  00
079AC:  ADDWFC 03,W
079AE:  MOVWF  FEA
079B0:  MOVLW  7F
079B2:  MOVWF  FEF
079B4:  CLRF   FEC
079B6:  CLRF   FEC
079B8:  CLRF   FEC
079BA:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
079BC:  MOVFF  6F8,732
079C0:  CALL   576A
079C4:  MOVFF  03,6FC
079C8:  MOVFF  02,6FB
079CC:  MOVFF  01,6FA
079D0:  MOVFF  00,6F9
079D4:  MOVLB  6
079D6:  MOVF   xF8,W
079D8:  MULLW  04
079DA:  MOVF   FF3,W
079DC:  CLRF   03
079DE:  ADDLW  8C
079E0:  MOVWF  FE9
079E2:  MOVLW  00
079E4:  ADDWFC 03,W
079E6:  MOVWF  FEA
079E8:  MOVFF  FEF,6FD
079EC:  MOVFF  FEC,6FE
079F0:  MOVFF  FEC,6FF
079F4:  MOVFF  FEC,700
079F8:  MOVFF  700,73C
079FC:  MOVFF  6FF,73B
07A00:  MOVFF  6FE,73A
07A04:  MOVFF  6FD,739
07A08:  MOVLB  7
07A0A:  CLRF   x40
07A0C:  CLRF   x3F
07A0E:  CLRF   x3E
07A10:  MOVLW  9E
07A12:  MOVWF  x3D
07A14:  MOVLB  0
07A16:  CALL   5638
07A1A:  MOVFF  03,738
07A1E:  MOVFF  02,737
07A22:  MOVFF  01,736
07A26:  MOVFF  00,735
07A2A:  CALL   57D0
07A2E:  MOVFF  03,700
07A32:  MOVFF  02,6FF
07A36:  MOVFF  01,6FE
07A3A:  MOVFF  00,6FD
07A3E:  MOVFF  6FC,73C
07A42:  MOVFF  6FB,73B
07A46:  MOVFF  6FA,73A
07A4A:  MOVFF  6F9,739
07A4E:  MOVFF  03,740
07A52:  MOVFF  02,73F
07A56:  MOVFF  01,73E
07A5A:  MOVFF  00,73D
07A5E:  CALL   1B64
.................... 		} 
07A62:  MOVLB  6
07A64:  INCF   xF8,F
07A66:  BRA    78E2
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
07A68:  MOVFF  8C,00
07A6C:  MOVFF  8D,01
07A70:  MOVFF  8E,02
07A74:  MOVFF  8F,03
07A78:  BRA    7C30
....................  
.................... 	} else { 
07A7A:  BRA    7C30
.................... 		 
.................... 		rs232_output_mute[(ch-1)] = 0; 
07A7C:  MOVLW  01
07A7E:  SUBWF  xF7,W
07A80:  CLRF   03
07A82:  ADDLW  9C
07A84:  MOVWF  FE9
07A86:  MOVLW  00
07A88:  ADDWFC 03,W
07A8A:  MOVWF  FEA
07A8C:  CLRF   FEF
.................... 		rs232_output_vol[(ch-1)] += 0.05; 
07A8E:  MOVLW  01
07A90:  SUBWF  xF7,W
07A92:  MULLW  04
07A94:  MOVF   FF3,W
07A96:  CLRF   03
07A98:  ADDLW  8C
07A9A:  MOVWF  FE9
07A9C:  MOVLW  00
07A9E:  ADDWFC 03,W
07AA0:  MOVWF  FEA
07AA2:  MOVFF  FEA,700
07AA6:  MOVFF  FE9,6FF
07AAA:  BCF    FD8.1
07AAC:  MOVFF  FEF,701
07AB0:  MOVFF  FEC,702
07AB4:  MOVFF  FEC,703
07AB8:  MOVFF  FEC,704
07ABC:  MOVLW  CD
07ABE:  MOVLB  7
07AC0:  MOVWF  x08
07AC2:  MOVLW  CC
07AC4:  MOVWF  x07
07AC6:  MOVLW  4C
07AC8:  MOVWF  x06
07ACA:  MOVLW  7A
07ACC:  MOVWF  x05
07ACE:  MOVLB  0
07AD0:  CALL   725C
07AD4:  MOVFF  700,FEA
07AD8:  MOVFF  6FF,FE9
07ADC:  MOVFF  00,FEF
07AE0:  MOVFF  01,FEC
07AE4:  MOVFF  02,FEC
07AE8:  MOVFF  03,FEC
.................... 		if(rs232_output_vol[(ch-1)] > 1) { 
07AEC:  MOVLW  01
07AEE:  MOVLB  6
07AF0:  SUBWF  xF7,W
07AF2:  MULLW  04
07AF4:  MOVF   FF3,W
07AF6:  CLRF   03
07AF8:  ADDLW  8C
07AFA:  MOVWF  FE9
07AFC:  MOVLW  00
07AFE:  ADDWFC 03,W
07B00:  MOVWF  FEA
07B02:  MOVFF  FEF,6F9
07B06:  MOVFF  FEC,6FA
07B0A:  MOVFF  FEC,6FB
07B0E:  MOVFF  FEC,6FC
07B12:  MOVLB  7
07B14:  CLRF   x00
07B16:  MOVLB  6
07B18:  CLRF   xFF
07B1A:  CLRF   xFE
07B1C:  MOVLW  7F
07B1E:  MOVWF  xFD
07B20:  MOVFF  6FC,704
07B24:  MOVFF  6FB,703
07B28:  MOVFF  6FA,702
07B2C:  MOVFF  6F9,701
07B30:  MOVLB  0
07B32:  RCALL  74D4
07B34:  BNC   7B56
.................... 			rs232_output_vol[(ch-1)] = 1; 
07B36:  MOVLW  01
07B38:  MOVLB  6
07B3A:  SUBWF  xF7,W
07B3C:  MULLW  04
07B3E:  MOVF   FF3,W
07B40:  CLRF   03
07B42:  ADDLW  8C
07B44:  MOVWF  FE9
07B46:  MOVLW  00
07B48:  ADDWFC 03,W
07B4A:  MOVWF  FEA
07B4C:  MOVLW  7F
07B4E:  MOVWF  FEF
07B50:  CLRF   FEC
07B52:  CLRF   FEC
07B54:  CLRF   FEC
.................... 		} 
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
07B56:  MOVLW  01
07B58:  MOVLB  6
07B5A:  SUBWF  xF7,W
07B5C:  MOVWF  xF9
07B5E:  MOVFF  FE8,732
07B62:  MOVLB  0
07B64:  CALL   576A
07B68:  MOVFF  03,6FC
07B6C:  MOVFF  02,6FB
07B70:  MOVFF  01,6FA
07B74:  MOVFF  00,6F9
07B78:  MOVLW  01
07B7A:  MOVLB  6
07B7C:  SUBWF  xF7,W
07B7E:  MULLW  04
07B80:  MOVF   FF3,W
07B82:  CLRF   03
07B84:  ADDLW  8C
07B86:  MOVWF  FE9
07B88:  MOVLW  00
07B8A:  ADDWFC 03,W
07B8C:  MOVWF  FEA
07B8E:  MOVFF  FEF,6FD
07B92:  MOVFF  FEC,6FE
07B96:  MOVFF  FEC,6FF
07B9A:  MOVFF  FEC,700
07B9E:  MOVFF  700,73C
07BA2:  MOVFF  6FF,73B
07BA6:  MOVFF  6FE,73A
07BAA:  MOVFF  6FD,739
07BAE:  MOVLB  7
07BB0:  CLRF   x40
07BB2:  CLRF   x3F
07BB4:  CLRF   x3E
07BB6:  MOVLW  9E
07BB8:  MOVWF  x3D
07BBA:  MOVLB  0
07BBC:  CALL   5638
07BC0:  MOVFF  03,738
07BC4:  MOVFF  02,737
07BC8:  MOVFF  01,736
07BCC:  MOVFF  00,735
07BD0:  CALL   57D0
07BD4:  MOVFF  03,700
07BD8:  MOVFF  02,6FF
07BDC:  MOVFF  01,6FE
07BE0:  MOVFF  00,6FD
07BE4:  MOVFF  6FC,73C
07BE8:  MOVFF  6FB,73B
07BEC:  MOVFF  6FA,73A
07BF0:  MOVFF  6F9,739
07BF4:  MOVFF  03,740
07BF8:  MOVFF  02,73F
07BFC:  MOVFF  01,73E
07C00:  MOVFF  00,73D
07C04:  CALL   1B64
.................... 		return rs232_output_vol[(ch-1)]; 
07C08:  MOVLW  01
07C0A:  MOVLB  6
07C0C:  SUBWF  xF7,W
07C0E:  MULLW  04
07C10:  MOVF   FF3,W
07C12:  CLRF   03
07C14:  ADDLW  8C
07C16:  MOVWF  FE9
07C18:  MOVLW  00
07C1A:  ADDWFC 03,W
07C1C:  MOVWF  FEA
07C1E:  MOVFF  FEF,00
07C22:  MOVFF  FEC,01
07C26:  MOVFF  FEC,02
07C2A:  MOVFF  FEC,03
07C2E:  BRA    7C30
.................... 	} 
.................... } 
07C30:  MOVLB  0
07C32:  GOTO   8744 (RETURN)
....................  
.................... double vol_big_down_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
07C36:  MOVLB  6
07C38:  MOVF   xF7,F
07C3A:  BTFSS  FD8.2
07C3C:  BRA    7DE2
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
07C3E:  CLRF   xF8
07C40:  MOVF   xF8,W
07C42:  SUBLW  03
07C44:  BTFSS  FD8.0
07C46:  BRA    7DCE
.................... 			rs232_output_mute[i] = 0; 
07C48:  CLRF   03
07C4A:  MOVF   xF8,W
07C4C:  ADDLW  9C
07C4E:  MOVWF  FE9
07C50:  MOVLW  00
07C52:  ADDWFC 03,W
07C54:  MOVWF  FEA
07C56:  CLRF   FEF
.................... 			if(rs232_output_vol[i] > 0.1) { // TODO - Change this to be a variable 
07C58:  MOVF   xF8,W
07C5A:  MULLW  04
07C5C:  MOVF   FF3,W
07C5E:  CLRF   03
07C60:  ADDLW  8C
07C62:  MOVWF  FE9
07C64:  MOVLW  00
07C66:  ADDWFC 03,W
07C68:  MOVWF  FEA
07C6A:  MOVFF  FEF,6F9
07C6E:  MOVFF  FEC,6FA
07C72:  MOVFF  FEC,6FB
07C76:  MOVFF  FEC,6FC
07C7A:  MOVLW  CD
07C7C:  MOVLB  7
07C7E:  MOVWF  x00
07C80:  MOVLW  CC
07C82:  MOVLB  6
07C84:  MOVWF  xFF
07C86:  MOVLW  4C
07C88:  MOVWF  xFE
07C8A:  MOVLW  7B
07C8C:  MOVWF  xFD
07C8E:  MOVFF  6FC,704
07C92:  MOVFF  6FB,703
07C96:  MOVFF  6FA,702
07C9A:  MOVFF  6F9,701
07C9E:  MOVLB  0
07CA0:  RCALL  74D4
07CA2:  BNC   7D04
.................... 				rs232_output_vol[i] -= 0.1; // TODO - Change this to be a variable 
07CA4:  MOVLB  6
07CA6:  MOVF   xF8,W
07CA8:  MULLW  04
07CAA:  MOVF   FF3,W
07CAC:  CLRF   03
07CAE:  ADDLW  8C
07CB0:  MOVWF  FE9
07CB2:  MOVLW  00
07CB4:  ADDWFC 03,W
07CB6:  MOVWF  FEA
07CB8:  MOVFF  FEA,700
07CBC:  MOVFF  FE9,6FF
07CC0:  BSF    FD8.1
07CC2:  MOVFF  FEF,701
07CC6:  MOVFF  FEC,702
07CCA:  MOVFF  FEC,703
07CCE:  MOVFF  FEC,704
07CD2:  MOVLW  CD
07CD4:  MOVLB  7
07CD6:  MOVWF  x08
07CD8:  MOVLW  CC
07CDA:  MOVWF  x07
07CDC:  MOVLW  4C
07CDE:  MOVWF  x06
07CE0:  MOVLW  7B
07CE2:  MOVWF  x05
07CE4:  MOVLB  0
07CE6:  CALL   725C
07CEA:  MOVFF  700,FEA
07CEE:  MOVFF  6FF,FE9
07CF2:  MOVFF  00,FEF
07CF6:  MOVFF  01,FEC
07CFA:  MOVFF  02,FEC
07CFE:  MOVFF  03,FEC
.................... 			} else { 
07D02:  BRA    7D22
.................... 				rs232_output_vol[i] = 0; 
07D04:  MOVLB  6
07D06:  MOVF   xF8,W
07D08:  MULLW  04
07D0A:  MOVF   FF3,W
07D0C:  CLRF   03
07D0E:  ADDLW  8C
07D10:  MOVWF  FE9
07D12:  MOVLW  00
07D14:  ADDWFC 03,W
07D16:  MOVWF  FEA
07D18:  CLRF   FEF
07D1A:  CLRF   FEC
07D1C:  CLRF   FEC
07D1E:  CLRF   FEC
07D20:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
07D22:  MOVFF  6F8,732
07D26:  CALL   576A
07D2A:  MOVFF  03,6FC
07D2E:  MOVFF  02,6FB
07D32:  MOVFF  01,6FA
07D36:  MOVFF  00,6F9
07D3A:  MOVLB  6
07D3C:  MOVF   xF8,W
07D3E:  MULLW  04
07D40:  MOVF   FF3,W
07D42:  CLRF   03
07D44:  ADDLW  8C
07D46:  MOVWF  FE9
07D48:  MOVLW  00
07D4A:  ADDWFC 03,W
07D4C:  MOVWF  FEA
07D4E:  MOVFF  FEF,6FD
07D52:  MOVFF  FEC,6FE
07D56:  MOVFF  FEC,6FF
07D5A:  MOVFF  FEC,700
07D5E:  MOVFF  700,73C
07D62:  MOVFF  6FF,73B
07D66:  MOVFF  6FE,73A
07D6A:  MOVFF  6FD,739
07D6E:  MOVLB  7
07D70:  CLRF   x40
07D72:  CLRF   x3F
07D74:  CLRF   x3E
07D76:  MOVLW  9E
07D78:  MOVWF  x3D
07D7A:  MOVLB  0
07D7C:  CALL   5638
07D80:  MOVFF  03,738
07D84:  MOVFF  02,737
07D88:  MOVFF  01,736
07D8C:  MOVFF  00,735
07D90:  CALL   57D0
07D94:  MOVFF  03,700
07D98:  MOVFF  02,6FF
07D9C:  MOVFF  01,6FE
07DA0:  MOVFF  00,6FD
07DA4:  MOVFF  6FC,73C
07DA8:  MOVFF  6FB,73B
07DAC:  MOVFF  6FA,73A
07DB0:  MOVFF  6F9,739
07DB4:  MOVFF  03,740
07DB8:  MOVFF  02,73F
07DBC:  MOVFF  01,73E
07DC0:  MOVFF  00,73D
07DC4:  CALL   1B64
.................... 		} 
07DC8:  MOVLB  6
07DCA:  INCF   xF8,F
07DCC:  BRA    7C40
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
07DCE:  MOVFF  8C,00
07DD2:  MOVFF  8D,01
07DD6:  MOVFF  8E,02
07DDA:  MOVFF  8F,03
07DDE:  BRA    7FA0
....................  
.................... 	} else { 
07DE0:  BRA    7FA0
.................... 		rs232_output_mute[(ch-1)] = 0; 
07DE2:  MOVLW  01
07DE4:  SUBWF  xF7,W
07DE6:  CLRF   03
07DE8:  ADDLW  9C
07DEA:  MOVWF  FE9
07DEC:  MOVLW  00
07DEE:  ADDWFC 03,W
07DF0:  MOVWF  FEA
07DF2:  CLRF   FEF
.................... 		if(rs232_output_vol[(ch-1)] > 0.1) { 
07DF4:  MOVLW  01
07DF6:  SUBWF  xF7,W
07DF8:  MULLW  04
07DFA:  MOVF   FF3,W
07DFC:  CLRF   03
07DFE:  ADDLW  8C
07E00:  MOVWF  FE9
07E02:  MOVLW  00
07E04:  ADDWFC 03,W
07E06:  MOVWF  FEA
07E08:  MOVFF  FEF,6F9
07E0C:  MOVFF  FEC,6FA
07E10:  MOVFF  FEC,6FB
07E14:  MOVFF  FEC,6FC
07E18:  MOVLW  CD
07E1A:  MOVLB  7
07E1C:  MOVWF  x00
07E1E:  MOVLW  CC
07E20:  MOVLB  6
07E22:  MOVWF  xFF
07E24:  MOVLW  4C
07E26:  MOVWF  xFE
07E28:  MOVLW  7B
07E2A:  MOVWF  xFD
07E2C:  MOVFF  6FC,704
07E30:  MOVFF  6FB,703
07E34:  MOVFF  6FA,702
07E38:  MOVFF  6F9,701
07E3C:  MOVLB  0
07E3E:  CALL   74D4
07E42:  BNC   7EA6
.................... 			rs232_output_vol[(ch-1)] -= 0.1; 
07E44:  MOVLW  01
07E46:  MOVLB  6
07E48:  SUBWF  xF7,W
07E4A:  MULLW  04
07E4C:  MOVF   FF3,W
07E4E:  CLRF   03
07E50:  ADDLW  8C
07E52:  MOVWF  FE9
07E54:  MOVLW  00
07E56:  ADDWFC 03,W
07E58:  MOVWF  FEA
07E5A:  MOVFF  FEA,700
07E5E:  MOVFF  FE9,6FF
07E62:  BSF    FD8.1
07E64:  MOVFF  FEF,701
07E68:  MOVFF  FEC,702
07E6C:  MOVFF  FEC,703
07E70:  MOVFF  FEC,704
07E74:  MOVLW  CD
07E76:  MOVLB  7
07E78:  MOVWF  x08
07E7A:  MOVLW  CC
07E7C:  MOVWF  x07
07E7E:  MOVLW  4C
07E80:  MOVWF  x06
07E82:  MOVLW  7B
07E84:  MOVWF  x05
07E86:  MOVLB  0
07E88:  CALL   725C
07E8C:  MOVFF  700,FEA
07E90:  MOVFF  6FF,FE9
07E94:  MOVFF  00,FEF
07E98:  MOVFF  01,FEC
07E9C:  MOVFF  02,FEC
07EA0:  MOVFF  03,FEC
.................... 		} else { 
07EA4:  BRA    7EC6
.................... 			rs232_output_vol[(ch-1)] = 0; 
07EA6:  MOVLW  01
07EA8:  MOVLB  6
07EAA:  SUBWF  xF7,W
07EAC:  MULLW  04
07EAE:  MOVF   FF3,W
07EB0:  CLRF   03
07EB2:  ADDLW  8C
07EB4:  MOVWF  FE9
07EB6:  MOVLW  00
07EB8:  ADDWFC 03,W
07EBA:  MOVWF  FEA
07EBC:  CLRF   FEF
07EBE:  CLRF   FEC
07EC0:  CLRF   FEC
07EC2:  CLRF   FEC
07EC4:  MOVLB  0
.................... 		} 
.................... 	 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Discrete volume for %u to %g\r\n",ch-1,rs232_output_vol[ch-1]); 
.................... 		} 
....................  
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
07EC6:  MOVLW  01
07EC8:  MOVLB  6
07ECA:  SUBWF  xF7,W
07ECC:  MOVWF  xF9
07ECE:  MOVFF  FE8,732
07ED2:  MOVLB  0
07ED4:  CALL   576A
07ED8:  MOVFF  03,6FC
07EDC:  MOVFF  02,6FB
07EE0:  MOVFF  01,6FA
07EE4:  MOVFF  00,6F9
07EE8:  MOVLW  01
07EEA:  MOVLB  6
07EEC:  SUBWF  xF7,W
07EEE:  MULLW  04
07EF0:  MOVF   FF3,W
07EF2:  CLRF   03
07EF4:  ADDLW  8C
07EF6:  MOVWF  FE9
07EF8:  MOVLW  00
07EFA:  ADDWFC 03,W
07EFC:  MOVWF  FEA
07EFE:  MOVFF  FEF,6FD
07F02:  MOVFF  FEC,6FE
07F06:  MOVFF  FEC,6FF
07F0A:  MOVFF  FEC,700
07F0E:  MOVFF  700,73C
07F12:  MOVFF  6FF,73B
07F16:  MOVFF  6FE,73A
07F1A:  MOVFF  6FD,739
07F1E:  MOVLB  7
07F20:  CLRF   x40
07F22:  CLRF   x3F
07F24:  CLRF   x3E
07F26:  MOVLW  9E
07F28:  MOVWF  x3D
07F2A:  MOVLB  0
07F2C:  CALL   5638
07F30:  MOVFF  03,738
07F34:  MOVFF  02,737
07F38:  MOVFF  01,736
07F3C:  MOVFF  00,735
07F40:  CALL   57D0
07F44:  MOVFF  03,700
07F48:  MOVFF  02,6FF
07F4C:  MOVFF  01,6FE
07F50:  MOVFF  00,6FD
07F54:  MOVFF  6FC,73C
07F58:  MOVFF  6FB,73B
07F5C:  MOVFF  6FA,73A
07F60:  MOVFF  6F9,739
07F64:  MOVFF  03,740
07F68:  MOVFF  02,73F
07F6C:  MOVFF  01,73E
07F70:  MOVFF  00,73D
07F74:  CALL   1B64
....................  
.................... 		return rs232_output_vol[(ch-1)]; 
07F78:  MOVLW  01
07F7A:  MOVLB  6
07F7C:  SUBWF  xF7,W
07F7E:  MULLW  04
07F80:  MOVF   FF3,W
07F82:  CLRF   03
07F84:  ADDLW  8C
07F86:  MOVWF  FE9
07F88:  MOVLW  00
07F8A:  ADDWFC 03,W
07F8C:  MOVWF  FEA
07F8E:  MOVFF  FEF,00
07F92:  MOVFF  FEC,01
07F96:  MOVFF  FEC,02
07F9A:  MOVFF  FEC,03
07F9E:  BRA    7FA0
.................... 	} 
.................... } 
07FA0:  MOVLB  0
07FA2:  GOTO   881C (RETURN)
....................  
.................... double vol_small_down_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
07FA6:  MOVLB  6
07FA8:  MOVF   xF7,F
07FAA:  BTFSS  FD8.2
07FAC:  BRA    8154
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
07FAE:  CLRF   xF8
07FB0:  MOVF   xF8,W
07FB2:  SUBLW  03
07FB4:  BTFSS  FD8.0
07FB6:  BRA    8140
.................... 			rs232_output_mute[i] = 0; 
07FB8:  CLRF   03
07FBA:  MOVF   xF8,W
07FBC:  ADDLW  9C
07FBE:  MOVWF  FE9
07FC0:  MOVLW  00
07FC2:  ADDWFC 03,W
07FC4:  MOVWF  FEA
07FC6:  CLRF   FEF
.................... 			if(rs232_output_vol[i] > 0.05) { // TODO - Change this to be a variable 
07FC8:  MOVF   xF8,W
07FCA:  MULLW  04
07FCC:  MOVF   FF3,W
07FCE:  CLRF   03
07FD0:  ADDLW  8C
07FD2:  MOVWF  FE9
07FD4:  MOVLW  00
07FD6:  ADDWFC 03,W
07FD8:  MOVWF  FEA
07FDA:  MOVFF  FEF,6F9
07FDE:  MOVFF  FEC,6FA
07FE2:  MOVFF  FEC,6FB
07FE6:  MOVFF  FEC,6FC
07FEA:  MOVLW  CD
07FEC:  MOVLB  7
07FEE:  MOVWF  x00
07FF0:  MOVLW  CC
07FF2:  MOVLB  6
07FF4:  MOVWF  xFF
07FF6:  MOVLW  4C
07FF8:  MOVWF  xFE
07FFA:  MOVLW  7A
07FFC:  MOVWF  xFD
07FFE:  MOVFF  6FC,704
08002:  MOVFF  6FB,703
08006:  MOVFF  6FA,702
0800A:  MOVFF  6F9,701
0800E:  MOVLB  0
08010:  CALL   74D4
08014:  BNC   8076
.................... 				rs232_output_vol[i] -= 0.05; // TODO - Change this to be a variable 
08016:  MOVLB  6
08018:  MOVF   xF8,W
0801A:  MULLW  04
0801C:  MOVF   FF3,W
0801E:  CLRF   03
08020:  ADDLW  8C
08022:  MOVWF  FE9
08024:  MOVLW  00
08026:  ADDWFC 03,W
08028:  MOVWF  FEA
0802A:  MOVFF  FEA,700
0802E:  MOVFF  FE9,6FF
08032:  BSF    FD8.1
08034:  MOVFF  FEF,701
08038:  MOVFF  FEC,702
0803C:  MOVFF  FEC,703
08040:  MOVFF  FEC,704
08044:  MOVLW  CD
08046:  MOVLB  7
08048:  MOVWF  x08
0804A:  MOVLW  CC
0804C:  MOVWF  x07
0804E:  MOVLW  4C
08050:  MOVWF  x06
08052:  MOVLW  7A
08054:  MOVWF  x05
08056:  MOVLB  0
08058:  CALL   725C
0805C:  MOVFF  700,FEA
08060:  MOVFF  6FF,FE9
08064:  MOVFF  00,FEF
08068:  MOVFF  01,FEC
0806C:  MOVFF  02,FEC
08070:  MOVFF  03,FEC
.................... 			} else { 
08074:  BRA    8094
.................... 				rs232_output_vol[i] = 0; 
08076:  MOVLB  6
08078:  MOVF   xF8,W
0807A:  MULLW  04
0807C:  MOVF   FF3,W
0807E:  CLRF   03
08080:  ADDLW  8C
08082:  MOVWF  FE9
08084:  MOVLW  00
08086:  ADDWFC 03,W
08088:  MOVWF  FEA
0808A:  CLRF   FEF
0808C:  CLRF   FEC
0808E:  CLRF   FEC
08090:  CLRF   FEC
08092:  MOVLB  0
.................... 			} 
.................... 				 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
08094:  MOVFF  6F8,732
08098:  CALL   576A
0809C:  MOVFF  03,6FC
080A0:  MOVFF  02,6FB
080A4:  MOVFF  01,6FA
080A8:  MOVFF  00,6F9
080AC:  MOVLB  6
080AE:  MOVF   xF8,W
080B0:  MULLW  04
080B2:  MOVF   FF3,W
080B4:  CLRF   03
080B6:  ADDLW  8C
080B8:  MOVWF  FE9
080BA:  MOVLW  00
080BC:  ADDWFC 03,W
080BE:  MOVWF  FEA
080C0:  MOVFF  FEF,6FD
080C4:  MOVFF  FEC,6FE
080C8:  MOVFF  FEC,6FF
080CC:  MOVFF  FEC,700
080D0:  MOVFF  700,73C
080D4:  MOVFF  6FF,73B
080D8:  MOVFF  6FE,73A
080DC:  MOVFF  6FD,739
080E0:  MOVLB  7
080E2:  CLRF   x40
080E4:  CLRF   x3F
080E6:  CLRF   x3E
080E8:  MOVLW  9E
080EA:  MOVWF  x3D
080EC:  MOVLB  0
080EE:  CALL   5638
080F2:  MOVFF  03,738
080F6:  MOVFF  02,737
080FA:  MOVFF  01,736
080FE:  MOVFF  00,735
08102:  CALL   57D0
08106:  MOVFF  03,700
0810A:  MOVFF  02,6FF
0810E:  MOVFF  01,6FE
08112:  MOVFF  00,6FD
08116:  MOVFF  6FC,73C
0811A:  MOVFF  6FB,73B
0811E:  MOVFF  6FA,73A
08122:  MOVFF  6F9,739
08126:  MOVFF  03,740
0812A:  MOVFF  02,73F
0812E:  MOVFF  01,73E
08132:  MOVFF  00,73D
08136:  CALL   1B64
.................... 		} 
0813A:  MOVLB  6
0813C:  INCF   xF8,F
0813E:  BRA    7FB0
....................  
.................... 		return rs232_output_vol[0]; // Temporarily just return the first channel volume 
08140:  MOVFF  8C,00
08144:  MOVFF  8D,01
08148:  MOVFF  8E,02
0814C:  MOVFF  8F,03
08150:  BRA    830E
....................  
.................... 	} else { 
08152:  BRA    830E
.................... 		 
.................... 		rs232_output_mute[(ch-1)] = 0; 
08154:  MOVLW  01
08156:  SUBWF  xF7,W
08158:  CLRF   03
0815A:  ADDLW  9C
0815C:  MOVWF  FE9
0815E:  MOVLW  00
08160:  ADDWFC 03,W
08162:  MOVWF  FEA
08164:  CLRF   FEF
.................... 		if(rs232_output_vol[(ch-1)] > 0.05) { 
08166:  MOVLW  01
08168:  SUBWF  xF7,W
0816A:  MULLW  04
0816C:  MOVF   FF3,W
0816E:  CLRF   03
08170:  ADDLW  8C
08172:  MOVWF  FE9
08174:  MOVLW  00
08176:  ADDWFC 03,W
08178:  MOVWF  FEA
0817A:  MOVFF  FEF,6F9
0817E:  MOVFF  FEC,6FA
08182:  MOVFF  FEC,6FB
08186:  MOVFF  FEC,6FC
0818A:  MOVLW  CD
0818C:  MOVLB  7
0818E:  MOVWF  x00
08190:  MOVLW  CC
08192:  MOVLB  6
08194:  MOVWF  xFF
08196:  MOVLW  4C
08198:  MOVWF  xFE
0819A:  MOVLW  7A
0819C:  MOVWF  xFD
0819E:  MOVFF  6FC,704
081A2:  MOVFF  6FB,703
081A6:  MOVFF  6FA,702
081AA:  MOVFF  6F9,701
081AE:  MOVLB  0
081B0:  CALL   74D4
081B4:  BNC   8218
.................... 			rs232_output_vol[(ch-1)] -= 0.05; 
081B6:  MOVLW  01
081B8:  MOVLB  6
081BA:  SUBWF  xF7,W
081BC:  MULLW  04
081BE:  MOVF   FF3,W
081C0:  CLRF   03
081C2:  ADDLW  8C
081C4:  MOVWF  FE9
081C6:  MOVLW  00
081C8:  ADDWFC 03,W
081CA:  MOVWF  FEA
081CC:  MOVFF  FEA,700
081D0:  MOVFF  FE9,6FF
081D4:  BSF    FD8.1
081D6:  MOVFF  FEF,701
081DA:  MOVFF  FEC,702
081DE:  MOVFF  FEC,703
081E2:  MOVFF  FEC,704
081E6:  MOVLW  CD
081E8:  MOVLB  7
081EA:  MOVWF  x08
081EC:  MOVLW  CC
081EE:  MOVWF  x07
081F0:  MOVLW  4C
081F2:  MOVWF  x06
081F4:  MOVLW  7A
081F6:  MOVWF  x05
081F8:  MOVLB  0
081FA:  CALL   725C
081FE:  MOVFF  700,FEA
08202:  MOVFF  6FF,FE9
08206:  MOVFF  00,FEF
0820A:  MOVFF  01,FEC
0820E:  MOVFF  02,FEC
08212:  MOVFF  03,FEC
.................... 		} else { 
08216:  BRA    8236
.................... 			rs232_output_vol[(ch-1)] = 0; 
08218:  MOVLW  01
0821A:  MOVLB  6
0821C:  SUBWF  xF7,W
0821E:  MULLW  04
08220:  MOVF   FF3,W
08222:  CLRF   03
08224:  ADDLW  8C
08226:  MOVWF  FE9
08228:  MOVLW  00
0822A:  ADDWFC 03,W
0822C:  MOVWF  FEA
0822E:  CLRF   FEF
08230:  CLRF   FEC
08232:  CLRF   FEC
08234:  CLRF   FEC
.................... 		} 
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
08236:  MOVLW  01
08238:  MOVLB  6
0823A:  SUBWF  xF7,W
0823C:  MOVWF  xF9
0823E:  MOVFF  FE8,732
08242:  MOVLB  0
08244:  CALL   576A
08248:  MOVFF  03,6FC
0824C:  MOVFF  02,6FB
08250:  MOVFF  01,6FA
08254:  MOVFF  00,6F9
08258:  MOVLW  01
0825A:  MOVLB  6
0825C:  SUBWF  xF7,W
0825E:  MULLW  04
08260:  MOVF   FF3,W
08262:  CLRF   03
08264:  ADDLW  8C
08266:  MOVWF  FE9
08268:  MOVLW  00
0826A:  ADDWFC 03,W
0826C:  MOVWF  FEA
0826E:  MOVFF  FEF,6FD
08272:  MOVFF  FEC,6FE
08276:  MOVFF  FEC,6FF
0827A:  MOVFF  FEC,700
0827E:  MOVFF  700,73C
08282:  MOVFF  6FF,73B
08286:  MOVFF  6FE,73A
0828A:  MOVFF  6FD,739
0828E:  MOVLB  7
08290:  CLRF   x40
08292:  CLRF   x3F
08294:  CLRF   x3E
08296:  MOVLW  9E
08298:  MOVWF  x3D
0829A:  MOVLB  0
0829C:  CALL   5638
082A0:  MOVFF  03,738
082A4:  MOVFF  02,737
082A8:  MOVFF  01,736
082AC:  MOVFF  00,735
082B0:  CALL   57D0
082B4:  MOVFF  03,700
082B8:  MOVFF  02,6FF
082BC:  MOVFF  01,6FE
082C0:  MOVFF  00,6FD
082C4:  MOVFF  6FC,73C
082C8:  MOVFF  6FB,73B
082CC:  MOVFF  6FA,73A
082D0:  MOVFF  6F9,739
082D4:  MOVFF  03,740
082D8:  MOVFF  02,73F
082DC:  MOVFF  01,73E
082E0:  MOVFF  00,73D
082E4:  CALL   1B64
....................  
.................... 		return rs232_output_vol[ch]; 
082E8:  MOVLB  6
082EA:  MOVF   xF7,W
082EC:  MULLW  04
082EE:  MOVF   FF3,W
082F0:  CLRF   03
082F2:  ADDLW  8C
082F4:  MOVWF  FE9
082F6:  MOVLW  00
082F8:  ADDWFC 03,W
082FA:  MOVWF  FEA
082FC:  MOVFF  FEF,00
08300:  MOVFF  FEC,01
08304:  MOVFF  FEC,02
08308:  MOVFF  FEC,03
0830C:  BRA    830E
.................... 	} 
.................... } 
0830E:  MOVLB  0
08310:  GOTO   88F4 (RETURN)
....................  
.................... void mute_on_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
08314:  MOVLB  6
08316:  MOVF   xF7,F
08318:  BNZ   8376
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0831A:  CLRF   xF8
0831C:  MOVF   xF8,W
0831E:  SUBLW  03
08320:  BNC   8374
.................... 			rs232_output_mute[i] = 1; 
08322:  CLRF   03
08324:  MOVF   xF8,W
08326:  ADDLW  9C
08328:  MOVWF  FE9
0832A:  MOVLW  00
0832C:  ADDWFC 03,W
0832E:  MOVWF  FEA
08330:  MOVLW  01
08332:  MOVWF  FEF
....................  
.................... 			send_dsp_command(get_AM_trim_channel(i),0x00000000); 
08334:  MOVFF  6F8,732
08338:  MOVLB  0
0833A:  CALL   576A
0833E:  MOVFF  03,6FC
08342:  MOVFF  02,6FB
08346:  MOVFF  01,6FA
0834A:  MOVFF  00,6F9
0834E:  MOVFF  03,73C
08352:  MOVFF  02,73B
08356:  MOVFF  01,73A
0835A:  MOVFF  00,739
0835E:  MOVLB  7
08360:  CLRF   x40
08362:  CLRF   x3F
08364:  CLRF   x3E
08366:  CLRF   x3D
08368:  MOVLB  0
0836A:  CALL   1B64
.................... 		} 
0836E:  MOVLB  6
08370:  INCF   xF8,F
08372:  BRA    831C
.................... 	} else { 
08374:  BRA    83CA
.................... 		rs232_output_mute[(ch-1)] = 1; 
08376:  MOVLW  01
08378:  SUBWF  xF7,W
0837A:  CLRF   03
0837C:  ADDLW  9C
0837E:  MOVWF  FE9
08380:  MOVLW  00
08382:  ADDWFC 03,W
08384:  MOVWF  FEA
08386:  MOVLW  01
08388:  MOVWF  FEF
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),0x00000000); 
0838A:  SUBWF  xF7,W
0838C:  MOVWF  xF9
0838E:  MOVFF  FE8,732
08392:  MOVLB  0
08394:  CALL   576A
08398:  MOVFF  03,6FC
0839C:  MOVFF  02,6FB
083A0:  MOVFF  01,6FA
083A4:  MOVFF  00,6F9
083A8:  MOVFF  03,73C
083AC:  MOVFF  02,73B
083B0:  MOVFF  01,73A
083B4:  MOVFF  00,739
083B8:  MOVLB  7
083BA:  CLRF   x40
083BC:  CLRF   x3F
083BE:  CLRF   x3E
083C0:  CLRF   x3D
083C2:  MOVLB  0
083C4:  CALL   1B64
083C8:  MOVLB  6
.................... 	}		 
.................... } 
083CA:  MOVLB  0
083CC:  GOTO   8B2C (RETURN)
....................  
.................... void mute_off_output(int ch) 
.................... { 
....................  
.................... 	if(ch == 0) { 
083D0:  MOVLB  6
083D2:  MOVF   xF7,F
083D4:  BNZ   849E
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
083D6:  CLRF   xF8
083D8:  MOVF   xF8,W
083DA:  SUBLW  03
083DC:  BNC   849C
.................... 			rs232_output_mute[i] = 0; 
083DE:  CLRF   03
083E0:  MOVF   xF8,W
083E2:  ADDLW  9C
083E4:  MOVWF  FE9
083E6:  MOVLW  00
083E8:  ADDWFC 03,W
083EA:  MOVWF  FEA
083EC:  CLRF   FEF
.................... 	 
.................... 			send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
083EE:  MOVFF  6F8,732
083F2:  MOVLB  0
083F4:  CALL   576A
083F8:  MOVFF  03,6FC
083FC:  MOVFF  02,6FB
08400:  MOVFF  01,6FA
08404:  MOVFF  00,6F9
08408:  MOVLB  6
0840A:  MOVF   xF8,W
0840C:  MULLW  04
0840E:  MOVF   FF3,W
08410:  CLRF   03
08412:  ADDLW  8C
08414:  MOVWF  FE9
08416:  MOVLW  00
08418:  ADDWFC 03,W
0841A:  MOVWF  FEA
0841C:  MOVFF  FEF,6FD
08420:  MOVFF  FEC,6FE
08424:  MOVFF  FEC,6FF
08428:  MOVFF  FEC,700
0842C:  MOVFF  700,73C
08430:  MOVFF  6FF,73B
08434:  MOVFF  6FE,73A
08438:  MOVFF  6FD,739
0843C:  MOVLB  7
0843E:  CLRF   x40
08440:  CLRF   x3F
08442:  CLRF   x3E
08444:  MOVLW  9E
08446:  MOVWF  x3D
08448:  MOVLB  0
0844A:  CALL   5638
0844E:  MOVFF  03,738
08452:  MOVFF  02,737
08456:  MOVFF  01,736
0845A:  MOVFF  00,735
0845E:  CALL   57D0
08462:  MOVFF  03,700
08466:  MOVFF  02,6FF
0846A:  MOVFF  01,6FE
0846E:  MOVFF  00,6FD
08472:  MOVFF  6FC,73C
08476:  MOVFF  6FB,73B
0847A:  MOVFF  6FA,73A
0847E:  MOVFF  6F9,739
08482:  MOVFF  03,740
08486:  MOVFF  02,73F
0848A:  MOVFF  01,73E
0848E:  MOVFF  00,73D
08492:  CALL   1B64
.................... 		} 
08496:  MOVLB  6
08498:  INCF   xF8,F
0849A:  BRA    83D8
.................... 	} else { 
0849C:  BRA    8562
.................... 		rs232_output_mute[(ch-1)] = 0; 
0849E:  MOVLW  01
084A0:  SUBWF  xF7,W
084A2:  CLRF   03
084A4:  ADDLW  9C
084A6:  MOVWF  FE9
084A8:  MOVLW  00
084AA:  ADDWFC 03,W
084AC:  MOVWF  FEA
084AE:  CLRF   FEF
.................... 	 
.................... 		send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
084B0:  MOVLW  01
084B2:  SUBWF  xF7,W
084B4:  MOVWF  xF9
084B6:  MOVFF  FE8,732
084BA:  MOVLB  0
084BC:  CALL   576A
084C0:  MOVFF  03,6FC
084C4:  MOVFF  02,6FB
084C8:  MOVFF  01,6FA
084CC:  MOVFF  00,6F9
084D0:  MOVLW  01
084D2:  MOVLB  6
084D4:  SUBWF  xF7,W
084D6:  MULLW  04
084D8:  MOVF   FF3,W
084DA:  CLRF   03
084DC:  ADDLW  8C
084DE:  MOVWF  FE9
084E0:  MOVLW  00
084E2:  ADDWFC 03,W
084E4:  MOVWF  FEA
084E6:  MOVFF  FEF,6FD
084EA:  MOVFF  FEC,6FE
084EE:  MOVFF  FEC,6FF
084F2:  MOVFF  FEC,700
084F6:  MOVFF  700,73C
084FA:  MOVFF  6FF,73B
084FE:  MOVFF  6FE,73A
08502:  MOVFF  6FD,739
08506:  MOVLB  7
08508:  CLRF   x40
0850A:  CLRF   x3F
0850C:  CLRF   x3E
0850E:  MOVLW  9E
08510:  MOVWF  x3D
08512:  MOVLB  0
08514:  CALL   5638
08518:  MOVFF  03,738
0851C:  MOVFF  02,737
08520:  MOVFF  01,736
08524:  MOVFF  00,735
08528:  CALL   57D0
0852C:  MOVFF  03,700
08530:  MOVFF  02,6FF
08534:  MOVFF  01,6FE
08538:  MOVFF  00,6FD
0853C:  MOVFF  6FC,73C
08540:  MOVFF  6FB,73B
08544:  MOVFF  6FA,73A
08548:  MOVFF  6F9,739
0854C:  MOVFF  03,740
08550:  MOVFF  02,73F
08554:  MOVFF  01,73E
08558:  MOVFF  00,73D
0855C:  CALL   1B64
08560:  MOVLB  6
.................... 	}		 
.................... } 
08562:  MOVLB  0
08564:  GOTO   8B4C (RETURN)
....................  
.................... int mute_toggle_output(int ch) 
.................... { 
.................... 	if(ch == 0) { 
*
05812:  MOVLB  7
05814:  MOVF   x2E,F
05816:  BTFSS  FD8.2
05818:  BRA    595A
.................... 		 
.................... 		for(int i = 0; i < 4; i++) { 
0581A:  CLRF   x2F
0581C:  MOVF   x2F,W
0581E:  SUBLW  03
05820:  BTFSS  FD8.0
05822:  BRA    594E
.................... 			rs232_output_mute[i] = !rs232_output_mute[i]; 
05824:  CLRF   03
05826:  MOVF   x2F,W
05828:  ADDLW  9C
0582A:  MOVWF  01
0582C:  MOVLW  00
0582E:  ADDWFC 03,F
05830:  MOVFF  01,730
05834:  MOVFF  03,731
05838:  CLRF   03
0583A:  MOVF   x2F,W
0583C:  ADDLW  9C
0583E:  MOVWF  FE9
05840:  MOVLW  00
05842:  ADDWFC 03,W
05844:  MOVWF  FEA
05846:  MOVF   FEF,F
05848:  BZ    584E
0584A:  MOVLW  00
0584C:  BRA    5850
0584E:  MOVLW  01
05850:  MOVFF  731,FEA
05854:  MOVFF  730,FE9
05858:  MOVWF  FEF
....................  
.................... 			if(rs232_output_mute[i]) { 
0585A:  CLRF   03
0585C:  MOVF   x2F,W
0585E:  ADDLW  9C
05860:  MOVWF  FE9
05862:  MOVLW  00
05864:  ADDWFC 03,W
05866:  MOVWF  FEA
05868:  MOVF   FEF,F
0586A:  BZ    58A8
.................... 				send_dsp_command(get_AM_trim_channel(i),0x00000000); 
0586C:  MOVFF  72F,732
05870:  MOVLB  0
05872:  RCALL  576A
05874:  MOVFF  03,733
05878:  MOVFF  02,732
0587C:  MOVFF  01,731
05880:  MOVFF  00,730
05884:  MOVFF  03,73C
05888:  MOVFF  02,73B
0588C:  MOVFF  01,73A
05890:  MOVFF  00,739
05894:  MOVLB  7
05896:  CLRF   x40
05898:  CLRF   x3F
0589A:  CLRF   x3E
0589C:  CLRF   x3D
0589E:  MOVLB  0
058A0:  CALL   1B64
.................... 			} else { 
058A4:  BRA    5948
058A6:  MOVLB  7
.................... 				send_dsp_command(get_AM_trim_channel(i),(int32)(rs232_output_vol[i]*2147483648.0)); 
058A8:  MOVFF  72F,732
058AC:  MOVLB  0
058AE:  RCALL  576A
058B0:  MOVFF  03,733
058B4:  MOVFF  02,732
058B8:  MOVFF  01,731
058BC:  MOVFF  00,730
058C0:  MOVLB  7
058C2:  MOVF   x2F,W
058C4:  MULLW  04
058C6:  MOVF   FF3,W
058C8:  CLRF   03
058CA:  ADDLW  8C
058CC:  MOVWF  FE9
058CE:  MOVLW  00
058D0:  ADDWFC 03,W
058D2:  MOVWF  FEA
058D4:  MOVFF  FEF,734
058D8:  MOVFF  FEC,735
058DC:  MOVFF  FEC,736
058E0:  MOVFF  FEC,737
058E4:  MOVFF  737,73C
058E8:  MOVFF  736,73B
058EC:  MOVFF  735,73A
058F0:  MOVFF  734,739
058F4:  CLRF   x40
058F6:  CLRF   x3F
058F8:  CLRF   x3E
058FA:  MOVLW  9E
058FC:  MOVWF  x3D
058FE:  MOVLB  0
05900:  RCALL  5638
05902:  MOVFF  03,738
05906:  MOVFF  02,737
0590A:  MOVFF  01,736
0590E:  MOVFF  00,735
05912:  RCALL  57D0
05914:  MOVFF  03,737
05918:  MOVFF  02,736
0591C:  MOVFF  01,735
05920:  MOVFF  00,734
05924:  MOVFF  733,73C
05928:  MOVFF  732,73B
0592C:  MOVFF  731,73A
05930:  MOVFF  730,739
05934:  MOVFF  03,740
05938:  MOVFF  02,73F
0593C:  MOVFF  01,73E
05940:  MOVFF  00,73D
05944:  CALL   1B64
.................... 			} 
.................... 		 
.................... 			 
.................... 		} 
05948:  MOVLB  7
0594A:  INCF   x2F,F
0594C:  BRA    581C
....................  
.................... 		return rs232_output_mute[0]; 
0594E:  MOVLB  0
05950:  MOVFF  9C,01
05954:  BRA    5AA8
....................  
.................... 	} else { 
05956:  BRA    5AA8
05958:  MOVLB  7
.................... 		rs232_output_mute[(ch-1)] = !rs232_output_mute[(ch-1)]; 
0595A:  MOVLW  01
0595C:  SUBWF  x2E,W
0595E:  CLRF   03
05960:  ADDLW  9C
05962:  MOVWF  01
05964:  MOVLW  00
05966:  ADDWFC 03,F
05968:  MOVFF  01,730
0596C:  MOVFF  03,731
05970:  MOVLW  01
05972:  SUBWF  x2E,W
05974:  CLRF   03
05976:  ADDLW  9C
05978:  MOVWF  FE9
0597A:  MOVLW  00
0597C:  ADDWFC 03,W
0597E:  MOVWF  FEA
05980:  MOVF   FEF,F
05982:  BZ    5988
05984:  MOVLW  00
05986:  BRA    598A
05988:  MOVLW  01
0598A:  MOVFF  731,FEA
0598E:  MOVFF  730,FE9
05992:  MOVWF  FEF
....................  
.................... 		if(rs232_output_mute[(ch-1)]) { 
05994:  MOVLW  01
05996:  SUBWF  x2E,W
05998:  CLRF   03
0599A:  ADDLW  9C
0599C:  MOVWF  FE9
0599E:  MOVLW  00
059A0:  ADDWFC 03,W
059A2:  MOVWF  FEA
059A4:  MOVF   FEF,F
059A6:  BZ    59E8
.................... 			send_dsp_command(get_AM_trim_channel(ch-1),0x00000000);	 
059A8:  MOVLW  01
059AA:  SUBWF  x2E,W
059AC:  MOVWF  x30
059AE:  MOVWF  x32
059B0:  MOVLB  0
059B2:  RCALL  576A
059B4:  MOVFF  03,733
059B8:  MOVFF  02,732
059BC:  MOVFF  01,731
059C0:  MOVFF  00,730
059C4:  MOVFF  03,73C
059C8:  MOVFF  02,73B
059CC:  MOVFF  01,73A
059D0:  MOVFF  00,739
059D4:  MOVLB  7
059D6:  CLRF   x40
059D8:  CLRF   x3F
059DA:  CLRF   x3E
059DC:  CLRF   x3D
059DE:  MOVLB  0
059E0:  CALL   1B64
.................... 		} else { 
059E4:  BRA    5A8E
059E6:  MOVLB  7
.................... 			send_dsp_command(get_AM_trim_channel(ch-1),(int32)(rs232_output_vol[ch-1]*2147483648.0)); 
059E8:  MOVLW  01
059EA:  SUBWF  x2E,W
059EC:  MOVWF  x30
059EE:  MOVWF  x32
059F0:  MOVLB  0
059F2:  RCALL  576A
059F4:  MOVFF  03,733
059F8:  MOVFF  02,732
059FC:  MOVFF  01,731
05A00:  MOVFF  00,730
05A04:  MOVLW  01
05A06:  MOVLB  7
05A08:  SUBWF  x2E,W
05A0A:  MULLW  04
05A0C:  MOVF   FF3,W
05A0E:  CLRF   03
05A10:  ADDLW  8C
05A12:  MOVWF  FE9
05A14:  MOVLW  00
05A16:  ADDWFC 03,W
05A18:  MOVWF  FEA
05A1A:  MOVFF  FEF,734
05A1E:  MOVFF  FEC,735
05A22:  MOVFF  FEC,736
05A26:  MOVFF  FEC,737
05A2A:  MOVFF  737,73C
05A2E:  MOVFF  736,73B
05A32:  MOVFF  735,73A
05A36:  MOVFF  734,739
05A3A:  CLRF   x40
05A3C:  CLRF   x3F
05A3E:  CLRF   x3E
05A40:  MOVLW  9E
05A42:  MOVWF  x3D
05A44:  MOVLB  0
05A46:  RCALL  5638
05A48:  MOVFF  03,738
05A4C:  MOVFF  02,737
05A50:  MOVFF  01,736
05A54:  MOVFF  00,735
05A58:  RCALL  57D0
05A5A:  MOVFF  03,737
05A5E:  MOVFF  02,736
05A62:  MOVFF  01,735
05A66:  MOVFF  00,734
05A6A:  MOVFF  733,73C
05A6E:  MOVFF  732,73B
05A72:  MOVFF  731,73A
05A76:  MOVFF  730,739
05A7A:  MOVFF  03,740
05A7E:  MOVFF  02,73F
05A82:  MOVFF  01,73E
05A86:  MOVFF  00,73D
05A8A:  CALL   1B64
.................... 		} 
.................... 	 
.................... 		return rs232_output_mute[(ch-1)]; 
05A8E:  MOVLW  01
05A90:  MOVLB  7
05A92:  SUBWF  x2E,W
05A94:  CLRF   03
05A96:  ADDLW  9C
05A98:  MOVWF  FE9
05A9A:  MOVLW  00
05A9C:  ADDWFC 03,W
05A9E:  MOVWF  FEA
05AA0:  MOVFF  FEF,01
05AA4:  MOVLB  0
05AA6:  BRA    5AA8
.................... 	} 
.................... } 
05AA8:  RETURN 0
....................  
.................... #include <timed_getc.c> 
.................... //timed_getc.c 
.................... int timeout_error; 
....................  
.................... short data_available_usb() 
.................... { 
.................... 	return kbhit(USB); 
....................  
....................  
.................... } 
.................... char timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
04DFC:  MOVLB  5
04DFE:  CLRF   xA9
.................... 	timeout = 0; 
04E00:  MOVLB  7
04E02:  CLRF   x37
04E04:  CLRF   x36
....................  
.................... 	while(!kbhit(USB)&&(++timeout<50000)) { // half a second 
04E06:  BTFSS  F82.7
04E08:  BRA    4E2A
04E0A:  INCF   x36,F
04E0C:  BTFSC  FD8.2
04E0E:  INCF   x37,F
04E10:  MOVF   x37,W
04E12:  SUBLW  C3
04E14:  BNC   4E2A
04E16:  BNZ   4E1E
04E18:  MOVF   x36,W
04E1A:  SUBLW  4F
04E1C:  BNC   4E2A
.................... 		delay_us(5); // this polls at 10x the 9600 baud rate 
04E1E:  MOVLW  05
04E20:  MOVWF  00
04E22:  DECFSZ 00,F
04E24:  BRA    4E22
04E26:  BRA    4E28
.................... 	} 
04E28:  BRA    4E06
....................  
.................... 	if(kbhit()) { 
04E2A:  BTFSC  F82.7
04E2C:  BRA    4E3E
.................... 		timeout_error = FALSE; 
04E2E:  MOVLB  5
04E30:  CLRF   xA9
.................... 		return(fgetc(USB)); 
04E32:  MOVLB  0
04E34:  RCALL  4CFE
04E36:  MOVF   01,W
04E38:  BRA    4E4C
.................... 	} else { 
04E3A:  BRA    4E4C
04E3C:  MOVLB  7
.................... 		timeout_error = TRUE; 
04E3E:  MOVLW  01
04E40:  MOVLB  5
04E42:  MOVWF  xA9
.................... 		return(0); 
04E44:  MOVLW  00
04E46:  MOVWF  01
04E48:  MOVLB  0
04E4A:  BRA    4E4C
.................... 	} 
.................... } 
04E4C:  RETURN 0
....................  
.................... char fast_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
04D48:  MOVLB  5
04D4A:  CLRF   xA9
.................... 	timeout = 0; 
04D4C:  MOVLB  7
04D4E:  CLRF   x2F
04D50:  CLRF   x2E
....................  
.................... 	while(!kbhit(USB)&&(++timeout<10000)) { // tenth of a second 
04D52:  BTFSS  F82.7
04D54:  BRA    4D76
04D56:  INCF   x2E,F
04D58:  BTFSC  FD8.2
04D5A:  INCF   x2F,F
04D5C:  MOVF   x2F,W
04D5E:  SUBLW  27
04D60:  BNC   4D76
04D62:  BNZ   4D6A
04D64:  MOVF   x2E,W
04D66:  SUBLW  0F
04D68:  BNC   4D76
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
04D6A:  MOVLW  0B
04D6C:  MOVWF  00
04D6E:  DECFSZ 00,F
04D70:  BRA    4D6E
04D72:  BRA    4D74
.................... 	} 
04D74:  BRA    4D52
....................  
.................... 	if(kbhit()) { 
04D76:  BTFSC  F82.7
04D78:  BRA    4D8A
.................... 		timeout_error = FALSE; 
04D7A:  MOVLB  5
04D7C:  CLRF   xA9
.................... 		return(getc()); 
04D7E:  MOVLB  0
04D80:  RCALL  4CFE
04D82:  MOVF   01,W
04D84:  BRA    4D98
.................... 	} else { 
04D86:  BRA    4D98
04D88:  MOVLB  7
.................... 		timeout_error = TRUE; 
04D8A:  MOVLW  01
04D8C:  MOVLB  5
04D8E:  MOVWF  xA9
.................... 		return(0); 
04D90:  MOVLW  00
04D92:  MOVWF  01
04D94:  MOVLB  0
04D96:  BRA    4D98
.................... 	} 
.................... } 
04D98:  RETURN 0
....................  
.................... char slow_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
.................... 	timeout = 0; 
....................  
.................... 	while(!kbhit(USB)&&(++timeout<20000)) { // fifth of a second 
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
.................... 	} 
....................  
.................... 	if(kbhit()) { 
.................... 		timeout_error = FALSE; 
.................... 		return(getc()); 
.................... 	} else { 
.................... 		timeout_error = TRUE; 
.................... 		return(0); 
.................... 	} 
.................... } 
....................  
.................... #include <streaming.c> 
.................... // streaming.c 
....................  
.................... #define NIBBLE_SIZE 32 
....................  
.................... /* VARIABLES FOR STREAMING */ 
.................... byte STREAMING_BUFFER[256]; 
....................  
.................... byte STREAM_NIBBLE_BUFFER[32]; 
....................  
.................... int16 streaming_buffer_index = 0; 
.................... int16 bytes_in_stream = 0; 
....................  
.................... int16 num_bytes_added = 0; 
....................  
.................... int stream_target_program = 0; 
.................... int stream_target_page = 0; 
....................  
.................... short is_streaming = 0; 
....................  
.................... int16 total_bytes_so_far = 0; 
....................  
.................... unsigned int nibble_crc = 0; 
....................  
.................... unsigned int verified_bytes = 0; 
.................... int nibble_index = 0; // 0-31 (local in STREAM_NIBBLE_BUFFER) 
....................  
....................  
.................... void flush_nibble_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
054A6:  MOVLB  6
054A8:  CLRF   xCB
054AA:  CLRF   xCA
.................... 	for(int j = 0; j < 32; j++) { 
054AC:  MOVLB  7
054AE:  CLRF   x36
054B0:  MOVF   x36,W
054B2:  SUBLW  1F
054B4:  BNC   54CA
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
054B6:  CLRF   03
054B8:  MOVF   x36,W
054BA:  ADDLW  AA
054BC:  MOVWF  FE9
054BE:  MOVLW  06
054C0:  ADDWFC 03,W
054C2:  MOVWF  FEA
054C4:  SETF   FEF
.................... 	} 
054C6:  INCF   x36,F
054C8:  BRA    54B0
....................  
.................... } 
054CA:  MOVLB  0
054CC:  GOTO   55E4 (RETURN)
....................  
....................  
.................... void flush_stream_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
0536A:  MOVLB  6
0536C:  CLRF   xCB
0536E:  CLRF   xCA
....................  
.................... 	for(int16 i = 0; i < 256; i++) { 
05370:  MOVLB  7
05372:  CLRF   x37
05374:  CLRF   x36
05376:  MOVF   x37,W
05378:  SUBLW  00
0537A:  BNC   5392
.................... 		STREAMING_BUFFER[i] = 0xFF; 
0537C:  MOVLW  AA
0537E:  ADDWF  x36,W
05380:  MOVWF  FE9
05382:  MOVLW  05
05384:  ADDWFC x37,W
05386:  MOVWF  FEA
05388:  SETF   FEF
.................... 	} 
0538A:  INCF   x36,F
0538C:  BTFSC  FD8.2
0538E:  INCF   x37,F
05390:  BRA    5376
....................  
.................... 	for(int j = 0; j < 32; j++) { 
05392:  CLRF   x38
05394:  MOVF   x38,W
05396:  SUBLW  1F
05398:  BNC   53AE
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
0539A:  CLRF   03
0539C:  MOVF   x38,W
0539E:  ADDLW  AA
053A0:  MOVWF  FE9
053A2:  MOVLW  06
053A4:  ADDWFC 03,W
053A6:  MOVWF  FEA
053A8:  SETF   FEF
.................... 	} 
053AA:  INCF   x38,F
053AC:  BRA    5394
....................  
.................... } 
053AE:  MOVLB  0
053B0:  RETURN 0
....................  
....................  
....................  
....................  
.................... int calc_crc_int(int *Buffer, int16 Len)  
.................... {  
*
053FC:  MOVLB  7
053FE:  SETF   x3D
05400:  SETF   x3C
05402:  CLRF   x3E
....................    int16 x;  
....................    int16 crc = 0xFFFF;  
....................    int return_int = 0; 
....................  
....................    while(Len--)  
....................    {  
05404:  MOVFF  739,03
05408:  MOVF   x38,W
0540A:  BTFSC  FD8.2
0540C:  DECF   x39,F
0540E:  DECF   x38,F
05410:  IORWF  03,W
05412:  BZ    5498
....................       x = make8(crc,1) ^ *Buffer++;  
05414:  MOVFF  737,03
05418:  MOVF   x36,W
0541A:  INCF   x36,F
0541C:  BTFSC  FD8.2
0541E:  INCF   x37,F
05420:  MOVWF  FE9
05422:  MOVFF  03,FEA
05426:  MOVF   FEF,W
05428:  XORWF  x3D,W
0542A:  MOVWF  x3A
0542C:  CLRF   x3B
....................       x ^= x>>4;  
0542E:  RRCF   x3B,W
05430:  MOVWF  03
05432:  RRCF   x3A,W
05434:  MOVWF  02
05436:  RRCF   03,F
05438:  RRCF   02,F
0543A:  RRCF   03,F
0543C:  RRCF   02,F
0543E:  RRCF   03,F
05440:  RRCF   02,F
05442:  MOVLW  0F
05444:  ANDWF  03,F
05446:  MOVF   02,W
05448:  XORWF  x3A,F
0544A:  MOVF   03,W
0544C:  XORWF  x3B,F
....................        
....................       crc = (crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
0544E:  MOVFF  73C,740
05452:  CLRF   x3F
05454:  SWAPF  x3A,W
05456:  MOVWF  03
05458:  CLRF   02
0545A:  MOVLW  F0
0545C:  ANDWF  03,F
0545E:  MOVF   02,W
05460:  XORWF  x3F,F
05462:  MOVF   03,W
05464:  XORWF  x40,F
05466:  RLCF   x3A,W
05468:  MOVWF  02
0546A:  RLCF   x3B,W
0546C:  MOVWF  03
0546E:  RLCF   02,F
05470:  RLCF   03,F
05472:  RLCF   02,F
05474:  RLCF   03,F
05476:  RLCF   02,F
05478:  RLCF   03,F
0547A:  RLCF   02,F
0547C:  RLCF   03,F
0547E:  MOVLW  E0
05480:  ANDWF  02,F
05482:  MOVF   02,W
05484:  XORWF  x3F,F
05486:  MOVF   03,W
05488:  XORWF  x40,F
0548A:  MOVF   x3F,W
0548C:  XORWF  x3A,W
0548E:  MOVWF  x3C
05490:  MOVF   x40,W
05492:  XORWF  x3B,W
05494:  MOVWF  x3D
....................    }  
05496:  BRA    5404
....................  
.................... 	return_int = crc & 0xFF; 
05498:  MOVFF  73C,73E
....................  
....................    	return return_int;  
0549C:  MOVFF  73E,01
.................... }  
054A0:  MOVLB  0
054A2:  GOTO   5586 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... void clear_nibble() 
.................... { 
.................... 	for(int n = 0; n < NIBBLE_SIZE; n++) { 
*
053B2:  MOVLB  7
053B4:  CLRF   x36
053B6:  MOVF   x36,W
053B8:  SUBLW  1F
053BA:  BNC   53D0
.................... 		STREAM_NIBBLE_BUFFER[n] = 0xFF; 
053BC:  CLRF   03
053BE:  MOVF   x36,W
053C0:  ADDLW  AA
053C2:  MOVWF  FE9
053C4:  MOVLW  06
053C6:  ADDWFC 03,W
053C8:  MOVWF  FEA
053CA:  SETF   FEF
.................... 	} 
053CC:  INCF   x36,F
053CE:  BRA    53B6
....................  
.................... 	nibble_index = 0; 
053D0:  MOVLB  6
053D2:  CLRF   xD7
.................... } 
053D4:  MOVLB  0
053D6:  GOTO   53E2 (RETURN)
....................  
.................... void add_nibble_to_buffer() 
.................... { 
.................... 	for(int m = 0; m < NIBBLE_SIZE; m++) { 
.................... 		STREAMING_BUFFER[verified_bytes++] = STREAM_NIBBLE_BUFFER[m]; 
.................... 	} 
....................  
.................... 	nibble_index = 0; 
.................... } 
....................  
.................... void kill_stream() 
.................... { 
.................... 	is_streaming = false; 
053DA:  MOVLB  6
053DC:  BCF    xD2.0
.................... 	clear_nibble(); 
053DE:  MOVLB  0
053E0:  BRA    53B2
.................... 	flush_stream_buffer(); 
053E2:  RCALL  536A
.................... 	streaming_buffer_index = 0; 
053E4:  MOVLB  6
053E6:  CLRF   xCB
053E8:  CLRF   xCA
.................... 	streaming_buffer_index = 0; 
053EA:  CLRF   xCB
053EC:  CLRF   xCA
.................... 	nibble_index = 0; 
053EE:  CLRF   xD7
.................... 	verified_bytes = 0; 
053F0:  CLRF   xD6
.................... 	total_bytes_so_far = 0; 
053F2:  CLRF   xD4
053F4:  CLRF   xD3
.................... 	 
....................  
....................  
.................... } 
053F6:  MOVLB  0
053F8:  GOTO   556C (RETURN)
....................  
.................... void print_stream_to_rs232() 
.................... { 
.................... 	for(int i = 0; i < 32; i++) { 
.................... 		fprintf(RS232,"%u ",STREAM_NIBBLE_BUFFER[i]); 
.................... 	} 
....................  
.................... 	char nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
....................  
.................... 	fprintf(RS232,"CRC = %u\r\n",nibble_crc); 
....................  
.................... 	 
....................  
.................... } 
....................  
.................... void perform_stream(int target_program, int target_page, int16 num_bytes) 
.................... { 
.................... 	char streamed_char; 
....................  
.................... 	stream_target_program = target_program; 
*
054D0:  MOVFF  72E,6D0
.................... 	stream_target_page = target_page; 
054D4:  MOVFF  72F,6D1
.................... 	bytes_in_stream = num_bytes; 
054D8:  MOVFF  731,6CD
054DC:  MOVFF  730,6CC
....................  
.................... 	streaming_buffer_index = 0; 
054E0:  MOVLB  6
054E2:  CLRF   xCB
054E4:  CLRF   xCA
.................... 	streaming_buffer_index = 0; 
054E6:  CLRF   xCB
054E8:  CLRF   xCA
.................... 	nibble_index = 0; 
054EA:  CLRF   xD7
.................... 	verified_bytes = 0; 
054EC:  CLRF   xD6
.................... 	total_bytes_so_far = 0; 
054EE:  CLRF   xD4
054F0:  CLRF   xD3
....................  
.................... 	num_bytes_added = 0; 
054F2:  CLRF   xCF
054F4:  CLRF   xCE
.................... 	total_bytes_so_far = 0; 
054F6:  CLRF   xD4
054F8:  CLRF   xD3
....................  
....................  
.................... 	is_streaming = true; 
054FA:  BSF    xD2.0
.................... 	flush_stream_buffer(); 
054FC:  MOVLB  0
054FE:  RCALL  536A
....................  
.................... 	fputc(0x06,USB); 
05500:  MOVLW  06
05502:  MOVLB  7
05504:  MOVWF  x36
05506:  MOVLB  0
05508:  RCALL  4D9A
.................... 	fputc(target_program,USB); 
0550A:  MOVFF  72E,736
0550E:  RCALL  4D9A
.................... 	fputc(target_page,USB); 
05510:  MOVFF  72F,736
05514:  RCALL  4D9A
.................... 	fputc(0x03,USB); 
05516:  MOVLW  03
05518:  MOVLB  7
0551A:  MOVWF  x36
0551C:  MOVLB  0
0551E:  RCALL  4D9A
....................  
.................... 	int nibble_byte_counter = 0; 
05520:  MOVLB  7
05522:  CLRF   x33
....................  
.................... 	for(int nibble_counter = 0; nibble_counter <8; nibble_counter++) 
05524:  CLRF   x34
05526:  MOVF   x34,W
05528:  SUBLW  07
0552A:  BNC   55EA
.................... 	{ 
.................... 		nibble_index = 0; 
0552C:  MOVLB  6
0552E:  CLRF   xD7
....................  
.................... 		for(nibble_byte_counter = 0; nibble_byte_counter < 32; nibble_byte_counter++) { 
05530:  MOVLB  7
05532:  CLRF   x33
05534:  MOVF   x33,W
05536:  SUBLW  1F
05538:  BNC   5562
....................  
.................... 			streamed_char = timed_getc(); 
0553A:  MOVLB  0
0553C:  RCALL  4DFC
0553E:  MOVFF  01,732
.................... 	 
.................... 			total_bytes_so_far++; 
05542:  MOVLB  6
05544:  INCF   xD3,F
05546:  BTFSC  FD8.2
05548:  INCF   xD4,F
....................  
.................... 			STREAM_NIBBLE_BUFFER[nibble_byte_counter] = streamed_char;	 
0554A:  CLRF   03
0554C:  MOVLB  7
0554E:  MOVF   x33,W
05550:  ADDLW  AA
05552:  MOVWF  FE9
05554:  MOVLW  06
05556:  ADDWFC 03,W
05558:  MOVWF  FEA
0555A:  MOVFF  732,FEF
.................... 		} 
0555E:  INCF   x33,F
05560:  BRA    5534
.................... 	 
.................... 		if(TIMEOUT_ERROR == true) { 
05562:  MOVLB  5
05564:  DECFSZ xA9,W
05566:  BRA    5572
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"Timed out after having read %lu bytes\r\n",total_bytes_so_far); 
.................... 				fprintf(RS232,"So far we have received: "); 
.................... 				print_stream_to_rs232(); 
.................... 			} 
.................... 			//send_error(ERR_COMMAND_TIMEOUT); 
.................... 			kill_stream(); 
05568:  MOVLB  0
0556A:  BRA    53DA
.................... 			return; 
0556C:  BRA    5634
.................... 		} else { 
0556E:  BRA    55E4
05570:  MOVLB  5
.................... 			 
.................... 			nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
05572:  MOVLW  06
05574:  MOVLB  7
05576:  MOVWF  x37
05578:  MOVLW  AA
0557A:  MOVWF  x36
0557C:  CLRF   x39
0557E:  MOVLW  20
05580:  MOVWF  x38
05582:  MOVLB  0
05584:  BRA    53FC
05586:  MOVFF  01,6D5
.................... 			//fprintf(RS232,"GOT FULL NIBBLE. So far %lu. Sending %u CRC\r\n",total_bytes_so_far,nibble_crc); 
.................... 			fputc(nibble_crc,USB); 
0558A:  MOVFF  6D5,736
0558E:  RCALL  4D9A
....................  
.................... 			for(int x = 0; x < 32; x++) { 
05590:  MOVLB  7
05592:  CLRF   x35
05594:  MOVF   x35,W
05596:  SUBLW  1F
05598:  BNC   55E0
.................... 				STREAMING_BUFFER[num_bytes_added++] = STREAM_NIBBLE_BUFFER[x]; 
0559A:  MOVLB  6
0559C:  MOVFF  6CF,03
055A0:  MOVF   xCE,W
055A2:  INCF   xCE,F
055A4:  BTFSC  FD8.2
055A6:  INCF   xCF,F
055A8:  MOVLB  7
055AA:  MOVWF  x36
055AC:  MOVFF  03,737
055B0:  MOVLW  AA
055B2:  ADDWF  x36,W
055B4:  MOVWF  01
055B6:  MOVLW  05
055B8:  ADDWFC 03,W
055BA:  MOVWF  03
055BC:  MOVWF  x39
055BE:  CLRF   03
055C0:  MOVF   x35,W
055C2:  ADDLW  AA
055C4:  MOVWF  FE9
055C6:  MOVLW  06
055C8:  ADDWFC 03,W
055CA:  MOVWF  FEA
055CC:  MOVFF  FEF,73A
055D0:  MOVFF  739,FEA
055D4:  MOVFF  01,FE9
055D8:  MOVFF  73A,FEF
.................... 			} 
055DC:  INCF   x35,F
055DE:  BRA    5594
....................  
.................... 			flush_nibble_buffer(); 
055E0:  MOVLB  0
055E2:  BRA    54A6
.................... 		} 
.................... 	} 
055E4:  MOVLB  7
055E6:  INCF   x34,F
055E8:  BRA    5526
....................  
.................... 	write_buffer_to_flash_page(&STREAMING_BUFFER,target_program, target_page); 
055EA:  MOVLW  05
055EC:  MOVWF  x37
055EE:  MOVLW  AA
055F0:  MOVWF  x36
055F2:  MOVFF  72E,738
055F6:  MOVFF  72F,739
055FA:  MOVLB  0
055FC:  CALL   1734
....................  
.................... 	fputc(0x06,USB); 
05600:  MOVLW  06
05602:  MOVLB  7
05604:  MOVWF  x36
05606:  MOVLB  0
05608:  CALL   4D9A
.................... 	fputc(0x01,USB); 
0560C:  MOVLW  01
0560E:  MOVLB  7
05610:  MOVWF  x36
05612:  MOVLB  0
05614:  CALL   4D9A
.................... 	fputc(target_program,USB); 
05618:  MOVFF  72E,736
0561C:  CALL   4D9A
.................... 	fputc(target_page,USB); 
05620:  MOVFF  72F,736
05624:  CALL   4D9A
.................... 	fputc(0x03,USB); 
05628:  MOVLW  03
0562A:  MOVLB  7
0562C:  MOVWF  x36
0562E:  MOVLB  0
05630:  CALL   4D9A
....................  
.................... } 
05634:  GOTO   6AF6 (RETURN)
....................  
.................... #include <sa_usb.c> 
.................... char last_byte1,last_byte2,last_byte3,last_byte4,last_address; 
.................... int finished; 
.................... int temp_byte; 
.................... char name_buffer[20]; 
.................... int x, y; 
....................  
.................... void send_error(char error_code) 
.................... { 
.................... 	fputc(ERR_START,USB); 
*
04DE0:  MOVLW  15
04DE2:  MOVLB  7
04DE4:  MOVWF  x36
04DE6:  MOVLB  0
04DE8:  RCALL  4D9A
.................... 	fputc(error_code,USB); 
04DEA:  MOVFF  72E,736
04DEE:  RCALL  4D9A
.................... 	fputc(0x03,USB); 
04DF0:  MOVLW  03
04DF2:  MOVLB  7
04DF4:  MOVWF  x36
04DF6:  MOVLB  0
04DF8:  RCALL  4D9A
.................... } 
04DFA:  RETURN 0
....................  
.................... void process_usb_data()  { 
....................  
.................... 	char start_char,command_char,dummy_char,byte1,byte2,byte3,byte4,channel; 
.................... 	int16 addr_lsb, addr_msb; 
.................... 	int16 final_address, last_address; 
....................  
....................  
.................... 	/*if(is_streaming) { 
.................... 		process_stream_byte(); 
.................... 		return; 
.................... 	} 
.................... */ 
.................... 	// Wait until we get a starting char. Escapes after timeout to allow program to continue processing 
....................  
.................... 	start_char = fast_timed_getc(); 
*
05EBE:  CALL   4D48
05EC2:  MOVFF  01,6F5
....................  
.................... 	if(TIMEOUT_ERROR == true) { 
05EC6:  MOVLB  5
05EC8:  DECFSZ xA9,W
05ECA:  BRA    5ED0
.................... 		return; 
05ECC:  GOTO   71FC
.................... 	} 
.................... 	 
.................... 	/* THIS LIST MUST BE UPDATED WHENEVER WE ADD A NEW START CHARACTER */ 
.................... 	if( 
.................... 		(start_char != 0x02) && // GENERAL 
.................... 		(start_char != 0x04) && // WRITE_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x05) && // GET_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x07) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x08) && // READ_DSP_VALUE 
.................... 		(start_char != 0x09) && // UTILITY 
.................... 		(start_char != 0x10) && // FLASH_PROGRAM_ACTIONS 
.................... 		(start_char != 0x12) && // READ_RS232_VALUE 
.................... 		(start_char != 0x13) && // SET_RS232_VALUE 
.................... 		(start_char != 0x14) && // SET_DEVICE_PROPERTY 
.................... 		(start_char != 0x17) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x15)    // GET_DEVICE_PROPERTY 
.................... 		) 
05ED0:  MOVLB  6
05ED2:  MOVF   xF5,W
05ED4:  SUBLW  02
05ED6:  BZ    5F2E
05ED8:  MOVF   xF5,W
05EDA:  SUBLW  04
05EDC:  BZ    5F2E
05EDE:  MOVF   xF5,W
05EE0:  SUBLW  05
05EE2:  BZ    5F2E
05EE4:  MOVF   xF5,W
05EE6:  SUBLW  07
05EE8:  BZ    5F2E
05EEA:  MOVF   xF5,W
05EEC:  SUBLW  08
05EEE:  BZ    5F2E
05EF0:  MOVF   xF5,W
05EF2:  SUBLW  09
05EF4:  BZ    5F2E
05EF6:  MOVF   xF5,W
05EF8:  SUBLW  10
05EFA:  BZ    5F2E
05EFC:  MOVF   xF5,W
05EFE:  SUBLW  12
05F00:  BZ    5F2E
05F02:  MOVF   xF5,W
05F04:  SUBLW  13
05F06:  BZ    5F2E
05F08:  MOVF   xF5,W
05F0A:  SUBLW  14
05F0C:  BZ    5F2E
05F0E:  MOVF   xF5,W
05F10:  SUBLW  17
05F12:  BZ    5F2E
05F14:  MOVF   xF5,W
05F16:  SUBLW  15
05F18:  BZ    5F2E
.................... 	{ 
.................... 		send_error(ERR_INVALID_START); 
05F1A:  MOVLW  02
05F1C:  MOVLB  7
05F1E:  MOVWF  x2E
05F20:  MOVLB  0
05F22:  CALL   4DE0
.................... 		return; 
05F26:  MOVLB  5
05F28:  GOTO   71FC
05F2C:  MOVLB  6
.................... 	} 
....................  
....................  
.................... 	if(start_char == 0x02) { 
05F2E:  MOVF   xF5,W
05F30:  SUBLW  02
05F32:  BNZ   5F36
.................... 		goto GENERAL; 
05F34:  BRA    5F8A
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x04) { 
05F36:  MOVF   xF5,W
05F38:  SUBLW  04
05F3A:  BNZ   5F3E
.................... 		goto WRITE_DSP_CONFIG_VALUE; 
05F3C:  BRA    6178
.................... 	} 
....................  
.................... 	if(start_char == 0x05) { 
05F3E:  MOVF   xF5,W
05F40:  SUBLW  05
05F42:  BNZ   5F46
.................... 		goto GET_DSP_CONFIG_VALUE; 
05F44:  BRA    641C
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x07) { 
05F46:  MOVF   xF5,W
05F48:  SUBLW  07
05F4A:  BNZ   5F4E
.................... 		goto SEND_DSP_VALUE; 
05F4C:  BRA    6582
.................... 	} 
....................  
.................... 	if(start_char == 0x08) { 
05F4E:  MOVF   xF5,W
05F50:  SUBLW  08
05F52:  BNZ   5F58
.................... 		goto READ_DSP_VALUE; 
05F54:  GOTO   6732
.................... 	} 
....................  
.................... 	//if(start_char == 0x09) { 
.................... 		//goto UTILITY; 
.................... 	//} 
....................  
.................... 	if(start_char == 0x10) { 
05F58:  MOVF   xF5,W
05F5A:  SUBLW  10
05F5C:  BNZ   5F62
.................... 		goto FLASH_PROGRAM_ACTIONS; 
05F5E:  GOTO   685A
.................... 	} 
.................... /* 
.................... 	if(start_char == 0x11) { 
.................... 		goto PHANTOM_POWER_ACTIONS; 
.................... 	} 
.................... */ 
....................  
.................... 	if(start_char == 0x12) { 
05F62:  MOVF   xF5,W
05F64:  SUBLW  12
05F66:  BNZ   5F6C
.................... 		goto READ_RS232_VALUE; 
05F68:  GOTO   6B10
.................... 	} 
....................  
.................... 	if(start_char == 0x13) { 
05F6C:  MOVF   xF5,W
05F6E:  SUBLW  13
05F70:  BNZ   5F76
.................... 		goto SET_RS232_VALUE; 
05F72:  GOTO   6C88
.................... 	} 
....................  
.................... 	if(start_char == 0x14) { 
05F76:  MOVF   xF5,W
05F78:  SUBLW  14
05F7A:  BNZ   5F80
.................... 		goto SET_DEVICE_PROPERTY; 
05F7C:  GOTO   6E40
.................... 	} 
....................  
.................... 	if(start_char == 0x15) { 
05F80:  MOVF   xF5,W
05F82:  SUBLW  15
05F84:  BNZ   5F8A
.................... 		goto GET_DEVICE_PROPERTY; 
05F86:  GOTO   7088
.................... 	} 
....................  
.................... 	 
....................  
.................... 	/* IF YOU ADD A NEW START CHARACTER, UPDATE THE VALID LIST ABOVE */ 
....................  
....................  
.................... GENERAL: 
.................... 	 
.................... 		command_char = timed_getc(); 
05F8A:  MOVLB  0
05F8C:  CALL   4DFC
05F90:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
05F94:  MOVLB  5
05F96:  DECFSZ xA9,W
05F98:  BRA    5FAC
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
05F9A:  MOVLW  10
05F9C:  MOVLB  7
05F9E:  MOVWF  x2E
05FA0:  MOVLB  0
05FA2:  CALL   4DE0
.................... 			return; 
05FA6:  MOVLB  5
05FA8:  GOTO   71FC
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
05FAC:  MOVLB  0
05FAE:  CALL   4DFC
05FB2:  MOVFF  01,6F7
.................... 	 
.................... 		if(timeout_error == true) { 
05FB6:  MOVLB  5
05FB8:  DECFSZ xA9,W
05FBA:  BRA    5FCE
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
05FBC:  MOVLW  11
05FBE:  MOVLB  7
05FC0:  MOVWF  x2E
05FC2:  MOVLB  0
05FC4:  CALL   4DE0
.................... 			return; 
05FC8:  MOVLB  5
05FCA:  GOTO   71FC
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
05FCE:  MOVLB  6
05FD0:  MOVF   xF7,W
05FD2:  SUBLW  03
05FD4:  BZ    5FEA
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
05FD6:  MOVLW  12
05FD8:  MOVLB  7
05FDA:  MOVWF  x2E
05FDC:  MOVLB  0
05FDE:  CALL   4DE0
.................... 			return; 
05FE2:  MOVLB  5
05FE4:  GOTO   71FC
05FE8:  MOVLB  6
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
05FEA:  MOVF   xF6,W
05FEC:  XORLW  01
05FEE:  MOVLB  0
05FF0:  BZ    6010
05FF2:  XORLW  05
05FF4:  BZ    603C
05FF6:  XORLW  01
05FF8:  BZ    607E
05FFA:  XORLW  02
05FFC:  BZ    60AE
05FFE:  XORLW  0F
06000:  BZ    60EA
06002:  XORLW  01
06004:  BTFSC  FD8.2
06006:  BRA    6112
06008:  XORLW  29
0600A:  BTFSC  FD8.2
0600C:  BRA    613E
0600E:  BRA    6164
.................... 			case 0x01 : 
.................... 				// RTS 
.................... 				fputc(0x06,USB); 
06010:  MOVLW  06
06012:  MOVLB  7
06014:  MOVWF  x36
06016:  MOVLB  0
06018:  CALL   4D9A
.................... 				fputc(0x01,USB); 
0601C:  MOVLW  01
0601E:  MOVLB  7
06020:  MOVWF  x36
06022:  MOVLB  0
06024:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06028:  MOVLW  03
0602A:  MOVLB  7
0602C:  MOVWF  x36
0602E:  MOVLB  0
06030:  CALL   4D9A
.................... 				return; 
06034:  MOVLB  5
06036:  GOTO   71FC
.................... 			break; 
0603A:  BRA    6178
....................  
.................... 			case 0x04 : 
.................... 				// DEVICE ID 
.................... 				fputc(0x06,USB); 
0603C:  MOVLW  06
0603E:  MOVLB  7
06040:  MOVWF  x36
06042:  MOVLB  0
06044:  CALL   4D9A
.................... 				fputc(0x04,USB); 
06048:  MOVLW  04
0604A:  MOVLB  7
0604C:  MOVWF  x36
0604E:  MOVLB  0
06050:  CALL   4D9A
.................... 				fputc(DEVICE_ID_MSB,USB); 
06054:  MOVLB  7
06056:  CLRF   x36
06058:  MOVLB  0
0605A:  CALL   4D9A
.................... 				fputc(DEVICE_ID_LSB,USB); 
0605E:  MOVLW  14
06060:  MOVLB  7
06062:  MOVWF  x36
06064:  MOVLB  0
06066:  CALL   4D9A
.................... 				fputc(0x03,USB); 
0606A:  MOVLW  03
0606C:  MOVLB  7
0606E:  MOVWF  x36
06070:  MOVLB  0
06072:  CALL   4D9A
.................... 				return; 
06076:  MOVLB  5
06078:  GOTO   71FC
.................... 			break; 
0607C:  BRA    6178
....................  
.................... 			case 0x05 : 
.................... 				// SOFT REBOOT 
.................... 				softboot(); 
0607E:  CALL   1FBA
.................... 				fputc(0x06,USB); 
06082:  MOVLW  06
06084:  MOVLB  7
06086:  MOVWF  x36
06088:  MOVLB  0
0608A:  CALL   4D9A
.................... 				fputc(0x05,USB); 
0608E:  MOVLW  05
06090:  MOVLB  7
06092:  MOVWF  x36
06094:  MOVLB  0
06096:  CALL   4D9A
.................... 				fputc(0x03,USB); 
0609A:  MOVLW  03
0609C:  MOVLB  7
0609E:  MOVWF  x36
060A0:  MOVLB  0
060A2:  CALL   4D9A
.................... 				return; 
060A6:  MOVLB  5
060A8:  GOTO   71FC
.................... 			break; 
060AC:  BRA    6178
....................  
.................... 			case 0x07 : 
.................... 				// Firmware Version 
....................  
.................... 				fputc(0x06,USB); 
060AE:  MOVLW  06
060B0:  MOVLB  7
060B2:  MOVWF  x36
060B4:  MOVLB  0
060B6:  CALL   4D9A
.................... 				fputc(0x07,USB); 
060BA:  MOVLW  07
060BC:  MOVLB  7
060BE:  MOVWF  x36
060C0:  MOVLB  0
060C2:  CALL   4D9A
.................... 				fputc(MAJOR_REVISION,USB); 
060C6:  MOVFF  39,736
060CA:  CALL   4D9A
.................... 				fputc(MINOR_REVISION,USB); 
060CE:  MOVFF  3A,736
060D2:  CALL   4D9A
.................... 				fputc(0x03,USB); 
060D6:  MOVLW  03
060D8:  MOVLB  7
060DA:  MOVWF  x36
060DC:  MOVLB  0
060DE:  CALL   4D9A
.................... 				return; 
060E2:  MOVLB  5
060E4:  GOTO   71FC
.................... 			break; 
060E8:  BRA    6178
....................  
.................... 			case 0x08 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				fputc(0x06,USB); 
060EA:  MOVLW  06
060EC:  MOVLB  7
060EE:  MOVWF  x36
060F0:  MOVLB  0
060F2:  CALL   4D9A
.................... 				fputc(0x08,USB); 
060F6:  MOVLW  08
060F8:  MOVLB  7
060FA:  MOVWF  x36
060FC:  MOVLB  0
060FE:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06102:  MOVLW  03
06104:  MOVLB  7
06106:  MOVWF  x36
06108:  MOVLB  0
0610A:  CALL   4D9A
.................... 			break; 
0610E:  MOVLB  5
06110:  BRA    6178
....................  
.................... 			case 0x09 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				update_phantom_power(); 
06112:  CALL   1F5E
....................  
.................... 				fputc(0x06,USB); 
06116:  MOVLW  06
06118:  MOVLB  7
0611A:  MOVWF  x36
0611C:  MOVLB  0
0611E:  CALL   4D9A
.................... 				fputc(0x09,USB); 
06122:  MOVLW  09
06124:  MOVLB  7
06126:  MOVWF  x36
06128:  MOVLB  0
0612A:  CALL   4D9A
.................... 				fputc(0x03,USB); 
0612E:  MOVLW  03
06130:  MOVLB  7
06132:  MOVWF  x36
06134:  MOVLB  0
06136:  CALL   4D9A
.................... 			break; 
0613A:  MOVLB  5
0613C:  BRA    6178
....................  
.................... 			case 0x20 : 
.................... 				// Reboot for firmware update 
.................... 				fputc(0x06,USB); 
0613E:  MOVLW  06
06140:  MOVLB  7
06142:  MOVWF  x36
06144:  MOVLB  0
06146:  CALL   4D9A
.................... 				fputc(0x20,USB); 
0614A:  MOVLW  20
0614C:  MOVLB  7
0614E:  MOVWF  x36
06150:  MOVLB  0
06152:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06156:  MOVLW  03
06158:  MOVLB  7
0615A:  MOVWF  x36
0615C:  MOVLB  0
0615E:  CALL   4D9A
.................... 				reset_cpu(); 
06162:  RESET
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
06164:  MOVLW  13
06166:  MOVLB  7
06168:  MOVWF  x2E
0616A:  MOVLB  0
0616C:  CALL   4DE0
.................... 				return; 
06170:  MOVLB  5
06172:  GOTO   71FC
.................... 			break; 
06176:  BRA    6178
.................... 		} 
....................  
.................... WRITE_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
06178:  MOVLB  0
0617A:  CALL   4DFC
0617E:  MOVLB  7
06180:  CLRF   x00
06182:  MOVFF  01,6FF
....................  
.................... 		if(timeout_error == true) { 
06186:  MOVLB  5
06188:  DECFSZ xA9,W
0618A:  BRA    619E
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
0618C:  MOVLW  14
0618E:  MOVLB  7
06190:  MOVWF  x2E
06192:  MOVLB  0
06194:  CALL   4DE0
.................... 			return; 
06198:  MOVLB  5
0619A:  GOTO   71FC
.................... 		} 
....................  
.................... 		addr_lsb = timed_getc(); 
0619E:  MOVLB  0
061A0:  CALL   4DFC
061A4:  MOVLB  6
061A6:  CLRF   xFE
061A8:  MOVFF  01,6FD
....................  
.................... 		if(timeout_error == true) { 
061AC:  MOVLB  5
061AE:  DECFSZ xA9,W
061B0:  BRA    61C4
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
061B2:  MOVLW  14
061B4:  MOVLB  7
061B6:  MOVWF  x2E
061B8:  MOVLB  0
061BA:  CALL   4DE0
.................... 			return; 
061BE:  MOVLB  5
061C0:  GOTO   71FC
.................... 		} 
....................  
....................  
.................... 		if(addr_msb > 0) { 
061C4:  MOVLB  6
061C6:  MOVF   xFF,F
061C8:  BNZ   61D2
061CA:  MOVLB  7
061CC:  MOVF   x00,F
061CE:  BZ    61F8
061D0:  MOVLB  6
.................... 			final_address = 0; 
061D2:  MOVLB  7
061D4:  CLRF   x02
061D6:  CLRF   x01
.................... 			final_address = addr_msb; 
061D8:  MOVFF  700,702
061DC:  MOVFF  6FF,701
.................... 			final_address <<= 8; 
061E0:  MOVFF  701,702
061E4:  CLRF   x01
.................... 			final_address |= addr_lsb; 
061E6:  MOVLB  6
061E8:  MOVF   xFD,W
061EA:  MOVLB  7
061EC:  IORWF  x01,F
061EE:  MOVLB  6
061F0:  MOVF   xFE,W
061F2:  MOVLB  7
061F4:  IORWF  x02,F
.................... 		} else { 
061F6:  BRA    6200
.................... 			final_address = addr_lsb; 
061F8:  MOVFF  6FE,702
061FC:  MOVFF  6FD,701
.................... 		} 
....................  
.................... 		//if((final_address >= 0) && (final_address <= num_dsp_values)) { 
....................  
.................... 			// byte1 is MSB 
.................... 			byte1 = fast_timed_getc(); 
06200:  MOVLB  0
06202:  CALL   4D48
06206:  MOVFF  01,6F8
.................... 			byte2 = fast_timed_getc(); 
0620A:  CALL   4D48
0620E:  MOVFF  01,6F9
.................... 			byte3 = fast_timed_getc(); 
06212:  CALL   4D48
06216:  MOVFF  01,6FA
.................... 			byte4 = fast_timed_getc(); 
0621A:  CALL   4D48
0621E:  MOVFF  01,6FB
....................  
.................... 			if(timeout_error == true) { 
06222:  MOVLB  5
06224:  DECFSZ xA9,W
06226:  BRA    6252
.................... 				// Timed out on one of the bytes 
.................... 				fputc(0x15,USB); 
06228:  MOVLW  15
0622A:  MOVLB  7
0622C:  MOVWF  x36
0622E:  MOVLB  0
06230:  CALL   4D9A
.................... 				fputc(ERR_DATA_TIMEOUT,USB); 
06234:  MOVLW  17
06236:  MOVLB  7
06238:  MOVWF  x36
0623A:  MOVLB  0
0623C:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06240:  MOVLW  03
06242:  MOVLB  7
06244:  MOVWF  x36
06246:  MOVLB  0
06248:  CALL   4D9A
.................... 				return; 
0624C:  MOVLB  5
0624E:  GOTO   71FC
.................... 			}	 
.................... 			 
.................... 			dummy_char = timed_getc(); 
06252:  MOVLB  0
06254:  CALL   4DFC
06258:  MOVFF  01,6F7
.................... 	 
.................... 			if(timeout_error == true) { 
0625C:  MOVLB  5
0625E:  DECFSZ xA9,W
06260:  BRA    628C
.................... 				// Timed out. No command. Start over. 
.................... 				fputc(0x15,USB); 
06262:  MOVLW  15
06264:  MOVLB  7
06266:  MOVWF  x36
06268:  MOVLB  0
0626A:  CALL   4D9A
.................... 				fputc(ERR_END_TIMEOUT,USB); 
0626E:  MOVLW  11
06270:  MOVLB  7
06272:  MOVWF  x36
06274:  MOVLB  0
06276:  CALL   4D9A
.................... 				fputc(0x03,USB); 
0627A:  MOVLW  03
0627C:  MOVLB  7
0627E:  MOVWF  x36
06280:  MOVLB  0
06282:  CALL   4D9A
.................... 				return; 
06286:  MOVLB  5
06288:  GOTO   71FC
.................... 			} 
.................... 	 
.................... 			if(dummy_char != 0x03) { 
0628C:  MOVLB  6
0628E:  MOVF   xF7,W
06290:  SUBLW  03
06292:  BZ    62C0
.................... 				// Ending char not 0x03 
.................... 				fputc(0x15,USB); 
06294:  MOVLW  15
06296:  MOVLB  7
06298:  MOVWF  x36
0629A:  MOVLB  0
0629C:  CALL   4D9A
.................... 				fputc(ERR_END_INVALID,USB); 
062A0:  MOVLW  12
062A2:  MOVLB  7
062A4:  MOVWF  x36
062A6:  MOVLB  0
062A8:  CALL   4D9A
.................... 				fputc(0x03,USB); 
062AC:  MOVLW  03
062AE:  MOVLB  7
062B0:  MOVWF  x36
062B2:  MOVLB  0
062B4:  CALL   4D9A
.................... 				return; 
062B8:  MOVLB  5
062BA:  GOTO   71FC
062BE:  MOVLB  6
.................... 			} 
.................... 			 
.................... 			last_address = final_address; 
062C0:  MOVFF  702,704
062C4:  MOVFF  701,703
.................... 			last_byte1 = byte1; 
062C8:  MOVFF  6F8,6D8
.................... 			last_byte2 = byte2; 
062CC:  MOVFF  6F9,6D9
.................... 			last_byte3 = byte3; 
062D0:  MOVFF  6FA,6DA
.................... 			last_byte4 = byte4; 
062D4:  MOVFF  6FB,6DB
....................  
.................... 			read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
062D8:  MOVFF  702,72F
062DC:  MOVFF  701,72E
062E0:  MOVLB  0
062E2:  CALL   4E4E
062E6:  MOVFF  01,72E
062EA:  MOVLB  7
062EC:  CLRF   x35
062EE:  MOVLW  A1
062F0:  MOVWF  x34
062F2:  MOVFF  A0,736
062F6:  MOVFF  01,737
062FA:  MOVLB  0
062FC:  CALL   14AC
....................  
.................... 			int32 new_dsp_value = 0x00000000 | byte1; 
06300:  MOVFF  6F8,705
06304:  MOVLB  7
06306:  CLRF   x06
06308:  CLRF   x07
0630A:  CLRF   x08
.................... 			new_dsp_value = new_dsp_value << 8; 
0630C:  MOVFF  707,708
06310:  MOVFF  706,707
06314:  MOVFF  705,706
06318:  CLRF   x05
.................... 			new_dsp_value = new_dsp_value | byte2; 
0631A:  MOVLB  6
0631C:  MOVF   xF9,W
0631E:  MOVLB  7
06320:  IORWF  x05,F
.................... 			new_dsp_value = new_dsp_value << 8; 
06322:  MOVFF  707,708
06326:  MOVFF  706,707
0632A:  MOVFF  705,706
0632E:  CLRF   x05
.................... 			new_dsp_value = new_dsp_value | byte3; 
06330:  MOVLB  6
06332:  MOVF   xFA,W
06334:  MOVLB  7
06336:  IORWF  x05,F
.................... 			new_dsp_value = new_dsp_value << 8; 
06338:  MOVFF  707,708
0633C:  MOVFF  706,707
06340:  MOVFF  705,706
06344:  CLRF   x05
.................... 			new_dsp_value = new_dsp_value | byte4; 
06346:  MOVLB  6
06348:  MOVF   xFB,W
0634A:  MOVLB  7
0634C:  IORWF  x05,F
....................  
....................  
.................... 			if(final_address < num_dsp_values) { 
0634E:  MOVF   x02,W
06350:  SUBWF  1A,W
06352:  BNC   6398
06354:  BNZ   635C
06356:  MOVF   19,W
06358:  SUBWF  x01,W
0635A:  BC    6398
.................... 				send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(final_address),new_dsp_value); 
0635C:  MOVFF  702,735
06360:  MOVFF  701,734
06364:  MOVLB  0
06366:  CALL   1BF4
0636A:  MOVFF  02,72F
0636E:  MOVFF  01,72E
06372:  MOVLW  F0
06374:  MOVLB  7
06376:  MOVWF  x3B
06378:  CLRF   x3A
0637A:  MOVFF  02,73D
0637E:  MOVFF  01,73C
06382:  MOVFF  708,741
06386:  MOVFF  707,740
0638A:  MOVFF  706,73F
0638E:  MOVFF  705,73E
06392:  MOVLB  0
06394:  CALL   1DD8
.................... 			} 
.................... 			PAGE_BUFFER_A[addr_index_to_buffer_index(final_address)] = new_dsp_value; 
06398:  MOVFF  702,72F
0639C:  MOVFF  701,72E
063A0:  MOVLB  0
063A2:  GOTO   4E78
063A6:  MOVF   01,W
063A8:  MULLW  04
063AA:  MOVF   FF3,W
063AC:  CLRF   03
063AE:  ADDLW  A1
063B0:  MOVWF  FE9
063B2:  MOVLW  00
063B4:  ADDWFC 03,W
063B6:  MOVWF  FEA
063B8:  MOVFF  705,FEF
063BC:  MOVFF  706,FEC
063C0:  MOVFF  707,FEC
063C4:  MOVFF  708,FEC
....................  
.................... 			write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
063C8:  MOVFF  702,72F
063CC:  MOVFF  701,72E
063D0:  CALL   4E4E
063D4:  MOVFF  01,72E
063D8:  MOVLB  7
063DA:  CLRF   x37
063DC:  MOVLW  A1
063DE:  MOVWF  x36
063E0:  MOVFF  A0,738
063E4:  MOVFF  01,739
063E8:  MOVLB  0
063EA:  CALL   1734
....................  
.................... 			// Send ACK 
.................... 			fputc(0x06,USB); 
063EE:  MOVLW  06
063F0:  MOVLB  7
063F2:  MOVWF  x36
063F4:  MOVLB  0
063F6:  CALL   4D9A
.................... 			fputc(addr_msb,USB); 
063FA:  MOVFF  6FF,736
063FE:  CALL   4D9A
.................... 			fputc(addr_lsb,USB); 
06402:  MOVFF  6FD,736
06406:  CALL   4D9A
.................... 			fputc(0x03,USB);	 
0640A:  MOVLW  03
0640C:  MOVLB  7
0640E:  MOVWF  x36
06410:  MOVLB  0
06412:  CALL   4D9A
.................... 			return; 
06416:  MOVLB  5
06418:  GOTO   71FC
....................  
.................... 		//} else { 
.................... 		//	// Invalid address 
.................... 		//	send_error(ERR_ADDR_INVALID); 
.................... 		//	return; 
.................... 		//} 
....................  
.................... GET_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
0641C:  MOVLB  0
0641E:  CALL   4DFC
06422:  MOVLB  7
06424:  CLRF   x00
06426:  MOVFF  01,6FF
....................  
.................... 		if(timeout_error == true) { 
0642A:  MOVLB  5
0642C:  DECFSZ xA9,W
0642E:  BRA    6442
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
06430:  MOVLW  14
06432:  MOVLB  7
06434:  MOVWF  x2E
06436:  MOVLB  0
06438:  CALL   4DE0
.................... 			return; 
0643C:  MOVLB  5
0643E:  GOTO   71FC
.................... 		} 
....................  
.................... 		//printf("Got address 1 %u\r\n",addr_index); 
....................  
.................... 		addr_lsb = timed_getc(); 
06442:  MOVLB  0
06444:  CALL   4DFC
06448:  MOVLB  6
0644A:  CLRF   xFE
0644C:  MOVFF  01,6FD
....................  
.................... 		if(timeout_error == true) { 
06450:  MOVLB  5
06452:  DECFSZ xA9,W
06454:  BRA    6468
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
06456:  MOVLW  14
06458:  MOVLB  7
0645A:  MOVWF  x2E
0645C:  MOVLB  0
0645E:  CALL   4DE0
.................... 			return; 
06462:  MOVLB  5
06464:  GOTO   71FC
.................... 		} 
....................  
.................... 		//printf("Got address 2 %u\r\n",addr_index); 
....................  
.................... 		if(addr_lsb == 255) { 
06468:  MOVLB  6
0646A:  INCFSZ xFD,W
0646C:  BRA    6498
0646E:  MOVF   xFE,F
06470:  BNZ   6498
.................... 			final_address = 0; 
06472:  MOVLB  7
06474:  CLRF   x02
06476:  CLRF   x01
.................... 			final_address += addr_msb; 
06478:  MOVLB  6
0647A:  MOVF   xFF,W
0647C:  MOVLB  7
0647E:  ADDWF  x01,F
06480:  MOVF   x00,W
06482:  ADDWFC x02,F
.................... 			final_address += addr_lsb; 
06484:  MOVLB  6
06486:  MOVF   xFD,W
06488:  MOVLB  7
0648A:  ADDWF  x01,F
0648C:  MOVLB  6
0648E:  MOVF   xFE,W
06490:  MOVLB  7
06492:  ADDWFC x02,F
.................... 		} else { 
06494:  BRA    64A0
06496:  MOVLB  6
.................... 			final_address = addr_lsb; 
06498:  MOVFF  6FE,702
0649C:  MOVFF  6FD,701
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
064A0:  MOVLB  0
064A2:  CALL   4DFC
064A6:  MOVFF  01,6F7
....................  
....................  
.................... 		if(timeout_error == true) { 
064AA:  MOVLB  5
064AC:  DECFSZ xA9,W
064AE:  BRA    64C2
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
064B0:  MOVLW  11
064B2:  MOVLB  7
064B4:  MOVWF  x2E
064B6:  MOVLB  0
064B8:  CALL   4DE0
.................... 			return; 
064BC:  MOVLB  5
064BE:  GOTO   71FC
.................... 		} 
.................... 		 
.................... 		if(dummy_char != 0x03) { 
064C2:  MOVLB  6
064C4:  MOVF   xF7,W
064C6:  SUBLW  03
064C8:  BZ    64DC
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
064CA:  MOVLW  12
064CC:  MOVLB  7
064CE:  MOVWF  x2E
064D0:  MOVLB  0
064D2:  CALL   4DE0
.................... 			return; 
064D6:  MOVLB  5
064D8:  GOTO   71FC
.................... 		} 
....................  
.................... 		if((final_address >= 0) && (final_address <= num_dsp_values)) { 
064DC:  MOVLB  7
064DE:  MOVF   x02,W
064E0:  SUBWF  1A,W
064E2:  BNC   6570
064E4:  BNZ   64EC
064E6:  MOVF   x01,W
064E8:  SUBWF  19,W
064EA:  BNC   6570
....................  
.................... 			// TODO - Re-implement 
.................... 			//int32 value = READ_CONFIG_VALUE(final_address); 
.................... 	 
.................... 			int32 value = 0; 
....................  
.................... 			char byte4 = value & 0xFF; 
064EC:  CLRF   x0C
064EE:  CLRF   x0B
064F0:  CLRF   x0A
064F2:  CLRF   x09
064F4:  MOVFF  709,70D
.................... 			value = value >> 8; 
064F8:  MOVFF  70A,709
064FC:  MOVFF  70B,70A
06500:  MOVFF  70C,70B
06504:  CLRF   x0C
.................... 		 
.................... 			char byte3 = value & 0xFF; 
06506:  MOVFF  709,70E
.................... 			value = value >> 8; 
0650A:  MOVFF  70A,709
0650E:  MOVFF  70B,70A
06512:  MOVFF  70C,70B
06516:  CLRF   x0C
.................... 			 
.................... 			char byte2 = value & 0xFF; 
.................... 			char byte1 = value >> 8; 
06518:  MOVFF  709,70F
0651C:  MOVFF  70A,710
.................... 		 
.................... 			fputc(0x06,USB); 
06520:  MOVLW  06
06522:  MOVWF  x36
06524:  MOVLB  0
06526:  CALL   4D9A
.................... 			fputc(addr_msb,USB); 
0652A:  MOVFF  6FF,736
0652E:  CALL   4D9A
.................... 			fputc(addr_lsb,USB); 
06532:  MOVFF  6FD,736
06536:  CALL   4D9A
.................... 			fputc(byte1,USB); 
0653A:  MOVFF  710,736
0653E:  CALL   4D9A
.................... 			fputc(byte2,USB); 
06542:  MOVFF  70F,736
06546:  CALL   4D9A
.................... 			fputc(byte3,USB); 
0654A:  MOVFF  70E,736
0654E:  CALL   4D9A
.................... 			fputc(byte4,USB); 
06552:  MOVFF  70D,736
06556:  CALL   4D9A
.................... 			fputc(0x03,USB); 
0655A:  MOVLW  03
0655C:  MOVLB  7
0655E:  MOVWF  x36
06560:  MOVLB  0
06562:  CALL   4D9A
.................... 			return; 
06566:  MOVLB  5
06568:  GOTO   71FC
.................... 	 
.................... 		} else { 
0656C:  BRA    6580
0656E:  MOVLB  7
.................... 			// Invalid address 
.................... 			send_error(ERR_ADDR_INVALID); 
06570:  MOVLW  16
06572:  MOVWF  x2E
06574:  MOVLB  0
06576:  CALL   4DE0
.................... 			return; 
0657A:  MOVLB  5
0657C:  GOTO   71FC
06580:  MOVLB  6
.................... 		} 
....................  
.................... 	// END GET_VALUE label 
....................  
.................... SEND_DSP_VALUE: 
....................  
.................... 		byte addr_byte1,addr_byte2,addr_byte3,addr_byte4; 
.................... 		byte val_byte1,val_byte2,val_byte3,val_byte4; 
....................  
.................... 		addr_byte1 = fast_timed_getc(); 
06582:  MOVLB  0
06584:  CALL   4D48
06588:  MOVFF  01,711
.................... 		addr_byte2 = fast_timed_getc(); 
0658C:  CALL   4D48
06590:  MOVFF  01,712
.................... 		addr_byte3 = fast_timed_getc(); 
06594:  CALL   4D48
06598:  MOVFF  01,713
.................... 		addr_byte4 = fast_timed_getc(); 
0659C:  CALL   4D48
065A0:  MOVFF  01,714
....................  
.................... 		val_byte1 = fast_timed_getc(); 
065A4:  CALL   4D48
065A8:  MOVFF  01,715
.................... 		val_byte2 = fast_timed_getc(); 
065AC:  CALL   4D48
065B0:  MOVFF  01,716
.................... 		val_byte3 = fast_timed_getc(); 
065B4:  CALL   4D48
065B8:  MOVFF  01,717
.................... 		val_byte4 = fast_timed_getc(); 
065BC:  CALL   4D48
065C0:  MOVFF  01,718
....................  
.................... 		if(timeout_error == true) { 
065C4:  MOVLB  5
065C6:  DECFSZ xA9,W
065C8:  BRA    65F4
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
065CA:  MOVLW  15
065CC:  MOVLB  7
065CE:  MOVWF  x36
065D0:  MOVLB  0
065D2:  CALL   4D9A
.................... 			fputc(0x17,USB); 
065D6:  MOVLW  17
065D8:  MOVLB  7
065DA:  MOVWF  x36
065DC:  MOVLB  0
065DE:  CALL   4D9A
.................... 			fputc(0x03,USB); 
065E2:  MOVLW  03
065E4:  MOVLB  7
065E6:  MOVWF  x36
065E8:  MOVLB  0
065EA:  CALL   4D9A
.................... 			return; 
065EE:  MOVLB  5
065F0:  GOTO   71FC
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
065F4:  MOVLB  0
065F6:  CALL   4DFC
065FA:  MOVFF  01,6F7
....................  
.................... 		if(timeout_error == true) { 
065FE:  MOVLB  5
06600:  DECFSZ xA9,W
06602:  BRA    662E
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
06604:  MOVLW  15
06606:  MOVLB  7
06608:  MOVWF  x36
0660A:  MOVLB  0
0660C:  CALL   4D9A
.................... 			fputc(ERR_END_TIMEOUT,USB); 
06610:  MOVLW  11
06612:  MOVLB  7
06614:  MOVWF  x36
06616:  MOVLB  0
06618:  CALL   4D9A
.................... 			fputc(0x03,USB); 
0661C:  MOVLW  03
0661E:  MOVLB  7
06620:  MOVWF  x36
06622:  MOVLB  0
06624:  CALL   4D9A
.................... 			return; 
06628:  MOVLB  5
0662A:  GOTO   71FC
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
0662E:  MOVLB  6
06630:  MOVF   xF7,W
06632:  SUBLW  03
06634:  BZ    6660
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
06636:  MOVLW  15
06638:  MOVLB  7
0663A:  MOVWF  x36
0663C:  MOVLB  0
0663E:  CALL   4D9A
.................... 			fputc(0x13,USB); 
06642:  MOVLW  13
06644:  MOVLB  7
06646:  MOVWF  x36
06648:  MOVLB  0
0664A:  CALL   4D9A
.................... 			fputc(0x03,USB); 
0664E:  MOVLW  03
06650:  MOVLB  7
06652:  MOVWF  x36
06654:  MOVLB  0
06656:  CALL   4D9A
.................... 			return; 
0665A:  MOVLB  5
0665C:  GOTO   71FC
.................... 		} 
....................  
.................... 		 
....................  
.................... 		int32 debug_address = 0x00000000 | addr_byte1; 
06660:  MOVLB  7
06662:  MOVFF  711,719
06666:  CLRF   x1A
06668:  CLRF   x1B
0666A:  CLRF   x1C
.................... 		debug_address = debug_address << 8; 
0666C:  MOVFF  71B,71C
06670:  MOVFF  71A,71B
06674:  MOVFF  719,71A
06678:  CLRF   x19
.................... 		debug_address = debug_address | addr_byte2; 
0667A:  MOVF   x12,W
0667C:  IORWF  x19,F
.................... 		debug_address = debug_address << 8; 
0667E:  MOVFF  71B,71C
06682:  MOVFF  71A,71B
06686:  MOVFF  719,71A
0668A:  CLRF   x19
.................... 		debug_address = debug_address | addr_byte3; 
0668C:  MOVF   x13,W
0668E:  IORWF  x19,F
.................... 		debug_address = debug_address << 8; 
06690:  MOVFF  71B,71C
06694:  MOVFF  71A,71B
06698:  MOVFF  719,71A
0669C:  CLRF   x19
.................... 		debug_address = debug_address | addr_byte4; 
0669E:  MOVF   x14,W
066A0:  IORWF  x19,F
....................  
.................... 		int32 debug_value = 0x00000000 | val_byte1; 
066A2:  MOVFF  715,71D
066A6:  CLRF   x1E
066A8:  CLRF   x1F
066AA:  CLRF   x20
.................... 		debug_value = debug_value << 8; 
066AC:  MOVFF  71F,720
066B0:  MOVFF  71E,71F
066B4:  MOVFF  71D,71E
066B8:  CLRF   x1D
.................... 		debug_value = debug_value | val_byte2; 
066BA:  MOVF   x16,W
066BC:  IORWF  x1D,F
.................... 		debug_value = debug_value << 8; 
066BE:  MOVFF  71F,720
066C2:  MOVFF  71E,71F
066C6:  MOVFF  71D,71E
066CA:  CLRF   x1D
.................... 		debug_value = debug_value | val_byte3; 
066CC:  MOVF   x17,W
066CE:  IORWF  x1D,F
.................... 		debug_value = debug_value << 8; 
066D0:  MOVFF  71F,720
066D4:  MOVFF  71E,71F
066D8:  MOVFF  71D,71E
066DC:  CLRF   x1D
.................... 		debug_value = debug_value | val_byte4; 
066DE:  MOVF   x18,W
066E0:  IORWF  x1D,F
.................... 			 
.................... 		send_dsp_command(debug_address,debug_value); 
066E2:  MOVFF  71C,73C
066E6:  MOVFF  71B,73B
066EA:  MOVFF  71A,73A
066EE:  MOVFF  719,739
066F2:  MOVFF  720,740
066F6:  MOVFF  71F,73F
066FA:  MOVFF  71E,73E
066FE:  MOVFF  71D,73D
06702:  MOVLB  0
06704:  CALL   1B64
....................  
.................... 		fputc(0x06); 
06708:  MOVLW  06
0670A:  MOVLB  7
0670C:  MOVWF  x36
0670E:  MOVLB  0
06710:  CALL   4D9A
.................... 		fputc(0x07); 
06714:  MOVLW  07
06716:  MOVLB  7
06718:  MOVWF  x36
0671A:  MOVLB  0
0671C:  CALL   4D9A
.................... 		fputc(0x03); 
06720:  MOVLW  03
06722:  MOVLB  7
06724:  MOVWF  x36
06726:  MOVLB  0
06728:  CALL   4D9A
....................  
....................  
.................... 		return; 
0672C:  MOVLB  5
0672E:  GOTO   71FC
....................  
.................... READ_DSP_VALUE: 
....................  
.................... 		byte1 = fast_timed_getc(); 
06732:  MOVLB  0
06734:  CALL   4D48
06738:  MOVFF  01,6F8
.................... 		byte2 = fast_timed_getc(); 
0673C:  CALL   4D48
06740:  MOVFF  01,6F9
.................... 		byte3 = fast_timed_getc(); 
06744:  CALL   4D48
06748:  MOVFF  01,6FA
.................... 		byte4 = fast_timed_getc(); 
0674C:  CALL   4D48
06750:  MOVFF  01,6FB
....................  
.................... 		if(timeout_error == true) { 
06754:  MOVLB  5
06756:  DECFSZ xA9,W
06758:  BRA    6784
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
0675A:  MOVLW  15
0675C:  MOVLB  7
0675E:  MOVWF  x36
06760:  MOVLB  0
06762:  CALL   4D9A
.................... 			fputc(0x17,USB); 
06766:  MOVLW  17
06768:  MOVLB  7
0676A:  MOVWF  x36
0676C:  MOVLB  0
0676E:  CALL   4D9A
.................... 			fputc(0x03,USB); 
06772:  MOVLW  03
06774:  MOVLB  7
06776:  MOVWF  x36
06778:  MOVLB  0
0677A:  CALL   4D9A
.................... 			return; 
0677E:  MOVLB  5
06780:  GOTO   71FC
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
06784:  MOVLB  0
06786:  CALL   4DFC
0678A:  MOVFF  01,6F7
....................  
.................... 		if(timeout_error == true) { 
0678E:  MOVLB  5
06790:  DECFSZ xA9,W
06792:  BRA    67BE
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
06794:  MOVLW  15
06796:  MOVLB  7
06798:  MOVWF  x36
0679A:  MOVLB  0
0679C:  CALL   4D9A
.................... 			fputc(ERR_END_TIMEOUT,USB); 
067A0:  MOVLW  11
067A2:  MOVLB  7
067A4:  MOVWF  x36
067A6:  MOVLB  0
067A8:  CALL   4D9A
.................... 			fputc(0x03,USB); 
067AC:  MOVLW  03
067AE:  MOVLB  7
067B0:  MOVWF  x36
067B2:  MOVLB  0
067B4:  CALL   4D9A
.................... 			return; 
067B8:  MOVLB  5
067BA:  GOTO   71FC
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
067BE:  MOVLB  6
067C0:  MOVF   xF7,W
067C2:  SUBLW  03
067C4:  BZ    67F0
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
067C6:  MOVLW  15
067C8:  MOVLB  7
067CA:  MOVWF  x36
067CC:  MOVLB  0
067CE:  CALL   4D9A
.................... 			fputc(0x13,USB); 
067D2:  MOVLW  13
067D4:  MOVLB  7
067D6:  MOVWF  x36
067D8:  MOVLB  0
067DA:  CALL   4D9A
.................... 			fputc(0x03,USB); 
067DE:  MOVLW  03
067E0:  MOVLB  7
067E2:  MOVWF  x36
067E4:  MOVLB  0
067E6:  CALL   4D9A
.................... 			return; 
067EA:  MOVLB  5
067EC:  GOTO   71FC
.................... 		} 
....................  
.................... 		int32 address = 0x00000000 | byte1; 
067F0:  MOVFF  6F8,721
067F4:  MOVLB  7
067F6:  CLRF   x22
067F8:  CLRF   x23
067FA:  CLRF   x24
.................... 		address = address << 8; 
067FC:  MOVFF  723,724
06800:  MOVFF  722,723
06804:  MOVFF  721,722
06808:  CLRF   x21
.................... 		address = address | byte2; 
0680A:  MOVLB  6
0680C:  MOVF   xF9,W
0680E:  MOVLB  7
06810:  IORWF  x21,F
.................... 		address = address << 8; 
06812:  MOVFF  723,724
06816:  MOVFF  722,723
0681A:  MOVFF  721,722
0681E:  CLRF   x21
.................... 		address = address | byte3; 
06820:  MOVLB  6
06822:  MOVF   xFA,W
06824:  MOVLB  7
06826:  IORWF  x21,F
.................... 		address = address << 8; 
06828:  MOVFF  723,724
0682C:  MOVFF  722,723
06830:  MOVFF  721,722
06834:  CLRF   x21
.................... 		address = address | byte4; 
06836:  MOVLB  6
06838:  MOVF   xFB,W
0683A:  MOVLB  7
0683C:  IORWF  x21,F
.................... 			 
.................... 		read_dsp_and_send_to_usb(address); 
0683E:  MOVFF  724,731
06842:  MOVFF  723,730
06846:  MOVFF  722,72F
0684A:  MOVFF  721,72E
0684E:  MOVLB  0
06850:  GOTO   4EF4
....................  
.................... 		return; 
06854:  MOVLB  5
06856:  GOTO   71FC
....................  
....................  
....................  
.................... FLASH_PROGRAM_ACTIONS: 
....................  
.................... 		command_char = timed_getc(); 
0685A:  MOVLB  0
0685C:  CALL   4DFC
06860:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
06864:  MOVLB  5
06866:  DECFSZ xA9,W
06868:  BRA    687C
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
0686A:  MOVLW  10
0686C:  MOVLB  7
0686E:  MOVWF  x2E
06870:  MOVLB  0
06872:  CALL   4DE0
.................... 			return; 
06876:  MOVLB  5
06878:  GOTO   71FC
.................... 		} 
....................  
.................... 		if(command_char == 0x04 || command_char == 0x05 || command_char == 0x09 || command_char == 0x11) { 
0687C:  MOVLB  6
0687E:  MOVF   xF6,W
06880:  SUBLW  04
06882:  BZ    6896
06884:  MOVF   xF6,W
06886:  SUBLW  05
06888:  BZ    6896
0688A:  MOVF   xF6,W
0688C:  SUBLW  09
0688E:  BZ    6896
06890:  MOVF   xF6,W
06892:  SUBLW  11
06894:  BNZ   68B4
.................... 			addr_msb = timed_getc(); 
06896:  MOVLB  0
06898:  CALL   4DFC
0689C:  MOVLB  7
0689E:  CLRF   x00
068A0:  MOVFF  01,6FF
.................... 			addr_lsb = timed_getc(); 
068A4:  MOVLB  0
068A6:  CALL   4DFC
068AA:  MOVLB  6
068AC:  CLRF   xFE
068AE:  MOVFF  01,6FD
.................... 		} else { 
068B2:  BRA    68BE
.................... 			temp_byte = timed_getc(); 
068B4:  MOVLB  0
068B6:  CALL   4DFC
068BA:  MOVFF  01,6DE
....................  
.................... 		} 
.................... 	 
.................... 		if(timeout_error == true) { 
068BE:  MOVLB  5
068C0:  DECFSZ xA9,W
068C2:  BRA    68D6
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
068C4:  MOVLW  17
068C6:  MOVLB  7
068C8:  MOVWF  x2E
068CA:  MOVLB  0
068CC:  CALL   4DE0
.................... 			return; 
068D0:  MOVLB  5
068D2:  GOTO   71FC
.................... 		} 
.................... 		 
.................... 	 
.................... 		 
....................  
.................... 		char stream_size_msb,stream_size_lsb; 
....................  
.................... 		if(command_char == 0x11) { 
068D6:  MOVLB  6
068D8:  MOVF   xF6,W
068DA:  SUBLW  11
068DC:  BNZ   68F0
.................... 			stream_size_msb = timed_getc(); 
068DE:  MOVLB  0
068E0:  CALL   4DFC
068E4:  MOVFF  01,725
.................... 			stream_size_lsb = timed_getc(); 
068E8:  CALL   4DFC
068EC:  MOVFF  01,726
.................... 		}	 
....................  
.................... 		dummy_char = timed_getc(); 
068F0:  MOVLB  0
068F2:  CALL   4DFC
068F6:  MOVFF  01,6F7
....................  
.................... 		if(timeout_error == true) { 
068FA:  MOVLB  5
068FC:  DECFSZ xA9,W
068FE:  BRA    6912
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
06900:  MOVLW  11
06902:  MOVLB  7
06904:  MOVWF  x2E
06906:  MOVLB  0
06908:  CALL   4DE0
.................... 			return; 
0690C:  MOVLB  5
0690E:  GOTO   71FC
.................... 		} 
....................  
.................... 		switch(command_char) { 
06912:  MOVLB  6
06914:  MOVF   xF6,W
06916:  XORLW  01
06918:  MOVLB  0
0691A:  BZ    693C
0691C:  XORLW  03
0691E:  BZ    6978
06920:  XORLW  06
06922:  BZ    69B0
06924:  XORLW  01
06926:  BZ    69EC
06928:  XORLW  0D
0692A:  BTFSC  FD8.2
0692C:  BRA    6A34
0692E:  XORLW  01
06930:  BTFSC  FD8.2
06932:  BRA    6A68
06934:  XORLW  18
06936:  BTFSC  FD8.2
06938:  BRA    6ACC
0693A:  BRA    6AFE
....................  
.................... 			case 0x01 : 
.................... 				// SWITCH ACTIVE PROGRAM 
.................... 				switch_flash_program(temp_byte); 
0693C:  MOVFF  6DE,72E
06940:  CALL   5056
.................... 				fputc(0x06,USB); 
06944:  MOVLW  06
06946:  MOVLB  7
06948:  MOVWF  x36
0694A:  MOVLB  0
0694C:  CALL   4D9A
.................... 				fputc(0x01,USB); 
06950:  MOVLW  01
06952:  MOVLB  7
06954:  MOVWF  x36
06956:  MOVLB  0
06958:  CALL   4D9A
.................... 				fputc(temp_byte,USB); 
0695C:  MOVFF  6DE,736
06960:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06964:  MOVLW  03
06966:  MOVLB  7
06968:  MOVWF  x36
0696A:  MOVLB  0
0696C:  CALL   4D9A
.................... 				return; 
06970:  MOVLB  5
06972:  GOTO   71FC
.................... 			break; 
06976:  BRA    6B10
....................  
.................... 			case 0x02 : 
.................... 				// SAVE ACTIVE PROGRAM 
....................  
.................... 				save_flash_program(); 
06978:  GOTO   5098
....................  
.................... 				fputc(0x06,USB); 
0697C:  MOVLW  06
0697E:  MOVLB  7
06980:  MOVWF  x36
06982:  MOVLB  0
06984:  CALL   4D9A
.................... 				fputc(0x02,USB); 
06988:  MOVLW  02
0698A:  MOVLB  7
0698C:  MOVWF  x36
0698E:  MOVLB  0
06990:  CALL   4D9A
.................... 				fputc(temp_byte,USB); 
06994:  MOVFF  6DE,736
06998:  CALL   4D9A
.................... 				fputc(0x03,USB); 
0699C:  MOVLW  03
0699E:  MOVLB  7
069A0:  MOVWF  x36
069A2:  MOVLB  0
069A4:  CALL   4D9A
.................... 				return; 
069A8:  MOVLB  5
069AA:  GOTO   71FC
.................... 			break; 
069AE:  BRA    6B10
....................  
.................... 			case 0x04 : 
....................  
.................... 				// SAVE ACTIVE SECTOR 
....................  
.................... 				fputc(0x06,USB); 
069B0:  MOVLW  06
069B2:  MOVLB  7
069B4:  MOVWF  x36
069B6:  MOVLB  0
069B8:  CALL   4D9A
.................... 				fputc(0x05,USB); 
069BC:  MOVLW  05
069BE:  MOVLB  7
069C0:  MOVWF  x36
069C2:  MOVLB  0
069C4:  CALL   4D9A
.................... 				fputc(addr_msb,USB); 
069C8:  MOVFF  6FF,736
069CC:  CALL   4D9A
.................... 				fputc(addr_lsb,USB); 
069D0:  MOVFF  6FD,736
069D4:  CALL   4D9A
.................... 				fputc(0x03,USB); 
069D8:  MOVLW  03
069DA:  MOVLB  7
069DC:  MOVWF  x36
069DE:  MOVLB  0
069E0:  CALL   4D9A
.................... 				return; 
069E4:  MOVLB  5
069E6:  GOTO   71FC
.................... 			break; 
069EA:  BRA    6B10
....................  
.................... 			case 0x05 : 
....................  
.................... 				FLASH_COPY_PROGRAM(addr_msb,addr_lsb); 
069EC:  MOVFF  6FF,72E
069F0:  MOVFF  6FD,72F
069F4:  GOTO   509C
....................  
.................... 				fputc(0x06,USB); 
069F8:  MOVLW  06
069FA:  MOVLB  7
069FC:  MOVWF  x36
069FE:  MOVLB  0
06A00:  CALL   4D9A
.................... 				fputc(0x05,USB); 
06A04:  MOVLW  05
06A06:  MOVLB  7
06A08:  MOVWF  x36
06A0A:  MOVLB  0
06A0C:  CALL   4D9A
.................... 				fputc(addr_msb,USB); 
06A10:  MOVFF  6FF,736
06A14:  CALL   4D9A
.................... 				fputc(addr_lsb,USB); 
06A18:  MOVFF  6FD,736
06A1C:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06A20:  MOVLW  03
06A22:  MOVLB  7
06A24:  MOVWF  x36
06A26:  MOVLB  0
06A28:  CALL   4D9A
.................... 				return; 
06A2C:  MOVLB  5
06A2E:  GOTO   71FC
.................... 			break; 
06A32:  BRA    6B10
....................  
....................  
.................... 			case 0x08 : 
....................  
.................... 				// GET ACTIVE PROGRAM INDEX 
....................  
.................... 				fputc(0x06,USB); 
06A34:  MOVLW  06
06A36:  MOVLB  7
06A38:  MOVWF  x36
06A3A:  MOVLB  0
06A3C:  CALL   4D9A
.................... 				fputc(0x08,USB); 
06A40:  MOVLW  08
06A42:  MOVLB  7
06A44:  MOVWF  x36
06A46:  MOVLB  0
06A48:  CALL   4D9A
.................... 				fputc(CURRENT_FLASH_PROGRAM,USB); 
06A4C:  MOVFF  A0,736
06A50:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06A54:  MOVLW  03
06A56:  MOVLB  7
06A58:  MOVWF  x36
06A5A:  MOVLB  0
06A5C:  CALL   4D9A
.................... 				return; 
06A60:  MOVLB  5
06A62:  GOTO   71FC
.................... 			break; 
06A66:  BRA    6B10
....................  
.................... 			case 0x09 : 
....................  
.................... 				// STREAM PROGRAM BLOCK TO USB 
....................  
.................... 				read_flash_page_into_buffer(&PAGE_BUFFER_A,addr_msb,addr_lsb); 
06A68:  MOVLB  7
06A6A:  CLRF   x35
06A6C:  MOVLW  A1
06A6E:  MOVWF  x34
06A70:  MOVFF  6FF,736
06A74:  MOVFF  6FD,737
06A78:  MOVLB  0
06A7A:  CALL   14AC
....................  
.................... 				fputc(0x06,USB); 
06A7E:  MOVLW  06
06A80:  MOVLB  7
06A82:  MOVWF  x36
06A84:  MOVLB  0
06A86:  CALL   4D9A
.................... 				fputc(0x09,USB); 
06A8A:  MOVLW  09
06A8C:  MOVLB  7
06A8E:  MOVWF  x36
06A90:  MOVLB  0
06A92:  CALL   4D9A
.................... 				fputc(addr_msb,USB); 
06A96:  MOVFF  6FF,736
06A9A:  CALL   4D9A
.................... 				fputc(addr_lsb,USB); 
06A9E:  MOVFF  6FD,736
06AA2:  CALL   4D9A
....................  
.................... 				write_buffer_to_stream(&PAGE_BUFFER_A); 
06AA6:  MOVLB  7
06AA8:  CLRF   x2F
06AAA:  MOVLW  A1
06AAC:  MOVWF  x2E
06AAE:  MOVLW  01
06AB0:  MOVWF  x30
06AB2:  MOVLB  0
06AB4:  GOTO   5318
....................  
.................... 				fputc(0x03,USB); 
06AB8:  MOVLW  03
06ABA:  MOVLB  7
06ABC:  MOVWF  x36
06ABE:  MOVLB  0
06AC0:  CALL   4D9A
.................... 				return; 
06AC4:  MOVLB  5
06AC6:  GOTO   71FC
.................... 			break; 
06ACA:  BRA    6B10
....................  
.................... 			case 0x11 : 
.................... 				 
.................... 				 
.................... 				int16 stream_size = 0; 
06ACC:  MOVLB  7
06ACE:  CLRF   x28
06AD0:  CLRF   x27
.................... 		 
.................... 				//fprintf(RS232,"Stream size MSB = %x, Stream size LSB = %x\r\n",stream_size_msb,stream_size_lsb); 
.................... 				stream_size = stream_size | stream_size_msb; 
06AD2:  MOVF   x25,W
06AD4:  IORWF  x27,F
.................... 				stream_size <<= 8; 
06AD6:  MOVFF  727,728
06ADA:  CLRF   x27
.................... 				stream_size = stream_size | stream_size_lsb; 
06ADC:  MOVF   x26,W
06ADE:  IORWF  x27,F
....................  
.................... 				/*if(data_available_usb()) { 
.................... 					fprintf(RS232,"Data still available on USB...\r\n"); 
.................... 				} else { 
.................... 					fprintf(RS232,"NO data available on USB...\r\n"); 
.................... 				} 
.................... */ 
.................... 				// initiate_stream(int target_program, int target_page, int16 num_bytes) 
.................... 				//initiate_stream(addr_msb,addr_lsb,stream_size); 
.................... 				perform_stream(addr_msb,addr_lsb,stream_size); 
06AE0:  MOVFF  6FF,72E
06AE4:  MOVFF  6FD,72F
06AE8:  MOVFF  728,731
06AEC:  MOVFF  727,730
06AF0:  MOVLB  0
06AF2:  GOTO   54D0
.................... 				return; 
06AF6:  MOVLB  5
06AF8:  GOTO   71FC
.................... 				 
....................  
.................... 			break; 
06AFC:  BRA    6B10
....................  
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
06AFE:  MOVLW  13
06B00:  MOVLB  7
06B02:  MOVWF  x2E
06B04:  MOVLB  0
06B06:  CALL   4DE0
.................... 				return; 
06B0A:  MOVLB  5
06B0C:  BRA    71FC
.................... 			break; 
06B0E:  BRA    6B10
....................  
.................... 		} 
....................  
.................... READ_RS232_VALUE: 
.................... 	 
.................... 		command_char = timed_getc(); 
06B10:  MOVLB  0
06B12:  CALL   4DFC
06B16:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
06B1A:  MOVLB  5
06B1C:  DECFSZ xA9,W
06B1E:  BRA    6B30
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
06B20:  MOVLW  10
06B22:  MOVLB  7
06B24:  MOVWF  x2E
06B26:  MOVLB  0
06B28:  CALL   4DE0
.................... 			return; 
06B2C:  MOVLB  5
06B2E:  BRA    71FC
.................... 		} 
....................  
.................... 		channel = timed_getc(); 
06B30:  MOVLB  0
06B32:  CALL   4DFC
06B36:  MOVFF  01,6FC
....................  
.................... 		if(timeout_error == true) { 
06B3A:  MOVLB  5
06B3C:  DECFSZ xA9,W
06B3E:  BRA    6B50
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_RS232_CH_TIMEOUT); 
06B40:  MOVLW  26
06B42:  MOVLB  7
06B44:  MOVWF  x2E
06B46:  MOVLB  0
06B48:  CALL   4DE0
.................... 			return; 
06B4C:  MOVLB  5
06B4E:  BRA    71FC
.................... 		} 
....................  
.................... 		// TODO - this is zero based but use NUM_CHANNELS later 
.................... 		if(channel > 4) { 
06B50:  MOVLB  6
06B52:  MOVF   xFC,W
06B54:  SUBLW  04
06B56:  BC    6B68
.................... 			send_error(ERR_RS232_CH_INVALID); 
06B58:  MOVLW  27
06B5A:  MOVLB  7
06B5C:  MOVWF  x2E
06B5E:  MOVLB  0
06B60:  CALL   4DE0
.................... 			return; 
06B64:  MOVLB  5
06B66:  BRA    71FC
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
06B68:  MOVLB  0
06B6A:  CALL   4DFC
06B6E:  MOVFF  01,6F7
.................... 	 
.................... 		if(timeout_error == true) { 
06B72:  MOVLB  5
06B74:  DECFSZ xA9,W
06B76:  BRA    6B88
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
06B78:  MOVLW  11
06B7A:  MOVLB  7
06B7C:  MOVWF  x2E
06B7E:  MOVLB  0
06B80:  CALL   4DE0
.................... 			return; 
06B84:  MOVLB  5
06B86:  BRA    71FC
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
06B88:  MOVLB  6
06B8A:  MOVF   xF7,W
06B8C:  SUBLW  03
06B8E:  BZ    6BA2
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
06B90:  MOVLW  12
06B92:  MOVLB  7
06B94:  MOVWF  x2E
06B96:  MOVLB  0
06B98:  CALL   4DE0
.................... 			return; 
06B9C:  MOVLB  5
06B9E:  BRA    71FC
06BA0:  MOVLB  6
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
06BA2:  MOVF   xF6,W
06BA4:  XORLW  01
06BA6:  MOVLB  0
06BA8:  BZ    6BB0
06BAA:  XORLW  03
06BAC:  BZ    6BEE
06BAE:  BRA    6C76
.................... 			case 0x01 : 
.................... 				// MUTE STATUS 
.................... 				fputc(0x06,USB); 
06BB0:  MOVLW  06
06BB2:  MOVLB  7
06BB4:  MOVWF  x36
06BB6:  MOVLB  0
06BB8:  CALL   4D9A
.................... 				fputc(rs232_output_mute[channel-1],USB); 
06BBC:  MOVLW  01
06BBE:  MOVLB  6
06BC0:  SUBWF  xFC,W
06BC2:  CLRF   03
06BC4:  ADDLW  9C
06BC6:  MOVWF  FE9
06BC8:  MOVLW  00
06BCA:  ADDWFC 03,W
06BCC:  MOVWF  FEA
06BCE:  MOVFF  FEF,72E
06BD2:  MOVFF  72E,736
06BD6:  MOVLB  0
06BD8:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06BDC:  MOVLW  03
06BDE:  MOVLB  7
06BE0:  MOVWF  x36
06BE2:  MOVLB  0
06BE4:  CALL   4D9A
.................... 				return; 
06BE8:  MOVLB  5
06BEA:  BRA    71FC
.................... 			break; 
06BEC:  BRA    6C88
....................  
.................... 			case 0x02 : 
.................... 				// VOL STATUS 
.................... 				fputc(0x06,USB); 
06BEE:  MOVLW  06
06BF0:  MOVLB  7
06BF2:  MOVWF  x36
06BF4:  MOVLB  0
06BF6:  CALL   4D9A
.................... 				fputc(((int)(rs232_output_vol[channel-1]*100)),USB); 
06BFA:  MOVLW  01
06BFC:  MOVLB  6
06BFE:  SUBWF  xFC,W
06C00:  MULLW  04
06C02:  MOVF   FF3,W
06C04:  CLRF   03
06C06:  ADDLW  8C
06C08:  MOVWF  FE9
06C0A:  MOVLW  00
06C0C:  ADDWFC 03,W
06C0E:  MOVWF  FEA
06C10:  MOVFF  FEF,72E
06C14:  MOVFF  FEC,72F
06C18:  MOVFF  FEC,730
06C1C:  MOVFF  FEC,731
06C20:  MOVFF  731,73C
06C24:  MOVFF  730,73B
06C28:  MOVFF  72F,73A
06C2C:  MOVFF  72E,739
06C30:  MOVLB  7
06C32:  CLRF   x40
06C34:  CLRF   x3F
06C36:  MOVLW  48
06C38:  MOVWF  x3E
06C3A:  MOVLW  85
06C3C:  MOVWF  x3D
06C3E:  MOVLB  0
06C40:  CALL   5638
06C44:  MOVFF  03,731
06C48:  MOVFF  02,730
06C4C:  MOVFF  01,72F
06C50:  MOVFF  00,72E
06C54:  CALL   572E
06C58:  MOVFF  01,72E
06C5C:  MOVFF  01,736
06C60:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06C64:  MOVLW  03
06C66:  MOVLB  7
06C68:  MOVWF  x36
06C6A:  MOVLB  0
06C6C:  CALL   4D9A
.................... 				return; 
06C70:  MOVLB  5
06C72:  BRA    71FC
.................... 			break; 
06C74:  BRA    6C88
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
06C76:  MOVLW  13
06C78:  MOVLB  7
06C7A:  MOVWF  x2E
06C7C:  MOVLB  0
06C7E:  CALL   4DE0
.................... 				return; 
06C82:  MOVLB  5
06C84:  BRA    71FC
.................... 			break; 
06C86:  BRA    6C88
.................... 		} 
....................  
.................... SET_RS232_VALUE: 
....................  
....................  
.................... 		command_char = timed_getc(); 
06C88:  MOVLB  0
06C8A:  CALL   4DFC
06C8E:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
06C92:  MOVLB  5
06C94:  DECFSZ xA9,W
06C96:  BRA    6CA8
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
06C98:  MOVLW  10
06C9A:  MOVLB  7
06C9C:  MOVWF  x2E
06C9E:  MOVLB  0
06CA0:  CALL   4DE0
.................... 			return; 
06CA4:  MOVLB  5
06CA6:  BRA    71FC
.................... 		} 
....................  
.................... 		channel = timed_getc(); 
06CA8:  MOVLB  0
06CAA:  CALL   4DFC
06CAE:  MOVFF  01,6FC
....................  
.................... 		if(timeout_error == true) { 
06CB2:  MOVLB  5
06CB4:  DECFSZ xA9,W
06CB6:  BRA    6CC8
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_RS232_CH_TIMEOUT); 
06CB8:  MOVLW  26
06CBA:  MOVLB  7
06CBC:  MOVWF  x2E
06CBE:  MOVLB  0
06CC0:  CALL   4DE0
.................... 			return; 
06CC4:  MOVLB  5
06CC6:  BRA    71FC
.................... 		} 
....................  
.................... 		// TODO - this is zero based but use NUM_CHANNELS later 
.................... 		if(channel > 4) { 
06CC8:  MOVLB  6
06CCA:  MOVF   xFC,W
06CCC:  SUBLW  04
06CCE:  BC    6CE0
.................... 			send_error(ERR_RS232_CH_INVALID); 
06CD0:  MOVLW  27
06CD2:  MOVLB  7
06CD4:  MOVWF  x2E
06CD6:  MOVLB  0
06CD8:  CALL   4DE0
.................... 			return; 
06CDC:  MOVLB  5
06CDE:  BRA    71FC
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
06CE0:  MOVLB  0
06CE2:  CALL   4DFC
06CE6:  MOVFF  01,6F7
.................... 	 
.................... 		if(timeout_error == true) { 
06CEA:  MOVLB  5
06CEC:  DECFSZ xA9,W
06CEE:  BRA    6D00
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
06CF0:  MOVLW  11
06CF2:  MOVLB  7
06CF4:  MOVWF  x2E
06CF6:  MOVLB  0
06CF8:  CALL   4DE0
.................... 			return; 
06CFC:  MOVLB  5
06CFE:  BRA    71FC
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
06D00:  MOVLB  6
06D02:  MOVF   xF7,W
06D04:  SUBLW  03
06D06:  BZ    6D1A
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
06D08:  MOVLW  12
06D0A:  MOVLB  7
06D0C:  MOVWF  x2E
06D0E:  MOVLB  0
06D10:  CALL   4DE0
.................... 			return; 
06D14:  MOVLB  5
06D16:  BRA    71FC
06D18:  MOVLB  6
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
06D1A:  MOVF   xF6,W
06D1C:  XORLW  00
06D1E:  MOVLB  0
06D20:  BZ    6D30
06D22:  XORLW  01
06D24:  BZ    6D78
06D26:  XORLW  03
06D28:  BZ    6DC2
06D2A:  XORLW  01
06D2C:  BZ    6DF4
06D2E:  BRA    6E2E
.................... 			case 0x00 : 
.................... 				// SET MUTE OFF 
.................... 				 
.................... 				if(rs232_output_mute[channel-1] == 1) { 
06D30:  MOVLW  01
06D32:  MOVLB  6
06D34:  SUBWF  xFC,W
06D36:  CLRF   03
06D38:  ADDLW  9C
06D3A:  MOVWF  FE9
06D3C:  MOVLW  00
06D3E:  ADDWFC 03,W
06D40:  MOVWF  FEA
06D42:  DECFSZ FEF,W
06D44:  BRA    6D50
.................... 					mute_toggle_output(channel); 
06D46:  MOVFF  6FC,72E
06D4A:  MOVLB  0
06D4C:  CALL   5812
.................... 				} 
....................  
.................... 				fputc(0x06,USB); 
06D50:  MOVLW  06
06D52:  MOVLB  7
06D54:  MOVWF  x36
06D56:  MOVLB  0
06D58:  CALL   4D9A
.................... 				fputc(0x00,USB); 
06D5C:  MOVLB  7
06D5E:  CLRF   x36
06D60:  MOVLB  0
06D62:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06D66:  MOVLW  03
06D68:  MOVLB  7
06D6A:  MOVWF  x36
06D6C:  MOVLB  0
06D6E:  CALL   4D9A
.................... 				return; 
06D72:  MOVLB  5
06D74:  BRA    71FC
.................... 			break; 
06D76:  BRA    6E40
....................  
.................... 				case 0x01 : 
.................... 				// SET MUTE ON 
.................... 				 
.................... 				if(rs232_output_mute[channel-1] == 0) { 
06D78:  MOVLW  01
06D7A:  MOVLB  6
06D7C:  SUBWF  xFC,W
06D7E:  CLRF   03
06D80:  ADDLW  9C
06D82:  MOVWF  FE9
06D84:  MOVLW  00
06D86:  ADDWFC 03,W
06D88:  MOVWF  FEA
06D8A:  MOVF   FEF,F
06D8C:  BNZ   6D98
.................... 					mute_toggle_output(channel); 
06D8E:  MOVFF  6FC,72E
06D92:  MOVLB  0
06D94:  CALL   5812
.................... 				} 
....................  
.................... 				fputc(0x06,USB); 
06D98:  MOVLW  06
06D9A:  MOVLB  7
06D9C:  MOVWF  x36
06D9E:  MOVLB  0
06DA0:  CALL   4D9A
.................... 				fputc(0x01,USB); 
06DA4:  MOVLW  01
06DA6:  MOVLB  7
06DA8:  MOVWF  x36
06DAA:  MOVLB  0
06DAC:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06DB0:  MOVLW  03
06DB2:  MOVLB  7
06DB4:  MOVWF  x36
06DB6:  MOVLB  0
06DB8:  CALL   4D9A
.................... 				return; 
06DBC:  MOVLB  5
06DBE:  BRA    71FC
.................... 			break; 
06DC0:  BRA    6E40
....................  
.................... 		 
.................... 			case 0x02 : 
.................... 				// SET MUTE TOGGLE 
.................... 				 
.................... 				mute_toggle_output(channel); 
06DC2:  MOVFF  6FC,72E
06DC6:  CALL   5812
.................... 				fputc(0x06,USB); 
06DCA:  MOVLW  06
06DCC:  MOVLB  7
06DCE:  MOVWF  x36
06DD0:  MOVLB  0
06DD2:  CALL   4D9A
.................... 				fputc(0x02,USB); 
06DD6:  MOVLW  02
06DD8:  MOVLB  7
06DDA:  MOVWF  x36
06DDC:  MOVLB  0
06DDE:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06DE2:  MOVLW  03
06DE4:  MOVLB  7
06DE6:  MOVWF  x36
06DE8:  MOVLB  0
06DEA:  CALL   4D9A
.................... 				return; 
06DEE:  MOVLB  5
06DF0:  BRA    71FC
.................... 			break; 
06DF2:  BRA    6E40
....................  
.................... 			case 0x03 : 
.................... 				// RESET VOLUME 
.................... 				 
.................... 				discrete_vol_output(channel,100); 
06DF4:  MOVFF  6FC,72E
06DF8:  MOVLW  64
06DFA:  MOVLB  7
06DFC:  MOVWF  x2F
06DFE:  MOVLB  0
06E00:  CALL   5C3E
.................... 				fputc(0x06,USB); 
06E04:  MOVLW  06
06E06:  MOVLB  7
06E08:  MOVWF  x36
06E0A:  MOVLB  0
06E0C:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06E10:  MOVLW  03
06E12:  MOVLB  7
06E14:  MOVWF  x36
06E16:  MOVLB  0
06E18:  CALL   4D9A
.................... 				fputc(0x03,USB); 
06E1C:  MOVLW  03
06E1E:  MOVLB  7
06E20:  MOVWF  x36
06E22:  MOVLB  0
06E24:  CALL   4D9A
.................... 				return; 
06E28:  MOVLB  5
06E2A:  BRA    71FC
.................... 			break; 
06E2C:  BRA    6E40
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
06E2E:  MOVLW  13
06E30:  MOVLB  7
06E32:  MOVWF  x2E
06E34:  MOVLB  0
06E36:  CALL   4DE0
.................... 				return; 
06E3A:  MOVLB  5
06E3C:  BRA    71FC
.................... 			break; 
06E3E:  BRA    6E40
.................... 		} 
....................  
.................... SET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
06E40:  MOVLB  0
06E42:  CALL   4DFC
06E46:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
06E4A:  MOVLB  5
06E4C:  DECFSZ xA9,W
06E4E:  BRA    6E60
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
06E50:  MOVLW  10
06E52:  MOVLB  7
06E54:  MOVWF  x2E
06E56:  MOVLB  0
06E58:  CALL   4DE0
.................... 			return; 
06E5C:  MOVLB  5
06E5E:  BRA    71FC
.................... 		} 
....................  
.................... 		unsigned int new_value = timed_getc(); 
06E60:  MOVLB  0
06E62:  CALL   4DFC
06E66:  MOVFF  01,729
.................... 	 
.................... 		if(timeout_error == true) { 
06E6A:  MOVLB  5
06E6C:  DECFSZ xA9,W
06E6E:  BRA    6E80
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
06E70:  MOVLW  17
06E72:  MOVLB  7
06E74:  MOVWF  x2E
06E76:  MOVLB  0
06E78:  CALL   4DE0
.................... 			return; 
06E7C:  MOVLB  5
06E7E:  BRA    71FC
.................... 		} 
.................... 	 
.................... 		unsigned int new_value2; 
....................  
.................... 		if(command_char == 0x11 || command_char == 0x12) { 
06E80:  MOVLB  6
06E82:  MOVF   xF6,W
06E84:  SUBLW  11
06E86:  BZ    6E8E
06E88:  MOVF   xF6,W
06E8A:  SUBLW  12
06E8C:  BNZ   6EAE
....................  
.................... 			// SETTING SLEEP_SECONDS OR SLEEP_HOLDTIME 
.................... 			// THESE ARE 16 BIT SO WE NEED TWO CHARS 
.................... 			 
.................... 			new_value2 = timed_getc(); 
06E8E:  MOVLB  0
06E90:  CALL   4DFC
06E94:  MOVFF  01,72A
....................  
.................... 			if(timeout_error == true) { 
06E98:  MOVLB  5
06E9A:  DECFSZ xA9,W
06E9C:  BRA    6EAE
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 				send_error(ERR_DATA_TIMEOUT); 
06E9E:  MOVLW  17
06EA0:  MOVLB  7
06EA2:  MOVWF  x2E
06EA4:  MOVLB  0
06EA6:  CALL   4DE0
.................... 				return; 
06EAA:  MOVLB  5
06EAC:  BRA    71FC
.................... 			} 
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
06EAE:  MOVLB  0
06EB0:  CALL   4DFC
06EB4:  MOVFF  01,6F7
.................... 		 
.................... 		if(timeout_error == true) { 
06EB8:  MOVLB  5
06EBA:  DECFSZ xA9,W
06EBC:  BRA    6ECE
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
06EBE:  MOVLW  11
06EC0:  MOVLB  7
06EC2:  MOVWF  x2E
06EC4:  MOVLB  0
06EC6:  CALL   4DE0
.................... 			return; 
06ECA:  MOVLB  5
06ECC:  BRA    71FC
.................... 		} 
.................... 		 
.................... 		int perform_eeprom_save = 0; 
06ECE:  MOVLB  7
06ED0:  CLRF   x2B
....................  
.................... 		switch(command_char) { 
06ED2:  MOVLB  6
06ED4:  MOVF   xF6,W
06ED6:  XORLW  06
06ED8:  MOVLB  0
06EDA:  BZ    6EE6
06EDC:  XORLW  0F
06EDE:  BZ    6F08
06EE0:  XORLW  1A
06EE2:  BZ    6F2A
06EE4:  BRA    701E
....................  
.................... 			case 0x06 : 
.................... 				// SETTING USBDETECT_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
06EE6:  MOVLB  7
06EE8:  MOVF   x29,W
06EEA:  SUBLW  01
06EEC:  BC    6EFE
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
06EEE:  MOVLW  30
06EF0:  MOVWF  x2E
06EF2:  MOVLB  0
06EF4:  CALL   4DE0
.................... 					return; 
06EF8:  MOVLB  5
06EFA:  BRA    71FC
06EFC:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.USBDETECT_ENABLE = new_value; 
06EFE:  MOVFF  729,1D
.................... 				perform_eeprom_save = 1; 
06F02:  MOVLW  01
06F04:  MOVWF  x2B
.................... 			break; 
06F06:  BRA    7032
.................... 		 
.................... 			case 0x09 : 
.................... 				// SETTING DSP_VALUESEND_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
06F08:  MOVLB  7
06F0A:  MOVF   x29,W
06F0C:  SUBLW  01
06F0E:  BC    6F20
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
06F10:  MOVLW  30
06F12:  MOVWF  x2E
06F14:  MOVLB  0
06F16:  CALL   4DE0
.................... 					return; 
06F1A:  MOVLB  5
06F1C:  BRA    71FC
06F1E:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.DSP_VALUESEND_ENABLE = new_value; 
06F20:  MOVFF  729,1E
.................... 				perform_eeprom_save = 1; 
06F24:  MOVLW  01
06F26:  MOVWF  x2B
.................... 			break; 
06F28:  BRA    7032
....................  
.................... 			case 0x13 : 
.................... 				// SETTING SERIAL NUMBER 
.................... 			 
.................... 				finished = false; 
06F2A:  MOVLB  6
06F2C:  CLRF   xDD
....................  
.................... 				for(x = 0; x < 20; x++) { 
06F2E:  CLRF   xF3
06F30:  MOVF   xF3,W
06F32:  SUBLW  13
06F34:  BNC   6F4A
.................... 					DEVICE_CONFIG.SERIAL[x] = 0xFF; 
06F36:  CLRF   03
06F38:  MOVF   xF3,W
06F3A:  ADDLW  1F
06F3C:  MOVWF  FE9
06F3E:  MOVLW  00
06F40:  ADDWFC 03,W
06F42:  MOVWF  FEA
06F44:  SETF   FEF
.................... 				} 
06F46:  INCF   xF3,F
06F48:  BRA    6F30
....................  
....................  
.................... 				int16 char_receive_count = 0; 
06F4A:  MOVLB  7
06F4C:  CLRF   x2D
06F4E:  CLRF   x2C
....................  
.................... 				while((char_receive_count < 20)	&& (timeout_error == false)&& (finished == false)) 
.................... 				{ 
06F50:  MOVF   x2D,F
06F52:  BNZ   6FA6
06F54:  MOVF   x2C,W
06F56:  SUBLW  13
06F58:  BNC   6FA6
06F5A:  MOVLB  5
06F5C:  MOVF   xA9,F
06F5E:  BTFSC  FD8.2
06F60:  BRA    6F66
06F62:  MOVLB  7
06F64:  BRA    6FA6
06F66:  MOVLB  6
06F68:  MOVF   xDD,F
06F6A:  BTFSC  FD8.2
06F6C:  BRA    6F72
06F6E:  MOVLB  7
06F70:  BRA    6FA6
.................... 					temp_byte = timed_getc(); 
06F72:  MOVLB  0
06F74:  CALL   4DFC
06F78:  MOVFF  01,6DE
.................... 					//temp_byte = fgetc(USB); 
.................... 					if(temp_byte == 0x0A) { 
06F7C:  MOVLB  6
06F7E:  MOVF   xDE,W
06F80:  SUBLW  0A
06F82:  BNZ   6F8A
.................... 						finished = true; 
06F84:  MOVLW  01
06F86:  MOVWF  xDD
.................... 					} else { 
06F88:  BRA    6F9C
.................... 						DEVICE_CONFIG.SERIAL[char_receive_count] = temp_byte;	 
06F8A:  MOVLW  1F
06F8C:  MOVLB  7
06F8E:  ADDWF  x2C,W
06F90:  MOVWF  FE9
06F92:  MOVLW  00
06F94:  ADDWFC x2D,W
06F96:  MOVWF  FEA
06F98:  MOVFF  6DE,FEF
....................  
.................... 					} 
.................... 					char_receive_count++; 
06F9C:  MOVLB  7
06F9E:  INCF   x2C,F
06FA0:  BTFSC  FD8.2
06FA2:  INCF   x2D,F
.................... 				 
.................... 				} 
06FA4:  BRA    6F50
....................  
.................... 				if(!finished) { 
06FA6:  MOVLB  6
06FA8:  MOVF   xDD,F
06FAA:  BNZ   7016
.................... 					dummy_char = timed_getc(); 
06FAC:  MOVLB  0
06FAE:  CALL   4DFC
06FB2:  MOVFF  01,6F7
.................... 					 
.................... 					if(timeout_error == true) { 
06FB6:  MOVLB  5
06FB8:  DECFSZ xA9,W
06FBA:  BRA    6FE4
.................... 						// Timed out. No command. Start over. 
.................... 						fputc(0x15,USB); 
06FBC:  MOVLW  15
06FBE:  MOVLB  7
06FC0:  MOVWF  x36
06FC2:  MOVLB  0
06FC4:  CALL   4D9A
.................... 						fputc(ERR_END_TIMEOUT,USB); 
06FC8:  MOVLW  11
06FCA:  MOVLB  7
06FCC:  MOVWF  x36
06FCE:  MOVLB  0
06FD0:  CALL   4D9A
.................... 						fputc(0x03,USB); 
06FD4:  MOVLW  03
06FD6:  MOVLB  7
06FD8:  MOVWF  x36
06FDA:  MOVLB  0
06FDC:  CALL   4D9A
.................... 						return; 
06FE0:  MOVLB  5
06FE2:  BRA    71FC
.................... 					} 
.................... 					 
.................... 					if(dummy_char != 0x03) { 
06FE4:  MOVLB  6
06FE6:  MOVF   xF7,W
06FE8:  SUBLW  03
06FEA:  BZ    7016
.................... 						// Ending char not 0x03 
.................... 						fputc(0x15,USB); 
06FEC:  MOVLW  15
06FEE:  MOVLB  7
06FF0:  MOVWF  x36
06FF2:  MOVLB  0
06FF4:  CALL   4D9A
.................... 						fputc(0x12,USB); 
06FF8:  MOVLW  12
06FFA:  MOVLB  7
06FFC:  MOVWF  x36
06FFE:  MOVLB  0
07000:  CALL   4D9A
.................... 						fputc(0x03,USB); 
07004:  MOVLW  03
07006:  MOVLB  7
07008:  MOVWF  x36
0700A:  MOVLB  0
0700C:  CALL   4D9A
.................... 						return; 
07010:  MOVLB  5
07012:  BRA    71FC
07014:  MOVLB  6
.................... 						 
.................... 					} 
.................... 				} 
....................  
.................... 				perform_eeprom_save = 1; 
07016:  MOVLW  01
07018:  MOVLB  7
0701A:  MOVWF  x2B
....................  
.................... 			break; 
0701C:  BRA    7032
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
0701E:  MOVLW  13
07020:  MOVLB  7
07022:  MOVWF  x2E
07024:  MOVLB  0
07026:  CALL   4DE0
.................... 				return; 
0702A:  MOVLB  5
0702C:  BRA    71FC
.................... 			break; 
0702E:  MOVLB  7
07030:  BRA    7032
.................... 		} 
....................  
.................... 		if(perform_eeprom_save == 1) { 
07032:  DECFSZ x2B,W
07034:  BRA    7088
.................... 			INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07036:  CLRF   x2F
07038:  MOVLW  1D
0703A:  MOVWF  x2E
0703C:  CLRF   x31
0703E:  MOVLW  16
07040:  MOVWF  x30
07042:  CLRF   x33
07044:  MOVLW  64
07046:  MOVWF  x32
07048:  MOVLB  0
0704A:  CALL   143C
.................... 			delay_ms(10); 
0704E:  MOVLW  0A
07050:  MOVLB  7
07052:  MOVWF  x37
07054:  MOVLB  0
07056:  CALL   0F2E
....................  
.................... 			fputc(0x06,USB); 
0705A:  MOVLW  06
0705C:  MOVLB  7
0705E:  MOVWF  x36
07060:  MOVLB  0
07062:  CALL   4D9A
.................... 			fputc(command_char,USB); 
07066:  MOVFF  6F6,736
0706A:  CALL   4D9A
.................... 			fputc(new_value,USB); 
0706E:  MOVFF  729,736
07072:  CALL   4D9A
.................... 			fputc(0x03,USB); 
07076:  MOVLW  03
07078:  MOVLB  7
0707A:  MOVWF  x36
0707C:  MOVLB  0
0707E:  CALL   4D9A
....................  
.................... 			return; 
07082:  MOVLB  5
07084:  BRA    71FC
07086:  MOVLB  7
.................... 		} 
....................  
.................... GET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
07088:  MOVLB  0
0708A:  CALL   4DFC
0708E:  MOVFF  01,6F6
.................... 	 
.................... 		if(timeout_error == true) { 
07092:  MOVLB  5
07094:  DECFSZ xA9,W
07096:  BRA    70A8
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
07098:  MOVLW  10
0709A:  MOVLB  7
0709C:  MOVWF  x2E
0709E:  MOVLB  0
070A0:  CALL   4DE0
.................... 			return; 
070A4:  MOVLB  5
070A6:  BRA    71FC
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
070A8:  MOVLB  0
070AA:  CALL   4DFC
070AE:  MOVFF  01,6F7
.................... 		 
.................... 		if(timeout_error == true) { 
070B2:  MOVLB  5
070B4:  DECFSZ xA9,W
070B6:  BRA    70C8
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
070B8:  MOVLW  11
070BA:  MOVLB  7
070BC:  MOVWF  x2E
070BE:  MOVLB  0
070C0:  CALL   4DE0
.................... 			return; 
070C4:  MOVLB  5
070C6:  BRA    71FC
.................... 		} 
....................  
.................... 		switch(command_char) { 
070C8:  MOVLB  6
070CA:  MOVF   xF6,W
070CC:  XORLW  06
070CE:  MOVLB  0
070D0:  BZ    70DC
070D2:  XORLW  0F
070D4:  BZ    710E
070D6:  XORLW  1A
070D8:  BZ    7140
070DA:  BRA    71C4
....................  
.................... 			case 0x06 : 
.................... 				// GET USBDETECT 
.................... 				fputc(0x06); 
070DC:  MOVLW  06
070DE:  MOVLB  7
070E0:  MOVWF  x36
070E2:  MOVLB  0
070E4:  CALL   4D9A
.................... 				fputc(0x06); 
070E8:  MOVLW  06
070EA:  MOVLB  7
070EC:  MOVWF  x36
070EE:  MOVLB  0
070F0:  CALL   4D9A
.................... 				fputc(DEVICE_CONFIG.USBDETECT_ENABLE); 
070F4:  MOVFF  1D,736
070F8:  CALL   4D9A
.................... 				fputc(0x03); 
070FC:  MOVLW  03
070FE:  MOVLB  7
07100:  MOVWF  x36
07102:  MOVLB  0
07104:  CALL   4D9A
.................... 				return; 
07108:  MOVLB  5
0710A:  BRA    71FC
.................... 			break; 
0710C:  BRA    71D6
....................  
.................... 			case 0x09 : 
.................... 				// DSP_VALUESEND 
.................... 				fputc(0x06); 
0710E:  MOVLW  06
07110:  MOVLB  7
07112:  MOVWF  x36
07114:  MOVLB  0
07116:  CALL   4D9A
.................... 				fputc(0x09); 
0711A:  MOVLW  09
0711C:  MOVLB  7
0711E:  MOVWF  x36
07120:  MOVLB  0
07122:  CALL   4D9A
.................... 				fputc(DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
07126:  MOVFF  1E,736
0712A:  CALL   4D9A
.................... 				fputc(0x03); 
0712E:  MOVLW  03
07130:  MOVLB  7
07132:  MOVWF  x36
07134:  MOVLB  0
07136:  CALL   4D9A
.................... 				return; 
0713A:  MOVLB  5
0713C:  BRA    71FC
.................... 			break; 
0713E:  BRA    71D6
.................... 	 
.................... 			case 0x13 : 
.................... 				// SERIAL NUMBER 
.................... 				memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
07140:  MOVLW  06
07142:  MOVWF  FEA
07144:  MOVLW  DF
07146:  MOVWF  FE9
07148:  CLRF   FE2
0714A:  MOVLW  1F
0714C:  MOVWF  FE1
0714E:  MOVLW  14
07150:  MOVWF  01
07152:  MOVFF  FE6,FEE
07156:  DECFSZ 01,F
07158:  BRA    7152
....................  
.................... 				fputc(0x06); 
0715A:  MOVLW  06
0715C:  MOVLB  7
0715E:  MOVWF  x36
07160:  MOVLB  0
07162:  CALL   4D9A
.................... 				fputc(0x13); 
07166:  MOVLW  13
07168:  MOVLB  7
0716A:  MOVWF  x36
0716C:  MOVLB  0
0716E:  CALL   4D9A
....................  
.................... 				for(y = 0; y < 20; y++) { 
07172:  MOVLB  6
07174:  CLRF   xF4
07176:  MOVF   xF4,W
07178:  SUBLW  13
0717A:  BNC   71B2
.................... 					if(name_buffer[y] == 0xFF) { 
0717C:  CLRF   03
0717E:  MOVF   xF4,W
07180:  ADDLW  DF
07182:  MOVWF  FE9
07184:  MOVLW  06
07186:  ADDWFC 03,W
07188:  MOVWF  FEA
0718A:  INCFSZ FEF,W
0718C:  BRA    7190
.................... 						break; 
0718E:  BRA    71B2
.................... 					} 
.................... 			 
.................... 					fputc(name_buffer[y],USB); 
07190:  CLRF   03
07192:  MOVF   xF4,W
07194:  ADDLW  DF
07196:  MOVWF  FE9
07198:  MOVLW  06
0719A:  ADDWFC 03,W
0719C:  MOVWF  FEA
0719E:  MOVFF  FEF,72E
071A2:  MOVFF  72E,736
071A6:  MOVLB  0
071A8:  CALL   4D9A
.................... 				} 
071AC:  MOVLB  6
071AE:  INCF   xF4,F
071B0:  BRA    7176
....................  
.................... 				fputc(0x03); 
071B2:  MOVLW  03
071B4:  MOVLB  7
071B6:  MOVWF  x36
071B8:  MOVLB  0
071BA:  CALL   4D9A
.................... 				return; 
071BE:  MOVLB  5
071C0:  BRA    71FC
.................... 			break; 
071C2:  BRA    71D6
....................  
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
071C4:  MOVLW  13
071C6:  MOVLB  7
071C8:  MOVWF  x2E
071CA:  MOVLB  0
071CC:  CALL   4DE0
.................... 				return; 
071D0:  MOVLB  5
071D2:  BRA    71FC
.................... 			break; 
071D4:  BRA    71D6
.................... 		} 
....................  
.................... 	// How did we get here? Should be impossible.. Let's send an error though... 
.................... 	// Someone probably forgot a return statement above... D'oh! 
....................  
....................  
.................... 	fputc(0x15,USB); 
071D6:  MOVLW  15
071D8:  MOVLB  7
071DA:  MOVWF  x36
071DC:  MOVLB  0
071DE:  CALL   4D9A
.................... 	fputc(ERR_UNKNOWN,USB); 
071E2:  MOVLW  09
071E4:  MOVLB  7
071E6:  MOVWF  x36
071E8:  MOVLB  0
071EA:  CALL   4D9A
.................... 	fputc(0x03,USB); 
071EE:  MOVLW  03
071F0:  MOVLB  7
071F2:  MOVWF  x36
071F4:  MOVLB  0
071F6:  CALL   4D9A
071FA:  MOVLB  5
.................... 	return; 
.................... } 
071FC:  MOVLB  0
071FE:  GOTO   8D48 (RETURN)
....................  
....................  
.................... #include <rs232.c> 
.................... /* RS232 BUFFER */ 
.................... #INT_RDA2 
.................... void serial_isr() { 
....................    int t; 
....................    buffer[next_in]=fgetc(RS232); 
*
00DA2:  CLRF   03
00DA4:  MOVF   x76,W
00DA6:  ADDLW  56
00DA8:  MOVWF  FE9
00DAA:  MOVLW  00
00DAC:  ADDWFC 03,W
00DAE:  MOVWF  FEA
00DB0:  MOVFF  FEA,769
00DB4:  MOVFF  FE9,768
00DB8:  BRA    0D8A
00DBA:  MOVFF  769,FEA
00DBE:  MOVFF  768,FE9
00DC2:  MOVFF  01,FEF
.................... 	buffer_unread++; 
00DC6:  INCF   51,F
....................    t=next_in; 
00DC8:  MOVFF  76,765
....................    next_in=(next_in+1) % RS232_BUFFER_SIZE; 
00DCC:  MOVLW  01
00DCE:  ADDWF  x76,W
00DD0:  ANDLW  1F
00DD2:  MOVWF  x76
....................    if(next_in==next_out)	{ 
00DD4:  MOVF   x77,W
00DD6:  SUBWF  x76,W
00DD8:  BNZ   0DDE
....................      next_in=t;           // Buffer full! 
00DDA:  MOVFF  765,76
.................... 	//fputc(0x99,RS232); 
.................... 	} 
.................... } 
....................  
00DDE:  BCF    FA4.5
00DE0:  GOTO   086C
.................... BYTE bgetc() { 
....................    BYTE c; 
....................  
....................    c=buffer[next_out]; 
*
07202:  CLRF   03
07204:  MOVF   x77,W
07206:  ADDLW  56
07208:  MOVWF  FE9
0720A:  MOVLW  00
0720C:  ADDWFC 03,W
0720E:  MOVWF  FEA
07210:  MOVFF  FEF,6F7
07214:  MOVLB  6
.................... 	buffer[next_out] = 0xFF; 
07216:  CLRF   03
07218:  MOVLB  0
0721A:  MOVF   x77,W
0721C:  ADDLW  56
0721E:  MOVWF  FE9
07220:  MOVLW  00
07222:  ADDWFC 03,W
07224:  MOVWF  FEA
07226:  SETF   FEF
....................    next_out=(next_out+1) % RS232_BUFFER_SIZE; 
07228:  MOVLW  01
0722A:  ADDWF  x77,W
0722C:  ANDLW  1F
0722E:  MOVWF  x77
....................    buffer_unread--; 
07230:  DECF   51,F
.................... 	return(c); 
07232:  MOVLB  6
07234:  MOVFF  6F7,01
.................... } 
07238:  MOVLB  0
0723A:  RETURN 0
....................  
....................  
.................... void send_rs232_error(char error_code) 
.................... { 
.................... 	fputc(0x12,RS232); 
0723C:  MOVLW  12
0723E:  CALL   5310
.................... 	fputc(error_code,RS232); 
07242:  MOVLB  6
07244:  MOVF   xF7,W
07246:  MOVLB  0
07248:  CALL   5310
.................... 	fputc(0x0A,RS232); 
0724C:  MOVLW  0A
0724E:  CALL   5310
....................  
.................... 	buffer_unread = 0; 
07252:  CLRF   51
.................... 	next_in = 0; 
07254:  CLRF   x76
.................... 	next_out = 0; 
07256:  CLRF   x77
.................... } 
07258:  GOTO   85AC (RETURN)
....................  
.................... void process_rs232_data() 
.................... { 
*
08568:  MOVLB  6
0856A:  CLRF   xF5
.................... 	char potential_start_byte = 0; 
.................... 	// Look for a start byte 
....................  
.................... 	if(buffer_unread < 4) { 
0856C:  MOVF   51,W
0856E:  SUBLW  03
08570:  BNC   8574
.................... 		return; 
08572:  BRA    8C52
.................... 	} 
....................  
.................... 	int bytes_read_before_start = 0; 
08574:  CLRF   xF6
....................  
.................... 	while(rs232_data_available && potential_start_byte != 0x12) 
.................... 	{ 
08576:  MOVLB  0
08578:  MOVF   x77,W
0857A:  SUBWF  x76,W
0857C:  BZ    859A
0857E:  MOVLB  6
08580:  MOVF   xF5,W
08582:  SUBLW  12
08584:  BTFSS  FD8.2
08586:  BRA    858C
08588:  MOVLB  0
0858A:  BRA    859A
.................... 		bytes_read_before_start++; 
0858C:  INCF   xF6,F
.................... 		potential_start_byte = bgetc(); 
0858E:  MOVLB  0
08590:  CALL   7202
08594:  MOVFF  01,6F5
.................... 	} 
08598:  BRA    8578
....................  
.................... 	if(potential_start_byte != 0x12) 
0859A:  MOVLB  6
0859C:  MOVF   xF5,W
0859E:  SUBLW  12
085A0:  BZ    85B0
.................... 	{ 
.................... 		send_rs232_error(0x49); 
085A2:  MOVLW  49
085A4:  MOVWF  xF7
085A6:  MOVLB  0
085A8:  GOTO   723C
.................... 		return; 
085AC:  MOVLB  6
085AE:  BRA    8C52
.................... 	} 
....................  
.................... 	RS232_BYTE1 = potential_start_byte; 
085B0:  MOVFF  6F5,52
.................... 	RS232_BYTE2 = bgetc(); 
085B4:  MOVLB  0
085B6:  CALL   7202
085BA:  MOVFF  01,53
.................... 	RS232_BYTE3 = bgetc(); 
085BE:  CALL   7202
085C2:  MOVFF  01,54
.................... 	RS232_BYTE4 = bgetc(); 
085C6:  CALL   7202
085CA:  MOVFF  01,55
.................... 	 
....................  
.................... 		switch(RS232_BYTE2) { 
085CE:  MOVF   53,W
085D0:  XORLW  01
085D2:  BZ    8664
085D4:  XORLW  54
085D6:  BZ    8664
085D8:  XORLW  57
085DA:  BTFSC  FD8.2
085DC:  BRA    873C
085DE:  XORLW  77
085E0:  BTFSC  FD8.2
085E2:  BRA    873C
085E4:  XORLW  71
085E6:  BTFSC  FD8.2
085E8:  BRA    8814
085EA:  XORLW  40
085EC:  BTFSC  FD8.2
085EE:  BRA    8814
085F0:  XORLW  41
085F2:  BTFSC  FD8.2
085F4:  BRA    88EC
085F6:  XORLW  61
085F8:  BTFSC  FD8.2
085FA:  BRA    88EC
085FC:  XORLW  62
085FE:  BTFSC  FD8.2
08600:  BRA    89C4
08602:  XORLW  50
08604:  BTFSC  FD8.2
08606:  BRA    89C4
08608:  XORLW  51
0860A:  BTFSC  FD8.2
0860C:  BRA    8AA0
0860E:  XORLW  45
08610:  BTFSC  FD8.2
08612:  BRA    8AA0
08614:  XORLW  4A
08616:  BTFSC  FD8.2
08618:  BRA    8B24
0861A:  XORLW  45
0861C:  BTFSC  FD8.2
0861E:  BRA    8B24
08620:  XORLW  44
08622:  BTFSC  FD8.2
08624:  BRA    8B46
08626:  XORLW  64
08628:  BTFSC  FD8.2
0862A:  BRA    8B46
0862C:  XORLW  7D
0862E:  BTFSC  FD8.2
08630:  BRA    8B66
08632:  XORLW  44
08634:  BTFSC  FD8.2
08636:  BRA    8B66
08638:  XORLW  45
0863A:  BTFSC  FD8.2
0863C:  BRA    8B90
0863E:  XORLW  52
08640:  BTFSC  FD8.2
08642:  BRA    8B90
08644:  XORLW  51
08646:  BTFSC  FD8.2
08648:  BRA    8BC2
0864A:  XORLW  01
0864C:  BTFSC  FD8.2
0864E:  BRA    8BE4
08650:  XORLW  55
08652:  BTFSC  FD8.2
08654:  BRA    8BE4
08656:  XORLW  52
08658:  BTFSC  FD8.2
0865A:  BRA    8C3A
0865C:  XORLW  01
0865E:  BTFSC  FD8.2
08660:  BRA    8C46
08662:  BRA    8C50
....................  
.................... 			case 0x01: 
.................... 			case 0x55: 
.................... 				// Volume up 10% 
.................... 				 
.................... 				vol_big_up_output(RS232_BYTE3); 
08664:  MOVFF  54,6F7
08668:  GOTO   757A
....................  
.................... 				fputc(0x06,RS232); 
0866C:  MOVLW  06
0866E:  CALL   5310
.................... 				if(RS232_BYTE3 == 0) { 
08672:  MOVF   54,F
08674:  BNZ   86BE
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
08676:  MOVFF  8F,73C
0867A:  MOVFF  8E,73B
0867E:  MOVFF  8D,73A
08682:  MOVFF  8C,739
08686:  MOVLB  7
08688:  CLRF   x40
0868A:  CLRF   x3F
0868C:  MOVLW  48
0868E:  MOVWF  x3E
08690:  MOVLW  85
08692:  MOVWF  x3D
08694:  MOVLB  0
08696:  CALL   5638
0869A:  MOVFF  03,731
0869E:  MOVFF  02,730
086A2:  MOVFF  01,72F
086A6:  MOVFF  00,72E
086AA:  CALL   572E
086AE:  MOVFF  01,6F7
086B2:  MOVLB  6
086B4:  MOVF   xF7,W
086B6:  MOVLB  0
086B8:  CALL   5310
.................... 				} else { 
086BC:  BRA    872E
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
086BE:  MOVLW  01
086C0:  SUBWF  54,W
086C2:  MULLW  04
086C4:  MOVF   FF3,W
086C6:  CLRF   03
086C8:  ADDLW  8C
086CA:  MOVWF  FE9
086CC:  MOVLW  00
086CE:  ADDWFC 03,W
086D0:  MOVWF  FEA
086D2:  MOVFF  FEF,6F7
086D6:  MOVFF  FEC,6F8
086DA:  MOVFF  FEC,6F9
086DE:  MOVFF  FEC,6FA
086E2:  MOVF   FED,F
086E4:  MOVF   FED,F
086E6:  MOVF   FED,F
086E8:  MOVFF  6FA,73C
086EC:  MOVFF  6F9,73B
086F0:  MOVFF  6F8,73A
086F4:  MOVFF  6F7,739
086F8:  MOVLB  7
086FA:  CLRF   x40
086FC:  CLRF   x3F
086FE:  MOVLW  48
08700:  MOVWF  x3E
08702:  MOVLW  85
08704:  MOVWF  x3D
08706:  MOVLB  0
08708:  CALL   5638
0870C:  MOVFF  03,731
08710:  MOVFF  02,730
08714:  MOVFF  01,72F
08718:  MOVFF  00,72E
0871C:  CALL   572E
08720:  MOVFF  01,6F7
08724:  MOVLB  6
08726:  MOVF   xF7,W
08728:  MOVLB  0
0872A:  CALL   5310
.................... 				} 
.................... 				fputc(0x0A,RS232); 
0872E:  MOVLW  0A
08730:  CALL   5310
.................... 				return; 
08734:  MOVLB  6
08736:  BRA    8C52
.................... 			break; 
08738:  MOVLB  0
0873A:  BRA    8C50
....................  
.................... 			case 0x02: 
.................... 			case 0x75: 
.................... 				// Volume up 5% 
....................  
.................... 				vol_small_up_output(RS232_BYTE3); 
0873C:  MOVFF  54,6F7
08740:  GOTO   78D8
....................  
.................... 				fputc(0x06,RS232); 
08744:  MOVLW  06
08746:  CALL   5310
.................... 				if(RS232_BYTE3 == 0) { 
0874A:  MOVF   54,F
0874C:  BNZ   8796
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
0874E:  MOVFF  8F,73C
08752:  MOVFF  8E,73B
08756:  MOVFF  8D,73A
0875A:  MOVFF  8C,739
0875E:  MOVLB  7
08760:  CLRF   x40
08762:  CLRF   x3F
08764:  MOVLW  48
08766:  MOVWF  x3E
08768:  MOVLW  85
0876A:  MOVWF  x3D
0876C:  MOVLB  0
0876E:  CALL   5638
08772:  MOVFF  03,731
08776:  MOVFF  02,730
0877A:  MOVFF  01,72F
0877E:  MOVFF  00,72E
08782:  CALL   572E
08786:  MOVFF  01,6F7
0878A:  MOVLB  6
0878C:  MOVF   xF7,W
0878E:  MOVLB  0
08790:  CALL   5310
.................... 				} else { 
08794:  BRA    8806
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
08796:  MOVLW  01
08798:  SUBWF  54,W
0879A:  MULLW  04
0879C:  MOVF   FF3,W
0879E:  CLRF   03
087A0:  ADDLW  8C
087A2:  MOVWF  FE9
087A4:  MOVLW  00
087A6:  ADDWFC 03,W
087A8:  MOVWF  FEA
087AA:  MOVFF  FEF,6F7
087AE:  MOVFF  FEC,6F8
087B2:  MOVFF  FEC,6F9
087B6:  MOVFF  FEC,6FA
087BA:  MOVF   FED,F
087BC:  MOVF   FED,F
087BE:  MOVF   FED,F
087C0:  MOVFF  6FA,73C
087C4:  MOVFF  6F9,73B
087C8:  MOVFF  6F8,73A
087CC:  MOVFF  6F7,739
087D0:  MOVLB  7
087D2:  CLRF   x40
087D4:  CLRF   x3F
087D6:  MOVLW  48
087D8:  MOVWF  x3E
087DA:  MOVLW  85
087DC:  MOVWF  x3D
087DE:  MOVLB  0
087E0:  CALL   5638
087E4:  MOVFF  03,731
087E8:  MOVFF  02,730
087EC:  MOVFF  01,72F
087F0:  MOVFF  00,72E
087F4:  CALL   572E
087F8:  MOVFF  01,6F7
087FC:  MOVLB  6
087FE:  MOVF   xF7,W
08800:  MOVLB  0
08802:  CALL   5310
.................... 				} 
.................... 				fputc(0x0A,RS232); 
08806:  MOVLW  0A
08808:  CALL   5310
.................... 				return; 
0880C:  MOVLB  6
0880E:  BRA    8C52
.................... 			break; 
08810:  MOVLB  0
08812:  BRA    8C50
....................  
.................... 			case 0x04: 
.................... 			case 0x44: 
.................... 				// Volume down 10% 
....................  
.................... 				vol_big_down_output(RS232_BYTE3); 
08814:  MOVFF  54,6F7
08818:  GOTO   7C36
....................  
.................... 				fputc(0x06,RS232); 
0881C:  MOVLW  06
0881E:  CALL   5310
.................... 				if(RS232_BYTE3 == 0) { 
08822:  MOVF   54,F
08824:  BNZ   886E
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
08826:  MOVFF  8F,73C
0882A:  MOVFF  8E,73B
0882E:  MOVFF  8D,73A
08832:  MOVFF  8C,739
08836:  MOVLB  7
08838:  CLRF   x40
0883A:  CLRF   x3F
0883C:  MOVLW  48
0883E:  MOVWF  x3E
08840:  MOVLW  85
08842:  MOVWF  x3D
08844:  MOVLB  0
08846:  CALL   5638
0884A:  MOVFF  03,731
0884E:  MOVFF  02,730
08852:  MOVFF  01,72F
08856:  MOVFF  00,72E
0885A:  CALL   572E
0885E:  MOVFF  01,6F7
08862:  MOVLB  6
08864:  MOVF   xF7,W
08866:  MOVLB  0
08868:  CALL   5310
.................... 				} else { 
0886C:  BRA    88DE
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
0886E:  MOVLW  01
08870:  SUBWF  54,W
08872:  MULLW  04
08874:  MOVF   FF3,W
08876:  CLRF   03
08878:  ADDLW  8C
0887A:  MOVWF  FE9
0887C:  MOVLW  00
0887E:  ADDWFC 03,W
08880:  MOVWF  FEA
08882:  MOVFF  FEF,6F7
08886:  MOVFF  FEC,6F8
0888A:  MOVFF  FEC,6F9
0888E:  MOVFF  FEC,6FA
08892:  MOVF   FED,F
08894:  MOVF   FED,F
08896:  MOVF   FED,F
08898:  MOVFF  6FA,73C
0889C:  MOVFF  6F9,73B
088A0:  MOVFF  6F8,73A
088A4:  MOVFF  6F7,739
088A8:  MOVLB  7
088AA:  CLRF   x40
088AC:  CLRF   x3F
088AE:  MOVLW  48
088B0:  MOVWF  x3E
088B2:  MOVLW  85
088B4:  MOVWF  x3D
088B6:  MOVLB  0
088B8:  CALL   5638
088BC:  MOVFF  03,731
088C0:  MOVFF  02,730
088C4:  MOVFF  01,72F
088C8:  MOVFF  00,72E
088CC:  CALL   572E
088D0:  MOVFF  01,6F7
088D4:  MOVLB  6
088D6:  MOVF   xF7,W
088D8:  MOVLB  0
088DA:  CALL   5310
.................... 				} 
.................... 				fputc(0x0A,RS232); 
088DE:  MOVLW  0A
088E0:  CALL   5310
.................... 				return; 
088E4:  MOVLB  6
088E6:  BRA    8C52
.................... 			break; 
088E8:  MOVLB  0
088EA:  BRA    8C50
....................  
.................... 			case 0x05: 
.................... 			case 0x64: 
.................... 				// Volume down 5% 
....................  
.................... 				vol_small_down_output(RS232_BYTE3); 
088EC:  MOVFF  54,6F7
088F0:  GOTO   7FA6
....................  
.................... 				fputc(0x06,RS232); 
088F4:  MOVLW  06
088F6:  CALL   5310
.................... 				if(RS232_BYTE3 == 0) { 
088FA:  MOVF   54,F
088FC:  BNZ   8946
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
088FE:  MOVFF  8F,73C
08902:  MOVFF  8E,73B
08906:  MOVFF  8D,73A
0890A:  MOVFF  8C,739
0890E:  MOVLB  7
08910:  CLRF   x40
08912:  CLRF   x3F
08914:  MOVLW  48
08916:  MOVWF  x3E
08918:  MOVLW  85
0891A:  MOVWF  x3D
0891C:  MOVLB  0
0891E:  CALL   5638
08922:  MOVFF  03,731
08926:  MOVFF  02,730
0892A:  MOVFF  01,72F
0892E:  MOVFF  00,72E
08932:  CALL   572E
08936:  MOVFF  01,6F7
0893A:  MOVLB  6
0893C:  MOVF   xF7,W
0893E:  MOVLB  0
08940:  CALL   5310
.................... 				} else { 
08944:  BRA    89B6
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
08946:  MOVLW  01
08948:  SUBWF  54,W
0894A:  MULLW  04
0894C:  MOVF   FF3,W
0894E:  CLRF   03
08950:  ADDLW  8C
08952:  MOVWF  FE9
08954:  MOVLW  00
08956:  ADDWFC 03,W
08958:  MOVWF  FEA
0895A:  MOVFF  FEF,6F7
0895E:  MOVFF  FEC,6F8
08962:  MOVFF  FEC,6F9
08966:  MOVFF  FEC,6FA
0896A:  MOVF   FED,F
0896C:  MOVF   FED,F
0896E:  MOVF   FED,F
08970:  MOVFF  6FA,73C
08974:  MOVFF  6F9,73B
08978:  MOVFF  6F8,73A
0897C:  MOVFF  6F7,739
08980:  MOVLB  7
08982:  CLRF   x40
08984:  CLRF   x3F
08986:  MOVLW  48
08988:  MOVWF  x3E
0898A:  MOVLW  85
0898C:  MOVWF  x3D
0898E:  MOVLB  0
08990:  CALL   5638
08994:  MOVFF  03,731
08998:  MOVFF  02,730
0899C:  MOVFF  01,72F
089A0:  MOVFF  00,72E
089A4:  CALL   572E
089A8:  MOVFF  01,6F7
089AC:  MOVLB  6
089AE:  MOVF   xF7,W
089B0:  MOVLB  0
089B2:  CALL   5310
.................... 				} 
.................... 				fputc(0x0A,RS232); 
089B6:  MOVLW  0A
089B8:  CALL   5310
.................... 				return; 
089BC:  MOVLB  6
089BE:  BRA    8C52
.................... 			break; 
089C0:  MOVLB  0
089C2:  BRA    8C50
....................  
.................... 			case 0x06: 
.................... 			case 0x56: 
.................... 				// Discrete volume 
....................  
.................... 				discrete_vol_output(RS232_BYTE3,RS232_BYTE4); 
089C4:  MOVFF  54,72E
089C8:  MOVFF  55,72F
089CC:  CALL   5C3E
....................  
.................... 				fputc(0x06,RS232); 
089D0:  MOVLW  06
089D2:  CALL   5310
.................... 			 
.................... 				if(RS232_BYTE3 == 0) { 
089D6:  MOVF   54,F
089D8:  BNZ   8A22
.................... 					fputc(((int)(rs232_output_vol[0]*100)),RS232); 
089DA:  MOVFF  8F,73C
089DE:  MOVFF  8E,73B
089E2:  MOVFF  8D,73A
089E6:  MOVFF  8C,739
089EA:  MOVLB  7
089EC:  CLRF   x40
089EE:  CLRF   x3F
089F0:  MOVLW  48
089F2:  MOVWF  x3E
089F4:  MOVLW  85
089F6:  MOVWF  x3D
089F8:  MOVLB  0
089FA:  CALL   5638
089FE:  MOVFF  03,731
08A02:  MOVFF  02,730
08A06:  MOVFF  01,72F
08A0A:  MOVFF  00,72E
08A0E:  CALL   572E
08A12:  MOVFF  01,6F7
08A16:  MOVLB  6
08A18:  MOVF   xF7,W
08A1A:  MOVLB  0
08A1C:  CALL   5310
.................... 				} else { 
08A20:  BRA    8A92
.................... 					fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
08A22:  MOVLW  01
08A24:  SUBWF  54,W
08A26:  MULLW  04
08A28:  MOVF   FF3,W
08A2A:  CLRF   03
08A2C:  ADDLW  8C
08A2E:  MOVWF  FE9
08A30:  MOVLW  00
08A32:  ADDWFC 03,W
08A34:  MOVWF  FEA
08A36:  MOVFF  FEF,6F7
08A3A:  MOVFF  FEC,6F8
08A3E:  MOVFF  FEC,6F9
08A42:  MOVFF  FEC,6FA
08A46:  MOVF   FED,F
08A48:  MOVF   FED,F
08A4A:  MOVF   FED,F
08A4C:  MOVFF  6FA,73C
08A50:  MOVFF  6F9,73B
08A54:  MOVFF  6F8,73A
08A58:  MOVFF  6F7,739
08A5C:  MOVLB  7
08A5E:  CLRF   x40
08A60:  CLRF   x3F
08A62:  MOVLW  48
08A64:  MOVWF  x3E
08A66:  MOVLW  85
08A68:  MOVWF  x3D
08A6A:  MOVLB  0
08A6C:  CALL   5638
08A70:  MOVFF  03,731
08A74:  MOVFF  02,730
08A78:  MOVFF  01,72F
08A7C:  MOVFF  00,72E
08A80:  CALL   572E
08A84:  MOVFF  01,6F7
08A88:  MOVLB  6
08A8A:  MOVF   xF7,W
08A8C:  MOVLB  0
08A8E:  CALL   5310
.................... 				} 
.................... 				fputc(0x0A,RS232); 
08A92:  MOVLW  0A
08A94:  CALL   5310
.................... 				return; 
08A98:  MOVLB  6
08A9A:  BRA    8C52
.................... 			break; 
08A9C:  MOVLB  0
08A9E:  BRA    8C50
....................  
.................... 			case 0x07: 
.................... 			case 0x42: 
.................... 				// Volume Status 
....................  
.................... 				fputc(0x06,RS232); 
08AA0:  MOVLW  06
08AA2:  CALL   5310
.................... 				fputc(((int)(rs232_output_vol[RS232_BYTE3-1]*100)),RS232); 
08AA6:  MOVLW  01
08AA8:  SUBWF  54,W
08AAA:  MULLW  04
08AAC:  MOVF   FF3,W
08AAE:  CLRF   03
08AB0:  ADDLW  8C
08AB2:  MOVWF  FE9
08AB4:  MOVLW  00
08AB6:  ADDWFC 03,W
08AB8:  MOVWF  FEA
08ABA:  MOVFF  FEF,6F7
08ABE:  MOVFF  FEC,6F8
08AC2:  MOVFF  FEC,6F9
08AC6:  MOVFF  FEC,6FA
08ACA:  MOVF   FED,F
08ACC:  MOVF   FED,F
08ACE:  MOVF   FED,F
08AD0:  MOVFF  6FA,73C
08AD4:  MOVFF  6F9,73B
08AD8:  MOVFF  6F8,73A
08ADC:  MOVFF  6F7,739
08AE0:  MOVLB  7
08AE2:  CLRF   x40
08AE4:  CLRF   x3F
08AE6:  MOVLW  48
08AE8:  MOVWF  x3E
08AEA:  MOVLW  85
08AEC:  MOVWF  x3D
08AEE:  MOVLB  0
08AF0:  CALL   5638
08AF4:  MOVFF  03,731
08AF8:  MOVFF  02,730
08AFC:  MOVFF  01,72F
08B00:  MOVFF  00,72E
08B04:  CALL   572E
08B08:  MOVFF  01,6F7
08B0C:  MOVLB  6
08B0E:  MOVF   xF7,W
08B10:  MOVLB  0
08B12:  CALL   5310
.................... 				fputc(0x0A,RS232); 
08B16:  MOVLW  0A
08B18:  CALL   5310
.................... 				return; 
08B1C:  MOVLB  6
08B1E:  BRA    8C52
.................... 			break; 
08B20:  MOVLB  0
08B22:  BRA    8C50
....................  
.................... 			case 0x08: 
.................... 			case 0x4D: 
.................... 				// Force mute on 
.................... 				 
.................... 				mute_on_output(RS232_BYTE3); 
08B24:  MOVFF  54,6F7
08B28:  GOTO   8314
.................... 				fputc(0x06,RS232); 
08B2C:  MOVLW  06
08B2E:  CALL   5310
.................... 				fputc(0x01,RS232); 
08B32:  MOVLW  01
08B34:  CALL   5310
.................... 				fputc(0x0A,RS232); 
08B38:  MOVLW  0A
08B3A:  CALL   5310
.................... 				return; 
08B3E:  MOVLB  6
08B40:  BRA    8C52
.................... 			break; 
08B42:  MOVLB  0
08B44:  BRA    8C50
....................  
.................... 			case 0x09: 
.................... 			case 0x6D: 
.................... 				// Force mute off 
.................... 				 
.................... 				mute_off_output(RS232_BYTE3); 
08B46:  MOVFF  54,6F7
08B4A:  BRA    83D0
.................... 				fputc(0x06,RS232); 
08B4C:  MOVLW  06
08B4E:  CALL   5310
.................... 				fputc(0x00,RS232); 
08B52:  MOVLW  00
08B54:  CALL   5310
.................... 				fputc(0x0A,RS232); 
08B58:  MOVLW  0A
08B5A:  CALL   5310
.................... 				return; 
08B5E:  MOVLB  6
08B60:  BRA    8C52
.................... 			break; 
08B62:  MOVLB  0
08B64:  BRA    8C50
....................  
.................... 			case 0x10: 
.................... 			case 0x54: 
.................... 				// Toggle mute 
....................  
.................... 				fputc(0x06,RS232); 
08B66:  MOVLW  06
08B68:  CALL   5310
.................... 				fputc(mute_toggle_output(RS232_BYTE3),RS232); 
08B6C:  MOVFF  54,72E
08B70:  CALL   5812
08B74:  MOVFF  01,6F7
08B78:  MOVLB  6
08B7A:  MOVF   xF7,W
08B7C:  MOVLB  0
08B7E:  CALL   5310
.................... 				fputc(0x0A,RS232);	 
08B82:  MOVLW  0A
08B84:  CALL   5310
.................... 				return; 
08B88:  MOVLB  6
08B8A:  BRA    8C52
.................... 			break; 
08B8C:  MOVLB  0
08B8E:  BRA    8C50
....................  
.................... 			case 0x11: 
.................... 			case 0x43: 
.................... 			// Mute status 
....................  
.................... 				fputc(0x06,RS232); 
08B90:  MOVLW  06
08B92:  CALL   5310
.................... 				fputc(((int)(rs232_output_mute[RS232_BYTE3-1])),RS232); 
08B96:  MOVLW  01
08B98:  SUBWF  54,W
08B9A:  CLRF   03
08B9C:  ADDLW  9C
08B9E:  MOVWF  FE9
08BA0:  MOVLW  00
08BA2:  ADDWFC 03,W
08BA4:  MOVWF  FEA
08BA6:  MOVFF  FEF,6F7
08BAA:  MOVLB  6
08BAC:  MOVF   xF7,W
08BAE:  MOVLB  0
08BB0:  CALL   5310
.................... 				fputc(0x0A,RS232); 
08BB4:  MOVLW  0A
08BB6:  CALL   5310
.................... 				return; 
08BBA:  MOVLB  6
08BBC:  BRA    8C52
.................... 			break; 
08BBE:  MOVLB  0
08BC0:  BRA    8C50
....................  
.................... 			case 0x12: 
.................... 				// Change preset 
....................  
.................... 				switch_flash_program(RS232_BYTE3); 
08BC2:  MOVFF  54,72E
08BC6:  CALL   5056
....................  
.................... 				fputc(0x06,RS232); 
08BCA:  MOVLW  06
08BCC:  CALL   5310
.................... 				fputc(((int)CURRENT_FLASH_PROGRAM),RS232); 
08BD0:  MOVF   xA0,W
08BD2:  CALL   5310
.................... 				fputc(0x0A,RS232); 
08BD6:  MOVLW  0A
08BD8:  CALL   5310
.................... 				return; 
08BDC:  MOVLB  6
08BDE:  BRA    8C52
....................  
.................... 			break; 
08BE0:  MOVLB  0
08BE2:  BRA    8C50
....................  
.................... 			case 0x13: 
.................... 			case 0x46: 
.................... 				// Firmware version 
.................... 				fprintf(RS232,"PIC firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
08BE4:  MOVLW  E4
08BE6:  MOVWF  FF6
08BE8:  MOVLW  0D
08BEA:  MOVWF  FF7
08BEC:  MOVLW  11
08BEE:  MOVLB  7
08BF0:  MOVWF  x3C
08BF2:  MOVLB  0
08BF4:  CALL   0FD0
08BF8:  MOVFF  39,73C
08BFC:  MOVLW  1B
08BFE:  MOVLB  7
08C00:  MOVWF  x3D
08C02:  MOVLB  0
08C04:  CALL   1026
08C08:  MOVLW  2E
08C0A:  BTFSS  FA4.4
08C0C:  BRA    8C0A
08C0E:  MOVWF  F73
08C10:  MOVFF  3A,73C
08C14:  MOVLW  1B
08C16:  MOVLB  7
08C18:  MOVWF  x3D
08C1A:  MOVLB  0
08C1C:  CALL   1026
08C20:  CLRF   FEA
08C22:  MOVLW  3B
08C24:  MOVWF  FE9
08C26:  CALL   10A4
08C2A:  MOVLW  0D
08C2C:  BTFSS  FA4.4
08C2E:  BRA    8C2C
08C30:  MOVWF  F73
.................... 				return; 
08C32:  MOVLB  6
08C34:  BRA    8C52
.................... 			break; 
08C36:  MOVLB  0
08C38:  BRA    8C50
....................  
.................... 			case 0x14: 
.................... 				// Softboot 
.................... 				softboot(); 
08C3A:  CALL   1FBA
.................... 				return; 
08C3E:  MOVLB  6
08C40:  BRA    8C52
.................... 			break; 
08C42:  MOVLB  0
08C44:  BRA    8C50
....................  
.................... 			case 0x15 : 
.................... 				reset_cpu(); 
08C46:  RESET
.................... 				return; 
08C48:  MOVLB  6
08C4A:  BRA    8C52
.................... 			break; 
08C4C:  MOVLB  0
08C4E:  BRA    8C50
08C50:  MOVLB  6
....................  
.................... 		} 
.................... 		 
.................... 	 
.................... } 
08C52:  MOVLB  0
08C54:  GOTO   8D50 (RETURN)
....................  
....................  
.................... #include <interrupts.c> 
.................... // USB DETECTION 
.................... #INT_EXT1  
.................... void USBDETECT_ISR(void)  
.................... {  
....................  
....................    	disable_interrupts (INT_EXT1); 
*
00DFE:  BCF    FF0.3
....................  
.................... 	delay_us(100); 
00E00:  MOVLW  7A
00E02:  MOVWF  00
00E04:  DECFSZ 00,F
00E06:  BRA    0E04
00E08:  NOP   
....................  
.................... 	if(input(PIN_B1)) { 
00E0A:  BSF    F93.1
00E0C:  BTFSS  F81.1
00E0E:  BRA    0E18
.................... 		IS_USB_CONNECTED = true; 
00E10:  MOVLW  01
00E12:  MOVWF  50
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is high. USB CONNECT EVENT. Triggering on H_TO_L.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,H_TO_L);  
00E14:  BCF    FF1.5
....................  
.................... 	} else { 
00E16:  BRA    0E1C
.................... 		IS_USB_CONNECTED = false; 
00E18:  CLRF   50
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is low. USB DISCONNECT EVENT. Triggering on L_TO_H.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,L_TO_H);  
00E1A:  BSF    FF1.5
.................... 	} 
.................... 	 
.................... 	enable_interrupts(INT_EXT1); 
00E1C:  BSF    FF0.3
.................... 	clear_interrupt(INT_EXT1); 
00E1E:  BCF    FF0.0
.................... }  
....................  
....................  
00E20:  BCF    FF0.0
00E22:  GOTO   086C
.................... void main() 
.................... { 
*
08C58:  CLRF   FF8
08C5A:  BCF    FD0.7
08C5C:  BSF    07.7
08C5E:  CLRF   FEA
08C60:  CLRF   FE9
08C62:  MOVLW  01
08C64:  MOVWF  1A
08C66:  MOVLW  DE
08C68:  MOVWF  19
08C6A:  MOVLW  01
08C6C:  MOVWF  1B
08C6E:  MOVWF  1C
08C70:  MOVLW  03
08C72:  MOVWF  39
08C74:  CLRF   3A
08C76:  BCF    F94.6
08C78:  BSF    F8B.6
08C7A:  CLRF   4F
08C7C:  BCF    F70.3
08C7E:  MOVLW  17
08C80:  MOVWF  F75
08C82:  MOVLW  A2
08C84:  MOVWF  F72
08C86:  MOVLW  90
08C88:  MOVWF  F71
08C8A:  BSF    F95.1
08C8C:  BCF    F95.4
08C8E:  BCF    F95.0
08C90:  BCF    F8C.0
08C92:  CLRF   51
08C94:  CLRF   x76
08C96:  CLRF   x77
08C98:  CLRF   xA0
08C9A:  MOVLB  6
08C9C:  CLRF   xCB
08C9E:  CLRF   xCA
08CA0:  CLRF   xCD
08CA2:  CLRF   xCC
08CA4:  CLRF   xCF
08CA6:  CLRF   xCE
08CA8:  CLRF   xD0
08CAA:  CLRF   xD1
08CAC:  BCF    xD2.0
08CAE:  CLRF   xD4
08CB0:  CLRF   xD3
08CB2:  CLRF   xD5
08CB4:  CLRF   xD6
08CB6:  CLRF   xD7
08CB8:  MOVLB  1
08CBA:  CLRF   x88
08CBC:  MOVF   FC1,W
08CBE:  ANDLW  F0
08CC0:  MOVWF  FC1
08CC2:  MOVLW  00
08CC4:  MOVLB  F
08CC6:  MOVWF  x38
08CC8:  MOVWF  x3C
08CCA:  MOVWF  x39
08CCC:  MOVWF  x3A
08CCE:  MOVWF  x3B
08CD0:  CLRF   F77
08CD2:  CLRF   F78
08CD4:  CLRF   F79
08CD6:  CLRF   33
08CD8:  CLRF   34
08CDA:  MOVLW  2D
08CDC:  MOVWF  3B
08CDE:  MOVLW  44
08CE0:  MOVWF  3C
08CE2:  MOVLW  53
08CE4:  MOVWF  3D
08CE6:  MOVLW  50
08CE8:  MOVWF  3E
08CEA:  MOVLW  34
08CEC:  MOVWF  3F
08CEE:  MOVLW  78
08CF0:  MOVWF  40
08CF2:  MOVLW  34
08CF4:  MOVWF  41
08CF6:  CLRF   42
.................... 	delay_ms(100); 
08CF8:  MOVLW  64
08CFA:  MOVLB  7
08CFC:  MOVWF  x37
08CFE:  MOVLB  0
08D00:  CALL   0F2E
.................... 	// Setup ADC's and Timers 
.................... 	setup_peripherals(); 
08D04:  GOTO   0F56
....................  
.................... 	// Initializes and reads external EEPROM. Loads default DEVICE_CONFIG if necessary 
.................... 	device_boot(); 
08D08:  GOTO   18CC
.................... 	 
.................... 	// Reset amplifier and DSP then load values into DSP 
.................... 	softboot(); 
08D0C:  CALL   1FBA
....................  
.................... 	// Enable/disable interrupts based on DEVICE_CONFIG parameters 
.................... 	setup_interrupts(); 
08D10:  GOTO   2006
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Saving addresses into FLASH [R&D only]..."); 
.................... 	} 
....................  
.................... 	default_addr(); 
08D14:  GOTO   2202
....................  
.................... 	FLASH_ADDR_WRITE(14); 
08D18:  MOVLW  0E
08D1A:  MOVLB  6
08D1C:  MOVWF  xF5
08D1E:  MOVLB  0
08D20:  GOTO   4BA2
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Disabling 100Hz High-Pass since we're a DSP 4x4..."); 
.................... 	} 
....................  
.................... 	send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,SEVENTYVHP_BYPASS,0x00000001); 
08D24:  MOVLW  F0
08D26:  MOVLB  7
08D28:  MOVWF  x3B
08D2A:  CLRF   x3A
08D2C:  MOVLW  04
08D2E:  MOVWF  x3D
08D30:  MOVLW  44
08D32:  MOVWF  x3C
08D34:  CLRF   x41
08D36:  CLRF   x40
08D38:  CLRF   x3F
08D3A:  MOVLW  01
08D3C:  MOVWF  x3E
08D3E:  MOVLB  0
08D40:  CALL   1DD8
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
....................  
.................... 	while(true)	 
.................... 	{	 
.................... 		//if(IS_USB_CONNECTED) { 
.................... 			process_usb_data(); 
08D44:  GOTO   5EBE
.................... 		//} 
....................  
.................... 		if(rs232_data_available) { 
08D48:  MOVF   x77,W
08D4A:  SUBWF  x76,W
08D4C:  BZ    8D50
.................... 			 
.................... 			process_rs232_data(); 
08D4E:  BRA    8568
.................... 			 
.................... 		} 
.................... 	} 
08D50:  BRA    8D44
.................... } 
08D52:  SLEEP 

Configuration Fuses:
   Word  1: E300   HSM NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
