CCS PCH C Compiler, Version 4.130, 13671               25-Jul-14 15:56

               Filename: C:\SOURCE\PIC\DSP100-2 - PIC\main.lst

               ROM used: 36014 bytes (55%)
                         Largest free fragment is 27470
               RAM used: 1752 (45%) at main() level
                         1972 (51%) worst case
               Stack:    16 worst case (9 in main + 7 for interrupts)

*
00800:  GOTO   9398
*
00808:  MOVWF  04
0080A:  MOVFF  FD8,05
0080E:  MOVFF  FE0,06
00812:  MOVLB  0
00814:  MOVFF  FE9,0C
00818:  MOVFF  FEA,07
0081C:  MOVFF  FE1,08
00820:  MOVFF  FE2,09
00824:  MOVFF  FD9,0A
00828:  MOVFF  FDA,0B
0082C:  MOVFF  FF3,12
00830:  MOVFF  FF4,13
00834:  MOVFF  FFA,14
00838:  MOVFF  FF5,15
0083C:  MOVFF  FF6,16
00840:  MOVFF  FF7,17
00844:  MOVFF  00,0E
00848:  MOVFF  01,0F
0084C:  MOVFF  02,10
00850:  MOVFF  03,11
00854:  BTFSS  FF2.5
00856:  GOTO   0860
0085A:  BTFSC  FF2.2
0085C:  GOTO   1254
00860:  BTFSS  F9D.0
00862:  GOTO   086C
00866:  BTFSC  F9E.0
00868:  GOTO   2AE2
0086C:  BTFSS  FF2.4
0086E:  GOTO   0878
00872:  BTFSC  FF2.1
00874:  GOTO   2E2A
00878:  BTFSS  FF0.3
0087A:  GOTO   0884
0087E:  BTFSC  FF0.0
00880:  GOTO   2F72
00884:  MOVFF  0E,00
00888:  MOVFF  0F,01
0088C:  MOVFF  10,02
00890:  MOVFF  11,03
00894:  MOVFF  0C,FE9
00898:  MOVFF  07,FEA
0089C:  BSF    07.7
0089E:  MOVFF  08,FE1
008A2:  MOVFF  09,FE2
008A6:  MOVFF  0A,FD9
008AA:  MOVFF  0B,FDA
008AE:  MOVFF  12,FF3
008B2:  MOVFF  13,FF4
008B6:  MOVFF  14,FFA
008BA:  MOVFF  15,FF5
008BE:  MOVFF  16,FF6
008C2:  MOVFF  17,FF7
008C6:  MOVF   04,W
008C8:  MOVFF  06,FE0
008CC:  MOVFF  05,FD8
008D0:  RETFIE 0
.................... #include <18LF46K22.h> 
.................... //////// Standard Header file for the PIC18LF46K22 device //////////////// 
.................... #device PIC18LF46K22 
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSM                   	//High speed Osc, medium power 4MHz-16MHz 
.................... #FUSES NOPLLEN               	//4X HW PLL disabled, 4X PLL enabled in software 
.................... #FUSES PUT                   	//Power Up Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES WDT_SW                	//No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=14745600) 
*
05FEA:  MOVLW  07
05FEC:  MOVWF  FEA
05FEE:  MOVLW  2B
05FF0:  MOVWF  FE9
05FF2:  MOVF   FEF,W
05FF4:  BZ    6010
05FF6:  MOVLW  04
05FF8:  MOVWF  01
05FFA:  CLRF   00
05FFC:  DECFSZ 00,F
05FFE:  BRA    5FFC
06000:  DECFSZ 01,F
06002:  BRA    5FFA
06004:  MOVLW  C7
06006:  MOVWF  00
06008:  DECFSZ 00,F
0600A:  BRA    6008
0600C:  DECFSZ FEF,F
0600E:  BRA    5FF6
06010:  RETURN 0
....................  
....................  
.................... #define BOOTLOADER_START        0x2A  
.................... #define BOOTLOADER_END          0x3FF + 0x400 
.................... #build (reset=BOOTLOADER_END +1  , interrupt=0x408 + 0x400 )  
.................... #org 0, BOOTLOADER_END {}  
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
019B4:  MOVLB  7
019B6:  BCF    x9F.0
....................    y = x; 
019B8:  MOVFF  793,798
019BC:  MOVFF  792,797
019C0:  MOVFF  791,796
019C4:  MOVFF  790,795
....................  
....................    if (x < 0) 
019C8:  MOVFF  793,7A3
019CC:  MOVFF  792,7A2
019D0:  MOVFF  791,7A1
019D4:  MOVFF  790,7A0
019D8:  CLRF   xA7
019DA:  CLRF   xA6
019DC:  CLRF   xA5
019DE:  CLRF   xA4
019E0:  MOVLB  0
019E2:  RCALL  18FE
019E4:  BNC   19F0
....................    { 
....................       s = 1; 
019E6:  MOVLB  7
019E8:  BSF    x9F.0
....................       y = -y; 
019EA:  MOVF   x96,W
019EC:  XORLW  80
019EE:  MOVWF  x96
....................    } 
....................  
....................    if (y <= 32768.0) 
019F0:  MOVFF  798,7A3
019F4:  MOVFF  797,7A2
019F8:  MOVFF  796,7A1
019FC:  MOVFF  795,7A0
01A00:  MOVLB  7
01A02:  CLRF   xA7
01A04:  CLRF   xA6
01A06:  CLRF   xA5
01A08:  MOVLW  8E
01A0A:  MOVWF  xA4
01A0C:  MOVLB  0
01A0E:  RCALL  18FE
01A10:  BC    1A14
01A12:  BNZ   1A42
....................       res = (float32)(unsigned int16)y; 
01A14:  MOVFF  798,7A3
01A18:  MOVFF  797,7A2
01A1C:  MOVFF  796,7A1
01A20:  MOVFF  795,7A0
01A24:  RCALL  1978
01A26:  MOVFF  02,7A5
01A2A:  MOVFF  01,7A4
01A2E:  RCALL  13FC
01A30:  MOVFF  03,79C
01A34:  MOVFF  02,79B
01A38:  MOVFF  01,79A
01A3C:  MOVFF  00,799
....................  
....................  else if (y < 10000000.0) 
01A40:  BRA    1BD0
01A42:  MOVFF  798,7A3
01A46:  MOVFF  797,7A2
01A4A:  MOVFF  796,7A1
01A4E:  MOVFF  795,7A0
01A52:  MOVLW  80
01A54:  MOVLB  7
01A56:  MOVWF  xA7
01A58:  MOVLW  96
01A5A:  MOVWF  xA6
01A5C:  MOVLW  18
01A5E:  MOVWF  xA5
01A60:  MOVLW  96
01A62:  MOVWF  xA4
01A64:  MOVLB  0
01A66:  RCALL  18FE
01A68:  BTFSS  FD8.0
01A6A:  BRA    1BC0
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
01A6C:  MOVFF  798,7A3
01A70:  MOVFF  797,7A2
01A74:  MOVFF  796,7A1
01A78:  MOVFF  795,7A0
01A7C:  MOVLB  7
01A7E:  CLRF   xA7
01A80:  CLRF   xA6
01A82:  CLRF   xA5
01A84:  MOVLW  70
01A86:  MOVWF  xA4
01A88:  MOVLB  0
01A8A:  RCALL  1808
01A8C:  MOVFF  03,7A3
01A90:  MOVFF  02,7A2
01A94:  MOVFF  01,7A1
01A98:  MOVFF  00,7A0
01A9C:  RCALL  1978
01A9E:  MOVFF  02,79E
01AA2:  MOVFF  01,79D
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
01AA6:  MOVFF  798,7A3
01AAA:  MOVFF  797,7A2
01AAE:  MOVFF  796,7A1
01AB2:  MOVFF  795,7A0
01AB6:  MOVLB  7
01AB8:  CLRF   xA7
01ABA:  CLRF   xA6
01ABC:  CLRF   xA5
01ABE:  MOVLW  70
01AC0:  MOVWF  xA4
01AC2:  MOVLB  0
01AC4:  RCALL  1808
01AC6:  MOVFF  00,7A0
01ACA:  MOVFF  01,7A1
01ACE:  MOVFF  02,7A2
01AD2:  MOVFF  03,7A3
01AD6:  MOVFF  79E,7A5
01ADA:  MOVFF  79D,7A4
01ADE:  RCALL  13FC
01AE0:  BSF    FD8.1
01AE2:  MOVFF  7A3,7A7
01AE6:  MOVFF  7A2,7A6
01AEA:  MOVFF  7A1,7A5
01AEE:  MOVFF  7A0,7A4
01AF2:  MOVFF  03,7AB
01AF6:  MOVFF  02,7AA
01AFA:  MOVFF  01,7A9
01AFE:  MOVFF  00,7A8
01B02:  RCALL  1432
01B04:  MOVLB  7
01B06:  CLRF   xA3
01B08:  CLRF   xA2
01B0A:  CLRF   xA1
01B0C:  MOVLW  8E
01B0E:  MOVWF  xA0
01B10:  MOVFF  03,7A7
01B14:  MOVFF  02,7A6
01B18:  MOVFF  01,7A5
01B1C:  MOVFF  00,7A4
01B20:  MOVLB  0
01B22:  RCALL  1808
01B24:  MOVFF  03,798
01B28:  MOVFF  02,797
01B2C:  MOVFF  01,796
01B30:  MOVFF  00,795
....................       res = 32768.0*(float32)l; 
01B34:  MOVFF  79E,7A5
01B38:  MOVFF  79D,7A4
01B3C:  RCALL  13FC
01B3E:  MOVLB  7
01B40:  CLRF   xA3
01B42:  CLRF   xA2
01B44:  CLRF   xA1
01B46:  MOVLW  8E
01B48:  MOVWF  xA0
01B4A:  MOVFF  03,7A7
01B4E:  MOVFF  02,7A6
01B52:  MOVFF  01,7A5
01B56:  MOVFF  00,7A4
01B5A:  MOVLB  0
01B5C:  RCALL  1808
01B5E:  MOVFF  03,79C
01B62:  MOVFF  02,79B
01B66:  MOVFF  01,79A
01B6A:  MOVFF  00,799
....................       res += (float32)(unsigned int16)y; 
01B6E:  MOVFF  798,7A3
01B72:  MOVFF  797,7A2
01B76:  MOVFF  796,7A1
01B7A:  MOVFF  795,7A0
01B7E:  RCALL  1978
01B80:  MOVFF  02,7A5
01B84:  MOVFF  01,7A4
01B88:  RCALL  13FC
01B8A:  BCF    FD8.1
01B8C:  MOVFF  79C,7A7
01B90:  MOVFF  79B,7A6
01B94:  MOVFF  79A,7A5
01B98:  MOVFF  799,7A4
01B9C:  MOVFF  03,7AB
01BA0:  MOVFF  02,7AA
01BA4:  MOVFF  01,7A9
01BA8:  MOVFF  00,7A8
01BAC:  RCALL  1432
01BAE:  MOVFF  03,79C
01BB2:  MOVFF  02,79B
01BB6:  MOVFF  01,79A
01BBA:  MOVFF  00,799
....................    } 
....................  
....................  else 
01BBE:  BRA    1BD0
....................   res = y; 
01BC0:  MOVFF  798,79C
01BC4:  MOVFF  797,79B
01BC8:  MOVFF  796,79A
01BCC:  MOVFF  795,799
....................  
....................  y = y - (float32)(unsigned int16)y; 
01BD0:  MOVFF  798,7A3
01BD4:  MOVFF  797,7A2
01BD8:  MOVFF  796,7A1
01BDC:  MOVFF  795,7A0
01BE0:  RCALL  1978
01BE2:  MOVFF  02,7A5
01BE6:  MOVFF  01,7A4
01BEA:  RCALL  13FC
01BEC:  BSF    FD8.1
01BEE:  MOVFF  798,7A7
01BF2:  MOVFF  797,7A6
01BF6:  MOVFF  796,7A5
01BFA:  MOVFF  795,7A4
01BFE:  MOVFF  03,7AB
01C02:  MOVFF  02,7AA
01C06:  MOVFF  01,7A9
01C0A:  MOVFF  00,7A8
01C0E:  RCALL  1432
01C10:  MOVFF  03,798
01C14:  MOVFF  02,797
01C18:  MOVFF  01,796
01C1C:  MOVFF  00,795
....................  
....................  if (s) 
01C20:  MOVLB  7
01C22:  BTFSS  x9F.0
01C24:  BRA    1C2C
....................   res = -res; 
01C26:  MOVF   x9A,W
01C28:  XORLW  80
01C2A:  MOVWF  x9A
....................  
....................  if (y != 0) 
01C2C:  MOVFF  798,7A3
01C30:  MOVFF  797,7A2
01C34:  MOVFF  796,7A1
01C38:  MOVFF  795,7A0
01C3C:  CLRF   xA7
01C3E:  CLRF   xA6
01C40:  CLRF   xA5
01C42:  CLRF   xA4
01C44:  MOVLB  0
01C46:  RCALL  18FE
01C48:  BZ    1CC2
....................  { 
....................   if (s == 1 && n == 0) 
01C4A:  MOVLB  7
01C4C:  BTFSS  x9F.0
01C4E:  BRA    1C88
01C50:  MOVF   x94,F
01C52:  BNZ   1C88
....................    res -= 1.0; 
01C54:  BSF    FD8.1
01C56:  MOVFF  79C,7A7
01C5A:  MOVFF  79B,7A6
01C5E:  MOVFF  79A,7A5
01C62:  MOVFF  799,7A4
01C66:  CLRF   xAB
01C68:  CLRF   xAA
01C6A:  CLRF   xA9
01C6C:  MOVLW  7F
01C6E:  MOVWF  xA8
01C70:  MOVLB  0
01C72:  CALL   1432
01C76:  MOVFF  03,79C
01C7A:  MOVFF  02,79B
01C7E:  MOVFF  01,79A
01C82:  MOVFF  00,799
01C86:  MOVLB  7
....................  
....................   if (s == 0 && n == 1) 
01C88:  BTFSC  x9F.0
01C8A:  BRA    1CC4
01C8C:  DECFSZ x94,W
01C8E:  BRA    1CC4
....................    res += 1.0; 
01C90:  BCF    FD8.1
01C92:  MOVFF  79C,7A7
01C96:  MOVFF  79B,7A6
01C9A:  MOVFF  79A,7A5
01C9E:  MOVFF  799,7A4
01CA2:  CLRF   xAB
01CA4:  CLRF   xAA
01CA6:  CLRF   xA9
01CA8:  MOVLW  7F
01CAA:  MOVWF  xA8
01CAC:  MOVLB  0
01CAE:  CALL   1432
01CB2:  MOVFF  03,79C
01CB6:  MOVFF  02,79B
01CBA:  MOVFF  01,79A
01CBE:  MOVFF  00,799
01CC2:  MOVLB  7
....................  } 
....................  if (x == 0) 
01CC4:  MOVFF  793,7A3
01CC8:  MOVFF  792,7A2
01CCC:  MOVFF  791,7A1
01CD0:  MOVFF  790,7A0
01CD4:  CLRF   xA7
01CD6:  CLRF   xA6
01CD8:  CLRF   xA5
01CDA:  CLRF   xA4
01CDC:  MOVLB  0
01CDE:  RCALL  18FE
01CE0:  BNZ   1CEE
....................     res = 0; 
01CE2:  MOVLB  7
01CE4:  CLRF   x9C
01CE6:  CLRF   x9B
01CE8:  CLRF   x9A
01CEA:  CLRF   x99
01CEC:  MOVLB  0
....................  
....................  return (res); 
01CEE:  MOVFF  799,00
01CF2:  MOVFF  79A,01
01CF6:  MOVFF  79B,02
01CFA:  MOVFF  79C,03
.................... } 
01CFE:  RETURN 0
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
01D1C:  MOVFF  78F,793
01D20:  MOVFF  78E,792
01D24:  MOVFF  78D,791
01D28:  MOVFF  78C,790
01D2C:  MOVLB  7
01D2E:  CLRF   x94
01D30:  MOVLB  0
01D32:  RCALL  19B4
.................... } 
01D34:  RETURN 0
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
01D00:  MOVFF  78F,793
01D04:  MOVFF  78E,792
01D08:  MOVFF  78D,791
01D0C:  MOVFF  78C,790
01D10:  MOVLW  01
01D12:  MOVLB  7
01D14:  MOVWF  x94
01D16:  MOVLB  0
01D18:  RCALL  19B4
.................... } 
01D1A:  RETURN 0
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
01D36:  MOVFF  783,7A3
01D3A:  MOVFF  782,7A2
01D3E:  MOVFF  781,7A1
01D42:  MOVFF  780,7A0
01D46:  MOVLB  7
01D48:  CLRF   xA7
01D4A:  CLRF   xA6
01D4C:  CLRF   xA5
01D4E:  CLRF   xA4
01D50:  MOVLB  0
01D52:  RCALL  18FE
01D54:  BTFSC  FD8.2
01D56:  BRA    1E90
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
01D58:  MOVFF  77F,79C
01D5C:  MOVFF  77E,79B
01D60:  MOVFF  77D,79A
01D64:  MOVFF  77C,799
01D68:  MOVFF  783,7A0
01D6C:  MOVFF  782,79F
01D70:  MOVFF  781,79E
01D74:  MOVFF  780,79D
01D78:  RCALL  16AA
01D7A:  MOVFF  00,788
01D7E:  MOVFF  01,789
01D82:  MOVFF  02,78A
01D86:  MOVFF  03,78B
01D8A:  MOVFF  03,7A3
01D8E:  MOVFF  02,7A2
01D92:  MOVFF  01,7A1
01D96:  MOVFF  00,7A0
01D9A:  MOVLB  7
01D9C:  CLRF   xA7
01D9E:  CLRF   xA6
01DA0:  CLRF   xA5
01DA2:  CLRF   xA4
01DA4:  MOVLB  0
01DA6:  RCALL  18FE
01DA8:  BNC   1DF0
01DAA:  MOVFF  77F,79C
01DAE:  MOVFF  77E,79B
01DB2:  MOVFF  77D,79A
01DB6:  MOVFF  77C,799
01DBA:  MOVFF  783,7A0
01DBE:  MOVFF  782,79F
01DC2:  MOVFF  781,79E
01DC6:  MOVFF  780,79D
01DCA:  RCALL  16AA
01DCC:  MOVFF  00,788
01DD0:  MOVFF  01,789
01DD4:  MOVFF  02,78A
01DD8:  MOVFF  03,78B
01DDC:  MOVFF  03,78F
01DE0:  MOVFF  02,78E
01DE4:  MOVFF  01,78D
01DE8:  MOVFF  00,78C
01DEC:  RCALL  1D00
01DEE:  BRA    1E34
01DF0:  MOVFF  77F,79C
01DF4:  MOVFF  77E,79B
01DF8:  MOVFF  77D,79A
01DFC:  MOVFF  77C,799
01E00:  MOVFF  783,7A0
01E04:  MOVFF  782,79F
01E08:  MOVFF  781,79E
01E0C:  MOVFF  780,79D
01E10:  RCALL  16AA
01E12:  MOVFF  00,788
01E16:  MOVFF  01,789
01E1A:  MOVFF  02,78A
01E1E:  MOVFF  03,78B
01E22:  MOVFF  03,78F
01E26:  MOVFF  02,78E
01E2A:  MOVFF  01,78D
01E2E:  MOVFF  00,78C
01E32:  RCALL  1D1C
01E34:  MOVFF  03,787
01E38:  MOVFF  02,786
01E3C:  MOVFF  01,785
01E40:  MOVFF  00,784
....................       return(x-(i*y)); 
01E44:  MOVFF  787,7A3
01E48:  MOVFF  786,7A2
01E4C:  MOVFF  785,7A1
01E50:  MOVFF  784,7A0
01E54:  MOVFF  783,7A7
01E58:  MOVFF  782,7A6
01E5C:  MOVFF  781,7A5
01E60:  MOVFF  780,7A4
01E64:  RCALL  1808
01E66:  BSF    FD8.1
01E68:  MOVFF  77F,7A7
01E6C:  MOVFF  77E,7A6
01E70:  MOVFF  77D,7A5
01E74:  MOVFF  77C,7A4
01E78:  MOVFF  03,7AB
01E7C:  MOVFF  02,7AA
01E80:  MOVFF  01,7A9
01E84:  MOVFF  00,7A8
01E88:  CALL   1432
01E8C:  BRA    1E90
....................    } 
....................    else 
01E8E:  BRA    1E90
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
01E90:  RETURN 0
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
02270:  MOVFF  783,7A3
02274:  MOVFF  782,7A2
02278:  MOVFF  781,7A1
0227C:  MOVFF  780,7A0
02280:  MOVLW  3B
02282:  MOVLB  7
02284:  MOVWF  xA7
02286:  MOVLW  AA
02288:  MOVWF  xA6
0228A:  MOVLW  38
0228C:  MOVWF  xA5
0228E:  MOVLW  7F
02290:  MOVWF  xA4
02292:  MOVLB  0
02294:  CALL   1808
02298:  MOVFF  03,7A3
0229C:  MOVFF  02,7A2
022A0:  MOVFF  01,7A1
022A4:  MOVFF  00,7A0
022A8:  CALL   1978
022AC:  MOVFF  01,790
....................    s = 0; 
022B0:  MOVLB  7
022B2:  BCF    x91.0
....................    y = x; 
022B4:  MOVFF  783,787
022B8:  MOVFF  782,786
022BC:  MOVFF  781,785
022C0:  MOVFF  780,784
....................  
....................    if (x < 0) 
022C4:  MOVFF  783,7A3
022C8:  MOVFF  782,7A2
022CC:  MOVFF  781,7A1
022D0:  MOVFF  780,7A0
022D4:  CLRF   xA7
022D6:  CLRF   xA6
022D8:  CLRF   xA5
022DA:  CLRF   xA4
022DC:  MOVLB  0
022DE:  CALL   18FE
022E2:  BNC   22F0
....................    { 
....................       s = 1; 
022E4:  MOVLB  7
022E6:  BSF    x91.0
....................       n = -n; 
022E8:  NEGF   x90
....................       y = -y; 
022EA:  MOVF   x85,W
022EC:  XORLW  80
022EE:  MOVWF  x85
....................    } 
....................  
....................    res = 0.0; 
022F0:  MOVLB  7
022F2:  CLRF   x8B
022F4:  CLRF   x8A
022F6:  CLRF   x89
022F8:  CLRF   x88
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
022FA:  MOVLW  07
022FC:  MOVWF  x93
022FE:  MOVLW  88
02300:  MOVWF  FE9
02302:  MOVFF  793,FEA
02306:  MOVLW  7F
02308:  ADDWF  x90,W
0230A:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0230C:  MOVFF  787,7A3
02310:  MOVFF  786,7A2
02314:  MOVFF  785,7A1
02318:  MOVFF  784,7A0
0231C:  MOVLW  3B
0231E:  MOVWF  xA7
02320:  MOVLW  AA
02322:  MOVWF  xA6
02324:  MOVLW  38
02326:  MOVWF  xA5
02328:  MOVLW  7F
0232A:  MOVWF  xA4
0232C:  MOVLB  0
0232E:  CALL   1808
02332:  MOVFF  00,792
02336:  MOVFF  01,793
0233A:  MOVFF  02,794
0233E:  MOVFF  03,795
02342:  MOVLB  7
02344:  CLRF   x97
02346:  MOVFF  790,796
0234A:  BTFSC  x96.7
0234C:  DECF   x97,F
0234E:  MOVLB  0
02350:  RCALL  1E92
02352:  BSF    FD8.1
02354:  MOVFF  795,7A7
02358:  MOVFF  794,7A6
0235C:  MOVFF  793,7A5
02360:  MOVFF  792,7A4
02364:  MOVFF  03,7AB
02368:  MOVFF  02,7AA
0236C:  MOVFF  01,7A9
02370:  MOVFF  00,7A8
02374:  CALL   1432
02378:  MOVFF  03,787
0237C:  MOVFF  02,786
02380:  MOVFF  01,785
02384:  MOVFF  00,784
....................  
....................    r = pe[0]*y + pe[1]; 
02388:  MOVLW  7C
0238A:  MOVLB  7
0238C:  MOVWF  xA3
0238E:  MOVLW  88
02390:  MOVWF  xA2
02392:  MOVLW  59
02394:  MOVWF  xA1
02396:  MOVLW  72
02398:  MOVWF  xA0
0239A:  MOVFF  787,7A7
0239E:  MOVFF  786,7A6
023A2:  MOVFF  785,7A5
023A6:  MOVFF  784,7A4
023AA:  MOVLB  0
023AC:  CALL   1808
023B0:  MOVFF  00,792
023B4:  MOVFF  01,793
023B8:  MOVFF  02,794
023BC:  MOVFF  03,795
023C0:  BCF    FD8.1
023C2:  MOVFF  03,7A7
023C6:  MOVFF  02,7A6
023CA:  MOVFF  01,7A5
023CE:  MOVFF  00,7A4
023D2:  MOVLW  E0
023D4:  MOVLB  7
023D6:  MOVWF  xAB
023D8:  MOVLW  97
023DA:  MOVWF  xAA
023DC:  MOVLW  26
023DE:  MOVWF  xA9
023E0:  MOVLW  75
023E2:  MOVWF  xA8
023E4:  MOVLB  0
023E6:  CALL   1432
023EA:  MOVFF  03,78F
023EE:  MOVFF  02,78E
023F2:  MOVFF  01,78D
023F6:  MOVFF  00,78C
....................    r = r*y + pe[2]; 
023FA:  MOVFF  78F,7A3
023FE:  MOVFF  78E,7A2
02402:  MOVFF  78D,7A1
02406:  MOVFF  78C,7A0
0240A:  MOVFF  787,7A7
0240E:  MOVFF  786,7A6
02412:  MOVFF  785,7A5
02416:  MOVFF  784,7A4
0241A:  CALL   1808
0241E:  MOVFF  00,792
02422:  MOVFF  01,793
02426:  MOVFF  02,794
0242A:  MOVFF  03,795
0242E:  BCF    FD8.1
02430:  MOVFF  03,7A7
02434:  MOVFF  02,7A6
02438:  MOVFF  01,7A5
0243C:  MOVFF  00,7A4
02440:  MOVLW  C4
02442:  MOVLB  7
02444:  MOVWF  xAB
02446:  MOVLW  1D
02448:  MOVWF  xAA
0244A:  MOVLW  1E
0244C:  MOVWF  xA9
0244E:  MOVLW  78
02450:  MOVWF  xA8
02452:  MOVLB  0
02454:  CALL   1432
02458:  MOVFF  03,78F
0245C:  MOVFF  02,78E
02460:  MOVFF  01,78D
02464:  MOVFF  00,78C
....................    r = r*y + pe[3]; 
02468:  MOVFF  78F,7A3
0246C:  MOVFF  78E,7A2
02470:  MOVFF  78D,7A1
02474:  MOVFF  78C,7A0
02478:  MOVFF  787,7A7
0247C:  MOVFF  786,7A6
02480:  MOVFF  785,7A5
02484:  MOVFF  784,7A4
02488:  CALL   1808
0248C:  MOVFF  00,792
02490:  MOVFF  01,793
02494:  MOVFF  02,794
02498:  MOVFF  03,795
0249C:  BCF    FD8.1
0249E:  MOVFF  03,7A7
024A2:  MOVFF  02,7A6
024A6:  MOVFF  01,7A5
024AA:  MOVFF  00,7A4
024AE:  MOVLW  5E
024B0:  MOVLB  7
024B2:  MOVWF  xAB
024B4:  MOVLW  50
024B6:  MOVWF  xAA
024B8:  MOVLW  63
024BA:  MOVWF  xA9
024BC:  MOVLW  7A
024BE:  MOVWF  xA8
024C0:  MOVLB  0
024C2:  CALL   1432
024C6:  MOVFF  03,78F
024CA:  MOVFF  02,78E
024CE:  MOVFF  01,78D
024D2:  MOVFF  00,78C
....................    r = r*y + pe[4]; 
024D6:  MOVFF  78F,7A3
024DA:  MOVFF  78E,7A2
024DE:  MOVFF  78D,7A1
024E2:  MOVFF  78C,7A0
024E6:  MOVFF  787,7A7
024EA:  MOVFF  786,7A6
024EE:  MOVFF  785,7A5
024F2:  MOVFF  784,7A4
024F6:  CALL   1808
024FA:  MOVFF  00,792
024FE:  MOVFF  01,793
02502:  MOVFF  02,794
02506:  MOVFF  03,795
0250A:  BCF    FD8.1
0250C:  MOVFF  03,7A7
02510:  MOVFF  02,7A6
02514:  MOVFF  01,7A5
02518:  MOVFF  00,7A4
0251C:  MOVLW  1A
0251E:  MOVLB  7
02520:  MOVWF  xAB
02522:  MOVLW  FE
02524:  MOVWF  xAA
02526:  MOVLW  75
02528:  MOVWF  xA9
0252A:  MOVLW  7C
0252C:  MOVWF  xA8
0252E:  MOVLB  0
02530:  CALL   1432
02534:  MOVFF  03,78F
02538:  MOVFF  02,78E
0253C:  MOVFF  01,78D
02540:  MOVFF  00,78C
....................    r = r*y + pe[5]; 
02544:  MOVFF  78F,7A3
02548:  MOVFF  78E,7A2
0254C:  MOVFF  78D,7A1
02550:  MOVFF  78C,7A0
02554:  MOVFF  787,7A7
02558:  MOVFF  786,7A6
0255C:  MOVFF  785,7A5
02560:  MOVFF  784,7A4
02564:  CALL   1808
02568:  MOVFF  00,792
0256C:  MOVFF  01,793
02570:  MOVFF  02,794
02574:  MOVFF  03,795
02578:  BCF    FD8.1
0257A:  MOVFF  03,7A7
0257E:  MOVFF  02,7A6
02582:  MOVFF  01,7A5
02586:  MOVFF  00,7A4
0258A:  MOVLW  18
0258C:  MOVLB  7
0258E:  MOVWF  xAB
02590:  MOVLW  72
02592:  MOVWF  xAA
02594:  MOVLW  31
02596:  MOVWF  xA9
02598:  MOVLW  7E
0259A:  MOVWF  xA8
0259C:  MOVLB  0
0259E:  CALL   1432
025A2:  MOVFF  03,78F
025A6:  MOVFF  02,78E
025AA:  MOVFF  01,78D
025AE:  MOVFF  00,78C
....................  
....................    res = res*(1.0 + y*r); 
025B2:  MOVFF  787,7A3
025B6:  MOVFF  786,7A2
025BA:  MOVFF  785,7A1
025BE:  MOVFF  784,7A0
025C2:  MOVFF  78F,7A7
025C6:  MOVFF  78E,7A6
025CA:  MOVFF  78D,7A5
025CE:  MOVFF  78C,7A4
025D2:  CALL   1808
025D6:  BCF    FD8.1
025D8:  MOVLB  7
025DA:  CLRF   xA7
025DC:  CLRF   xA6
025DE:  CLRF   xA5
025E0:  MOVLW  7F
025E2:  MOVWF  xA4
025E4:  MOVFF  03,7AB
025E8:  MOVFF  02,7AA
025EC:  MOVFF  01,7A9
025F0:  MOVFF  00,7A8
025F4:  MOVLB  0
025F6:  CALL   1432
025FA:  MOVFF  78B,7A3
025FE:  MOVFF  78A,7A2
02602:  MOVFF  789,7A1
02606:  MOVFF  788,7A0
0260A:  MOVFF  03,7A7
0260E:  MOVFF  02,7A6
02612:  MOVFF  01,7A5
02616:  MOVFF  00,7A4
0261A:  CALL   1808
0261E:  MOVFF  03,78B
02622:  MOVFF  02,78A
02626:  MOVFF  01,789
0262A:  MOVFF  00,788
....................  
....................    if (s) 
0262E:  MOVLB  7
02630:  BTFSS  x91.0
02632:  BRA    2666
....................       res = 1.0/res; 
02634:  CLRF   x9C
02636:  CLRF   x9B
02638:  CLRF   x9A
0263A:  MOVLW  7F
0263C:  MOVWF  x99
0263E:  MOVFF  78B,7A0
02642:  MOVFF  78A,79F
02646:  MOVFF  789,79E
0264A:  MOVFF  788,79D
0264E:  MOVLB  0
02650:  CALL   16AA
02654:  MOVFF  03,78B
02658:  MOVFF  02,78A
0265C:  MOVFF  01,789
02660:  MOVFF  00,788
02664:  MOVLB  7
....................    return(res); 
02666:  MOVFF  788,00
0266A:  MOVFF  789,01
0266E:  MOVFF  78A,02
02672:  MOVFF  78B,03
.................... } 
02676:  MOVLB  0
02678:  RETURN 0
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
01EE2:  MOVFF  783,787
01EE6:  MOVFF  782,786
01EEA:  MOVFF  781,785
01EEE:  MOVFF  780,784
....................  
....................    if (y != 1.0) 
01EF2:  MOVFF  787,7A3
01EF6:  MOVFF  786,7A2
01EFA:  MOVFF  785,7A1
01EFE:  MOVFF  784,7A0
01F02:  MOVLB  7
01F04:  CLRF   xA7
01F06:  CLRF   xA6
01F08:  CLRF   xA5
01F0A:  MOVLW  7F
01F0C:  MOVWF  xA4
01F0E:  MOVLB  0
01F10:  RCALL  18FE
01F12:  BTFSC  FD8.2
01F14:  BRA    2252
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
01F16:  MOVLW  07
01F18:  MOVLB  7
01F1A:  MOVWF  x96
01F1C:  MOVLW  84
01F1E:  MOVWF  FE9
01F20:  MOVFF  796,FEA
01F24:  MOVLW  7E
01F26:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
01F28:  BSF    FD8.1
01F2A:  MOVFF  787,7A7
01F2E:  MOVFF  786,7A6
01F32:  MOVFF  785,7A5
01F36:  MOVFF  784,7A4
01F3A:  CLRF   xAB
01F3C:  CLRF   xAA
01F3E:  CLRF   xA9
01F40:  MOVLW  7F
01F42:  MOVWF  xA8
01F44:  MOVLB  0
01F46:  CALL   1432
01F4A:  MOVFF  00,795
01F4E:  MOVFF  01,796
01F52:  MOVFF  02,797
01F56:  MOVFF  03,798
01F5A:  BCF    FD8.1
01F5C:  MOVFF  787,7A7
01F60:  MOVFF  786,7A6
01F64:  MOVFF  785,7A5
01F68:  MOVFF  784,7A4
01F6C:  MOVLB  7
01F6E:  CLRF   xAB
01F70:  CLRF   xAA
01F72:  CLRF   xA9
01F74:  MOVLW  7F
01F76:  MOVWF  xA8
01F78:  MOVLB  0
01F7A:  CALL   1432
01F7E:  MOVFF  798,79C
01F82:  MOVFF  797,79B
01F86:  MOVFF  796,79A
01F8A:  MOVFF  795,799
01F8E:  MOVFF  03,7A0
01F92:  MOVFF  02,79F
01F96:  MOVFF  01,79E
01F9A:  MOVFF  00,79D
01F9E:  CALL   16AA
01FA2:  MOVFF  03,787
01FA6:  MOVFF  02,786
01FAA:  MOVFF  01,785
01FAE:  MOVFF  00,784
....................  
....................       y2=y*y; 
01FB2:  MOVFF  787,7A3
01FB6:  MOVFF  786,7A2
01FBA:  MOVFF  785,7A1
01FBE:  MOVFF  784,7A0
01FC2:  MOVFF  787,7A7
01FC6:  MOVFF  786,7A6
01FCA:  MOVFF  785,7A5
01FCE:  MOVFF  784,7A4
01FD2:  RCALL  1808
01FD4:  MOVFF  03,793
01FD8:  MOVFF  02,792
01FDC:  MOVFF  01,791
01FE0:  MOVFF  00,790
....................  
....................       res = pl[0]*y2 + pl[1]; 
01FE4:  MOVLW  99
01FE6:  MOVLB  7
01FE8:  MOVWF  xA3
01FEA:  MOVLW  47
01FEC:  MOVWF  xA2
01FEE:  MOVLW  8A
01FF0:  MOVWF  xA1
01FF2:  MOVLW  7F
01FF4:  MOVWF  xA0
01FF6:  MOVFF  793,7A7
01FFA:  MOVFF  792,7A6
01FFE:  MOVFF  791,7A5
02002:  MOVFF  790,7A4
02006:  MOVLB  0
02008:  CALL   1808
0200C:  MOVFF  00,795
02010:  MOVFF  01,796
02014:  MOVFF  02,797
02018:  MOVFF  03,798
0201C:  BCF    FD8.1
0201E:  MOVFF  03,7A7
02022:  MOVFF  02,7A6
02026:  MOVFF  01,7A5
0202A:  MOVFF  00,7A4
0202E:  MOVLB  7
02030:  CLRF   xAB
02032:  CLRF   xAA
02034:  CLRF   xA9
02036:  MOVLW  80
02038:  MOVWF  xA8
0203A:  MOVLB  0
0203C:  CALL   1432
02040:  MOVFF  03,78B
02044:  MOVFF  02,78A
02048:  MOVFF  01,789
0204C:  MOVFF  00,788
....................  
....................       r = ql[0]*y2 + ql[1]; 
02050:  MOVLW  4C
02052:  MOVLB  7
02054:  MOVWF  xA3
02056:  MOVLW  F3
02058:  MOVWF  xA2
0205A:  MOVLW  3A
0205C:  MOVWF  xA1
0205E:  MOVLW  7B
02060:  MOVWF  xA0
02062:  MOVFF  793,7A7
02066:  MOVFF  792,7A6
0206A:  MOVFF  791,7A5
0206E:  MOVFF  790,7A4
02072:  MOVLB  0
02074:  CALL   1808
02078:  MOVFF  00,795
0207C:  MOVFF  01,796
02080:  MOVFF  02,797
02084:  MOVFF  03,798
02088:  BCF    FD8.1
0208A:  MOVFF  03,7A7
0208E:  MOVFF  02,7A6
02092:  MOVFF  01,7A5
02096:  MOVFF  00,7A4
0209A:  MOVLW  2B
0209C:  MOVLB  7
0209E:  MOVWF  xAB
020A0:  MOVLW  9D
020A2:  MOVWF  xAA
020A4:  MOVLW  DF
020A6:  MOVWF  xA9
020A8:  MOVLW  7E
020AA:  MOVWF  xA8
020AC:  MOVLB  0
020AE:  CALL   1432
020B2:  MOVFF  03,78F
020B6:  MOVFF  02,78E
020BA:  MOVFF  01,78D
020BE:  MOVFF  00,78C
....................       r = r*y2 + 1.0; 
020C2:  MOVFF  78F,7A3
020C6:  MOVFF  78E,7A2
020CA:  MOVFF  78D,7A1
020CE:  MOVFF  78C,7A0
020D2:  MOVFF  793,7A7
020D6:  MOVFF  792,7A6
020DA:  MOVFF  791,7A5
020DE:  MOVFF  790,7A4
020E2:  CALL   1808
020E6:  MOVFF  00,795
020EA:  MOVFF  01,796
020EE:  MOVFF  02,797
020F2:  MOVFF  03,798
020F6:  BCF    FD8.1
020F8:  MOVFF  03,7A7
020FC:  MOVFF  02,7A6
02100:  MOVFF  01,7A5
02104:  MOVFF  00,7A4
02108:  MOVLB  7
0210A:  CLRF   xAB
0210C:  CLRF   xAA
0210E:  CLRF   xA9
02110:  MOVLW  7F
02112:  MOVWF  xA8
02114:  MOVLB  0
02116:  CALL   1432
0211A:  MOVFF  03,78F
0211E:  MOVFF  02,78E
02122:  MOVFF  01,78D
02126:  MOVFF  00,78C
....................  
....................       res = y*res/r; 
0212A:  MOVFF  787,7A3
0212E:  MOVFF  786,7A2
02132:  MOVFF  785,7A1
02136:  MOVFF  784,7A0
0213A:  MOVFF  78B,7A7
0213E:  MOVFF  78A,7A6
02142:  MOVFF  789,7A5
02146:  MOVFF  788,7A4
0214A:  CALL   1808
0214E:  MOVFF  00,795
02152:  MOVFF  01,796
02156:  MOVFF  02,797
0215A:  MOVFF  03,798
0215E:  MOVFF  03,79C
02162:  MOVFF  02,79B
02166:  MOVFF  01,79A
0216A:  MOVFF  00,799
0216E:  MOVFF  78F,7A0
02172:  MOVFF  78E,79F
02176:  MOVFF  78D,79E
0217A:  MOVFF  78C,79D
0217E:  CALL   16AA
02182:  MOVFF  03,78B
02186:  MOVFF  02,78A
0218A:  MOVFF  01,789
0218E:  MOVFF  00,788
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
02192:  MOVLW  07
02194:  MOVLB  7
02196:  MOVWF  x96
02198:  MOVLW  80
0219A:  MOVWF  FE9
0219C:  MOVFF  796,FEA
021A0:  MOVLW  7E
021A2:  SUBWF  FEF,W
021A4:  MOVWF  x94
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
021A6:  BTFSC  x94.7
021A8:  BRA    21AC
021AA:  BRA    21D4
....................          r = -(float32)-n; 
021AC:  MOVLW  00
021AE:  BSF    FD8.0
021B0:  SUBFWB x94,W
021B2:  CLRF   x97
021B4:  MOVWF  x96
021B6:  BTFSC  x96.7
021B8:  DECF   x97,F
021BA:  MOVLB  0
021BC:  RCALL  1E92
021BE:  MOVFF  00,78C
021C2:  MOVF   01,W
021C4:  XORLW  80
021C6:  MOVLB  7
021C8:  MOVWF  x8D
021CA:  MOVFF  02,78E
021CE:  MOVFF  03,78F
....................       else 
021D2:  BRA    21F4
....................          r = (float32)n; 
021D4:  CLRF   x97
021D6:  MOVFF  794,796
021DA:  BTFSC  x96.7
021DC:  DECF   x97,F
021DE:  MOVLB  0
021E0:  RCALL  1E92
021E2:  MOVFF  03,78F
021E6:  MOVFF  02,78E
021EA:  MOVFF  01,78D
021EE:  MOVFF  00,78C
021F2:  MOVLB  7
....................  
....................       res += r*LN2; 
021F4:  MOVFF  78F,7A3
021F8:  MOVFF  78E,7A2
021FC:  MOVFF  78D,7A1
02200:  MOVFF  78C,7A0
02204:  MOVLW  18
02206:  MOVWF  xA7
02208:  MOVLW  72
0220A:  MOVWF  xA6
0220C:  MOVLW  31
0220E:  MOVWF  xA5
02210:  MOVLW  7E
02212:  MOVWF  xA4
02214:  MOVLB  0
02216:  CALL   1808
0221A:  BCF    FD8.1
0221C:  MOVFF  78B,7A7
02220:  MOVFF  78A,7A6
02224:  MOVFF  789,7A5
02228:  MOVFF  788,7A4
0222C:  MOVFF  03,7AB
02230:  MOVFF  02,7AA
02234:  MOVFF  01,7A9
02238:  MOVFF  00,7A8
0223C:  CALL   1432
02240:  MOVFF  03,78B
02244:  MOVFF  02,78A
02248:  MOVFF  01,789
0224C:  MOVFF  00,788
....................    } 
....................  
....................    else 
02250:  BRA    225E
....................       res = 0.0; 
02252:  MOVLB  7
02254:  CLRF   x8B
02256:  CLRF   x8A
02258:  CLRF   x89
0225A:  CLRF   x88
0225C:  MOVLB  0
....................  
....................    return(res); 
0225E:  MOVFF  788,00
02262:  MOVFF  789,01
02266:  MOVFF  78A,02
0226A:  MOVFF  78B,03
.................... } 
0226E:  RETURN 0
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
0267A:  MOVFF  777,7A3
0267E:  MOVFF  776,7A2
02682:  MOVFF  775,7A1
02686:  MOVFF  774,7A0
0268A:  MOVLB  7
0268C:  CLRF   xA7
0268E:  CLRF   xA6
02690:  CLRF   xA5
02692:  CLRF   xA4
02694:  MOVLB  0
02696:  CALL   18FE
0269A:  BTFSS  FD8.0
0269C:  BRA    2850
0269E:  MOVFF  77B,77F
026A2:  MOVFF  77A,77E
026A6:  MOVFF  779,77D
026AA:  MOVFF  778,77C
026AE:  MOVLB  7
026B0:  CLRF   x83
026B2:  CLRF   x82
026B4:  CLRF   x81
026B6:  MOVLW  7F
026B8:  MOVWF  x80
026BA:  MOVLB  0
026BC:  CALL   1D36
026C0:  MOVFF  00,77C
026C4:  MOVFF  01,77D
026C8:  MOVFF  02,77E
026CC:  MOVFF  03,77F
026D0:  MOVFF  03,7A3
026D4:  MOVFF  02,7A2
026D8:  MOVFF  01,7A1
026DC:  MOVFF  00,7A0
026E0:  MOVLB  7
026E2:  CLRF   xA7
026E4:  CLRF   xA6
026E6:  CLRF   xA5
026E8:  CLRF   xA4
026EA:  MOVLB  0
026EC:  CALL   18FE
026F0:  BTFSS  FD8.2
026F2:  BRA    2850
....................       if(fmod(y, 2) == 0) { 
026F4:  MOVFF  77B,77F
026F8:  MOVFF  77A,77E
026FC:  MOVFF  779,77D
02700:  MOVFF  778,77C
02704:  MOVLB  7
02706:  CLRF   x83
02708:  CLRF   x82
0270A:  CLRF   x81
0270C:  MOVLW  80
0270E:  MOVWF  x80
02710:  MOVLB  0
02712:  CALL   1D36
02716:  MOVFF  00,77C
0271A:  MOVFF  01,77D
0271E:  MOVFF  02,77E
02722:  MOVFF  03,77F
02726:  MOVFF  03,7A3
0272A:  MOVFF  02,7A2
0272E:  MOVFF  01,7A1
02732:  MOVFF  00,7A0
02736:  MOVLB  7
02738:  CLRF   xA7
0273A:  CLRF   xA6
0273C:  CLRF   xA5
0273E:  CLRF   xA4
02740:  MOVLB  0
02742:  CALL   18FE
02746:  BNZ   27CA
....................          return (exp(log(-x) * y)); 
02748:  MOVFF  774,77C
0274C:  MOVLB  7
0274E:  MOVF   x75,W
02750:  XORLW  80
02752:  MOVWF  x7D
02754:  MOVFF  776,77E
02758:  MOVFF  777,77F
0275C:  MOVFF  777,783
02760:  MOVFF  776,782
02764:  MOVWF  x81
02766:  MOVFF  774,780
0276A:  MOVLB  0
0276C:  CALL   1EE2
02770:  MOVFF  00,77C
02774:  MOVFF  01,77D
02778:  MOVFF  02,77E
0277C:  MOVFF  03,77F
02780:  MOVFF  03,7A3
02784:  MOVFF  02,7A2
02788:  MOVFF  01,7A1
0278C:  MOVFF  00,7A0
02790:  MOVFF  77B,7A7
02794:  MOVFF  77A,7A6
02798:  MOVFF  779,7A5
0279C:  MOVFF  778,7A4
027A0:  CALL   1808
027A4:  MOVFF  00,77C
027A8:  MOVFF  01,77D
027AC:  MOVFF  02,77E
027B0:  MOVFF  03,77F
027B4:  MOVFF  03,783
027B8:  MOVFF  02,782
027BC:  MOVFF  01,781
027C0:  MOVFF  00,780
027C4:  RCALL  2270
027C6:  BRA    2984
....................       } else { 
027C8:  BRA    284E
....................          return (-exp(log(-x) * y)); 
027CA:  MOVFF  774,77C
027CE:  MOVLB  7
027D0:  MOVF   x75,W
027D2:  XORLW  80
027D4:  MOVWF  x7D
027D6:  MOVFF  776,77E
027DA:  MOVFF  777,77F
027DE:  MOVFF  777,783
027E2:  MOVFF  776,782
027E6:  MOVWF  x81
027E8:  MOVFF  774,780
027EC:  MOVLB  0
027EE:  CALL   1EE2
027F2:  MOVFF  00,77C
027F6:  MOVFF  01,77D
027FA:  MOVFF  02,77E
027FE:  MOVFF  03,77F
02802:  MOVFF  03,7A3
02806:  MOVFF  02,7A2
0280A:  MOVFF  01,7A1
0280E:  MOVFF  00,7A0
02812:  MOVFF  77B,7A7
02816:  MOVFF  77A,7A6
0281A:  MOVFF  779,7A5
0281E:  MOVFF  778,7A4
02822:  CALL   1808
02826:  MOVFF  00,77C
0282A:  MOVFF  01,77D
0282E:  MOVFF  02,77E
02832:  MOVFF  03,77F
02836:  MOVFF  03,783
0283A:  MOVFF  02,782
0283E:  MOVFF  01,781
02842:  MOVFF  00,780
02846:  RCALL  2270
02848:  MOVLW  80
0284A:  XORWF  01,F
0284C:  BRA    2984
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
0284E:  BRA    2984
02850:  MOVFF  777,7A3
02854:  MOVFF  776,7A2
02858:  MOVFF  775,7A1
0285C:  MOVFF  774,7A0
02860:  MOVLB  7
02862:  CLRF   xA7
02864:  CLRF   xA6
02866:  CLRF   xA5
02868:  CLRF   xA4
0286A:  MOVLB  0
0286C:  CALL   18FE
02870:  BNC   28D2
02872:  MOVFF  77B,77F
02876:  MOVFF  77A,77E
0287A:  MOVFF  779,77D
0287E:  MOVFF  778,77C
02882:  MOVLB  7
02884:  CLRF   x83
02886:  CLRF   x82
02888:  CLRF   x81
0288A:  MOVLW  7F
0288C:  MOVWF  x80
0288E:  MOVLB  0
02890:  CALL   1D36
02894:  MOVFF  00,77C
02898:  MOVFF  01,77D
0289C:  MOVFF  02,77E
028A0:  MOVFF  03,77F
028A4:  MOVFF  03,7A3
028A8:  MOVFF  02,7A2
028AC:  MOVFF  01,7A1
028B0:  MOVFF  00,7A0
028B4:  MOVLB  7
028B6:  CLRF   xA7
028B8:  CLRF   xA6
028BA:  CLRF   xA5
028BC:  CLRF   xA4
028BE:  MOVLB  0
028C0:  CALL   18FE
028C4:  BZ    28D2
....................       return 0; 
028C6:  CLRF   00
028C8:  CLRF   01
028CA:  CLRF   02
028CC:  CLRF   03
028CE:  BRA    2984
....................    } else { 
028D0:  BRA    2984
....................       if(x != 0 || 0 >= y) { 
028D2:  MOVFF  777,7A3
028D6:  MOVFF  776,7A2
028DA:  MOVFF  775,7A1
028DE:  MOVFF  774,7A0
028E2:  MOVLB  7
028E4:  CLRF   xA7
028E6:  CLRF   xA6
028E8:  CLRF   xA5
028EA:  CLRF   xA4
028EC:  MOVLB  0
028EE:  CALL   18FE
028F2:  BNZ   2918
028F4:  MOVFF  77B,7A3
028F8:  MOVFF  77A,7A2
028FC:  MOVFF  779,7A1
02900:  MOVFF  778,7A0
02904:  MOVLB  7
02906:  CLRF   xA7
02908:  CLRF   xA6
0290A:  CLRF   xA5
0290C:  CLRF   xA4
0290E:  MOVLB  0
02910:  CALL   18FE
02914:  BC    2918
02916:  BNZ   2984
....................          return (exp(log(x) * y)); 
02918:  MOVFF  777,783
0291C:  MOVFF  776,782
02920:  MOVFF  775,781
02924:  MOVFF  774,780
02928:  CALL   1EE2
0292C:  MOVFF  00,77C
02930:  MOVFF  01,77D
02934:  MOVFF  02,77E
02938:  MOVFF  03,77F
0293C:  MOVFF  03,7A3
02940:  MOVFF  02,7A2
02944:  MOVFF  01,7A1
02948:  MOVFF  00,7A0
0294C:  MOVFF  77B,7A7
02950:  MOVFF  77A,7A6
02954:  MOVFF  779,7A5
02958:  MOVFF  778,7A4
0295C:  CALL   1808
02960:  MOVFF  00,77C
02964:  MOVFF  01,77D
02968:  MOVFF  02,77E
0296C:  MOVFF  03,77F
02970:  MOVFF  03,783
02974:  MOVFF  02,782
02978:  MOVFF  01,781
0297C:  MOVFF  00,780
02980:  RCALL  2270
02982:  BRA    2984
....................       } 
....................    } 
.................... } 
02984:  RETURN 0
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <DSP100_PINS.h> 
.................... // File DSP4x4_PINS.h 
....................  
.................... #define PIN_EEPROM_SDA  	PIN_C3  
.................... #define PIN_EEPROM_SCL  	PIN_C2  
....................  
.................... #define PIN_DSP_nRESET 		PIN_A4 
.................... #define PIN_DSP_SDA 		PIN_B0 
.................... #define PIN_DSP_SCL 		PIN_B1 
.................... #define PIN_DSP_IRQ			PIN_B2 
....................  
.................... #define PIN_AMP_nRESET 		PIN_A5 
.................... #define PIN_AMP_nMUTE		PIN_C1 
.................... #define PIN_AMP_READY		PIN_E2 
....................  
.................... #define PIN_AMP_M1			PIN_A1 
.................... #define PIN_AMP_M2			PIN_A2 
.................... #define PIN_AMP_M3			PIN_A3 
....................  
.................... #define PIN_USB_TX			PIN_C5 
.................... #define PIN_USB_RX			PIN_C4		 
....................  
.................... #define PIN_RS232_TX		PIN_D6 
.................... #define PIN_RS232_RX		PIN_D7 
....................  
.................... #define PIN_PHANTOM_ENABLE 	PIN_D5 
.................... #define PIN_PHANTOM_CH1 	PIN_B4 
.................... #define PIN_PHANTOM_CH2 	PIN_B5 
....................  
.................... #define AUD_MUTE			PIN_D3 
....................  
.................... // to be removed 
.................... #define PIN_CLIP1			PIN_A5 
.................... #define PIN_CLIP2			PIN_E0 
.................... #define PIN_CLIP3			PIN_E2 
.................... #define PIN_CLIP4			PIN_E1 
....................  
.................... #define PIN_PSON			PIN_B4 
....................  
.................... #define PIN_AUDIODETECT		PIN_B0 
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP1002_CONFIG.h> 
.................... // File DSP4x4_CONFIG.h 
....................  
.................... #define POWERUP_DELAY	200 
....................  
.................... #define IEEPROM_PRESET_LOC	0x10 
.................... #define IEEPROM_DEVICE_CONFIG_LOC 0x64 
.................... #define IEEPROM_FLAG_LOC 0x20 
....................  
.................... #define FLASH_PHANTOM_LOC 0x200 
.................... #define NUM_PRESETS			10 
.................... #define DEFAULT_PRESET		0 
....................  
.................... long int num_dsp_values = 478; // Not a define since the software will automatically change this if necessary 
....................  
.................... #define NUM_PRESET_PAGES			12 
.................... #define NUM_DSP_VALUE_PAGES			8		 
.................... #define NUM_PLAIN_VALUE_PAGES		4 
.................... #define PLAIN_VALUE_PAGES_OFFSET	8	 
.................... #define NUM_ADDRESS_PAGES			4 
.................... #define IOLABEL_PAGE				11 
....................  
.................... #define DEFAULT_ADDR_BLOCK			14 
.................... #define DEFAULT_VALUE_BLOCK			15 
....................  
.................... long int AUDIODETECT_HOLDTIME_SECONDS = 2; 
....................  
....................  
.................... #define DELAY_POWERUP			100 
.................... #define DELAY_AMP_MODE_SETTLE	1000 
.................... #define DELAY_DSP_RESET_SETTLE	50 
....................  
.................... unsigned int RVC_NOISE_FLOOR = 0; // Higher the number the fewer the subdivisions 
....................  
.................... /* store in EEPROM */ 
....................  
.................... const int DEBUG = 0; 
....................  
.................... double DEFAULT_ADC_CALIBRATION_MIN	= 30.0; 
.................... double DEFAULT_ADC_CALIBRATION_MAX	= 240.0; 
....................  
.................... int DEFAULT_AMP_MODE = 1; // 0 = 4CH, 1 = 2CH, 2 = 1CH 
.................... int DEFAULT_IS_70V = 1; 
....................  
.................... int DEFAULT_RVC_ENABLE = 1; 
.................... int DEFAULT_USBDETECT_ENABLE = 1; 
.................... int DEFAULT_AMPBOOT_DELAY_ENABLE = 1; 
.................... int DEFAULT_PS_PIN_ENABLE = 0; 
.................... int DEFAULT_DSP_VALUESEND_ENABLE = 1; 
.................... int DEFAULT_SLEEP_ENABLE = 0; 
.................... int16 DEFAULT_SLEEP_SECONDS = 65; 
.................... int16 DEFAULT_SLEEP_HOLDTIME = 60; 
....................  
.................... #define DEVICE_ID_MSB	0 
.................... #define DEVICE_ID_LSB	0x1F 
....................  
.................... typedef struct { 
.................... 	 
.................... 	int AMP_MODE; 
.................... 	int IS_70V; 
.................... 	 
.................... 	double ADC_CALIBRATION_MIN; 
.................... 	double ADC_CALIBRATION_MAX; 
....................  
.................... 	 
.................... 	int RVC_ENABLE; 
.................... 	int USBDETECT_ENABLE; 
.................... 	int AMPBOOT_DELAY_ENABLE; 
.................... 	int PS_PIN_ENABLE; 
.................... 	int DSP_VALUESEND_ENABLE; 
.................... 	int SLEEP_ENABLE; 
.................... 	int16 SLEEP_SECONDS; 
.................... 	int16 SLEEP_HOLDTIME; 
.................... 	char SERIAL[20]; 
.................... } device_configuration; 
....................  
.................... device_configuration DEVICE_CONFIG; 
....................  
.................... 	 
....................  
....................  
.................... #include <main.h> 
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // VERSION INFO 
.................... int MAJOR_REVISION = 1; 
.................... int MINOR_REVISION = 1; 
.................... char REVISION_TEXT[20] = "-DSP100-2"; 
....................  
.................... // USEFUL DEFINES 
.................... #define hi(x) (*((int8*)&x+1))  
.................... #define ON     0x00000001 
.................... #define OFF    0x00000000 
....................  
.................... // Used for eeprom.c 
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... // EEPROM DEFINES 
.................... #use I2C(MASTER, SDA=PIN_C3, SCL=PIN_C2) 
*
012C8:  MOVLW  08
012CA:  MOVWF  01
012CC:  MOVLW  03
012CE:  MOVWF  00
012D0:  DECFSZ 00,F
012D2:  BRA    12D0
012D4:  BCF    F8B.2
012D6:  BCF    F94.2
012D8:  MOVLW  03
012DA:  MOVWF  00
012DC:  DECFSZ 00,F
012DE:  BRA    12DC
012E0:  MOVLB  7
012E2:  RLCF   x83,F
012E4:  BCF    F8B.3
012E6:  BTFSC  FD8.0
012E8:  BSF    F94.3
012EA:  BTFSS  FD8.0
012EC:  BCF    F94.3
012EE:  BSF    F94.2
012F0:  BTFSS  F82.2
012F2:  BRA    12F0
012F4:  DECFSZ 01,F
012F6:  BRA    12FA
012F8:  BRA    12FE
012FA:  MOVLB  0
012FC:  BRA    12CC
012FE:  MOVLW  03
01300:  MOVWF  00
01302:  DECFSZ 00,F
01304:  BRA    1302
01306:  BCF    F8B.2
01308:  BCF    F94.2
0130A:  NOP   
0130C:  BSF    F94.3
0130E:  MOVLW  03
01310:  MOVWF  00
01312:  DECFSZ 00,F
01314:  BRA    1312
01316:  MOVLW  03
01318:  MOVWF  00
0131A:  DECFSZ 00,F
0131C:  BRA    131A
0131E:  BSF    F94.2
01320:  BTFSS  F82.2
01322:  BRA    1320
01324:  CLRF   01
01326:  MOVLW  03
01328:  MOVWF  00
0132A:  DECFSZ 00,F
0132C:  BRA    132A
0132E:  BTFSC  F82.3
01330:  BSF    01.0
01332:  BCF    F8B.2
01334:  BCF    F94.2
01336:  BCF    F8B.3
01338:  BCF    F94.3
0133A:  MOVLB  0
0133C:  RETURN 0
*
07324:  MOVLW  08
07326:  MOVLB  7
07328:  MOVWF  x29
0732A:  MOVFF  00,72A
0732E:  BSF    F94.3
07330:  MOVLW  03
07332:  MOVWF  00
07334:  DECFSZ 00,F
07336:  BRA    7334
07338:  BSF    F94.2
0733A:  BTFSS  F82.2
0733C:  BRA    733A
0733E:  BTFSC  F82.3
07340:  BSF    FD8.0
07342:  BTFSS  F82.3
07344:  BCF    FD8.0
07346:  RLCF   01,F
07348:  MOVLW  03
0734A:  MOVWF  00
0734C:  DECFSZ 00,F
0734E:  BRA    734C
07350:  BCF    F94.2
07352:  BCF    F8B.2
07354:  DECFSZ x29,F
07356:  BRA    732E
07358:  BSF    F94.3
0735A:  MOVLW  03
0735C:  MOVWF  00
0735E:  DECFSZ 00,F
07360:  BRA    735E
07362:  BCF    F8B.3
07364:  MOVF   x2A,W
07366:  BTFSS  FD8.2
07368:  BCF    F94.3
0736A:  NOP   
0736C:  BSF    F94.2
0736E:  BTFSS  F82.2
07370:  BRA    736E
07372:  MOVLW  03
07374:  MOVWF  00
07376:  DECFSZ 00,F
07378:  BRA    7376
0737A:  BCF    F8B.2
0737C:  BCF    F94.2
0737E:  MOVLW  03
07380:  MOVWF  00
07382:  DECFSZ 00,F
07384:  BRA    7382
07386:  BCF    F8B.3
07388:  BCF    F94.3
0738A:  MOVLB  0
0738C:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int  
.................... #define EEPROM_SIZE   (128*8*8)  
....................  
.................... // RS232 DEFINES 
....................  
.................... #use rs232(baud=19200,parity=N,xmit=PIN_USB_TX,rcv=PIN_USB_RX,bits=8,errors,stream=USB,FORCE_SW) 
*
07198:  BSF    F94.4
0719A:  BTFSC  F82.4
0719C:  BRA    719A
0719E:  MOVLW  08
071A0:  MOVWF  00
071A2:  MOVLB  7
071A4:  CLRF   x2A
071A6:  BSF    00.7
071A8:  BRA    71C6
071AA:  BCF    00.7
071AC:  BRA    71C6
071AE:  BCF    FD8.0
071B0:  BTFSC  F82.4
071B2:  BSF    FD8.0
071B4:  RRCF   x2A,F
071B6:  BSF    00.6
071B8:  BRA    71C6
071BA:  BCF    00.6
071BC:  DECFSZ 00,F
071BE:  BRA    71AE
071C0:  MOVFF  72A,01
071C4:  BRA    71DE
071C6:  MOVLW  39
071C8:  BTFSC  00.7
071CA:  MOVLW  0F
071CC:  MOVWF  01
071CE:  DECFSZ 01,F
071D0:  BRA    71CE
071D2:  BRA    71D4
071D4:  BTFSC  00.7
071D6:  BRA    71AA
071D8:  BTFSC  00.6
071DA:  BRA    71BA
071DC:  BRA    71AE
071DE:  MOVLB  0
071E0:  RETURN 0
*
07234:  BCF    F94.5
07236:  BCF    F8B.5
07238:  MOVLW  08
0723A:  MOVWF  01
0723C:  BRA    723E
0723E:  NOP   
07240:  BSF    01.7
07242:  BRA    7264
07244:  BCF    01.7
07246:  MOVLB  7
07248:  RRCF   x29,F
0724A:  MOVLB  0
0724C:  BTFSC  FD8.0
0724E:  BSF    F8B.5
07250:  BTFSS  FD8.0
07252:  BCF    F8B.5
07254:  BSF    01.6
07256:  BRA    7264
07258:  BCF    01.6
0725A:  DECFSZ 01,F
0725C:  BRA    7246
0725E:  BRA    7260
07260:  NOP   
07262:  BSF    F8B.5
07264:  MOVLW  39
07266:  MOVWF  FE9
07268:  DECFSZ FE9,F
0726A:  BRA    7268
0726C:  BRA    726E
0726E:  NOP   
07270:  BTFSC  01.7
07272:  BRA    7244
07274:  BTFSC  01.6
07276:  BRA    7258
07278:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_RS232_TX,rcv=PIN_RS232_RX,bits=8,errors, stream=RS232) 
*
077DC:  BTFSS  FA4.4
077DE:  BRA    77DC
077E0:  MOVWF  F73
077E2:  GOTO   7828 (RETURN)
....................  
.................... #define FLASH_CS	PIN_D2 
....................  
.................... #use SPI(DO = PIN_D4, DI = PIN_D1, CLK = PIN_D0,BITS = 8,MSB_FIRST, SAMPLE_RISE)  
*
05CCA:  MOVLB  7
05CCC:  MOVF   x45,W
05CCE:  SUBLW  08
05CD0:  BZ    5CDA
05CD2:  MOVWF  x46
05CD4:  RLCF   x44,F
05CD6:  DECFSZ x46,F
05CD8:  BRA    5CD4
05CDA:  BSF    F95.1
05CDC:  BCF    F95.4
05CDE:  BCF    F95.0
05CE0:  BCF    F8C.0
05CE2:  MOVFF  745,746
05CE6:  BTFSS  x44.7
05CE8:  BCF    F8C.4
05CEA:  BTFSC  x44.7
05CEC:  BSF    F8C.4
05CEE:  RLCF   x44,F
05CF0:  BSF    F8C.0
05CF2:  RLCF   01,F
05CF4:  BTFSS  F83.1
05CF6:  BCF    01.0
05CF8:  BTFSC  F83.1
05CFA:  BSF    01.0
05CFC:  BCF    F8C.0
05CFE:  DECFSZ x46,F
05D00:  BRA    5CE6
05D02:  MOVLB  0
05D04:  RETURN 0
....................  
.................... int IS_USB_CONNECTED; 
....................  
....................  
.................... // DSP DEFINES 
.................... #define DSP_I2C_ADDRESS 0x80 
....................  
.................... // MEMORY DEFINES 
.................... int CURRENT_FLASH_PROGRAM = 0; 
....................  
.................... #define PAGE_SIZE  64  
.................... #define NUM_PAGES 9 
.................... #define TOTAL_ARRAY_SIZE (PAGE_SIZE*NUM_PAGES) 
....................  
.................... int32 PAGE_BUFFER_A[PAGE_SIZE]; 
....................  
....................  
.................... /* VARIABLES FOR RVC */ 
.................... unsigned int last_adc = 0; 
.................... unsigned int current_adc = 0; 
....................  
.................... int is_muted = 0; 
.................... int pin_in_mute_state = 0; 
....................  
....................  
.................... /* VARIABLES FOR SLEEP TIMER */ 
.................... int16 sleepseconds; 
.................... int16 sleeptimeout_seconds = 10; 
....................  
.................... int is_in_sleep = 0; 
.................... int sleep_timer_active = 0; 
....................  
.................... typedef struct { 
.................... 	int16 ADDRESSES_1[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_2[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_3[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_4[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_5[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_6[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_7[PAGE_SIZE]; 
.................... 	int16 ADDRESSES_8[PAGE_SIZE]; 
.................... } dsp_addresses; 
....................  
.................... dsp_addresses DSP_ADDR; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <DSP_mapping.h> 
.................... // This map is for FLX4CHANNEL_WITHNET_REVI 
.................... // Map generated 1-30-14 by Patrick Paul 
....................  
.................... #define DSP_ADDRESS_WRITE_PREFIX 0xF000 
.................... #define DSP_ADDRESS_READ_PREFIX 0xF0C0 
....................  
.................... /** 'AUDIO MANAGER' **/ 
.................... #define AM_MASTERGAIN		0x83000000	 
.................... #define AM_ANALOG1_TRIM		0x8300000a 
.................... #define AM_ANALOG2_TRIM		0x8300000b 
.................... #define AM_ANALOG3_TRIM		0x8300000c 
.................... #define AM_ANALOG4_TRIM		0x8300000d 
....................  
.................... #define PREGAIN_CH1 0x0373 
.................... #define PREGAIN_MUTE_CH1 0x0443 
.................... #define PREGAIN_CH2 0x03cf 
.................... #define PREGAIN_MUTE_CH2 0x0441 
.................... #define PREGAIN_CH3 0x03cb 
.................... #define PREGAIN_MUTE_CH3 0x043f 
.................... #define PREGAIN_CH4 0x03c7 
.................... #define PREGAIN_MUTE_CH4 0x043d 
.................... #define PREGAIN_CH5 0x03c3 
.................... #define PREGAIN_MUTE_CH5 0x043b 
.................... #define PREGAIN_CH6 0x03bf 
.................... #define PREGAIN_MUTE_CH6 0x0439 
.................... #define PREGAIN_CH7 0x03bb 
.................... #define PREGAIN_MUTE_CH7 0x0437 
.................... #define PREGAIN_CH8 0x03b7 
.................... #define PREGAIN_MUTE_CH8 0x0435 
.................... #define PREMIX_CH1 0x03b3 
.................... #define PREMIX_MUTE_CH1 0x0433 
.................... #define PREMIX_CH2 0x03af 
.................... #define PREMIX_MUTE_CH2 0x0431 
.................... #define PREMIX_CH3 0x03ab 
.................... #define PREMIX_MUTE_CH3 0x042f 
.................... #define PREMIX_CH4 0x03a7 
.................... #define PREMIX_MUTE_CH4 0x042d 
.................... #define PREMIX_CH5 0x03a3 
.................... #define PREMIX_MUTE_CH5 0x042b 
.................... #define PREMIX_CH6 0x039f 
.................... #define PREMIX_MUTE_CH6 0x0429 
.................... #define PREMIX_CH7 0x039b 
.................... #define PREMIX_MUTE_CH7 0x0427 
.................... #define PREMIX_CH8 0x0397 
.................... #define PREMIX_MUTE_CH8 0x0425 
.................... #define TRIM_CH1 0x0393 
.................... #define TRIM_MUTE_CH1 0x0423 
.................... #define TRIM_CH2 0x038f 
.................... #define TRIM_MUTE_CH2 0x0421 
.................... #define TRIM_CH3 0x038b 
.................... #define TRIM_MUTE_CH3 0x041f 
.................... #define TRIM_CH4 0x0387 
.................... #define TRIM_MUTE_CH4 0x041d 
.................... #define OUTPUTGAIN_CH1 0x0383 
.................... #define OUTPUT_MUTE_CH1 0x041b 
.................... #define OUTPUTGAIN_CH2 0x037f 
.................... #define OUTPUT_MUTE_CH2 0x0419 
.................... #define OUTPUTGAIN_CH3 0x037b 
.................... #define OUTPUT_MUTE_CH3 0x0417 
.................... #define OUTPUTGAIN_CH4 0x0377 
.................... #define OUTPUT_MUTE_CH4 0x0415 
.................... #define INDUCKROUTER_SELECT0 0x020e 
.................... #define INDUCKROUTER_SELECT1 0x020f 
.................... #define INDUCKROUTER_SELECT2 0x0210 
.................... #define INDUCKROUTER_SELECT3 0x0211 
.................... #define INDUCKROUTER_SELECT4 0x0212 
.................... #define INDUCKROUTER_SELECT5 0x0213 
.................... #define INDUCKROUTER_SELECT6 0x0214 
.................... #define INDUCKROUTER_SELECT7 0x0215 
.................... #define OUTDUCKROUTER_SELECT0 0x0205 
.................... #define OUTDUCKROUTER_SELECT1 0x0206 
.................... #define OUTDUCKROUTER_SELECT2 0x0207 
.................... #define OUTDUCKROUTER_SELECT3 0x0208 
.................... #define OUTDUCKROUTER_SELECT4 0x0209 
.................... #define OUTDUCKROUTER_SELECT5 0x020a 
.................... #define OUTDUCKROUTER_SELECT6 0x020b 
.................... #define OUTDUCKROUTER_SELECT7 0x020c 
.................... #define DUCKER_THRESHOLD 0x0276 
.................... #define DUCKER_HOLD 0x0277 
.................... #define DUCKER_DEPTH 0x0278 
.................... #define DUCKER_ATTACK 0x0279 
.................... #define DUCKER_RELEASE 0x027a 
.................... #define DUCKER_BYPASS 0x027b 
.................... #define IN_1_1_FILTER_B0 0x036d 
.................... #define IN_1_1_FILTER_B1 0x036e 
.................... #define IN_1_1_FILTER_B2 0x036f 
.................... #define IN_1_1_FILTER_MINUSA1 0x0370 
.................... #define IN_1_1_FILTER_MINUSA2 0x0371 
.................... #define IN_1_2_FILTER_B0 0x0368 
.................... #define IN_1_2_FILTER_B1 0x0369 
.................... #define IN_1_2_FILTER_B2 0x036a 
.................... #define IN_1_2_FILTER_MINUSA1 0x036b 
.................... #define IN_1_2_FILTER_MINUSA2 0x036c 
.................... #define IN_1_3_FILTER_B0 0x0363 
.................... #define IN_1_3_FILTER_B1 0x0364 
.................... #define IN_1_3_FILTER_B2 0x0365 
.................... #define IN_1_3_FILTER_MINUSA1 0x0366 
.................... #define IN_1_3_FILTER_MINUSA2 0x0367 
.................... #define IN_2_1_FILTER_B0 0x035e 
.................... #define IN_2_1_FILTER_B1 0x035f 
.................... #define IN_2_1_FILTER_B2 0x0360 
.................... #define IN_2_1_FILTER_MINUSA1 0x0361 
.................... #define IN_2_1_FILTER_MINUSA2 0x0362 
.................... #define IN_2_2_FILTER_B0 0x0359 
.................... #define IN_2_2_FILTER_B1 0x035a 
.................... #define IN_2_2_FILTER_B2 0x035b 
.................... #define IN_2_2_FILTER_MINUSA1 0x035c 
.................... #define IN_2_2_FILTER_MINUSA2 0x035d 
.................... #define IN_2_3_FILTER_B0 0x0354 
.................... #define IN_2_3_FILTER_B1 0x0355 
.................... #define IN_2_3_FILTER_B2 0x0356 
.................... #define IN_2_3_FILTER_MINUSA1 0x0357 
.................... #define IN_2_3_FILTER_MINUSA2 0x0358 
.................... #define IN_3_1_FILTER_B0 0x034f 
.................... #define IN_3_1_FILTER_B1 0x0350 
.................... #define IN_3_1_FILTER_B2 0x0351 
.................... #define IN_3_1_FILTER_MINUSA1 0x0352 
.................... #define IN_3_1_FILTER_MINUSA2 0x0353 
.................... #define IN_3_2_FILTER_B0 0x034a 
.................... #define IN_3_2_FILTER_B1 0x034b 
.................... #define IN_3_2_FILTER_B2 0x034c 
.................... #define IN_3_2_FILTER_MINUSA1 0x034d 
.................... #define IN_3_2_FILTER_MINUSA2 0x034e 
.................... #define IN_3_3_FILTER_B0 0x0345 
.................... #define IN_3_3_FILTER_B1 0x0346 
.................... #define IN_3_3_FILTER_B2 0x0347 
.................... #define IN_3_3_FILTER_MINUSA1 0x0348 
.................... #define IN_3_3_FILTER_MINUSA2 0x0349 
.................... #define IN_4_1_FILTER_B0 0x0340 
.................... #define IN_4_1_FILTER_B1 0x0341 
.................... #define IN_4_1_FILTER_B2 0x0342 
.................... #define IN_4_1_FILTER_MINUSA1 0x0343 
.................... #define IN_4_1_FILTER_MINUSA2 0x0344 
.................... #define IN_4_2_FILTER_B0 0x033b 
.................... #define IN_4_2_FILTER_B1 0x033c 
.................... #define IN_4_2_FILTER_B2 0x033d 
.................... #define IN_4_2_FILTER_MINUSA1 0x033e 
.................... #define IN_4_2_FILTER_MINUSA2 0x033f 
.................... #define IN_4_3_FILTER_B0 0x0336 
.................... #define IN_4_3_FILTER_B1 0x0337 
.................... #define IN_4_3_FILTER_B2 0x0338 
.................... #define IN_4_3_FILTER_MINUSA1 0x0339 
.................... #define IN_4_3_FILTER_MINUSA2 0x033a 
.................... #define IN_5_1_FILTER_B0 0x0331 
.................... #define IN_5_1_FILTER_B1 0x0332 
.................... #define IN_5_1_FILTER_B2 0x0333 
.................... #define IN_5_1_FILTER_MINUSA1 0x0334 
.................... #define IN_5_1_FILTER_MINUSA2 0x0335 
.................... #define IN_5_2_FILTER_B0 0x032c 
.................... #define IN_5_2_FILTER_B1 0x032d 
.................... #define IN_5_2_FILTER_B2 0x032e 
.................... #define IN_5_2_FILTER_MINUSA1 0x032f 
.................... #define IN_5_2_FILTER_MINUSA2 0x0330 
.................... #define IN_5_3_FILTER_B0 0x0327 
.................... #define IN_5_3_FILTER_B1 0x0328 
.................... #define IN_5_3_FILTER_B2 0x0329 
.................... #define IN_5_3_FILTER_MINUSA1 0x032a 
.................... #define IN_5_3_FILTER_MINUSA2 0x032b 
.................... #define IN_6_1_FILTER_B0 0x0322 
.................... #define IN_6_1_FILTER_B1 0x0323 
.................... #define IN_6_1_FILTER_B2 0x0324 
.................... #define IN_6_1_FILTER_MINUSA1 0x0325 
.................... #define IN_6_1_FILTER_MINUSA2 0x0326 
.................... #define IN_6_2_FILTER_B0 0x031d 
.................... #define IN_6_2_FILTER_B1 0x031e 
.................... #define IN_6_2_FILTER_B2 0x031f 
.................... #define IN_6_2_FILTER_MINUSA1 0x0320 
.................... #define IN_6_2_FILTER_MINUSA2 0x0321 
.................... #define IN_6_3_FILTER_B0 0x0318 
.................... #define IN_6_3_FILTER_B1 0x0319 
.................... #define IN_6_3_FILTER_B2 0x031a 
.................... #define IN_6_3_FILTER_MINUSA1 0x031b 
.................... #define IN_6_3_FILTER_MINUSA2 0x031c 
.................... #define IN_7_1_FILTER_B0 0x0313 
.................... #define IN_7_1_FILTER_B1 0x0314 
.................... #define IN_7_1_FILTER_B2 0x0315 
.................... #define IN_7_1_FILTER_MINUSA1 0x0316 
.................... #define IN_7_1_FILTER_MINUSA2 0x0317 
.................... #define IN_7_2_FILTER_B0 0x030e 
.................... #define IN_7_2_FILTER_B1 0x030f 
.................... #define IN_7_2_FILTER_B2 0x0310 
.................... #define IN_7_2_FILTER_MINUSA1 0x0311 
.................... #define IN_7_2_FILTER_MINUSA2 0x0312 
.................... #define IN_7_3_FILTER_B0 0x0309 
.................... #define IN_7_3_FILTER_B1 0x030a 
.................... #define IN_7_3_FILTER_B2 0x030b 
.................... #define IN_7_3_FILTER_MINUSA1 0x030c 
.................... #define IN_7_3_FILTER_MINUSA2 0x030d 
.................... #define IN_8_1_FILTER_B0 0x0304 
.................... #define IN_8_1_FILTER_B1 0x0305 
.................... #define IN_8_1_FILTER_B2 0x0306 
.................... #define IN_8_1_FILTER_MINUSA1 0x0307 
.................... #define IN_8_1_FILTER_MINUSA2 0x0308 
.................... #define IN_8_2_FILTER_B0 0x02ff 
.................... #define IN_8_2_FILTER_B1 0x0300 
.................... #define IN_8_2_FILTER_B2 0x0301 
.................... #define IN_8_2_FILTER_MINUSA1 0x0302 
.................... #define IN_8_2_FILTER_MINUSA2 0x0303 
.................... #define IN_8_3_FILTER_B0 0x02fa 
.................... #define IN_8_3_FILTER_B1 0x02fb 
.................... #define IN_8_3_FILTER_B2 0x02fc 
.................... #define IN_8_3_FILTER_MINUSA1 0x02fd 
.................... #define IN_8_3_FILTER_MINUSA2 0x02fe 
.................... #define CH1COMP_THRESHOLD 0x026e 
.................... #define CH1COMP_KNEE 0x026f 
.................... #define CH1COMP_RATIO 0x0270 
.................... #define CH1COMP_ATTACK 0x0271 
.................... #define CH1COMP_RELEASE 0x0272 
.................... #define CH1COMP_BYPASS 0x0273 
.................... #define CH2COMP_THRESHOLD 0x0266 
.................... #define CH2COMP_KNEE 0x0267 
.................... #define CH2COMP_RATIO 0x0268 
.................... #define CH2COMP_ATTACK 0x0269 
.................... #define CH2COMP_RELEASE 0x026a 
.................... #define CH2COMP_BYPASS 0x026b 
.................... #define CH3COMP_THRESHOLD 0x025e 
.................... #define CH3COMP_KNEE 0x025f 
.................... #define CH3COMP_RATIO 0x0260 
.................... #define CH3COMP_ATTACK 0x0261 
.................... #define CH3COMP_RELEASE 0x0262 
.................... #define CH3COMP_BYPASS 0x0263 
.................... #define CH4COMP_THRESHOLD 0x0256 
.................... #define CH4COMP_KNEE 0x0257 
.................... #define CH4COMP_RATIO 0x0258 
.................... #define CH4COMP_ATTACK 0x0259 
.................... #define CH4COMP_RELEASE 0x025a 
.................... #define CH4COMP_BYPASS 0x025b 
.................... #define CH5COMP_THRESHOLD 0x024e 
.................... #define CH5COMP_KNEE 0x024f 
.................... #define CH5COMP_RATIO 0x0250 
.................... #define CH5COMP_ATTACK 0x0251 
.................... #define CH5COMP_RELEASE 0x0252 
.................... #define CH5COMP_BYPASS 0x0253 
.................... #define CH6COMP_THRESHOLD 0x0246 
.................... #define CH6COMP_KNEE 0x0247 
.................... #define CH6COMP_RATIO 0x0248 
.................... #define CH6COMP_ATTACK 0x0249 
.................... #define CH6COMP_RELEASE 0x024a 
.................... #define CH6COMP_BYPASS 0x024b 
.................... #define CH7COMP_THRESHOLD 0x023e 
.................... #define CH7COMP_KNEE 0x023f 
.................... #define CH7COMP_RATIO 0x0240 
.................... #define CH7COMP_ATTACK 0x0241 
.................... #define CH7COMP_RELEASE 0x0242 
.................... #define CH7COMP_BYPASS 0x0243 
.................... #define CH8COMP_THRESHOLD 0x0236 
.................... #define CH8COMP_KNEE 0x0237 
.................... #define CH8COMP_RATIO 0x0238 
.................... #define CH8COMP_ATTACK 0x0239 
.................... #define CH8COMP_RELEASE 0x023a 
.................... #define CH8COMP_BYPASS 0x023b 
.................... #define MIXER_SELECT0 0x0003 
.................... #define MIXER_SELECT1 0x0004 
.................... #define MIXER_SELECT2 0x0005 
.................... #define MIXER_SELECT3 0x0006 
.................... #define MIXER_SELECT4 0x0007 
.................... #define MIXER_SELECT5 0x0008 
.................... #define MIXER_SELECT6 0x0009 
.................... #define MIXER_SELECT7 0x000a 
.................... #define MIXER_SELECT8 0x000b 
.................... #define MIXER_SELECT9 0x000c 
.................... #define MIXER_SELECT10 0x000d 
.................... #define MIXER_SELECT11 0x000e 
.................... #define MIXER_SELECT12 0x000f 
.................... #define MIXER_SELECT13 0x0010 
.................... #define MIXER_SELECT14 0x0011 
.................... #define MIXER_SELECT15 0x0012 
.................... #define MIXER_SELECT16 0x0013 
.................... #define MIXER_SELECT17 0x0014 
.................... #define MIXER_SELECT18 0x0015 
.................... #define MIXER_SELECT19 0x0016 
.................... #define MIXER_SELECT20 0x0017 
.................... #define MIXER_SELECT21 0x0018 
.................... #define MIXER_SELECT22 0x0019 
.................... #define MIXER_SELECT23 0x001a 
.................... #define MIXER_SELECT24 0x001b 
.................... #define MIXER_SELECT25 0x001c 
.................... #define MIXER_SELECT26 0x001d 
.................... #define MIXER_SELECT27 0x001e 
.................... #define MIXER_SELECT28 0x001f 
.................... #define MIXER_SELECT29 0x0020 
.................... #define MIXER_SELECT30 0x0021 
.................... #define MIXER_SELECT31 0x0022 
.................... #define MIXER_SELECT32 0x0023 
.................... #define MIXER_SELECT33 0x0024 
.................... #define MIXER_SELECT34 0x0025 
.................... #define MIXER_SELECT35 0x0026 
.................... #define MIXER_SELECT36 0x0027 
.................... #define MIXER_SELECT37 0x0028 
.................... #define MIXER_SELECT38 0x0029 
.................... #define MIXER_SELECT39 0x002a 
.................... #define MIXER_SELECT40 0x002b 
.................... #define MIXER_SELECT41 0x002c 
.................... #define MIXER_SELECT42 0x002d 
.................... #define MIXER_SELECT43 0x002e 
.................... #define MIXER_SELECT44 0x002f 
.................... #define MIXER_SELECT45 0x0030 
.................... #define MIXER_SELECT46 0x0031 
.................... #define MIXER_SELECT47 0x0032 
.................... #define MIXER_SELECT48 0x0033 
.................... #define MIXER_SELECT49 0x0034 
.................... #define MIXER_SELECT50 0x0035 
.................... #define MIXER_SELECT51 0x0036 
.................... #define MIXER_SELECT52 0x0037 
.................... #define MIXER_SELECT53 0x0038 
.................... #define MIXER_SELECT54 0x0039 
.................... #define MIXER_SELECT55 0x003a 
.................... #define MIXER_SELECT56 0x003b 
.................... #define MIXER_SELECT57 0x003c 
.................... #define MIXER_SELECT58 0x003d 
.................... #define MIXER_SELECT59 0x003e 
.................... #define MIXER_SELECT60 0x003f 
.................... #define MIXER_SELECT61 0x0040 
.................... #define MIXER_SELECT62 0x0041 
.................... #define MIXER_SELECT63 0x0042 
.................... #define MIXER_SELECT64 0x0043 
.................... #define MIXER_SELECT65 0x0044 
.................... #define MIXER_SELECT66 0x0045 
.................... #define MIXER_SELECT67 0x0046 
.................... #define MIXER_SELECT68 0x0047 
.................... #define MIXER_SELECT69 0x0048 
.................... #define MIXER_SELECT70 0x0049 
.................... #define MIXER_SELECT71 0x004a 
.................... #define MIXER_SELECT72 0x004b 
.................... #define MIXER_SELECT73 0x004c 
.................... #define MIXER_SELECT74 0x004d 
.................... #define MIXER_SELECT75 0x004e 
.................... #define MIXER_SELECT76 0x004f 
.................... #define MIXER_SELECT77 0x0050 
.................... #define MIXER_SELECT78 0x0051 
.................... #define MIXER_SELECT79 0x0052 
.................... #define OUT_1_1_FILTER_B0 0x02f5 
.................... #define OUT_1_1_FILTER_B1 0x02f6 
.................... #define OUT_1_1_FILTER_B2 0x02f7 
.................... #define OUT_1_1_FILTER_NEGATIVEA1 0x02f8 
.................... #define OUT_1_1_FILTER_NEGATIVEA2 0x02f9 
.................... #define OUT_1_2_FILTER_B0 0x02f0 
.................... #define OUT_1_2_FILTER_B1 0x02f1 
.................... #define OUT_1_2_FILTER_B2 0x02f2 
.................... #define OUT_1_2_FILTER_NEGATIVEA1 0x02f3 
.................... #define OUT_1_2_FILTER_NEGATIVEA2 0x02f4 
.................... #define OUT_1_3_FILTER_B0 0x02eb 
.................... #define OUT_1_3_FILTER_B1 0x02ec 
.................... #define OUT_1_3_FILTER_B2 0x02ed 
.................... #define OUT_1_3_FILTER_NEGATIVEA1 0x02ee 
.................... #define OUT_1_3_FILTER_NEGATIVEA2 0x02ef 
.................... #define OUT_1_4_FILTER_B0 0x02b9 
.................... #define OUT_1_4_FILTER_B1 0x02ba 
.................... #define OUT_1_4_FILTER_B2 0x02bb 
.................... #define OUT_1_4_FILTER_NEGATIVEA1 0x02bc 
.................... #define OUT_1_4_FILTER_NEGATIVEA2 0x02bd 
.................... #define OUT_1_5_FILTER_B0 0x02b4 
.................... #define OUT_1_5_FILTER_B1 0x02b5 
.................... #define OUT_1_5_FILTER_B2 0x02b6 
.................... #define OUT_1_5_FILTER_NEGATIVEA1 0x02b7 
.................... #define OUT_1_5_FILTER_NEGATIVEA2 0x02b8 
.................... #define OUT_1_6_FILTER_B0 0x02af 
.................... #define OUT_1_6_FILTER_B1 0x02b0 
.................... #define OUT_1_6_FILTER_B2 0x02b1 
.................... #define OUT_1_6_FILTER_NEGATIVEA1 0x02b2 
.................... #define OUT_1_6_FILTER_NEGATIVEA2 0x02b3 
.................... #define OUT_2_1_FILTER_B0 0x02e6 
.................... #define OUT_2_1_FILTER_B1 0x02e7 
.................... #define OUT_2_1_FILTER_B2 0x02e8 
.................... #define OUT_2_1_FILTER_NEGATIVEA1 0x02e9 
.................... #define OUT_2_1_FILTER_NEGATIVEA2 0x02ea 
.................... #define OUT_2_2_FILTER_B0 0x02e1 
.................... #define OUT_2_2_FILTER_B1 0x02e2 
.................... #define OUT_2_2_FILTER_B2 0x02e3 
.................... #define OUT_2_2_FILTER_NEGATIVEA1 0x02e4 
.................... #define OUT_2_2_FILTER_NEGATIVEA2 0x02e5 
.................... #define OUT_2_3_FILTER_B0 0x02dc 
.................... #define OUT_2_3_FILTER_B1 0x02dd 
.................... #define OUT_2_3_FILTER_B2 0x02de 
.................... #define OUT_2_3_FILTER_NEGATIVEA1 0x02df 
.................... #define OUT_2_3_FILTER_NEGATIVEA2 0x02e0 
.................... #define OUT_2_4_FILTER_B0 0x02aa 
.................... #define OUT_2_4_FILTER_B1 0x02ab 
.................... #define OUT_2_4_FILTER_B2 0x02ac 
.................... #define OUT_2_4_FILTER_NEGATIVEA1 0x02ad 
.................... #define OUT_2_4_FILTER_NEGATIVEA2 0x02ae 
.................... #define OUT_2_5_FILTER_B0 0x02a5 
.................... #define OUT_2_5_FILTER_B1 0x02a6 
.................... #define OUT_2_5_FILTER_B2 0x02a7 
.................... #define OUT_2_5_FILTER_NEGATIVEA1 0x02a8 
.................... #define OUT_2_5_FILTER_NEGATIVEA2 0x02a9 
.................... #define OUT_2_6_FILTER_B0 0x02a0 
.................... #define OUT_2_6_FILTER_B1 0x02a1 
.................... #define OUT_2_6_FILTER_B2 0x02a2 
.................... #define OUT_2_6_FILTER_NEGATIVEA1 0x02a3 
.................... #define OUT_2_6_FILTER_NEGATIVEA2 0x02a4 
.................... #define OUT_3_1_FILTER_B0 0x02d7 
.................... #define OUT_3_1_FILTER_B1 0x02d8 
.................... #define OUT_3_1_FILTER_B2 0x02d9 
.................... #define OUT_3_1_FILTER_NEGATIVEA1 0x02da 
.................... #define OUT_3_1_FILTER_NEGATIVEA2 0x02db 
.................... #define OUT_3_2_FILTER_B0 0x02d2 
.................... #define OUT_3_2_FILTER_B1 0x02d3 
.................... #define OUT_3_2_FILTER_B2 0x02d4 
.................... #define OUT_3_2_FILTER_NEGATIVEA1 0x02d5 
.................... #define OUT_3_2_FILTER_NEGATIVEA2 0x02d6 
.................... #define OUT_3_3_FILTER_B0 0x02cd 
.................... #define OUT_3_3_FILTER_B1 0x02ce 
.................... #define OUT_3_3_FILTER_B2 0x02cf 
.................... #define OUT_3_3_FILTER_NEGATIVEA1 0x02d0 
.................... #define OUT_3_3_FILTER_NEGATIVEA2 0x02d1 
.................... #define OUT_3_4_FILTER_B0 0x029b 
.................... #define OUT_3_4_FILTER_B1 0x029c 
.................... #define OUT_3_4_FILTER_B2 0x029d 
.................... #define OUT_3_4_FILTER_NEGATIVEA1 0x029e 
.................... #define OUT_3_4_FILTER_NEGATIVEA2 0x029f 
.................... #define OUT_3_5_FILTER_B0 0x0296 
.................... #define OUT_3_5_FILTER_B1 0x0297 
.................... #define OUT_3_5_FILTER_B2 0x0298 
.................... #define OUT_3_5_FILTER_NEGATIVEA1 0x0299 
.................... #define OUT_3_5_FILTER_NEGATIVEA2 0x029a 
.................... #define OUT_3_6_FILTER_B0 0x0291 
.................... #define OUT_3_6_FILTER_B1 0x0292 
.................... #define OUT_3_6_FILTER_B2 0x0293 
.................... #define OUT_3_6_FILTER_NEGATIVEA1 0x0294 
.................... #define OUT_3_6_FILTER_NEGATIVEA2 0x0295 
.................... #define OUT_4_1_FILTER_B0 0x02c8 
.................... #define OUT_4_1_FILTER_B1 0x02c9 
.................... #define OUT_4_1_FILTER_B2 0x02ca 
.................... #define OUT_4_1_FILTER_NEGATIVEA1 0x02cb 
.................... #define OUT_4_1_FILTER_NEGATIVEA2 0x02cc 
.................... #define OUT_4_2_FILTER_B0 0x02c3 
.................... #define OUT_4_2_FILTER_B1 0x02c4 
.................... #define OUT_4_2_FILTER_B2 0x02c5 
.................... #define OUT_4_2_FILTER_NEGATIVEA1 0x02c6 
.................... #define OUT_4_2_FILTER_NEGATIVEA2 0x02c7 
.................... #define OUT_4_3_FILTER_B0 0x02be 
.................... #define OUT_4_3_FILTER_B1 0x02bf 
.................... #define OUT_4_3_FILTER_B2 0x02c0 
.................... #define OUT_4_3_FILTER_NEGATIVEA1 0x02c1 
.................... #define OUT_4_3_FILTER_NEGATIVEA2 0x02c2 
.................... #define OUT_4_4_FILTER_B0 0x028c 
.................... #define OUT_4_4_FILTER_B1 0x028d 
.................... #define OUT_4_4_FILTER_B2 0x028e 
.................... #define OUT_4_4_FILTER_NEGATIVEA1 0x028f 
.................... #define OUT_4_4_FILTER_NEGATIVEA2 0x0290 
.................... #define OUT_4_5_FILTER_B0 0x0287 
.................... #define OUT_4_5_FILTER_B1 0x0288 
.................... #define OUT_4_5_FILTER_B2 0x0289 
.................... #define OUT_4_5_FILTER_NEGATIVEA1 0x028a 
.................... #define OUT_4_5_FILTER_NEGATIVEA2 0x028b 
.................... #define OUT_4_6_FILTER_B0 0x0282 
.................... #define OUT_4_6_FILTER_B1 0x0283 
.................... #define OUT_4_6_FILTER_B2 0x0284 
.................... #define OUT_4_6_FILTER_NEGATIVEA1 0x0285 
.................... #define OUT_4_6_FILTER_NEGATIVEA2 0x0286 
.................... #define CH1LIM_THRESHOLD 0x022e 
.................... #define CH1LIM_KNEE 0x022f 
.................... #define CH1LIM_RATIO 0x0230 
.................... #define CH1LIM_ATTACK 0x0231 
.................... #define CH1LIM_RELEASE 0x0232 
.................... #define CH1LIM_BYPASS 0x0233 
.................... #define CH2LIM_THRESHOLD 0x0226 
.................... #define CH2LIM_KNEE 0x0227 
.................... #define CH2LIM_RATIO 0x0228 
.................... #define CH2LIM_ATTACK 0x0229 
.................... #define CH2LIM_RELEASE 0x022a 
.................... #define CH2LIM_BYPASS 0x022b 
.................... #define CH3LIM_THRESHOLD 0x021e 
.................... #define CH3LIM_KNEE 0x021f 
.................... #define CH3LIM_RATIO 0x0220 
.................... #define CH3LIM_ATTACK 0x0221 
.................... #define CH3LIM_RELEASE 0x0222 
.................... #define CH3LIM_BYPASS 0x0223 
.................... #define CH4LIM_THRESHOLD 0x0216 
.................... #define CH4LIM_KNEE 0x0217 
.................... #define CH4LIM_RATIO 0x0218 
.................... #define CH4LIM_ATTACK 0x0219 
.................... #define CH4LIM_RELEASE 0x021a 
.................... #define CH4LIM_BYPASS 0x021b 
.................... #define DELAY_CH1 0x03dd 
.................... #define DELAY_CH2 0x03da 
.................... #define DELAY_CH3 0x03d7 
.................... #define DELAY_CH4 0x03d4 
.................... #define DELAY_BYPASS_CH1 0x0448 
.................... #define DELAY_BYPASS_CH2 0x0447 
.................... #define DELAY_BYPASS_CH3 0x0446 
.................... #define DELAY_BYPASS_CH4 0x0445 
.................... #define BRIDGEROUTER_SELECT0 0x027e 
.................... #define BRIDGEROUTER_SELECT1 0x027f 
.................... #define BRIDGEROUTER_SELECT2 0x0280 
.................... #define BRIDGEROUTER_SELECT3 0x0281 
.................... #define GEN_PINK_GAIN 0x0411 
.................... #define GEN_SINE_OMEGA 0x03eb 
.................... #define GEN_SINE_GAIN 0x03ec 
.................... #define SEVENTYVHP_BYPASS 0x0444 
.................... #define MUTE_OUTPUTS 0x0413 
....................  
....................  
.................... #include <memory.c> 
.................... /*void WRITE_CONFIG_BOTH(int16 index, int16 address, int32 value) 
.................... { 
.................... 	if(index > num_dsp_values) { 
.................... 		num_dsp_values = index; 
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE * 2)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
.................... 		DSP_CONFIG.VALUES_2[index - (PAGE_SIZE*1)] = value;   
....................   	}  else if(index < (PAGE_SIZE * 3)) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;    
.................... 		DSP_CONFIG.VALUES_3[index - (PAGE_SIZE*2)] = value;    
....................   	}  else if(index < ((PAGE_SIZE*4))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;    
.................... 		DSP_CONFIG.VALUES_4[index - (PAGE_SIZE*3)] = value;    
....................   	} else if(index < ((PAGE_SIZE*5))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;    
.................... 		DSP_CONFIG.VALUES_5[index - (PAGE_SIZE*4)] = value;    
....................   	} else if(index < ((PAGE_SIZE*6))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;    
.................... 		DSP_CONFIG.VALUES_6[index - (PAGE_SIZE*5)] = value;    
....................   	} else if(index < ((PAGE_SIZE*7))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;    
.................... 		DSP_CONFIG.VALUES_7[index - (PAGE_SIZE*6)] = value;    
....................   	} else if(index < ((PAGE_SIZE*8))) 
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
.................... 		//DSP_CONFIG.VALUES_8[index - (PAGE_SIZE*7)] = value;    
....................   	} 
....................  
.................... } 
.................... */ 
.................... void WRITE_CONFIG_ADDRESS(int16 index, int16 address) 
.................... { 
.................... 	if(index > num_dsp_values) { 
*
03080:  MOVF   1B,W
03082:  MOVLB  6
03084:  SUBWF  xD9,W
03086:  BNC   3098
03088:  BNZ   3090
0308A:  MOVF   xD8,W
0308C:  SUBWF  1A,W
0308E:  BC    3098
.................... 		num_dsp_values = index; 
03090:  MOVFF  6D9,1B
03094:  MOVFF  6D8,1A
.................... 	} 
....................  
.................... 	if(index < PAGE_SIZE) 
03098:  MOVF   xD9,F
0309A:  BNZ   30C4
0309C:  MOVF   xD8,W
0309E:  SUBLW  3F
030A0:  BNC   30C4
....................   	{  
....................    		DSP_ADDR.ADDRESSES_1[index] = address; 
030A2:  BCF    FD8.0
030A4:  RLCF   xD8,W
030A6:  MOVWF  02
030A8:  RLCF   xD9,W
030AA:  MOVWF  03
030AC:  MOVF   02,W
030AE:  ADDLW  84
030B0:  MOVWF  FE9
030B2:  MOVLW  01
030B4:  ADDWFC 03,W
030B6:  MOVWF  FEA
030B8:  MOVFF  6DB,FEC
030BC:  MOVF   FED,F
030BE:  MOVFF  6DA,FEF
....................   	} else if(index < (PAGE_SIZE * 2)) 
030C2:  BRA    324E
030C4:  MOVF   xD9,F
030C6:  BNZ   30FC
030C8:  MOVF   xD8,W
030CA:  SUBLW  7F
030CC:  BNC   30FC
....................   	{  
....................    		DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)] = address; 
030CE:  MOVLW  40
030D0:  SUBWF  xD8,W
030D2:  MOVWF  xDC
030D4:  MOVLW  00
030D6:  SUBWFB xD9,W
030D8:  MOVWF  xDD
030DA:  BCF    FD8.0
030DC:  RLCF   xDC,W
030DE:  MOVWF  02
030E0:  RLCF   xDD,W
030E2:  MOVWF  03
030E4:  MOVF   02,W
030E6:  ADDLW  04
030E8:  MOVWF  FE9
030EA:  MOVLW  02
030EC:  ADDWFC 03,W
030EE:  MOVWF  FEA
030F0:  MOVFF  6DB,FEC
030F4:  MOVF   FED,F
030F6:  MOVFF  6DA,FEF
....................   	}  else if(index < (PAGE_SIZE * 3)) 
030FA:  BRA    324E
030FC:  MOVF   xD9,F
030FE:  BNZ   3134
03100:  MOVF   xD8,W
03102:  SUBLW  BF
03104:  BNC   3134
....................   	{  
....................    		DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)] = address;  
03106:  MOVLW  80
03108:  SUBWF  xD8,W
0310A:  MOVWF  xDC
0310C:  MOVLW  00
0310E:  SUBWFB xD9,W
03110:  MOVWF  xDD
03112:  BCF    FD8.0
03114:  RLCF   xDC,W
03116:  MOVWF  02
03118:  RLCF   xDD,W
0311A:  MOVWF  03
0311C:  MOVF   02,W
0311E:  ADDLW  84
03120:  MOVWF  FE9
03122:  MOVLW  02
03124:  ADDWFC 03,W
03126:  MOVWF  FEA
03128:  MOVFF  6DB,FEC
0312C:  MOVF   FED,F
0312E:  MOVFF  6DA,FEF
....................   	}  else if(index < ((PAGE_SIZE*4))) 
03132:  BRA    324E
03134:  MOVF   xD9,W
03136:  SUBLW  00
03138:  BNC   3168
....................   	{  
....................    		DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)] = address;   
0313A:  MOVLW  C0
0313C:  SUBWF  xD8,W
0313E:  MOVWF  xDC
03140:  MOVLW  00
03142:  SUBWFB xD9,W
03144:  MOVWF  xDD
03146:  BCF    FD8.0
03148:  RLCF   xDC,W
0314A:  MOVWF  02
0314C:  RLCF   xDD,W
0314E:  MOVWF  03
03150:  MOVF   02,W
03152:  ADDLW  04
03154:  MOVWF  FE9
03156:  MOVLW  03
03158:  ADDWFC 03,W
0315A:  MOVWF  FEA
0315C:  MOVFF  6DB,FEC
03160:  MOVF   FED,F
03162:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*5))) 
03166:  BRA    324E
03168:  MOVF   xD9,W
0316A:  SUBLW  01
0316C:  BNC   31A4
0316E:  BNZ   3176
03170:  MOVF   xD8,W
03172:  SUBLW  3F
03174:  BNC   31A4
....................   	{  
....................    		DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)] = address;  
03176:  MOVLW  00
03178:  SUBWF  xD8,W
0317A:  MOVWF  xDC
0317C:  MOVLW  01
0317E:  SUBWFB xD9,W
03180:  MOVWF  xDD
03182:  BCF    FD8.0
03184:  RLCF   xDC,W
03186:  MOVWF  02
03188:  RLCF   xDD,W
0318A:  MOVWF  03
0318C:  MOVF   02,W
0318E:  ADDLW  84
03190:  MOVWF  FE9
03192:  MOVLW  03
03194:  ADDWFC 03,W
03196:  MOVWF  FEA
03198:  MOVFF  6DB,FEC
0319C:  MOVF   FED,F
0319E:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*6))) 
031A2:  BRA    324E
031A4:  MOVF   xD9,W
031A6:  SUBLW  01
031A8:  BNC   31E0
031AA:  BNZ   31B2
031AC:  MOVF   xD8,W
031AE:  SUBLW  7F
031B0:  BNC   31E0
....................   	{  
....................    		DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)] = address;  
031B2:  MOVLW  40
031B4:  SUBWF  xD8,W
031B6:  MOVWF  xDC
031B8:  MOVLW  01
031BA:  SUBWFB xD9,W
031BC:  MOVWF  xDD
031BE:  BCF    FD8.0
031C0:  RLCF   xDC,W
031C2:  MOVWF  02
031C4:  RLCF   xDD,W
031C6:  MOVWF  03
031C8:  MOVF   02,W
031CA:  ADDLW  04
031CC:  MOVWF  FE9
031CE:  MOVLW  04
031D0:  ADDWFC 03,W
031D2:  MOVWF  FEA
031D4:  MOVFF  6DB,FEC
031D8:  MOVF   FED,F
031DA:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*7))) 
031DE:  BRA    324E
031E0:  MOVF   xD9,W
031E2:  SUBLW  01
031E4:  BNC   321C
031E6:  BNZ   31EE
031E8:  MOVF   xD8,W
031EA:  SUBLW  BF
031EC:  BNC   321C
....................   	{  
....................    		DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)] = address;  
031EE:  MOVLW  80
031F0:  SUBWF  xD8,W
031F2:  MOVWF  xDC
031F4:  MOVLW  01
031F6:  SUBWFB xD9,W
031F8:  MOVWF  xDD
031FA:  BCF    FD8.0
031FC:  RLCF   xDC,W
031FE:  MOVWF  02
03200:  RLCF   xDD,W
03202:  MOVWF  03
03204:  MOVF   02,W
03206:  ADDLW  84
03208:  MOVWF  FE9
0320A:  MOVLW  04
0320C:  ADDWFC 03,W
0320E:  MOVWF  FEA
03210:  MOVFF  6DB,FEC
03214:  MOVF   FED,F
03216:  MOVFF  6DA,FEF
....................   	} else if(index < ((PAGE_SIZE*8))) 
0321A:  BRA    324E
0321C:  MOVF   xD9,W
0321E:  SUBLW  01
03220:  BNC   324E
....................   	{  
....................    		DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)] = address;    
03222:  MOVLW  C0
03224:  SUBWF  xD8,W
03226:  MOVWF  xDC
03228:  MOVLW  01
0322A:  SUBWFB xD9,W
0322C:  MOVWF  xDD
0322E:  BCF    FD8.0
03230:  RLCF   xDC,W
03232:  MOVWF  02
03234:  RLCF   xDD,W
03236:  MOVWF  03
03238:  MOVF   02,W
0323A:  ADDLW  04
0323C:  MOVWF  FE9
0323E:  MOVLW  05
03240:  ADDWFC 03,W
03242:  MOVWF  FEA
03244:  MOVFF  6DB,FEC
03248:  MOVF   FED,F
0324A:  MOVFF  6DA,FEF
....................   	} 
....................  
.................... } 
0324E:  MOVLB  0
03250:  RETURN 0
....................  
....................  
.................... int16 READ_CONFIG_ADDRESS(int16 index)  
.................... {  
.................... 	int16 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
*
06930:  MOVLB  7
06932:  MOVF   x2B,F
06934:  BNZ   6962
06936:  MOVF   x2A,W
06938:  SUBLW  3F
0693A:  BNC   6962
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_1[index]; 
0693C:  BCF    FD8.0
0693E:  RLCF   x2A,W
06940:  MOVWF  02
06942:  RLCF   x2B,W
06944:  MOVWF  03
06946:  MOVF   02,W
06948:  ADDLW  84
0694A:  MOVWF  FE9
0694C:  MOVLW  01
0694E:  ADDWFC 03,W
06950:  MOVWF  FEA
06952:  MOVFF  FEC,03
06956:  MOVF   FED,F
06958:  MOVFF  FEF,72C
0695C:  MOVFF  03,72D
....................   	} else if(index < (PAGE_SIZE * 2)) 
06960:  BRA    6B08
06962:  MOVF   x2B,F
06964:  BNZ   699E
06966:  MOVF   x2A,W
06968:  SUBLW  7F
0696A:  BNC   699E
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_2[index - (PAGE_SIZE*1)]; 
0696C:  MOVLW  40
0696E:  SUBWF  x2A,W
06970:  MOVWF  x2E
06972:  MOVLW  00
06974:  SUBWFB x2B,W
06976:  MOVWF  x2F
06978:  BCF    FD8.0
0697A:  RLCF   x2E,W
0697C:  MOVWF  02
0697E:  RLCF   x2F,W
06980:  MOVWF  03
06982:  MOVF   02,W
06984:  ADDLW  04
06986:  MOVWF  FE9
06988:  MOVLW  02
0698A:  ADDWFC 03,W
0698C:  MOVWF  FEA
0698E:  MOVFF  FEC,03
06992:  MOVF   FED,F
06994:  MOVFF  FEF,72C
06998:  MOVFF  03,72D
....................   	}  else if(index < (PAGE_SIZE * 3)) 
0699C:  BRA    6B08
0699E:  MOVF   x2B,F
069A0:  BNZ   69DA
069A2:  MOVF   x2A,W
069A4:  SUBLW  BF
069A6:  BNC   69DA
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_3[index - (PAGE_SIZE*2)]; 
069A8:  MOVLW  80
069AA:  SUBWF  x2A,W
069AC:  MOVWF  x2E
069AE:  MOVLW  00
069B0:  SUBWFB x2B,W
069B2:  MOVWF  x2F
069B4:  BCF    FD8.0
069B6:  RLCF   x2E,W
069B8:  MOVWF  02
069BA:  RLCF   x2F,W
069BC:  MOVWF  03
069BE:  MOVF   02,W
069C0:  ADDLW  84
069C2:  MOVWF  FE9
069C4:  MOVLW  02
069C6:  ADDWFC 03,W
069C8:  MOVWF  FEA
069CA:  MOVFF  FEC,03
069CE:  MOVF   FED,F
069D0:  MOVFF  FEF,72C
069D4:  MOVFF  03,72D
....................   	}  else if(index < ((PAGE_SIZE*4))) 
069D8:  BRA    6B08
069DA:  MOVF   x2B,W
069DC:  SUBLW  00
069DE:  BNC   6A12
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_4[index - (PAGE_SIZE*3)]; 
069E0:  MOVLW  C0
069E2:  SUBWF  x2A,W
069E4:  MOVWF  x2E
069E6:  MOVLW  00
069E8:  SUBWFB x2B,W
069EA:  MOVWF  x2F
069EC:  BCF    FD8.0
069EE:  RLCF   x2E,W
069F0:  MOVWF  02
069F2:  RLCF   x2F,W
069F4:  MOVWF  03
069F6:  MOVF   02,W
069F8:  ADDLW  04
069FA:  MOVWF  FE9
069FC:  MOVLW  03
069FE:  ADDWFC 03,W
06A00:  MOVWF  FEA
06A02:  MOVFF  FEC,03
06A06:  MOVF   FED,F
06A08:  MOVFF  FEF,72C
06A0C:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*5))) 
06A10:  BRA    6B08
06A12:  MOVF   x2B,W
06A14:  SUBLW  01
06A16:  BNC   6A52
06A18:  BNZ   6A20
06A1A:  MOVF   x2A,W
06A1C:  SUBLW  3F
06A1E:  BNC   6A52
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_5[index - (PAGE_SIZE*4)];   
06A20:  MOVLW  00
06A22:  SUBWF  x2A,W
06A24:  MOVWF  x2E
06A26:  MOVLW  01
06A28:  SUBWFB x2B,W
06A2A:  MOVWF  x2F
06A2C:  BCF    FD8.0
06A2E:  RLCF   x2E,W
06A30:  MOVWF  02
06A32:  RLCF   x2F,W
06A34:  MOVWF  03
06A36:  MOVF   02,W
06A38:  ADDLW  84
06A3A:  MOVWF  FE9
06A3C:  MOVLW  03
06A3E:  ADDWFC 03,W
06A40:  MOVWF  FEA
06A42:  MOVFF  FEC,03
06A46:  MOVF   FED,F
06A48:  MOVFF  FEF,72C
06A4C:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*6))) 
06A50:  BRA    6B08
06A52:  MOVF   x2B,W
06A54:  SUBLW  01
06A56:  BNC   6A92
06A58:  BNZ   6A60
06A5A:  MOVF   x2A,W
06A5C:  SUBLW  7F
06A5E:  BNC   6A92
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_6[index - (PAGE_SIZE*5)]; 
06A60:  MOVLW  40
06A62:  SUBWF  x2A,W
06A64:  MOVWF  x2E
06A66:  MOVLW  01
06A68:  SUBWFB x2B,W
06A6A:  MOVWF  x2F
06A6C:  BCF    FD8.0
06A6E:  RLCF   x2E,W
06A70:  MOVWF  02
06A72:  RLCF   x2F,W
06A74:  MOVWF  03
06A76:  MOVF   02,W
06A78:  ADDLW  04
06A7A:  MOVWF  FE9
06A7C:  MOVLW  04
06A7E:  ADDWFC 03,W
06A80:  MOVWF  FEA
06A82:  MOVFF  FEC,03
06A86:  MOVF   FED,F
06A88:  MOVFF  FEF,72C
06A8C:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*7))) 
06A90:  BRA    6B08
06A92:  MOVF   x2B,W
06A94:  SUBLW  01
06A96:  BNC   6AD2
06A98:  BNZ   6AA0
06A9A:  MOVF   x2A,W
06A9C:  SUBLW  BF
06A9E:  BNC   6AD2
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_7[index - (PAGE_SIZE*6)]; 
06AA0:  MOVLW  80
06AA2:  SUBWF  x2A,W
06AA4:  MOVWF  x2E
06AA6:  MOVLW  01
06AA8:  SUBWFB x2B,W
06AAA:  MOVWF  x2F
06AAC:  BCF    FD8.0
06AAE:  RLCF   x2E,W
06AB0:  MOVWF  02
06AB2:  RLCF   x2F,W
06AB4:  MOVWF  03
06AB6:  MOVF   02,W
06AB8:  ADDLW  84
06ABA:  MOVWF  FE9
06ABC:  MOVLW  04
06ABE:  ADDWFC 03,W
06AC0:  MOVWF  FEA
06AC2:  MOVFF  FEC,03
06AC6:  MOVF   FED,F
06AC8:  MOVFF  FEF,72C
06ACC:  MOVFF  03,72D
....................   	} else if(index < ((PAGE_SIZE*8))) 
06AD0:  BRA    6B08
06AD2:  MOVF   x2B,W
06AD4:  SUBLW  01
06AD6:  BNC   6B08
....................   	{  
....................    		retval = DSP_ADDR.ADDRESSES_8[index - (PAGE_SIZE*7)]; 
06AD8:  MOVLW  C0
06ADA:  SUBWF  x2A,W
06ADC:  MOVWF  x2E
06ADE:  MOVLW  01
06AE0:  SUBWFB x2B,W
06AE2:  MOVWF  x2F
06AE4:  BCF    FD8.0
06AE6:  RLCF   x2E,W
06AE8:  MOVWF  02
06AEA:  RLCF   x2F,W
06AEC:  MOVWF  03
06AEE:  MOVF   02,W
06AF0:  ADDLW  04
06AF2:  MOVWF  FE9
06AF4:  MOVLW  05
06AF6:  ADDWFC 03,W
06AF8:  MOVWF  FEA
06AFA:  MOVFF  FEC,03
06AFE:  MOVF   FED,F
06B00:  MOVFF  FEF,72C
06B04:  MOVFF  03,72D
....................   	} 
....................  
.................... 	return(retval);  
06B08:  MOVFF  72C,01
06B0C:  MOVFF  72D,02
.................... } 
06B10:  MOVLB  0
06B12:  RETURN 0
....................  
.................... /* 
.................... int32 READ_CONFIG_VALUE(int16 index)  
.................... {  
.................... 	int32 retval;  
....................  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_1[index];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_2[index - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE];   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE- PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
....................    		retval = DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE];   
....................   	} else 
....................   	{  
....................    		retval = 0;  
....................   	}  
....................  
.................... 	return(retval);  
.................... } 
....................  
.................... void WRITE_CONFIG_VALUE(int16 index, int32 value)  
.................... {  
.................... 	if(index < PAGE_SIZE) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_1[index] = value;   
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_2[index - PAGE_SIZE] = value;   
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_3[index - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	}  else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_4[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{    
.................... 		DSP_CONFIG.VALUES_5[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{  
.................... 		DSP_CONFIG.VALUES_6[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} else if(index < (PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE + PAGE_SIZE)) 
....................   	{     
.................... 		DSP_CONFIG.VALUES_7[index - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE - PAGE_SIZE] = value;    
....................   	} 
.................... } 
....................  
.................... */ 
....................  
....................  
.................... #include <w25q80bv.c> 
.................... #define W25Q80BV_PAGE_LEN     		256  // in bytes 
.................... #define W25Q80BV_PAGES_PER_SECTOR	16 
....................  
.................... #define W25Q80BV_SECTOR_LEN			W25Q80BV_PAGE_LEN*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_SECTORS_PER_BLOCK	16 
....................  
.................... #define W25Q80BV_BLOCK_LEN			W25Q80BV_SECTOR_LEN*W25Q80BV_SECTORS_PER_BLOCK 
....................   	 
.................... #define W25Q80BV_NUM_BLOCKS			16 
.................... #define W25Q80BV_NUM_SECTORS		W25Q80BV_NUM_BLOCKS*W25Q80BV_SECTORS_PER_BLOCK 
.................... #define W25Q80BV_NUM_PAGES    		W25Q80BV_NUM_SECTORS*W25Q80BV_PAGES_PER_SECTOR 
.................... #define W25Q80BV_NUM_BYTES    		W25Q80BV_NUM_BLOCKS*W25Q80BV_BLOCK_LEN 
....................  
.................... #define W25Q80BV_WRITE_ENABLE 0x06 
.................... #define W25Q80BV_CHIP_ERASE   0xC7 
.................... #define W25Q80BV_SECTOR_ERASE 0x20 
.................... #define W25Q80BV_READ_STATUS1 0x05 
.................... #define W25Q80BV_PAGE_PROGRAM 0x02 
.................... #define W25Q80BV_DEVICE_ID    0xAB 
.................... #define W25Q80BV_UNIQUE_ID    0x4B 
....................  
.................... #define W25Q80BV_STATUS_BUSY  0x01 
....................  
.................... #define W25Q80BV_READ 0x03 
....................  
.................... #define W25Q80BV_DEVICE_ID_RES  0x13 /* Expected device_id for W25Q80BV */ 
....................  
.................... unsigned int32 page_address(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
*
05BF2:  MOVFF  749,752
05BF6:  MOVFF  748,751
05BFA:  MOVFF  747,750
05BFE:  MOVLB  7
05C00:  CLRF   x4F
05C02:  CLRF   x53
05C04:  RLCF   x53,W
05C06:  MOVWF  00
05C08:  RLCF   x43,W
05C0A:  MOVWF  01
05C0C:  RLCF   x44,W
05C0E:  MOVWF  02
05C10:  RLCF   x45,W
05C12:  MOVWF  03
05C14:  RLCF   00,F
05C16:  RLCF   01,F
05C18:  RLCF   02,F
05C1A:  RLCF   03,F
05C1C:  RLCF   00,F
05C1E:  RLCF   01,F
05C20:  RLCF   02,F
05C22:  RLCF   03,F
05C24:  RLCF   00,F
05C26:  RLCF   01,F
05C28:  RLCF   02,F
05C2A:  RLCF   03,F
05C2C:  MOVLW  F0
05C2E:  ANDWF  00,F
05C30:  MOVF   00,W
05C32:  ADDWF  x4F,F
05C34:  MOVF   01,W
05C36:  ADDWFC x50,F
05C38:  MOVF   02,W
05C3A:  ADDWFC x51,F
05C3C:  MOVF   03,W
05C3E:  ADDWFC x52,F
05C40:  MOVFF  741,756
05C44:  MOVFF  740,755
05C48:  MOVFF  73F,754
05C4C:  CLRF   x53
05C4E:  RLCF   x53,F
05C50:  RLCF   x54,F
05C52:  RLCF   x55,F
05C54:  RLCF   x56,F
05C56:  RLCF   x53,F
05C58:  RLCF   x54,F
05C5A:  RLCF   x55,F
05C5C:  RLCF   x56,F
05C5E:  RLCF   x53,F
05C60:  RLCF   x54,F
05C62:  RLCF   x55,F
05C64:  RLCF   x56,F
05C66:  RLCF   x53,F
05C68:  RLCF   x54,F
05C6A:  RLCF   x55,F
05C6C:  RLCF   x56,F
05C6E:  MOVLW  F0
05C70:  ANDWF  x53,F
05C72:  RLCF   x53,W
05C74:  MOVWF  00
05C76:  RLCF   x54,W
05C78:  MOVWF  01
05C7A:  RLCF   x55,W
05C7C:  MOVWF  02
05C7E:  RLCF   x56,W
05C80:  MOVWF  03
05C82:  RLCF   00,F
05C84:  RLCF   01,F
05C86:  RLCF   02,F
05C88:  RLCF   03,F
05C8A:  RLCF   00,F
05C8C:  RLCF   01,F
05C8E:  RLCF   02,F
05C90:  RLCF   03,F
05C92:  RLCF   00,F
05C94:  RLCF   01,F
05C96:  RLCF   02,F
05C98:  RLCF   03,F
05C9A:  MOVLW  F0
05C9C:  ANDWF  00,F
05C9E:  MOVF   00,W
05CA0:  ADDWF  x4F,W
05CA2:  MOVWF  x4B
05CA4:  MOVF   01,W
05CA6:  ADDWFC x50,W
05CA8:  MOVWF  x4C
05CAA:  MOVF   02,W
05CAC:  ADDWFC x51,W
05CAE:  MOVWF  x4D
05CB0:  MOVF   03,W
05CB2:  ADDWFC x52,W
05CB4:  MOVWF  x4E
.................... 	unsigned int32 return_address = (page_index*W25Q80BV_PAGE_LEN) + (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
05CB6:  MOVFF  74B,00
05CBA:  MOVFF  74C,01
05CBE:  MOVFF  74D,02
05CC2:  MOVFF  74E,03
.................... } 
05CC6:  MOVLB  0
05CC8:  RETURN 0
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
.................... 	unsigned int32 return_address = (sector_index*W25Q80BV_SECTOR_LEN) + (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
.................... unsigned int32 sector_address(unsigned int32 block_index) 
.................... { 
.................... 	unsigned int32 return_address = (block_index*W25Q80BV_BLOCK_LEN);	 
.................... 	return return_address; 
.................... } 
....................  
....................  
.................... int flash_get_device_id() 
.................... { 
*
05D06:  MOVLB  7
05D08:  CLRF   x3F
.................... 	int data = 0; 
....................  
....................     output_low(FLASH_CS); 
05D0A:  BCF    F95.2
05D0C:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_DEVICE_ID); 
05D0E:  MOVLW  AB
05D10:  MOVWF  x44
05D12:  MOVLW  08
05D14:  MOVWF  x45
05D16:  MOVLB  0
05D18:  RCALL  5CCA
.................... 	 
.................... 	data = spi_xfer(0x00); 
05D1A:  MOVLB  7
05D1C:  CLRF   x44
05D1E:  MOVLW  08
05D20:  MOVWF  x45
05D22:  MOVLB  0
05D24:  RCALL  5CCA
05D26:  MOVF   01,W
05D28:  MOVFF  01,73F
.................... 	data = spi_xfer(0x00); 
05D2C:  MOVLB  7
05D2E:  CLRF   x44
05D30:  MOVLW  08
05D32:  MOVWF  x45
05D34:  MOVLB  0
05D36:  RCALL  5CCA
05D38:  MOVF   01,W
05D3A:  MOVFF  01,73F
.................... 	data = spi_xfer(0x00); 
05D3E:  MOVLB  7
05D40:  CLRF   x44
05D42:  MOVLW  08
05D44:  MOVWF  x45
05D46:  MOVLB  0
05D48:  RCALL  5CCA
05D4A:  MOVF   01,W
05D4C:  MOVFF  01,73F
....................  
.................... 	data = spi_xfer(0xFF); 
05D50:  MOVLB  7
05D52:  SETF   x44
05D54:  MOVLW  08
05D56:  MOVWF  x45
05D58:  MOVLB  0
05D5A:  RCALL  5CCA
05D5C:  MOVF   01,W
05D5E:  MOVFF  01,73F
....................  
.................... 	output_high(FLASH_CS); 
05D62:  BCF    F95.2
05D64:  BSF    F8C.2
....................  
.................... 	return data; 
05D66:  MOVLB  7
05D68:  MOVFF  73F,01
.................... } 
05D6C:  MOVLB  0
05D6E:  GOTO   5E18 (RETURN)
....................  
.................... short verify_device_id() 
.................... { 
.................... 	if(flash_get_device_id() == W25Q80BV_DEVICE_ID_RES) { 
.................... 		return 1; 
.................... 	} else { 
.................... 		return 0; 
.................... 	} 
.................... } 
....................  
.................... int flash_get_status() 
.................... { 
05D72:  MOVLB  7
05D74:  CLRF   x3F
.................... 	int value = 0; 
.................... 	output_low(FLASH_CS); 
05D76:  BCF    F95.2
05D78:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ_STATUS1); 
05D7A:  MOVLW  05
05D7C:  MOVWF  x44
05D7E:  MOVLW  08
05D80:  MOVWF  x45
05D82:  MOVLB  0
05D84:  RCALL  5CCA
....................     value = spi_xfer(0x00); 
05D86:  MOVLB  7
05D88:  CLRF   x44
05D8A:  MOVLW  08
05D8C:  MOVWF  x45
05D8E:  MOVLB  0
05D90:  RCALL  5CCA
05D92:  MOVF   01,W
05D94:  MOVFF  01,73F
....................     output_high(FLASH_CS); 
05D98:  BCF    F95.2
05D9A:  BSF    F8C.2
.................... 	 
.................... 	return value; 
05D9C:  MOVLB  7
05D9E:  MOVFF  73F,01
.................... } 
05DA2:  MOVLB  0
05DA4:  RETURN 0
....................  
.................... void flash_wait_while_busy() 
.................... { 
.................... 	while ((flash_get_status() & W25Q80BV_STATUS_BUSY)) 
.................... 	{ 
05DA6:  RCALL  5D72
05DA8:  BTFSS  01.0
05DAA:  BRA    5DAE
.................... 	} 
05DAC:  BRA    5DA6
.................... } 
05DAE:  RETURN 0
....................  
.................... void flash_write_enable() 
.................... { 
.................... 	flash_wait_while_busy(); 
05DB0:  RCALL  5DA6
.................... 	output_low(FLASH_CS); 
05DB2:  BCF    F95.2
05DB4:  BCF    F8C.2
.................... 	spi_xfer(0x06); 
05DB6:  MOVLW  06
05DB8:  MOVLB  7
05DBA:  MOVWF  x44
05DBC:  MOVLW  08
05DBE:  MOVWF  x45
05DC0:  MOVLB  0
05DC2:  RCALL  5CCA
....................     output_high(FLASH_CS); 
05DC4:  BCF    F95.2
05DC6:  BSF    F8C.2
.................... } 
05DC8:  RETURN 0
....................  
.................... void flash_chip_erase() 
.................... { 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting chip erase...\r\n"); 
.................... 		} 
....................         int device_id = 0; 
....................  
....................         device_id = 0; 
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
....................                 device_id = flash_get_device_id(); 
....................         } 
....................  
....................         flash_write_enable(); 
....................         flash_wait_while_busy(); 
.................... 		output_low(PIN_C0); 
....................         output_low(FLASH_CS); 
....................         spi_xfer(W25Q80BV_CHIP_ERASE); 
....................         output_high(FLASH_CS); 
.................... 		 
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
.................... 		} 
.................... 		output_high(PIN_C0); 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
.................... } 
....................  
.................... void flash_sector_erase(unsigned int32 block_index, unsigned int32 sector_index) 
.................... { 
05DCA:  MOVLB  7
05DCC:  CLRF   x3A
05DCE:  MOVFF  735,742
05DD2:  MOVFF  734,741
05DD6:  MOVFF  733,740
05DDA:  MOVFF  732,73F
05DDE:  MOVFF  739,746
05DE2:  MOVFF  738,745
05DE6:  MOVFF  737,744
05DEA:  MOVFF  736,743
05DEE:  CLRF   x4A
05DF0:  CLRF   x49
05DF2:  CLRF   x48
05DF4:  CLRF   x47
05DF6:  MOVLB  0
05DF8:  RCALL  5BF2
05DFA:  MOVFF  03,73E
05DFE:  MOVFF  02,73D
05E02:  MOVFF  01,73C
05E06:  MOVFF  00,73B
....................         int device_id = 0; 
....................  
.................... 		unsigned int32 starting_address = page_address(block_index,sector_index,0); 
....................  
....................         device_id = 0; 
05E0A:  MOVLB  7
05E0C:  CLRF   x3A
....................         while(device_id != W25Q80BV_DEVICE_ID_RES) 
....................         { 
05E0E:  MOVF   x3A,W
05E10:  SUBLW  13
05E12:  BZ    5E20
....................                 device_id = flash_get_device_id(); 
05E14:  MOVLB  0
05E16:  BRA    5D06
05E18:  MOVFF  01,73A
....................         } 
05E1C:  MOVLB  7
05E1E:  BRA    5E0E
....................  
....................         flash_write_enable(); 
05E20:  MOVLB  0
05E22:  RCALL  5DB0
....................         flash_wait_while_busy(); 
05E24:  RCALL  5DA6
....................         output_low(FLASH_CS); 
05E26:  BCF    F95.2
05E28:  BCF    F8C.2
....................         spi_xfer(W25Q80BV_SECTOR_ERASE); 
05E2A:  MOVLW  20
05E2C:  MOVLB  7
05E2E:  MOVWF  x44
05E30:  MOVLW  08
05E32:  MOVWF  x45
05E34:  MOVLB  0
05E36:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05E38:  MOVLB  7
05E3A:  CLRF   x3F
05E3C:  CLRF   x40
05E3E:  MOVFF  73D,741
05E42:  CLRF   x42
05E44:  MOVFF  73D,73F
05E48:  MOVFF  742,740
05E4C:  CLRF   x41
05E4E:  CLRF   x42
05E50:  MOVFF  73D,744
05E54:  MOVLW  08
05E56:  MOVWF  x45
05E58:  MOVLB  0
05E5A:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05E5C:  MOVLB  7
05E5E:  CLRF   x3F
05E60:  CLRF   x41
05E62:  CLRF   x42
05E64:  MOVFF  73C,73F
05E68:  MOVFF  741,740
05E6C:  MOVFF  742,741
05E70:  CLRF   x42
05E72:  MOVFF  73C,744
05E76:  MOVLW  08
05E78:  MOVWF  x45
05E7A:  MOVLB  0
05E7C:  RCALL  5CCA
.................... 		spi_xfer(starting_address & 0xFF); 
05E7E:  MOVLB  7
05E80:  MOVFF  73B,73F
05E84:  CLRF   x40
05E86:  CLRF   x41
05E88:  CLRF   x42
05E8A:  MOVFF  73B,744
05E8E:  MOVLW  08
05E90:  MOVWF  x45
05E92:  MOVLB  0
05E94:  RCALL  5CCA
....................         output_high(FLASH_CS); 
05E96:  BCF    F95.2
05E98:  BSF    F8C.2
....................  
.................... 		while (flash_get_status() & W25Q80BV_STATUS_BUSY) 
.................... 		{ 
05E9A:  RCALL  5D72
05E9C:  BTFSS  01.0
05E9E:  BRA    5EA2
.................... 		} 
05EA0:  BRA    5E9A
....................  
.................... } 
05EA2:  RETURN 0
....................  
.................... int flash_write_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		spi_xfer(ptr[i]); 
.................... 		rolling_checksum += ptr[i]; 
.................... 	} 
.................... 	 
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void flash_read_full_page(int *ptr,unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_read_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < number_of_bytes; i++) 
.................... 	{ 
.................... 		ptr[i] = spi_xfer(0x00); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... void flash_write_bytes(int *ptr, int16 number_of_bytes, unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(block_index,sector_index); 
....................  
.................... 	starting_address = page_address(block_index,sector_index,page_index); 
....................  
.................... 	flash_write_enable(); 
.................... 	flash_wait_while_busy(); 
.................... 	 
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 	for (value_counter = 0; value_counter < number_of_bytes; value_counter++) 
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
.................... 	} 
....................  
.................... 	output_high(FLASH_CS); 
....................  
.................... 	flash_wait_while_busy(); 
.................... } 
....................  
.................... /* DEBUG STUFF */ 
....................  
.................... void flash_print_page(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	//starting_address = 0; 
.................... 	fprintf(RS232,"\r\nPrinting flash at starting address (%u,%u,%u) %lu\r\n",block_index,sector_index,page_index,starting_address); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		printf("%x",data); 
....................  
.................... 		if((i % 4) == 3) { 
.................... 			printf(" "); 
.................... 		} 
....................  
.................... 		if((i % 32) == 31) { 
.................... 			printf("\r\n"); 
.................... 		} 
.................... 	} 
.................... 	output_high(FLASH_CS); 
.................... } 
....................  
....................  
.................... int flash_page_checksum(unsigned int32 block_index, unsigned int32 sector_index, unsigned int32 page_index) 
.................... { 
.................... 	unsigned int32 starting_address = page_address(block_index,sector_index,page_index); 
.................... 	unsigned int data = 0; 
.................... 	flash_wait_while_busy(); 
....................  
.................... 	output_low(FLASH_CS); 
.................... 	spi_xfer(W25Q80BV_READ); 
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 	spi_xfer(starting_address & 0xFF); 
....................  
.................... 	unsigned int rolling_checksum = 0; 
....................  
.................... 	for (int16 i = 0; i < 256; i++) 
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
.................... 		rolling_checksum += data; 
.................... 	} 
.................... 	output_high(FLASH_CS); 
....................  
.................... 	return rolling_checksum; 
.................... } 
....................  
.................... /* 
.................... void FLASH_PROGRAM_WRITE(int program_index) {  
....................     
....................  
....................     // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		flash_sector_erase(program_index,sector_counter); 
.................... 		//fprintf(RS232,"Status1: %x\r\n",flash_get_status()); 
.................... 		//delay_ms(40); 
.................... 		//fprintf(RS232,"Status2: %x\r\n",flash_get_status()); 
.................... 		//ptr = &DSP_CONFIG.TEST_VALUES[0]; 
.................... 		starting_address = page_address(program_index,sector_counter,0); 
.................... 		flash_write_enable(); 
.................... 		flash_wait_while_busy(); 
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			spi_xfer(ptr[value_counter]); 
.................... 			test_val++; 
.................... 			value_counter++; 
.................... 		} 
.................... 		 
.................... 		output_high(FLASH_CS); 
....................  
.................... 		flash_wait_while_busy(); 
.................... 	} 
.................... } 
.................... */ 
.................... /* 
.................... void FLASH_PROGRAM_READ(int program_index) 
.................... { 
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
....................  
.................... 		starting_address = page_address(program_index,sector_counter,0); 
....................  
.................... 		output_low(FLASH_CS); 
.................... 		spi_xfer(W25Q80BV_READ); 
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
.................... 		spi_xfer(starting_address & 0xFF); 
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
.................... 			ptr[value_counter] = data; 
.................... 			value_counter++; 
....................  
.................... 			//fprintf(RS232,"%x||",data); 
.................... 		} 
....................  
.................... 		output_high(FLASH_CS); 
.................... 	} 
.................... } 
.................... */ 
.................... void FLASH_ADDR_WRITE(int block_index) {  
05EA4:  MOVLB  6
05EA6:  CLRF   xDA
05EA8:  CLRF   xD9
....................     
....................  
....................    // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
05EAA:  MOVLW  01
05EAC:  MOVWF  xDA
05EAE:  MOVLW  84
05EB0:  MOVWF  xD9
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 test_val = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
05EB2:  CLRF   xDC
05EB4:  CLRF   xDB
05EB6:  CLRF   xE0
05EB8:  CLRF   xDF
05EBA:  CLRF   xDE
05EBC:  CLRF   xDD
05EBE:  CLRF   xE2
05EC0:  CLRF   xE1
05EC2:  CLRF   xE4
05EC4:  CLRF   xE3
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
05EC6:  CLRF   xE5
05EC8:  MOVF   xE5,W
05ECA:  SUBLW  03
05ECC:  BTFSS  FD8.0
05ECE:  BRA    5FE4
.................... 		 
.................... 		flash_sector_erase(block_index,sector_counter); 
05ED0:  MOVLB  7
05ED2:  CLRF   x35
05ED4:  CLRF   x34
05ED6:  CLRF   x33
05ED8:  MOVFF  6D8,732
05EDC:  CLRF   x39
05EDE:  CLRF   x38
05EE0:  CLRF   x37
05EE2:  MOVFF  6E5,736
05EE6:  MOVLB  0
05EE8:  RCALL  5DCA
.................... 		starting_address = page_address(block_index,sector_counter,0); 
05EEA:  MOVLB  7
05EEC:  CLRF   x42
05EEE:  CLRF   x41
05EF0:  CLRF   x40
05EF2:  MOVFF  6D8,73F
05EF6:  CLRF   x46
05EF8:  CLRF   x45
05EFA:  CLRF   x44
05EFC:  MOVFF  6E5,743
05F00:  CLRF   x4A
05F02:  CLRF   x49
05F04:  CLRF   x48
05F06:  CLRF   x47
05F08:  MOVLB  0
05F0A:  RCALL  5BF2
05F0C:  MOVFF  03,6E0
05F10:  MOVFF  02,6DF
05F14:  MOVFF  01,6DE
05F18:  MOVFF  00,6DD
.................... 		flash_write_enable(); 
05F1C:  RCALL  5DB0
.................... 		flash_wait_while_busy(); 
05F1E:  RCALL  5DA6
....................  
.................... 			 
.................... 		output_low(FLASH_CS); 
05F20:  BCF    F95.2
05F22:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_PAGE_PROGRAM); 
05F24:  MOVLW  02
05F26:  MOVLB  7
05F28:  MOVWF  x44
05F2A:  MOVLW  08
05F2C:  MOVWF  x45
05F2E:  MOVLB  0
05F30:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
05F32:  MOVLB  6
05F34:  CLRF   xE6
05F36:  CLRF   xE7
05F38:  MOVFF  6DF,6E8
05F3C:  CLRF   xE9
05F3E:  MOVFF  6DF,6E6
05F42:  MOVFF  6E9,6E7
05F46:  CLRF   xE8
05F48:  CLRF   xE9
05F4A:  MOVFF  6DF,744
05F4E:  MOVLW  08
05F50:  MOVLB  7
05F52:  MOVWF  x45
05F54:  MOVLB  0
05F56:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
05F58:  MOVLB  6
05F5A:  CLRF   xE6
05F5C:  CLRF   xE8
05F5E:  CLRF   xE9
05F60:  MOVFF  6DE,6E6
05F64:  MOVFF  6E8,6E7
05F68:  MOVFF  6E9,6E8
05F6C:  CLRF   xE9
05F6E:  MOVFF  6DE,744
05F72:  MOVLW  08
05F74:  MOVLB  7
05F76:  MOVWF  x45
05F78:  MOVLB  0
05F7A:  RCALL  5CCA
.................... 		spi_xfer(starting_address & 0xFF); 
05F7C:  MOVLB  6
05F7E:  MOVFF  6DD,6E6
05F82:  CLRF   xE7
05F84:  CLRF   xE8
05F86:  CLRF   xE9
05F88:  MOVFF  6DD,744
05F8C:  MOVLW  08
05F8E:  MOVLB  7
05F90:  MOVWF  x45
05F92:  MOVLB  0
05F94:  RCALL  5CCA
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
05F96:  MOVLB  6
05F98:  CLRF   xE4
05F9A:  CLRF   xE3
05F9C:  MOVF   xE4,W
05F9E:  SUBLW  00
05FA0:  BNC   5FD6
.................... 		{ 
.................... 			//spi_xfer(value_counter); 
.................... 			spi_xfer(ptr[value_counter]); 
05FA2:  MOVF   xD9,W
05FA4:  ADDWF  xDB,W
05FA6:  MOVWF  FE9
05FA8:  MOVF   xDA,W
05FAA:  ADDWFC xDC,W
05FAC:  MOVWF  FEA
05FAE:  MOVFF  FEF,6E6
05FB2:  MOVFF  6E6,744
05FB6:  MOVLW  08
05FB8:  MOVLB  7
05FBA:  MOVWF  x45
05FBC:  MOVLB  0
05FBE:  RCALL  5CCA
.................... 			test_val++; 
05FC0:  MOVLB  6
05FC2:  INCF   xE1,F
05FC4:  BTFSC  FD8.2
05FC6:  INCF   xE2,F
.................... 			value_counter++; 
05FC8:  INCF   xDB,F
05FCA:  BTFSC  FD8.2
05FCC:  INCF   xDC,F
.................... 		} 
05FCE:  INCF   xE3,F
05FD0:  BTFSC  FD8.2
05FD2:  INCF   xE4,F
05FD4:  BRA    5F9C
.................... 		 
.................... 		output_high(FLASH_CS); 
05FD6:  BCF    F95.2
05FD8:  BSF    F8C.2
....................  
.................... 		flash_wait_while_busy(); 
05FDA:  MOVLB  0
05FDC:  RCALL  5DA6
....................  
.................... 		//fprintf(RS232,"Wrote %lu bytes\r\n",test_val); 
.................... 		 
.................... 	} 
05FDE:  MOVLB  6
05FE0:  INCF   xE5,F
05FE2:  BRA    5EC8
.................... } 
05FE4:  MOVLB  0
05FE6:  GOTO   949A (RETURN)
....................  
....................  
.................... void FLASH_ADDR_READ() 
.................... { 
*
06130:  MOVLB  6
06132:  CLRF   xDB
06134:  CLRF   xDA
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
06136:  MOVLW  01
06138:  MOVWF  xDB
0613A:  MOVLW  84
0613C:  MOVWF  xDA
....................  
.................... 	int32 starting_address = 0; 
....................  
.................... 	int16 value_counter = 0; 
....................  
.................... 	int data = 0; 
0613E:  CLRF   xDF
06140:  CLRF   xDE
06142:  CLRF   xDD
06144:  CLRF   xDC
06146:  CLRF   xE1
06148:  CLRF   xE0
0614A:  CLRF   xE2
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
0614C:  CLRF   xE3
0614E:  MOVF   xE3,W
06150:  SUBLW  03
06152:  BTFSS  FD8.0
06154:  BRA    6244
....................  
.................... 		starting_address = page_address(DEFAULT_ADDR_BLOCK,sector_counter,0); 
06156:  MOVLB  7
06158:  CLRF   x42
0615A:  CLRF   x41
0615C:  CLRF   x40
0615E:  MOVLW  0E
06160:  MOVWF  x3F
06162:  CLRF   x46
06164:  CLRF   x45
06166:  CLRF   x44
06168:  MOVFF  6E3,743
0616C:  CLRF   x4A
0616E:  CLRF   x49
06170:  CLRF   x48
06172:  CLRF   x47
06174:  MOVLB  0
06176:  RCALL  5BF2
06178:  MOVFF  03,6DF
0617C:  MOVFF  02,6DE
06180:  MOVFF  01,6DD
06184:  MOVFF  00,6DC
....................  
.................... 		output_low(FLASH_CS); 
06188:  BCF    F95.2
0618A:  BCF    F8C.2
.................... 		spi_xfer(W25Q80BV_READ); 
0618C:  MOVLW  03
0618E:  MOVLB  7
06190:  MOVWF  x44
06192:  MOVLW  08
06194:  MOVWF  x45
06196:  MOVLB  0
06198:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF0000) >> 16); 
0619A:  MOVLB  6
0619C:  CLRF   xE6
0619E:  CLRF   xE7
061A0:  MOVFF  6DE,6E8
061A4:  CLRF   xE9
061A6:  MOVFF  6DE,6E6
061AA:  MOVFF  6E9,6E7
061AE:  CLRF   xE8
061B0:  CLRF   xE9
061B2:  MOVFF  6DE,744
061B6:  MOVLW  08
061B8:  MOVLB  7
061BA:  MOVWF  x45
061BC:  MOVLB  0
061BE:  RCALL  5CCA
.................... 		spi_xfer((starting_address & 0xFF00) >> 8); 
061C0:  MOVLB  6
061C2:  CLRF   xE6
061C4:  CLRF   xE8
061C6:  CLRF   xE9
061C8:  MOVFF  6DD,6E6
061CC:  MOVFF  6E8,6E7
061D0:  MOVFF  6E9,6E8
061D4:  CLRF   xE9
061D6:  MOVFF  6DD,744
061DA:  MOVLW  08
061DC:  MOVLB  7
061DE:  MOVWF  x45
061E0:  MOVLB  0
061E2:  RCALL  5CCA
.................... 		spi_xfer(starting_address & 0xFF); 
061E4:  MOVLB  6
061E6:  MOVFF  6DC,6E6
061EA:  CLRF   xE7
061EC:  CLRF   xE8
061EE:  CLRF   xE9
061F0:  MOVFF  6DC,744
061F4:  MOVLW  08
061F6:  MOVLB  7
061F8:  MOVWF  x45
061FA:  MOVLB  0
061FC:  RCALL  5CCA
.................... 	 
.................... 		for (int16 i = 0; i < 256; i++) 
061FE:  MOVLB  6
06200:  CLRF   xE5
06202:  CLRF   xE4
06204:  MOVF   xE5,W
06206:  SUBLW  00
06208:  BNC   623C
.................... 		{ 
.................... 			data = spi_xfer(0x00); 
0620A:  MOVLB  7
0620C:  CLRF   x44
0620E:  MOVLW  08
06210:  MOVWF  x45
06212:  MOVLB  0
06214:  RCALL  5CCA
06216:  MOVF   01,W
06218:  MOVFF  01,6E2
.................... 			ptr[value_counter] = data; 
0621C:  MOVLB  6
0621E:  MOVF   xDA,W
06220:  ADDWF  xE0,W
06222:  MOVWF  FE9
06224:  MOVF   xDB,W
06226:  ADDWFC xE1,W
06228:  MOVWF  FEA
0622A:  MOVFF  6E2,FEF
.................... 			value_counter++; 
0622E:  INCF   xE0,F
06230:  BTFSC  FD8.2
06232:  INCF   xE1,F
.................... 			 
.................... 		} 
06234:  INCF   xE4,F
06236:  BTFSC  FD8.2
06238:  INCF   xE5,F
0623A:  BRA    6204
....................  
.................... 		output_high(FLASH_CS); 
0623C:  BCF    F95.2
0623E:  BSF    F8C.2
.................... 	} 
06240:  INCF   xE3,F
06242:  BRA    614E
.................... } 
06244:  MOVLB  0
06246:  GOTO   675A (RETURN)
....................  
.................... /* 
.................... void PRINT_READ_PROGRAM() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_CONFIG; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
.................... */ 
.................... void PRINT_READ_ADDR() 
.................... { 
....................  
.................... // This function will write the current DSP_CONFIG in memory to the program at index program_index 
....................  
.................... 	int *ptr = 0; 
....................  
.................... 	ptr = &DSP_ADDR; 
....................  
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG is %lu\r\n",sizeof(DSP_CONFIG)); 
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
.................... 	for(int sector_counter = 0; sector_counter < NUM_ADDRESS_PAGES; sector_counter++) { 
.................... 		 
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void FLASH_COPY_PROGRAM(int from_index, int to_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\nCopying program from %u to %u ... ",from_index,to_index); 
*
07568:  MOVLW  32
0756A:  MOVWF  FF6
0756C:  MOVLW  09
0756E:  MOVWF  FF7
07570:  MOVLW  17
07572:  MOVLB  7
07574:  MOVWF  x2E
07576:  MOVLB  0
07578:  CALL   6034
0757C:  MOVFF  720,72E
07580:  MOVLW  1B
07582:  MOVLB  7
07584:  MOVWF  x2F
07586:  MOVLB  0
07588:  CALL   608A
0758C:  MOVLW  4B
0758E:  MOVWF  FF6
07590:  MOVLW  09
07592:  MOVWF  FF7
07594:  MOVLW  04
07596:  MOVLB  7
07598:  MOVWF  x2E
0759A:  MOVLB  0
0759C:  CALL   6034
075A0:  MOVFF  721,72E
075A4:  MOVLW  1B
075A6:  MOVLB  7
075A8:  MOVWF  x2F
075AA:  MOVLB  0
075AC:  CALL   608A
075B0:  MOVLW  51
075B2:  MOVWF  FF6
075B4:  MOVLW  09
075B6:  MOVWF  FF7
075B8:  MOVLW  05
075BA:  MOVLB  7
075BC:  MOVWF  x2E
075BE:  MOVLB  0
075C0:  CALL   6034
.................... 	//fprintf(RS232,"Sizeof DSP_CONFIG.TEST_VALUES is %lu\r\n",sizeof(DSP_CONFIG.TEST_VALUES)); 
.................... 	int32 read_starting_address = 0; 
.................... 	int32 write_starting_address = 0; 
.................... 	 
.................... 	int read_data = 0; 
075C4:  MOVLB  7
075C6:  CLRF   x25
075C8:  CLRF   x24
075CA:  CLRF   x23
075CC:  CLRF   x22
075CE:  CLRF   x29
075D0:  CLRF   x28
075D2:  CLRF   x27
075D4:  CLRF   x26
075D6:  CLRF   x2A
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
075D8:  CLRF   x2B
075DA:  MOVF   x2B,W
075DC:  SUBLW  0B
075DE:  BTFSS  FD8.0
075E0:  BRA    77CA
....................  
.................... 		flash_sector_erase(to_index,sector_counter); 
075E2:  CLRF   x35
075E4:  CLRF   x34
075E6:  CLRF   x33
075E8:  MOVFF  721,732
075EC:  CLRF   x39
075EE:  CLRF   x38
075F0:  CLRF   x37
075F2:  MOVFF  72B,736
075F6:  MOVLB  0
075F8:  CALL   5DCA
....................  
.................... 		write_starting_address = page_address(to_index,sector_counter,0); 
075FC:  MOVLB  7
075FE:  CLRF   x42
07600:  CLRF   x41
07602:  CLRF   x40
07604:  MOVFF  721,73F
07608:  CLRF   x46
0760A:  CLRF   x45
0760C:  CLRF   x44
0760E:  MOVFF  72B,743
07612:  CLRF   x4A
07614:  CLRF   x49
07616:  CLRF   x48
07618:  CLRF   x47
0761A:  MOVLB  0
0761C:  CALL   5BF2
07620:  MOVFF  03,729
07624:  MOVFF  02,728
07628:  MOVFF  01,727
0762C:  MOVFF  00,726
.................... 		read_starting_address = page_address(from_index,sector_counter,0); 
07630:  MOVLB  7
07632:  CLRF   x42
07634:  CLRF   x41
07636:  CLRF   x40
07638:  MOVFF  720,73F
0763C:  CLRF   x46
0763E:  CLRF   x45
07640:  CLRF   x44
07642:  MOVFF  72B,743
07646:  CLRF   x4A
07648:  CLRF   x49
0764A:  CLRF   x48
0764C:  CLRF   x47
0764E:  MOVLB  0
07650:  CALL   5BF2
07654:  MOVFF  03,725
07658:  MOVFF  02,724
0765C:  MOVFF  01,723
07660:  MOVFF  00,722
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
07664:  MOVLB  7
07666:  CLRF   x2D
07668:  CLRF   x2C
0766A:  MOVF   x2D,W
0766C:  SUBLW  00
0766E:  BTFSS  FD8.0
07670:  BRA    77C6
.................... 		{ 
.................... 			output_low(FLASH_CS); 
07672:  BCF    F95.2
07674:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_READ); 
07676:  MOVLW  03
07678:  MOVWF  x44
0767A:  MOVLW  08
0767C:  MOVWF  x45
0767E:  MOVLB  0
07680:  CALL   5CCA
.................... 			spi_xfer((read_starting_address & 0xFF0000) >> 16); 
07684:  MOVLB  7
07686:  CLRF   x2E
07688:  CLRF   x2F
0768A:  MOVFF  724,730
0768E:  CLRF   x31
07690:  MOVFF  724,72E
07694:  MOVFF  731,72F
07698:  CLRF   x30
0769A:  CLRF   x31
0769C:  MOVFF  724,744
076A0:  MOVLW  08
076A2:  MOVWF  x45
076A4:  MOVLB  0
076A6:  CALL   5CCA
.................... 			spi_xfer((read_starting_address & 0xFF00) >> 8); 
076AA:  MOVLB  7
076AC:  CLRF   x2E
076AE:  CLRF   x30
076B0:  CLRF   x31
076B2:  MOVFF  723,72E
076B6:  MOVFF  730,72F
076BA:  MOVFF  731,730
076BE:  CLRF   x31
076C0:  MOVFF  723,744
076C4:  MOVLW  08
076C6:  MOVWF  x45
076C8:  MOVLB  0
076CA:  CALL   5CCA
.................... 			spi_xfer(read_starting_address & 0xFF); 
076CE:  MOVLB  7
076D0:  MOVFF  722,72E
076D4:  CLRF   x2F
076D6:  CLRF   x30
076D8:  CLRF   x31
076DA:  MOVFF  722,744
076DE:  MOVLW  08
076E0:  MOVWF  x45
076E2:  MOVLB  0
076E4:  CALL   5CCA
.................... 		 
.................... 			read_data = spi_xfer(0x00); 
076E8:  MOVLB  7
076EA:  CLRF   x44
076EC:  MOVLW  08
076EE:  MOVWF  x45
076F0:  MOVLB  0
076F2:  CALL   5CCA
076F6:  MOVF   01,W
076F8:  MOVFF  01,72A
....................  
.................... 			output_high(FLASH_CS); 
076FC:  BCF    F95.2
076FE:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
07700:  CALL   5DA6
....................  
.................... 			flash_write_enable(); 
07704:  CALL   5DB0
.................... 			flash_wait_while_busy(); 
07708:  CALL   5DA6
....................  
.................... 			output_low(FLASH_CS); 
0770C:  BCF    F95.2
0770E:  BCF    F8C.2
.................... 			spi_xfer(W25Q80BV_PAGE_PROGRAM); 
07710:  MOVLW  02
07712:  MOVLB  7
07714:  MOVWF  x44
07716:  MOVLW  08
07718:  MOVWF  x45
0771A:  MOVLB  0
0771C:  CALL   5CCA
.................... 			spi_xfer((write_starting_address & 0xFF0000) >> 16); 
07720:  MOVLB  7
07722:  CLRF   x2E
07724:  CLRF   x2F
07726:  MOVFF  728,730
0772A:  CLRF   x31
0772C:  MOVFF  728,72E
07730:  MOVFF  731,72F
07734:  CLRF   x30
07736:  CLRF   x31
07738:  MOVFF  728,744
0773C:  MOVLW  08
0773E:  MOVWF  x45
07740:  MOVLB  0
07742:  CALL   5CCA
.................... 			spi_xfer((write_starting_address & 0xFF00) >> 8); 
07746:  MOVLB  7
07748:  CLRF   x2E
0774A:  CLRF   x30
0774C:  CLRF   x31
0774E:  MOVFF  727,72E
07752:  MOVFF  730,72F
07756:  MOVFF  731,730
0775A:  CLRF   x31
0775C:  MOVFF  727,744
07760:  MOVLW  08
07762:  MOVWF  x45
07764:  MOVLB  0
07766:  CALL   5CCA
.................... 			spi_xfer(write_starting_address & 0xFF); 
0776A:  MOVLB  7
0776C:  MOVFF  726,72E
07770:  CLRF   x2F
07772:  CLRF   x30
07774:  CLRF   x31
07776:  MOVFF  726,744
0777A:  MOVLW  08
0777C:  MOVWF  x45
0777E:  MOVLB  0
07780:  CALL   5CCA
....................  
.................... 			spi_xfer(read_data); 
07784:  MOVFF  72A,744
07788:  MOVLW  08
0778A:  MOVLB  7
0778C:  MOVWF  x45
0778E:  MOVLB  0
07790:  CALL   5CCA
....................  
.................... 			output_high(FLASH_CS); 
07794:  BCF    F95.2
07796:  BSF    F8C.2
....................  
.................... 			flash_wait_while_busy(); 
07798:  CALL   5DA6
....................  
.................... 			read_starting_address++; 
0779C:  MOVLW  01
0779E:  MOVLB  7
077A0:  ADDWF  x22,F
077A2:  BTFSC  FD8.0
077A4:  INCF   x23,F
077A6:  BTFSC  FD8.2
077A8:  INCF   x24,F
077AA:  BTFSC  FD8.2
077AC:  INCF   x25,F
.................... 			write_starting_address++; 
077AE:  MOVLW  01
077B0:  ADDWF  x26,F
077B2:  BTFSC  FD8.0
077B4:  INCF   x27,F
077B6:  BTFSC  FD8.2
077B8:  INCF   x28,F
077BA:  BTFSC  FD8.2
077BC:  INCF   x29,F
....................  
.................... 			//fprintf(RS232,"%x||",read_data); 
.................... 		} 
077BE:  INCF   x2C,F
077C0:  BTFSC  FD8.2
077C2:  INCF   x2D,F
077C4:  BRA    766A
.................... 	} 
077C6:  INCF   x2B,F
077C8:  BRA    75DA
....................  
.................... 	fprintf(RS232,"DONE!\r\n"); 
077CA:  MOVLW  58
077CC:  MOVWF  FF6
077CE:  MOVLW  09
077D0:  MOVWF  FF7
077D2:  MOVLB  0
077D4:  CALL   6012
.................... } 
077D8:  GOTO   8974 (RETURN)
....................  
.................... void FLASH_COMPARE_PROGRAM(int a_index, int b_index) 
.................... { 
....................  
.................... 	fprintf(RS232,"\r\Comparing programs %u and %u ... ",a_index,b_index); 
....................  
.................... 	int32 compare_a_starting_address = 0; 
.................... 	int32 compare_b_starting_address = 0; 
.................... 	 
.................... 	int read_data_a = 0; 
.................... 	int read_data_b = 0; 
....................  
.................... 	int errors_found = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < NUM_PRESET_PAGES; sector_counter++) { 
....................  
....................  
.................... 		compare_a_starting_address = page_address(a_index,sector_counter,0); 
.................... 		compare_b_starting_address = page_address(b_index,sector_counter,0); 
....................  
.................... 		 
....................  
.................... 		for (int16 i = 0; i < 256; i++) 
.................... 		{ 
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_a_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_a_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_a = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
....................  
.................... 			output_low(FLASH_CS); 
.................... 			spi_xfer(W25Q80BV_READ); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF0000) >> 16); 
.................... 			spi_xfer((compare_b_starting_address & 0xFF00) >> 8); 
.................... 			spi_xfer(compare_b_starting_address & 0xFF); 
.................... 		 
.................... 			read_data_b = spi_xfer(0x00); 
....................  
.................... 			output_high(FLASH_CS); 
....................  
.................... 			flash_wait_while_busy(); 
....................  
.................... 			compare_a_starting_address++; 
.................... 			compare_b_starting_address++; 
....................  
.................... 			if(read_data_a != read_data_b) { 
.................... 				fprintf(RS232,"[ERROR] found in sector %u at address %lu. A = %x, B = %x\r\n",sector_counter,i,read_data_a,read_data_b); 
.................... 				errors_found++; 
.................... 			} else { 
.................... 				//fprintf(RS232,"%x == %x ",read_data_a,read_data_b); 
.................... 				 
.................... 			} 
.................... 		} 
....................  
.................... 		//fprintf(RS232,"Completed sector %u, %u errors found.\r\n",sector_counter,errors_in_sector); 
.................... 	} 
....................  
.................... 	fprintf(RS232,"%u errors found\r\n",errors_found); 
.................... } 
....................  
.................... int addr_index_to_page_index(int16 addr_index) { 
.................... 	return (int)(addr_index / PAGE_SIZE); 
*
072E8:  MOVLB  7
072EA:  RRCF   x21,W
072EC:  MOVWF  03
072EE:  RRCF   x20,W
072F0:  MOVWF  02
072F2:  RRCF   03,F
072F4:  RRCF   02,F
072F6:  RRCF   03,F
072F8:  RRCF   02,F
072FA:  RRCF   03,F
072FC:  RRCF   02,F
072FE:  RRCF   03,F
07300:  RRCF   02,F
07302:  RRCF   03,F
07304:  RRCF   02,F
07306:  MOVLW  03
07308:  ANDWF  03,F
0730A:  MOVFF  02,01
.................... } 
0730E:  MOVLB  0
07310:  RETURN 0
....................  
.................... int addr_index_to_buffer_index(int16 addr_index) { 
.................... 	return (int)(addr_index % PAGE_SIZE); 
07312:  MOVLB  7
07314:  MOVF   x20,W
07316:  ANDLW  3F
07318:  MOVWF  00
0731A:  CLRF   03
0731C:  MOVWF  01
.................... } 
0731E:  MOVLB  0
07320:  GOTO   8314 (RETURN)
....................  
.................... void read_flash_page_into_buffer(int *ptr,int program_index, int page_index)  
.................... { 
*
063F8:  MOVLB  7
063FA:  CLRF   x31
063FC:  CLRF   x30
063FE:  CLRF   x2F
06400:  CLRF   x2E
06402:  CLRF   x32
.................... 	int32 starting_address = 0; 
.................... 	int data = 0; 
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
06404:  CLRF   x42
06406:  CLRF   x41
06408:  CLRF   x40
0640A:  MOVFF  72C,73F
0640E:  CLRF   x46
06410:  CLRF   x45
06412:  CLRF   x44
06414:  MOVFF  72D,743
06418:  CLRF   x4A
0641A:  CLRF   x49
0641C:  CLRF   x48
0641E:  CLRF   x47
06420:  MOVLB  0
06422:  CALL   5BF2
06426:  MOVFF  03,731
0642A:  MOVFF  02,730
0642E:  MOVFF  01,72F
06432:  MOVFF  00,72E
....................  
.................... 	output_low(FLASH_CS); 
06436:  BCF    F95.2
06438:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_READ); 
0643A:  MOVLW  03
0643C:  MOVLB  7
0643E:  MOVWF  x44
06440:  MOVLW  08
06442:  MOVWF  x45
06444:  MOVLB  0
06446:  RCALL  5CCA
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
06448:  MOVLB  7
0644A:  CLRF   x35
0644C:  CLRF   x36
0644E:  MOVFF  730,737
06452:  CLRF   x38
06454:  MOVFF  730,735
06458:  MOVFF  738,736
0645C:  CLRF   x37
0645E:  CLRF   x38
06460:  MOVFF  730,744
06464:  MOVLW  08
06466:  MOVWF  x45
06468:  MOVLB  0
0646A:  RCALL  5CCA
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
0646C:  MOVLB  7
0646E:  CLRF   x35
06470:  CLRF   x37
06472:  CLRF   x38
06474:  MOVFF  72F,735
06478:  MOVFF  737,736
0647C:  MOVFF  738,737
06480:  CLRF   x38
06482:  MOVFF  72F,744
06486:  MOVLW  08
06488:  MOVWF  x45
0648A:  MOVLB  0
0648C:  RCALL  5CCA
.................... 	spi_xfer(starting_address & 0xFF); 
0648E:  MOVLB  7
06490:  MOVFF  72E,735
06494:  CLRF   x36
06496:  CLRF   x37
06498:  CLRF   x38
0649A:  MOVFF  72E,744
0649E:  MOVLW  08
064A0:  MOVWF  x45
064A2:  MOVLB  0
064A4:  RCALL  5CCA
.................... 	 
.................... 	for (int16 i = 0; i < 256; i++) 
064A6:  MOVLB  7
064A8:  CLRF   x34
064AA:  CLRF   x33
064AC:  MOVF   x34,W
064AE:  SUBLW  00
064B0:  BNC   64DC
.................... 	{ 
.................... 		data = spi_xfer(0x00); 
064B2:  CLRF   x44
064B4:  MOVLW  08
064B6:  MOVWF  x45
064B8:  MOVLB  0
064BA:  RCALL  5CCA
064BC:  MOVF   01,W
064BE:  MOVFF  01,732
.................... 		ptr[i] = data; 
064C2:  MOVLB  7
064C4:  MOVF   x2A,W
064C6:  ADDWF  x33,W
064C8:  MOVWF  FE9
064CA:  MOVF   x2B,W
064CC:  ADDWFC x34,W
064CE:  MOVWF  FEA
064D0:  MOVFF  732,FEF
.................... 	} 
064D4:  INCF   x33,F
064D6:  BTFSC  FD8.2
064D8:  INCF   x34,F
064DA:  BRA    64AC
....................  
.................... 	output_high(FLASH_CS); 
064DC:  BCF    F95.2
064DE:  BSF    F8C.2
.................... } 
064E0:  MOVLB  0
064E2:  RETURN 0
....................  
....................  
.................... void write_buffer_to_flash_page(int *ptr,int program_index, int page_index)  
.................... { 
064E4:  MOVLB  7
064E6:  CLRF   x2F
064E8:  CLRF   x2E
064EA:  CLRF   x2D
064EC:  CLRF   x2C
064EE:  CLRF   x31
064F0:  CLRF   x30
.................... 	int32 starting_address = 0; 
.................... 	int16 value_counter = 0; 
.................... 	 
.................... 	flash_sector_erase(program_index,page_index); 
064F2:  CLRF   x35
064F4:  CLRF   x34
064F6:  CLRF   x33
064F8:  MOVFF  72A,732
064FC:  CLRF   x39
064FE:  CLRF   x38
06500:  CLRF   x37
06502:  MOVFF  72B,736
06506:  MOVLB  0
06508:  RCALL  5DCA
....................  
.................... 	starting_address = page_address(program_index,page_index,0); 
0650A:  MOVLB  7
0650C:  CLRF   x42
0650E:  CLRF   x41
06510:  CLRF   x40
06512:  MOVFF  72A,73F
06516:  CLRF   x46
06518:  CLRF   x45
0651A:  CLRF   x44
0651C:  MOVFF  72B,743
06520:  CLRF   x4A
06522:  CLRF   x49
06524:  CLRF   x48
06526:  CLRF   x47
06528:  MOVLB  0
0652A:  CALL   5BF2
0652E:  MOVFF  03,72F
06532:  MOVFF  02,72E
06536:  MOVFF  01,72D
0653A:  MOVFF  00,72C
....................  
.................... 	flash_write_enable(); 
0653E:  RCALL  5DB0
.................... 	flash_wait_while_busy(); 
06540:  RCALL  5DA6
.................... 	 
.................... 	output_low(FLASH_CS); 
06542:  BCF    F95.2
06544:  BCF    F8C.2
.................... 	spi_xfer(W25Q80BV_PAGE_PROGRAM); 
06546:  MOVLW  02
06548:  MOVLB  7
0654A:  MOVWF  x44
0654C:  MOVLW  08
0654E:  MOVWF  x45
06550:  MOVLB  0
06552:  CALL   5CCA
.................... 	spi_xfer((starting_address & 0xFF0000) >> 16); 
06556:  MOVLB  7
06558:  CLRF   x32
0655A:  CLRF   x33
0655C:  MOVFF  72E,734
06560:  CLRF   x35
06562:  MOVFF  72E,732
06566:  MOVFF  735,733
0656A:  CLRF   x34
0656C:  CLRF   x35
0656E:  MOVFF  72E,744
06572:  MOVLW  08
06574:  MOVWF  x45
06576:  MOVLB  0
06578:  CALL   5CCA
.................... 	spi_xfer((starting_address & 0xFF00) >> 8); 
0657C:  MOVLB  7
0657E:  CLRF   x32
06580:  CLRF   x34
06582:  CLRF   x35
06584:  MOVFF  72D,732
06588:  MOVFF  734,733
0658C:  MOVFF  735,734
06590:  CLRF   x35
06592:  MOVFF  72D,744
06596:  MOVLW  08
06598:  MOVWF  x45
0659A:  MOVLB  0
0659C:  CALL   5CCA
.................... 	spi_xfer(starting_address & 0xFF); 
065A0:  MOVLB  7
065A2:  MOVFF  72C,732
065A6:  CLRF   x33
065A8:  CLRF   x34
065AA:  CLRF   x35
065AC:  MOVFF  72C,744
065B0:  MOVLW  08
065B2:  MOVWF  x45
065B4:  MOVLB  0
065B6:  CALL   5CCA
.................... 		 
.................... 	for (value_counter = 0; value_counter < 256; value_counter++) 
065BA:  MOVLB  7
065BC:  CLRF   x31
065BE:  CLRF   x30
065C0:  MOVF   x31,W
065C2:  SUBLW  00
065C4:  BNC   65EE
.................... 	{ 
.................... 		spi_xfer(ptr[value_counter]); 
065C6:  MOVF   x28,W
065C8:  ADDWF  x30,W
065CA:  MOVWF  FE9
065CC:  MOVF   x29,W
065CE:  ADDWFC x31,W
065D0:  MOVWF  FEA
065D2:  MOVFF  FEF,732
065D6:  MOVFF  732,744
065DA:  MOVLW  08
065DC:  MOVWF  x45
065DE:  MOVLB  0
065E0:  CALL   5CCA
.................... 	} 
065E4:  MOVLB  7
065E6:  INCF   x30,F
065E8:  BTFSC  FD8.2
065EA:  INCF   x31,F
065EC:  BRA    65C0
....................  
.................... 	output_high(FLASH_CS); 
065EE:  BCF    F95.2
065F0:  BSF    F8C.2
....................  
.................... 	flash_wait_while_busy(); 
065F2:  MOVLB  0
065F4:  CALL   5DA6
.................... } 
065F8:  RETURN 0
....................  
.................... void write_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
*
077E6:  MOVLB  7
077E8:  CLRF   x24
077EA:  CLRF   x23
077EC:  MOVF   x24,W
077EE:  SUBLW  00
077F0:  BNC   7832
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
077F2:  DECFSZ x22,W
077F4:  BRA    7812
.................... 			fputc(ptr[value_counter],USB); 
077F6:  MOVF   x20,W
077F8:  ADDWF  x23,W
077FA:  MOVWF  FE9
077FC:  MOVF   x21,W
077FE:  ADDWFC x24,W
07800:  MOVWF  FEA
07802:  MOVFF  FEF,725
07806:  MOVFF  725,729
0780A:  MOVLB  0
0780C:  RCALL  7234
.................... 		} else { 
0780E:  BRA    7828
07810:  MOVLB  7
.................... 			fputc(ptr[value_counter],RS232); 
07812:  MOVF   x20,W
07814:  ADDWF  x23,W
07816:  MOVWF  FE9
07818:  MOVF   x21,W
0781A:  ADDWFC x24,W
0781C:  MOVWF  FEA
0781E:  MOVFF  FEF,725
07822:  MOVF   x25,W
07824:  MOVLB  0
07826:  BRA    77DC
.................... 		} 
.................... 	}	 
07828:  MOVLB  7
0782A:  INCF   x23,F
0782C:  BTFSC  FD8.2
0782E:  INCF   x24,F
07830:  BRA    77EC
.................... } 
07832:  MOVLB  0
07834:  GOTO   8A34 (RETURN)
....................  
.................... void print_buffer_to_stream(int *ptr, int is_usb_stream = 1)  
.................... { 
.................... 	for (int16 value_counter = 0; value_counter < 256; value_counter++) 
.................... 	{ 
.................... 		if(is_usb_stream == 1) { 
.................... 			fprintf(USB,"%x",ptr[value_counter]); 
.................... 		} else { 
.................... 			fprintf(RS232,"%x",ptr[value_counter]); 
....................  
.................... 			if((value_counter % 4) == 3) { 
.................... 				fprintf(RS232," ");	 
.................... 			} 
....................  
.................... 			if((value_counter % 32) == 31) { 
.................... 				fprintf(RS232,"\r\n");	 
.................... 			} 
.................... 		} 
.................... 	}	 
.................... } 
....................  
....................  
.................... void print_flash_page_buffer(int *ptr) 
.................... { 
.................... 	int16 value_counter = 0; 
....................  
.................... 	int16 value_in_sector_counter = 0; 
....................  
.................... 		for (value_in_sector_counter = 0; value_in_sector_counter < 256; value_in_sector_counter++) 
.................... 		{ 
.................... 			printf("%x",ptr[value_counter]); 
....................  
.................... 			if((value_in_sector_counter % 4) == 3) { 
.................... 				printf(" "); 
.................... 			} 
.................... 	 
.................... 			if((value_in_sector_counter % 32) == 31) { 
.................... 				printf("\r\n"); 
.................... 			} 
....................  
.................... 			value_counter++; 
.................... 	 
.................... 		} 
.................... } 
....................  
....................  
....................  
.................... #include <errorlist.h> 
....................  #define ERR_START 						0x15 
....................  
....................  #define ERR_INVALID_START 				0x02 
....................  
....................  #define ERR_UNKNOWN 					0x09 
....................  
....................  #define ERR_COMMAND_TIMEOUT 			0x10 
....................  #define ERR_COMMAND_INVALID			0x13 
....................  
....................  #define ERR_END_TIMEOUT 				0x11 
....................  #define ERR_END_INVALID 				0x12 
....................  
....................   
....................  #define ERR_ADDR_TIMEOUT 				0x14 
....................  #define ERR_ADDR_INVALID 				0x16 
....................  
....................  #define ERR_DATA_TIMEOUT 				0x17 
....................  #define ERR_DATA_INVALID 				0x17 
....................  
....................  #define ERR_PHANTOM_BOOL_TIMEOUT		0x18 
....................  #define ERR_PHANTOM_BOOL_INVALID 		0x19 
....................  
....................  #define ERR_PHANTOM_CH_TIMEOUT 		0x20 
....................  #define ERR_PHANTOM_CH_INVALID 		0x21 
....................  
....................  #define ERR_VOL_CH_TIMEOUT				0x22 
....................  #define ERR_VOL_CH_INVALID				0x23 
....................  
....................  #define ERR_VOL_TIMEOUT				0x24 
....................  #define ERR_VOL_INVALID				0x25 
....................  
....................  #define ERR_RS232_CH_TIMEOUT			0x26 
....................  #define ERR_RS232_CH_INVALID			0x27 
....................  
....................  #define ERR_RS232_DATA_TIMEOUT			0x28 
....................  #define ERR_RS232_DATA_INVALID			0x29 
....................  
....................  #define ERR_DEVICE_CONFIG_INVALID		0x30 
....................  
....................  
....................  
....................  
.................... #include <dsp_comm.c> 
.................... BYTE dsp_read_buffer[8]; 
....................  
.................... void i2c_write_4byte(int32 fourBytes) { 
*
0133E:  MOVLB  7
01340:  MOVFF  77B,77F
....................  
....................       int byte4 = fourBytes & 0xFF; 
....................       fourBytes = fourBytes >> 8; 
01344:  MOVFF  77C,77B
01348:  MOVFF  77D,77C
0134C:  MOVFF  77E,77D
01350:  CLRF   x7E
....................     
....................       int byte3 = fourBytes & 0xFF; 
01352:  MOVFF  77B,780
....................       fourBytes = fourBytes >> 8; 
01356:  MOVFF  77C,77B
0135A:  MOVFF  77D,77C
0135E:  MOVFF  77E,77D
01362:  CLRF   x7E
....................     
....................       int byte2 = fourBytes & 0xFF; 
....................     
....................       int byte1 = fourBytes >> 8; 
01364:  MOVFF  77B,781
01368:  MOVFF  77C,782
....................     
....................       i2c_write(byte1); 
0136C:  MOVFF  782,783
01370:  MOVLB  0
01372:  RCALL  12C8
....................       i2c_write(byte2);  
01374:  MOVFF  781,783
01378:  RCALL  12C8
....................       i2c_write(byte3); 
0137A:  MOVFF  780,783
0137E:  RCALL  12C8
....................       i2c_write(byte4); 
01380:  MOVFF  77F,783
01384:  RCALL  12C8
....................     
.................... } 
01386:  RETURN 0
....................  
.................... void reset_dsp() { 
....................  
.................... 	output_high(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_low(PIN_DSP_nRESET); 
.................... 	delay_ms(200); 
.................... 	output_high(PIN_DSP_nRESET); 
.................... } 
....................  
....................  
.................... void send_dsp_command(int32 address, int32 command) { 
....................  
....................    i2c_start(); 
01388:  BSF    F94.3
0138A:  MOVLW  03
0138C:  MOVWF  00
0138E:  DECFSZ 00,F
01390:  BRA    138E
01392:  BSF    F94.2
01394:  MOVLW  03
01396:  MOVWF  00
01398:  DECFSZ 00,F
0139A:  BRA    1398
0139C:  BCF    F8B.3
0139E:  BCF    F94.3
013A0:  MOVLW  03
013A2:  MOVWF  00
013A4:  DECFSZ 00,F
013A6:  BRA    13A4
013A8:  BCF    F8B.2
013AA:  BCF    F94.2
....................    i2c_write(DSP_I2C_ADDRESS); 
013AC:  MOVLW  80
013AE:  MOVLB  7
013B0:  MOVWF  x83
013B2:  MOVLB  0
013B4:  RCALL  12C8
....................    i2c_write_4byte(address); 
013B6:  MOVFF  776,77E
013BA:  MOVFF  775,77D
013BE:  MOVFF  774,77C
013C2:  MOVFF  773,77B
013C6:  RCALL  133E
....................    i2c_write_4byte(command); 
013C8:  MOVFF  77A,77E
013CC:  MOVFF  779,77D
013D0:  MOVFF  778,77C
013D4:  MOVFF  777,77B
013D8:  RCALL  133E
....................    i2c_stop(); 
013DA:  BCF    F94.3
013DC:  NOP   
013DE:  BSF    F94.2
013E0:  BTFSS  F82.2
013E2:  BRA    13E0
013E4:  MOVLW  03
013E6:  MOVWF  00
013E8:  DECFSZ 00,F
013EA:  BRA    13E8
013EC:  BRA    13EE
013EE:  NOP   
013F0:  BSF    F94.3
013F2:  MOVLW  03
013F4:  MOVWF  00
013F6:  DECFSZ 00,F
013F8:  BRA    13F6
....................  
.................... } 
013FA:  RETURN 0
....................  
....................  
.................... void send_dsp_message(int32 message) { 
....................  
....................    i2c_start(); 
....................    i2c_write(DSP_I2C_ADDRESS); 
....................    i2c_write_4byte(message); 
....................    i2c_stop(); 
.................... } 
....................  
.................... void send_prefixed_dsp_command(int16 address_prefix, int16 address_suffix, int32 command) { 
....................  
....................    i2c_start(); 
*
06844:  BSF    F94.3
06846:  MOVLW  03
06848:  MOVWF  00
0684A:  DECFSZ 00,F
0684C:  BRA    684A
0684E:  BSF    F94.2
06850:  MOVLW  03
06852:  MOVWF  00
06854:  DECFSZ 00,F
06856:  BRA    6854
06858:  BCF    F8B.3
0685A:  BCF    F94.3
0685C:  MOVLW  03
0685E:  MOVWF  00
06860:  DECFSZ 00,F
06862:  BRA    6860
06864:  BCF    F8B.2
06866:  BCF    F94.2
06868:  CLRF   19
0686A:  BTFSC  FF2.7
0686C:  BSF    19.7
0686E:  BCF    FF2.7
....................    i2c_write(DSP_I2C_ADDRESS); 
06870:  MOVLW  80
06872:  MOVLB  7
06874:  MOVWF  x83
06876:  MOVLB  0
06878:  CALL   12C8
0687C:  BTFSC  19.7
0687E:  BSF    FF2.7
....................  
....................    int32 address = address_prefix; 
06880:  MOVLB  7
06882:  CLRF   x3B
06884:  CLRF   x3A
06886:  MOVFF  731,739
0688A:  MOVFF  730,738
....................    address <<= 16; 
0688E:  MOVFF  739,73B
06892:  MOVFF  738,73A
06896:  CLRF   x38
06898:  CLRF   x39
....................    address |= address_suffix; 
0689A:  MOVF   x32,W
0689C:  IORWF  x38,F
0689E:  MOVF   x33,W
068A0:  IORWF  x39,F
068A2:  CLRF   19
068A4:  BTFSC  FF2.7
068A6:  BSF    19.7
068A8:  BCF    FF2.7
....................    i2c_write_4byte(address); 
068AA:  MOVFF  73B,77E
068AE:  MOVFF  73A,77D
068B2:  MOVFF  739,77C
068B6:  MOVFF  738,77B
068BA:  MOVLB  0
068BC:  CALL   133E
068C0:  BTFSC  19.7
068C2:  BSF    FF2.7
068C4:  CLRF   19
068C6:  BTFSC  FF2.7
068C8:  BSF    19.7
068CA:  BCF    FF2.7
....................    i2c_write_4byte(command); 
068CC:  MOVFF  737,77E
068D0:  MOVFF  736,77D
068D4:  MOVFF  735,77C
068D8:  MOVFF  734,77B
068DC:  CALL   133E
068E0:  BTFSC  19.7
068E2:  BSF    FF2.7
....................    i2c_stop(); 
068E4:  BCF    F94.3
068E6:  NOP   
068E8:  BSF    F94.2
068EA:  BTFSS  F82.2
068EC:  BRA    68EA
068EE:  MOVLW  03
068F0:  MOVWF  00
068F2:  DECFSZ 00,F
068F4:  BRA    68F2
068F6:  BRA    68F8
068F8:  NOP   
068FA:  BSF    F94.3
068FC:  MOVLW  03
068FE:  MOVWF  00
06900:  DECFSZ 00,F
06902:  BRA    6900
....................  
.................... } 
06904:  RETURN 0
....................  
.................... int read_dsp_int_prefixed(int16 address_prefix,int16 address_suffix) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	int32 address = address_prefix; 
....................    	address <<= 16; 
....................    	address |= address_suffix; 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
....................  
.................... 	return dsp_read_buffer[7]; 
.................... } 
....................  
....................  
.................... void read_dsp_and_send_to_usb(int32 address) 
.................... { 
.................... 	i2c_start(); 
*
0738E:  BSF    F94.3
07390:  MOVLW  03
07392:  MOVWF  00
07394:  DECFSZ 00,F
07396:  BRA    7394
07398:  BSF    F94.2
0739A:  MOVLW  03
0739C:  MOVWF  00
0739E:  DECFSZ 00,F
073A0:  BRA    739E
073A2:  BCF    F8B.3
073A4:  BCF    F94.3
073A6:  MOVLW  03
073A8:  MOVWF  00
073AA:  DECFSZ 00,F
073AC:  BRA    73AA
073AE:  BCF    F8B.2
073B0:  BCF    F94.2
073B2:  CLRF   19
073B4:  BTFSC  FF2.7
073B6:  BSF    19.7
073B8:  BCF    FF2.7
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
073BA:  MOVLW  80
073BC:  MOVLB  7
073BE:  MOVWF  x83
073C0:  MOVLB  0
073C2:  CALL   12C8
073C6:  BTFSC  19.7
073C8:  BSF    FF2.7
073CA:  CLRF   19
073CC:  BTFSC  FF2.7
073CE:  BSF    19.7
073D0:  BCF    FF2.7
.................... 	i2c_write_4byte(address); 
073D2:  MOVFF  723,77E
073D6:  MOVFF  722,77D
073DA:  MOVFF  721,77C
073DE:  MOVFF  720,77B
073E2:  CALL   133E
073E6:  BTFSC  19.7
073E8:  BSF    FF2.7
.................... 	i2c_stop(); 
073EA:  BCF    F94.3
073EC:  NOP   
073EE:  BSF    F94.2
073F0:  BTFSS  F82.2
073F2:  BRA    73F0
073F4:  MOVLW  03
073F6:  MOVWF  00
073F8:  DECFSZ 00,F
073FA:  BRA    73F8
073FC:  BRA    73FE
073FE:  NOP   
07400:  BSF    F94.3
07402:  MOVLW  03
07404:  MOVWF  00
07406:  DECFSZ 00,F
07408:  BRA    7406
....................  
.................... 	delay_ms(1); 
0740A:  MOVLW  01
0740C:  MOVLB  7
0740E:  MOVWF  x2B
07410:  MOVLB  0
07412:  CALL   5FEA
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
07416:  BSF    F93.2
07418:  BTFSC  F81.2
0741A:  BRA    751C
....................  
.................... 		i2c_start(); 
0741C:  BSF    F94.3
0741E:  MOVLW  03
07420:  MOVWF  00
07422:  DECFSZ 00,F
07424:  BRA    7422
07426:  BSF    F94.2
07428:  MOVLW  03
0742A:  MOVWF  00
0742C:  DECFSZ 00,F
0742E:  BRA    742C
07430:  BCF    F8B.3
07432:  BCF    F94.3
07434:  MOVLW  03
07436:  MOVWF  00
07438:  DECFSZ 00,F
0743A:  BRA    7438
0743C:  BCF    F8B.2
0743E:  BCF    F94.2
07440:  CLRF   19
07442:  BTFSC  FF2.7
07444:  BSF    19.7
07446:  BCF    FF2.7
....................  
.................... 		if(i2c_write(0x81) == 0) { 
07448:  MOVLW  81
0744A:  MOVLB  7
0744C:  MOVWF  x83
0744E:  MOVLB  0
07450:  CALL   12C8
07454:  BTFSC  19.7
07456:  BSF    FF2.7
07458:  MOVF   01,F
0745A:  BNZ   74FA
....................  
.................... 			for(int i = 0; i < 8; i++) { 
0745C:  MOVLB  7
0745E:  CLRF   x24
07460:  MOVF   x24,W
07462:  SUBLW  07
07464:  BNC   74B2
.................... 				if(i == 7) { 
07466:  MOVF   x24,W
07468:  SUBLW  07
0746A:  BNZ   7488
.................... 					dsp_read_buffer[i] = i2c_read(0); 
0746C:  CLRF   03
0746E:  MOVF   x24,W
07470:  ADDLW  84
07472:  MOVWF  FE9
07474:  MOVLW  05
07476:  ADDWFC 03,W
07478:  MOVWF  FEA
0747A:  CLRF   00
0747C:  MOVLB  0
0747E:  RCALL  7324
07480:  MOVFF  01,FEF
.................... 				} else { 
07484:  BRA    74A2
07486:  MOVLB  7
.................... 					dsp_read_buffer[i] = i2c_read(); 
07488:  CLRF   03
0748A:  MOVF   x24,W
0748C:  ADDLW  84
0748E:  MOVWF  FE9
07490:  MOVLW  05
07492:  ADDWFC 03,W
07494:  MOVWF  FEA
07496:  MOVLW  01
07498:  MOVWF  00
0749A:  MOVLB  0
0749C:  RCALL  7324
0749E:  MOVFF  01,FEF
.................... 				} 
....................  
.................... 				delay_us(100); 
074A2:  MOVLW  7A
074A4:  MOVWF  00
074A6:  DECFSZ 00,F
074A8:  BRA    74A6
074AA:  NOP   
.................... 			} 
074AC:  MOVLB  7
074AE:  INCF   x24,F
074B0:  BRA    7460
.................... 	 
.................... 			fputc(0x06,USB); 
074B2:  MOVLW  06
074B4:  MOVWF  x29
074B6:  MOVLB  0
074B8:  RCALL  7234
.................... 			//delay_ms(1); 
.................... 			for(int x = 4; x < 8; x++) { 
074BA:  MOVLW  04
074BC:  MOVLB  7
074BE:  MOVWF  x25
074C0:  MOVF   x25,W
074C2:  SUBLW  07
074C4:  BNC   74E6
.................... 				fputc(dsp_read_buffer[x],USB); 
074C6:  CLRF   03
074C8:  MOVF   x25,W
074CA:  ADDLW  84
074CC:  MOVWF  FE9
074CE:  MOVLW  05
074D0:  ADDWFC 03,W
074D2:  MOVWF  FEA
074D4:  MOVFF  FEF,726
074D8:  MOVFF  726,729
074DC:  MOVLB  0
074DE:  RCALL  7234
.................... 				//delay_ms(1); 
.................... 			} 
074E0:  MOVLB  7
074E2:  INCF   x25,F
074E4:  BRA    74C0
.................... 			//delay_ms(1); 
.................... 			fputc(0x03,USB); 
074E6:  MOVLW  03
074E8:  MOVWF  x29
074EA:  MOVLB  0
074EC:  RCALL  7234
.................... 			delay_ms(1); 
074EE:  MOVLW  01
074F0:  MOVLB  7
074F2:  MOVWF  x2B
074F4:  MOVLB  0
074F6:  CALL   5FEA
.................... 		} 
....................  
.................... 		i2c_stop(); 
074FA:  BCF    F94.3
074FC:  NOP   
074FE:  BSF    F94.2
07500:  BTFSS  F82.2
07502:  BRA    7500
07504:  MOVLW  03
07506:  MOVWF  00
07508:  DECFSZ 00,F
0750A:  BRA    7508
0750C:  BRA    750E
0750E:  NOP   
07510:  BSF    F94.3
07512:  MOVLW  03
07514:  MOVWF  00
07516:  DECFSZ 00,F
07518:  BRA    7516
.................... 	} else { 
0751A:  BRA    751C
.................... 		//fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
0751C:  GOTO   87D0 (RETURN)
....................  
.................... void read_dsp_and_send_to_rs232(int32 address) 
.................... { 
.................... 	i2c_start(); 
....................  
.................... 	i2c_write(DSP_I2C_ADDRESS); 
.................... 	i2c_write_4byte(address); 
.................... 	i2c_stop(); 
....................  
.................... 	delay_ms(1); 
....................  
.................... 	if(input(PIN_DSP_IRQ) == 0) { 
....................  
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_ms(1); 
.................... 			} 
.................... 	 
.................... 			fprintf(RS232,"Read:"); 
.................... 			for(int x = 4; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
.................... 	} else { 
.................... 		fprintf(RS232,"IRQ never goes low"); 
.................... 	} 
.................... } 
.................... void read_unsolicited_DSP_message() 
.................... { 
.................... 		i2c_start(); 
....................  
.................... 		if(i2c_write(0x81) == 0) { 
....................  
.................... 			for(int i = 0; i < 8; i++) { 
.................... 				if(i == 7) { 
.................... 					dsp_read_buffer[i] = i2c_read(0);; 
.................... 				} else { 
.................... 					dsp_read_buffer[i] = i2c_read(); 
.................... 				} 
....................  
.................... 				delay_us(100); 
.................... 			} 
.................... 			for(int x = 0; x < 8; x++) { 
.................... 				fputc(dsp_read_buffer[x],RS232); 
.................... 			} 
.................... 			fprintf(RS232,"\r\n"); 
.................... 		} 
....................  
.................... 		i2c_stop(); 
....................  
.................... } 
....................  
.................... void load_dsp_values() { 
....................  
.................... /* 
.................... 	for(int16 i = 0; i <= num_dsp_values; i++) { 
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(i),READ_CONFIG_VALUE(i)); 
.................... 		//delay_ms(2);	 
.................... 	} 
.................... */ 
.................... } 
....................  
.................... void dsp_mute_outputs() 
.................... { 
*
06906:  CLRF   19
06908:  BTFSC  FF2.7
0690A:  BSF    19.7
0690C:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x00000000); 
0690E:  MOVLW  83
06910:  MOVLB  7
06912:  MOVWF  x76
06914:  CLRF   x75
06916:  CLRF   x74
06918:  CLRF   x73
0691A:  CLRF   x7A
0691C:  CLRF   x79
0691E:  CLRF   x78
06920:  CLRF   x77
06922:  MOVLB  0
06924:  CALL   1388
06928:  BTFSC  19.7
0692A:  BSF    FF2.7
.................... } 
0692C:  GOTO   6E2E (RETURN)
....................  
.................... void dsp_unmute_outputs() 
.................... { 
*
06C8E:  CLRF   19
06C90:  BTFSC  FF2.7
06C92:  BSF    19.7
06C94:  BCF    FF2.7
.................... 	send_dsp_command(AM_MASTERGAIN,0x08000000); 
06C96:  MOVLW  83
06C98:  MOVLB  7
06C9A:  MOVWF  x76
06C9C:  CLRF   x75
06C9E:  CLRF   x74
06CA0:  CLRF   x73
06CA2:  MOVLW  08
06CA4:  MOVWF  x7A
06CA6:  CLRF   x79
06CA8:  CLRF   x78
06CAA:  CLRF   x77
06CAC:  MOVLB  0
06CAE:  CALL   1388
06CB2:  BTFSC  19.7
06CB4:  BSF    FF2.7
.................... } 
06CB6:  RETURN 0
....................  
.................... void send_flash_program_to_dsp_buffered(int prog_index) 
.................... { 
*
06B14:  MOVLB  7
06B16:  CLRF   x27
06B18:  CLRF   x26
.................... 	int16 overall_counter = 0; 
....................  
.................... 	for(int sector_counter = 0; sector_counter < 8; sector_counter++) { 
06B1A:  CLRF   x28
06B1C:  MOVF   x28,W
06B1E:  SUBLW  07
06B20:  BTFSS  FD8.0
06B22:  BRA    6C88
....................  
.................... 		read_flash_page_into_buffer(&PAGE_BUFFER_A,prog_index,sector_counter); 
06B24:  CLRF   x2B
06B26:  MOVLW  7A
06B28:  MOVWF  x2A
06B2A:  MOVFF  725,72C
06B2E:  MOVFF  728,72D
06B32:  MOVLB  0
06B34:  RCALL  63F8
....................  
.................... 		for(int i = 0; i < 64; i++) { 
06B36:  MOVLB  7
06B38:  CLRF   x29
06B3A:  MOVF   x29,W
06B3C:  SUBLW  3F
06B3E:  BTFSS  FD8.0
06B40:  BRA    6C84
.................... 			if(PAGE_BUFFER_A[i] == 0xFFFFFFFF) { 
06B42:  MOVF   x29,W
06B44:  MULLW  04
06B46:  MOVF   FF3,W
06B48:  CLRF   03
06B4A:  ADDLW  7A
06B4C:  MOVWF  FE9
06B4E:  MOVLW  00
06B50:  ADDWFC 03,W
06B52:  MOVWF  FEA
06B54:  MOVFF  FEF,72A
06B58:  MOVFF  FEC,72B
06B5C:  MOVFF  FEC,72C
06B60:  MOVFF  FEC,72D
06B64:  INCFSZ x2A,W
06B66:  BRA    6B76
06B68:  INCFSZ x2B,W
06B6A:  BRA    6B76
06B6C:  INCFSZ x2C,W
06B6E:  BRA    6B76
06B70:  INCFSZ x2D,W
06B72:  BRA    6B76
.................... 				break; 
06B74:  BRA    6C84
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT0) { 
06B76:  MOVFF  727,72B
06B7A:  MOVFF  726,72A
06B7E:  MOVLB  0
06B80:  RCALL  6930
06B82:  MOVFF  02,72B
06B86:  MOVFF  01,72A
06B8A:  MOVLB  7
06B8C:  MOVF   01,W
06B8E:  SUBLW  7E
06B90:  BNZ   6BA0
06B92:  MOVF   x2B,W
06B94:  SUBLW  02
06B96:  BNZ   6BA0
.................... 				overall_counter++; 
06B98:  INCF   x26,F
06B9A:  BTFSC  FD8.2
06B9C:  INCF   x27,F
.................... 				continue;	 
06B9E:  BRA    6C80
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT1) { 
06BA0:  MOVFF  727,72B
06BA4:  MOVFF  726,72A
06BA8:  MOVLB  0
06BAA:  RCALL  6930
06BAC:  MOVFF  02,72B
06BB0:  MOVFF  01,72A
06BB4:  MOVLB  7
06BB6:  MOVF   01,W
06BB8:  SUBLW  7F
06BBA:  BNZ   6BCA
06BBC:  MOVF   x2B,W
06BBE:  SUBLW  02
06BC0:  BNZ   6BCA
.................... 				overall_counter++; 
06BC2:  INCF   x26,F
06BC4:  BTFSC  FD8.2
06BC6:  INCF   x27,F
.................... 				continue;	 
06BC8:  BRA    6C80
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT2) { 
06BCA:  MOVFF  727,72B
06BCE:  MOVFF  726,72A
06BD2:  MOVLB  0
06BD4:  RCALL  6930
06BD6:  MOVFF  02,72B
06BDA:  MOVFF  01,72A
06BDE:  MOVLB  7
06BE0:  MOVF   01,W
06BE2:  SUBLW  80
06BE4:  BNZ   6BF4
06BE6:  MOVF   x2B,W
06BE8:  SUBLW  02
06BEA:  BNZ   6BF4
.................... 				overall_counter++; 
06BEC:  INCF   x26,F
06BEE:  BTFSC  FD8.2
06BF0:  INCF   x27,F
.................... 				continue;	 
06BF2:  BRA    6C80
.................... 			} 
....................  
.................... 			if(READ_CONFIG_ADDRESS(overall_counter) == BRIDGEROUTER_SELECT3) { 
06BF4:  MOVFF  727,72B
06BF8:  MOVFF  726,72A
06BFC:  MOVLB  0
06BFE:  RCALL  6930
06C00:  MOVFF  02,72B
06C04:  MOVFF  01,72A
06C08:  MOVLB  7
06C0A:  MOVF   01,W
06C0C:  SUBLW  81
06C0E:  BNZ   6C1E
06C10:  MOVF   x2B,W
06C12:  SUBLW  02
06C14:  BNZ   6C1E
.................... 				overall_counter++; 
06C16:  INCF   x26,F
06C18:  BTFSC  FD8.2
06C1A:  INCF   x27,F
.................... 				continue;	 
06C1C:  BRA    6C80
.................... 			} 
....................  
....................  
.................... 			send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(overall_counter),PAGE_BUFFER_A[i]); 
06C1E:  MOVFF  727,72B
06C22:  MOVFF  726,72A
06C26:  MOVLB  0
06C28:  RCALL  6930
06C2A:  MOVFF  02,72B
06C2E:  MOVFF  01,72A
06C32:  MOVLB  7
06C34:  MOVF   x29,W
06C36:  MULLW  04
06C38:  MOVF   FF3,W
06C3A:  CLRF   03
06C3C:  ADDLW  7A
06C3E:  MOVWF  FE9
06C40:  MOVLW  00
06C42:  ADDWFC 03,W
06C44:  MOVWF  FEA
06C46:  MOVFF  FEF,72C
06C4A:  MOVFF  FEC,72D
06C4E:  MOVFF  FEC,72E
06C52:  MOVFF  FEC,72F
06C56:  MOVLW  F0
06C58:  MOVWF  x31
06C5A:  CLRF   x30
06C5C:  MOVFF  02,733
06C60:  MOVFF  01,732
06C64:  MOVFF  72F,737
06C68:  MOVFF  72E,736
06C6C:  MOVFF  72D,735
06C70:  MOVFF  72C,734
06C74:  MOVLB  0
06C76:  RCALL  6844
.................... 			overall_counter++; 
06C78:  MOVLB  7
06C7A:  INCF   x26,F
06C7C:  BTFSC  FD8.2
06C7E:  INCF   x27,F
.................... 		} 
06C80:  INCF   x29,F
06C82:  BRA    6B3A
....................  
.................... 		 
.................... 	} 
06C84:  INCF   x28,F
06C86:  BRA    6B1C
.................... } 
06C88:  MOVLB  0
06C8A:  GOTO   6E34 (RETURN)
....................  
....................  
.................... #include <debug.c> 
.................... // file debug.c 
....................  
.................... #include <eeprom.c> 
.................... #byte INTCON=0xFF2 //Change for a 16 chip  
.................... #bit INT_GIE=INTCON.7  
....................  
....................  
.................... void write_int16_eeprom(int16 address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
06318:  MOVLB  7
0631A:  CLRF   x32
0631C:  MOVF   x32,W
0631E:  SUBLW  01
06320:  BNC   6382
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
06322:  MOVF   x32,W
06324:  ADDWF  x2E,W
06326:  MOVWF  x33
06328:  MOVLW  00
0632A:  ADDWFC x2F,W
0632C:  MOVWF  x34
0632E:  MOVLW  07
06330:  MOVWF  x36
06332:  MOVLW  30
06334:  MOVWF  x35
06336:  MOVF   x32,W
06338:  ADDWF  x35,W
0633A:  MOVWF  01
0633C:  MOVLW  00
0633E:  ADDWFC x36,W
06340:  MOVWF  03
06342:  MOVF   01,W
06344:  MOVWF  FE9
06346:  MOVFF  03,FEA
0634A:  MOVFF  FEF,735
0634E:  MOVFF  734,FAA
06352:  MOVFF  733,FA9
06356:  MOVFF  735,FA8
0635A:  BCF    FA6.6
0635C:  BCF    FA6.7
0635E:  BSF    FA6.2
06360:  MOVF   FF2,W
06362:  MOVWF  00
06364:  BCF    FF2.7
06366:  MOVLB  F
06368:  MOVLW  55
0636A:  MOVWF  FA7
0636C:  MOVLW  AA
0636E:  MOVWF  FA7
06370:  BSF    FA6.1
06372:  BTFSC  FA6.1
06374:  BRA    6372
06376:  BCF    FA6.2
06378:  MOVF   00,W
0637A:  IORWF  FF2,F
....................    } 
0637C:  MOVLB  7
0637E:  INCF   x32,F
06380:  BRA    631C
.................... } 
06382:  MOVLB  0
06384:  GOTO   63D8 (RETURN)
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(int16 address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
*
0624A:  MOVLB  6
0624C:  CLRF   xE9
0624E:  MOVF   xE9,W
06250:  SUBLW  01
06252:  BNC   629C
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
06254:  MOVLW  06
06256:  MOVWF  xED
06258:  MOVLW  EA
0625A:  MOVWF  xEC
0625C:  MOVF   xE9,W
0625E:  ADDWF  xEC,W
06260:  MOVWF  01
06262:  MOVLW  00
06264:  ADDWFC xED,W
06266:  MOVWF  03
06268:  MOVF   01,W
0626A:  MOVWF  FE9
0626C:  MOVFF  03,FEA
06270:  MOVF   xE9,W
06272:  ADDWF  xE7,W
06274:  MOVWF  xEE
06276:  MOVLW  00
06278:  ADDWFC xE8,W
0627A:  MOVWF  xEF
0627C:  MOVFF  FF2,6F0
06280:  BCF    FF2.7
06282:  MOVFF  6EF,FAA
06286:  MOVFF  6EE,FA9
0628A:  BCF    FA6.6
0628C:  BCF    FA6.7
0628E:  BSF    FA6.0
06290:  MOVF   FA8,W
06292:  BTFSC  xF0.7
06294:  BSF    FF2.7
06296:  MOVWF  FEF
....................    } 
06298:  INCF   xE9,F
0629A:  BRA    624E
....................  
....................    return(data); 
0629C:  MOVFF  6EA,01
062A0:  MOVFF  6EB,02
.................... } 
062A4:  MOVLB  0
062A6:  GOTO   62F4 (RETURN)
....................  
....................  
.................... void INTEEPROM_GET(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
062AA:  MOVLB  6
062AC:  BCF    xE2.0
062AE:  BTFSC  FF2.7
062B0:  BSF    xE2.0
....................    for (count=0;count<num;count++)  
062B2:  CLRF   xE1
062B4:  CLRF   xE0
062B6:  MOVF   xE1,W
062B8:  SUBWF  xDD,W
062BA:  BNC   6312
062BC:  BNZ   62C4
062BE:  MOVF   xDC,W
062C0:  SUBWF  xE0,W
062C2:  BC    6312
....................    {  
....................       disable_interrupts(global);  
062C4:  BCF    FF2.6
062C6:  BCF    FF2.7
062C8:  BTFSC  FF2.7
062CA:  BRA    62C6
....................       ptr[count]=read_int16_eeprom(addr+count);  
062CC:  MOVF   xDA,W
062CE:  ADDWF  xE0,W
062D0:  MOVWF  01
062D2:  MOVF   xDB,W
062D4:  ADDWFC xE1,W
062D6:  MOVWF  03
062D8:  MOVFF  01,6E3
062DC:  MOVWF  xE4
062DE:  MOVF   xE0,W
062E0:  ADDWF  xDE,W
062E2:  MOVWF  xE5
062E4:  MOVF   xE1,W
062E6:  ADDWFC xDF,W
062E8:  MOVWF  xE6
062EA:  MOVWF  xE8
062EC:  MOVFF  6E5,6E7
062F0:  MOVLB  0
062F2:  BRA    624A
062F4:  MOVFF  6E4,FEA
062F8:  MOVFF  6E3,FE9
062FC:  MOVFF  01,FEF
....................       if (int_enabled) enable_interrupts(global);  
06300:  MOVLB  6
06302:  BTFSS  xE2.0
06304:  BRA    630A
06306:  MOVLW  C0
06308:  IORWF  FF2,F
....................    }  
0630A:  INCF   xE0,F
0630C:  BTFSC  FD8.2
0630E:  INCF   xE1,F
06310:  BRA    62B6
.................... }  
06312:  MOVLB  0
06314:  GOTO   67EE (RETURN)
....................  
.................... void INTEEPROM_PUT(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
*
06388:  MOVLB  7
0638A:  BCF    x2A.0
0638C:  BTFSC  FF2.7
0638E:  BSF    x2A.0
....................    for (count=0;count<num;count++)  
06390:  CLRF   x29
06392:  CLRF   x28
06394:  MOVF   x29,W
06396:  SUBWF  x25,W
06398:  BNC   63F4
0639A:  BNZ   63A2
0639C:  MOVF   x24,W
0639E:  SUBWF  x28,W
063A0:  BC    63F4
....................    {  
....................       disable_interrupts(global);  
063A2:  BCF    FF2.6
063A4:  BCF    FF2.7
063A6:  BTFSC  FF2.7
063A8:  BRA    63A4
....................       //WRITE_EEPROM  
.................... 		write_int16_eeprom(addr+count,ptr[count]); 
063AA:  MOVF   x28,W
063AC:  ADDWF  x26,W
063AE:  MOVWF  x2B
063B0:  MOVF   x29,W
063B2:  ADDWFC x27,W
063B4:  MOVWF  x2C
063B6:  MOVF   x22,W
063B8:  ADDWF  x28,W
063BA:  MOVWF  FE9
063BC:  MOVF   x23,W
063BE:  ADDWFC x29,W
063C0:  MOVWF  FEA
063C2:  MOVFF  FEF,72D
063C6:  MOVFF  72C,72F
063CA:  MOVFF  72B,72E
063CE:  CLRF   x31
063D0:  MOVFF  72D,730
063D4:  MOVLB  0
063D6:  BRA    6318
.................... 		delay_ms(3); 
063D8:  MOVLW  03
063DA:  MOVLB  7
063DC:  MOVWF  x2B
063DE:  MOVLB  0
063E0:  RCALL  5FEA
....................       if (int_enabled) enable_interrupts(global);  
063E2:  MOVLB  7
063E4:  BTFSS  x2A.0
063E6:  BRA    63EC
063E8:  MOVLW  C0
063EA:  IORWF  FF2,F
....................    } 
063EC:  INCF   x28,F
063EE:  BTFSC  FD8.2
063F0:  INCF   x29,F
063F2:  BRA    6394
.................... }  
063F4:  MOVLB  0
063F6:  RETURN 0
....................  
....................  
.................... void INTEEPROM_GET8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled=INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       ptr[count]=read_eeprom(addr+count);  
....................       if (int_enabled) enable_interrupts(global);  
....................    }  
.................... }  
....................  
.................... void INTEEPROM_PUT8(int *ptr,int16 num,int16 addr) {  
....................    int16 count;  
....................    int1 int_enabled;  
....................    int_enabled= INT_GIE;  
....................    for (count=0;count<num;count++)  
....................    {  
....................       disable_interrupts(global);  
....................       //WRITE_EEPROM  
.................... 		write_eeprom(addr+count,ptr[count]); 
.................... 		delay_ms(3); 
....................       if (int_enabled) enable_interrupts(global);  
....................    } 
.................... }  
....................  
.................... void default_addr() 
.................... { 
.................... 	WRITE_CONFIG_ADDRESS(0, PREGAIN_CH1);     	// PREGAIN_CH1 
*
03252:  MOVLB  6
03254:  CLRF   xD9
03256:  CLRF   xD8
03258:  MOVLW  03
0325A:  MOVWF  xDB
0325C:  MOVLW  73
0325E:  MOVWF  xDA
03260:  MOVLB  0
03262:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(1, PREGAIN_MUTE_CH1);  // PREGAIN_MUTE_CH1 
03264:  MOVLB  6
03266:  CLRF   xD9
03268:  MOVLW  01
0326A:  MOVWF  xD8
0326C:  MOVLW  04
0326E:  MOVWF  xDB
03270:  MOVLW  43
03272:  MOVWF  xDA
03274:  MOVLB  0
03276:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(2, PREGAIN_CH2);     	// PREGAIN_CH2 
03278:  MOVLB  6
0327A:  CLRF   xD9
0327C:  MOVLW  02
0327E:  MOVWF  xD8
03280:  MOVLW  03
03282:  MOVWF  xDB
03284:  MOVLW  CF
03286:  MOVWF  xDA
03288:  MOVLB  0
0328A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(3, PREGAIN_MUTE_CH2);  // PREGAIN_MUTE_CH2 
0328C:  MOVLB  6
0328E:  CLRF   xD9
03290:  MOVLW  03
03292:  MOVWF  xD8
03294:  MOVLW  04
03296:  MOVWF  xDB
03298:  MOVLW  41
0329A:  MOVWF  xDA
0329C:  MOVLB  0
0329E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(4, PREGAIN_CH3);     	// PREGAIN_CH3 
032A0:  MOVLB  6
032A2:  CLRF   xD9
032A4:  MOVLW  04
032A6:  MOVWF  xD8
032A8:  MOVLW  03
032AA:  MOVWF  xDB
032AC:  MOVLW  CB
032AE:  MOVWF  xDA
032B0:  MOVLB  0
032B2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(5, PREGAIN_MUTE_CH3);  // PREGAIN_MUTE_CH3 
032B4:  MOVLB  6
032B6:  CLRF   xD9
032B8:  MOVLW  05
032BA:  MOVWF  xD8
032BC:  MOVLW  04
032BE:  MOVWF  xDB
032C0:  MOVLW  3F
032C2:  MOVWF  xDA
032C4:  MOVLB  0
032C6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(6, PREGAIN_CH4);     	// PREGAIN_CH4 
032C8:  MOVLB  6
032CA:  CLRF   xD9
032CC:  MOVLW  06
032CE:  MOVWF  xD8
032D0:  MOVLW  03
032D2:  MOVWF  xDB
032D4:  MOVLW  C7
032D6:  MOVWF  xDA
032D8:  MOVLB  0
032DA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(7, PREGAIN_MUTE_CH4);  // PREGAIN_MUTE_CH4 
032DC:  MOVLB  6
032DE:  CLRF   xD9
032E0:  MOVLW  07
032E2:  MOVWF  xD8
032E4:  MOVLW  04
032E6:  MOVWF  xDB
032E8:  MOVLW  3D
032EA:  MOVWF  xDA
032EC:  MOVLB  0
032EE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(8, PREGAIN_CH5);     	// PREGAIN_CH5 
032F0:  MOVLB  6
032F2:  CLRF   xD9
032F4:  MOVLW  08
032F6:  MOVWF  xD8
032F8:  MOVLW  03
032FA:  MOVWF  xDB
032FC:  MOVLW  C3
032FE:  MOVWF  xDA
03300:  MOVLB  0
03302:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(9, PREGAIN_MUTE_CH5);  // PREGAIN_MUTE_CH5 
03304:  MOVLB  6
03306:  CLRF   xD9
03308:  MOVLW  09
0330A:  MOVWF  xD8
0330C:  MOVLW  04
0330E:  MOVWF  xDB
03310:  MOVLW  3B
03312:  MOVWF  xDA
03314:  MOVLB  0
03316:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(10, PREGAIN_CH6);     	// PREGAIN_CH6 
03318:  MOVLB  6
0331A:  CLRF   xD9
0331C:  MOVLW  0A
0331E:  MOVWF  xD8
03320:  MOVLW  03
03322:  MOVWF  xDB
03324:  MOVLW  BF
03326:  MOVWF  xDA
03328:  MOVLB  0
0332A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(11, PREGAIN_MUTE_CH6); // PREGAIN_MUTE_CH6 
0332C:  MOVLB  6
0332E:  CLRF   xD9
03330:  MOVLW  0B
03332:  MOVWF  xD8
03334:  MOVLW  04
03336:  MOVWF  xDB
03338:  MOVLW  39
0333A:  MOVWF  xDA
0333C:  MOVLB  0
0333E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(12, PREGAIN_CH7);     	// PREGAIN_CH7 
03340:  MOVLB  6
03342:  CLRF   xD9
03344:  MOVLW  0C
03346:  MOVWF  xD8
03348:  MOVLW  03
0334A:  MOVWF  xDB
0334C:  MOVLW  BB
0334E:  MOVWF  xDA
03350:  MOVLB  0
03352:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(13, PREGAIN_MUTE_CH7); // PREGAIN_MUTE_CH7 
03354:  MOVLB  6
03356:  CLRF   xD9
03358:  MOVLW  0D
0335A:  MOVWF  xD8
0335C:  MOVLW  04
0335E:  MOVWF  xDB
03360:  MOVLW  37
03362:  MOVWF  xDA
03364:  MOVLB  0
03366:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(14, PREGAIN_CH8);     	// PREGAIN_CH8 
03368:  MOVLB  6
0336A:  CLRF   xD9
0336C:  MOVLW  0E
0336E:  MOVWF  xD8
03370:  MOVLW  03
03372:  MOVWF  xDB
03374:  MOVLW  B7
03376:  MOVWF  xDA
03378:  MOVLB  0
0337A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(15, PREGAIN_MUTE_CH8); // PREGAIN_MUTE_CH8 
0337C:  MOVLB  6
0337E:  CLRF   xD9
03380:  MOVLW  0F
03382:  MOVWF  xD8
03384:  MOVLW  04
03386:  MOVWF  xDB
03388:  MOVLW  35
0338A:  MOVWF  xDA
0338C:  MOVLB  0
0338E:  RCALL  3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(16, PREMIX_CH1);     	// PREMIX_CH1 
03390:  MOVLB  6
03392:  CLRF   xD9
03394:  MOVLW  10
03396:  MOVWF  xD8
03398:  MOVLW  03
0339A:  MOVWF  xDB
0339C:  MOVLW  B3
0339E:  MOVWF  xDA
033A0:  MOVLB  0
033A2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(17, PREMIX_MUTE_CH1);  // PREMIX_MUTE_CH1 
033A4:  MOVLB  6
033A6:  CLRF   xD9
033A8:  MOVLW  11
033AA:  MOVWF  xD8
033AC:  MOVLW  04
033AE:  MOVWF  xDB
033B0:  MOVLW  33
033B2:  MOVWF  xDA
033B4:  MOVLB  0
033B6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(18, PREMIX_CH2);     	// PREMIX_CH2 
033B8:  MOVLB  6
033BA:  CLRF   xD9
033BC:  MOVLW  12
033BE:  MOVWF  xD8
033C0:  MOVLW  03
033C2:  MOVWF  xDB
033C4:  MOVLW  AF
033C6:  MOVWF  xDA
033C8:  MOVLB  0
033CA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(19, PREMIX_MUTE_CH2);  // PREMIX_MUTE_CH2 
033CC:  MOVLB  6
033CE:  CLRF   xD9
033D0:  MOVLW  13
033D2:  MOVWF  xD8
033D4:  MOVLW  04
033D6:  MOVWF  xDB
033D8:  MOVLW  31
033DA:  MOVWF  xDA
033DC:  MOVLB  0
033DE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(20, PREMIX_CH3);     	// PREMIX_CH3 
033E0:  MOVLB  6
033E2:  CLRF   xD9
033E4:  MOVLW  14
033E6:  MOVWF  xD8
033E8:  MOVLW  03
033EA:  MOVWF  xDB
033EC:  MOVLW  AB
033EE:  MOVWF  xDA
033F0:  MOVLB  0
033F2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(21, PREMIX_MUTE_CH3);  // PREMIX_MUTE_CH3 
033F4:  MOVLB  6
033F6:  CLRF   xD9
033F8:  MOVLW  15
033FA:  MOVWF  xD8
033FC:  MOVLW  04
033FE:  MOVWF  xDB
03400:  MOVLW  2F
03402:  MOVWF  xDA
03404:  MOVLB  0
03406:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(22, PREMIX_CH4);     	// PREMIX_CH4 
03408:  MOVLB  6
0340A:  CLRF   xD9
0340C:  MOVLW  16
0340E:  MOVWF  xD8
03410:  MOVLW  03
03412:  MOVWF  xDB
03414:  MOVLW  A7
03416:  MOVWF  xDA
03418:  MOVLB  0
0341A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(23, PREMIX_MUTE_CH4);  // PREMIX_MUTE_CH4 
0341C:  MOVLB  6
0341E:  CLRF   xD9
03420:  MOVLW  17
03422:  MOVWF  xD8
03424:  MOVLW  04
03426:  MOVWF  xDB
03428:  MOVLW  2D
0342A:  MOVWF  xDA
0342C:  MOVLB  0
0342E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(24, PREMIX_CH5);     	// PREMIX_CH5 
03430:  MOVLB  6
03432:  CLRF   xD9
03434:  MOVLW  18
03436:  MOVWF  xD8
03438:  MOVLW  03
0343A:  MOVWF  xDB
0343C:  MOVLW  A3
0343E:  MOVWF  xDA
03440:  MOVLB  0
03442:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(25, PREMIX_MUTE_CH5);  // PREMIX_MUTE_CH5 
03444:  MOVLB  6
03446:  CLRF   xD9
03448:  MOVLW  19
0344A:  MOVWF  xD8
0344C:  MOVLW  04
0344E:  MOVWF  xDB
03450:  MOVLW  2B
03452:  MOVWF  xDA
03454:  MOVLB  0
03456:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(26, PREMIX_CH6);     	// PREMIX_CH6 
03458:  MOVLB  6
0345A:  CLRF   xD9
0345C:  MOVLW  1A
0345E:  MOVWF  xD8
03460:  MOVLW  03
03462:  MOVWF  xDB
03464:  MOVLW  9F
03466:  MOVWF  xDA
03468:  MOVLB  0
0346A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(27, PREMIX_MUTE_CH6);  // PREMIX_MUTE_CH6 
0346C:  MOVLB  6
0346E:  CLRF   xD9
03470:  MOVLW  1B
03472:  MOVWF  xD8
03474:  MOVLW  04
03476:  MOVWF  xDB
03478:  MOVLW  29
0347A:  MOVWF  xDA
0347C:  MOVLB  0
0347E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(28, PREMIX_CH7);     	// PREMIX_CH7 
03480:  MOVLB  6
03482:  CLRF   xD9
03484:  MOVLW  1C
03486:  MOVWF  xD8
03488:  MOVLW  03
0348A:  MOVWF  xDB
0348C:  MOVLW  9B
0348E:  MOVWF  xDA
03490:  MOVLB  0
03492:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(29, PREMIX_MUTE_CH7);  // PREMIX_MUTE_CH7 
03494:  MOVLB  6
03496:  CLRF   xD9
03498:  MOVLW  1D
0349A:  MOVWF  xD8
0349C:  MOVLW  04
0349E:  MOVWF  xDB
034A0:  MOVLW  27
034A2:  MOVWF  xDA
034A4:  MOVLB  0
034A6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(30, PREMIX_CH8);     	// PREMIX_CH8 
034A8:  MOVLB  6
034AA:  CLRF   xD9
034AC:  MOVLW  1E
034AE:  MOVWF  xD8
034B0:  MOVLW  03
034B2:  MOVWF  xDB
034B4:  MOVLW  97
034B6:  MOVWF  xDA
034B8:  MOVLB  0
034BA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(31, PREMIX_MUTE_CH8);  // PREMIX_MUTE_CH8 
034BC:  MOVLB  6
034BE:  CLRF   xD9
034C0:  MOVLW  1F
034C2:  MOVWF  xD8
034C4:  MOVLW  04
034C6:  MOVWF  xDB
034C8:  MOVLW  25
034CA:  MOVWF  xDA
034CC:  MOVLB  0
034CE:  RCALL  3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(32, TRIM_CH1);     	// TRIM_CH1 
034D0:  MOVLB  6
034D2:  CLRF   xD9
034D4:  MOVLW  20
034D6:  MOVWF  xD8
034D8:  MOVLW  03
034DA:  MOVWF  xDB
034DC:  MOVLW  93
034DE:  MOVWF  xDA
034E0:  MOVLB  0
034E2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(33, TRIM_MUTE_CH1);    // TRIM_MUTE_CH1 
034E4:  MOVLB  6
034E6:  CLRF   xD9
034E8:  MOVLW  21
034EA:  MOVWF  xD8
034EC:  MOVLW  04
034EE:  MOVWF  xDB
034F0:  MOVLW  23
034F2:  MOVWF  xDA
034F4:  MOVLB  0
034F6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(34, TRIM_CH2);     	// TRIM_CH2 
034F8:  MOVLB  6
034FA:  CLRF   xD9
034FC:  MOVLW  22
034FE:  MOVWF  xD8
03500:  MOVLW  03
03502:  MOVWF  xDB
03504:  MOVLW  8F
03506:  MOVWF  xDA
03508:  MOVLB  0
0350A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(35, TRIM_MUTE_CH2);    // TRIM_MUTE_CH2 
0350C:  MOVLB  6
0350E:  CLRF   xD9
03510:  MOVLW  23
03512:  MOVWF  xD8
03514:  MOVLW  04
03516:  MOVWF  xDB
03518:  MOVLW  21
0351A:  MOVWF  xDA
0351C:  MOVLB  0
0351E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(36, TRIM_CH3);     	// TRIM_CH3 
03520:  MOVLB  6
03522:  CLRF   xD9
03524:  MOVLW  24
03526:  MOVWF  xD8
03528:  MOVLW  03
0352A:  MOVWF  xDB
0352C:  MOVLW  8B
0352E:  MOVWF  xDA
03530:  MOVLB  0
03532:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(37, TRIM_MUTE_CH3);    // TRIM_MUTE_CH3 
03534:  MOVLB  6
03536:  CLRF   xD9
03538:  MOVLW  25
0353A:  MOVWF  xD8
0353C:  MOVLW  04
0353E:  MOVWF  xDB
03540:  MOVLW  1F
03542:  MOVWF  xDA
03544:  MOVLB  0
03546:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(38, TRIM_CH4);     	// TRIM_CH4 
03548:  MOVLB  6
0354A:  CLRF   xD9
0354C:  MOVLW  26
0354E:  MOVWF  xD8
03550:  MOVLW  03
03552:  MOVWF  xDB
03554:  MOVLW  87
03556:  MOVWF  xDA
03558:  MOVLB  0
0355A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(39, TRIM_MUTE_CH4);     // TRIM_MUTE_CH4 
0355C:  MOVLB  6
0355E:  CLRF   xD9
03560:  MOVLW  27
03562:  MOVWF  xD8
03564:  MOVLW  04
03566:  MOVWF  xDB
03568:  MOVLW  1D
0356A:  MOVWF  xDA
0356C:  MOVLB  0
0356E:  RCALL  3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(40, OUTPUTGAIN_CH1);     // OUTPUTGAIN_CH1 
03570:  MOVLB  6
03572:  CLRF   xD9
03574:  MOVLW  28
03576:  MOVWF  xD8
03578:  MOVLW  03
0357A:  MOVWF  xDB
0357C:  MOVLW  83
0357E:  MOVWF  xDA
03580:  MOVLB  0
03582:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(41, OUTPUT_MUTE_CH1);     // OUTPUT_MUTE_CH1 
03584:  MOVLB  6
03586:  CLRF   xD9
03588:  MOVLW  29
0358A:  MOVWF  xD8
0358C:  MOVLW  04
0358E:  MOVWF  xDB
03590:  MOVLW  1B
03592:  MOVWF  xDA
03594:  MOVLB  0
03596:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(42, OUTPUTGAIN_CH2);     // OUTPUTGAIN_CH2 
03598:  MOVLB  6
0359A:  CLRF   xD9
0359C:  MOVLW  2A
0359E:  MOVWF  xD8
035A0:  MOVLW  03
035A2:  MOVWF  xDB
035A4:  MOVLW  7F
035A6:  MOVWF  xDA
035A8:  MOVLB  0
035AA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(43, OUTPUT_MUTE_CH2);     // OUTPUT_MUTE_CH2 
035AC:  MOVLB  6
035AE:  CLRF   xD9
035B0:  MOVLW  2B
035B2:  MOVWF  xD8
035B4:  MOVLW  04
035B6:  MOVWF  xDB
035B8:  MOVLW  19
035BA:  MOVWF  xDA
035BC:  MOVLB  0
035BE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(44, OUTPUTGAIN_CH3);     // OUTPUTGAIN_CH3 
035C0:  MOVLB  6
035C2:  CLRF   xD9
035C4:  MOVLW  2C
035C6:  MOVWF  xD8
035C8:  MOVLW  03
035CA:  MOVWF  xDB
035CC:  MOVLW  7B
035CE:  MOVWF  xDA
035D0:  MOVLB  0
035D2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(45, OUTPUT_MUTE_CH3);     // OUTPUT_MUTE_CH3 
035D4:  MOVLB  6
035D6:  CLRF   xD9
035D8:  MOVLW  2D
035DA:  MOVWF  xD8
035DC:  MOVLW  04
035DE:  MOVWF  xDB
035E0:  MOVLW  17
035E2:  MOVWF  xDA
035E4:  MOVLB  0
035E6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(46, OUTPUTGAIN_CH4);     // OUTPUTGAIN_CH4 
035E8:  MOVLB  6
035EA:  CLRF   xD9
035EC:  MOVLW  2E
035EE:  MOVWF  xD8
035F0:  MOVLW  03
035F2:  MOVWF  xDB
035F4:  MOVLW  77
035F6:  MOVWF  xDA
035F8:  MOVLB  0
035FA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(47, OUTPUT_MUTE_CH4);     // OUTPUT_MUTE_CH4 
035FC:  MOVLB  6
035FE:  CLRF   xD9
03600:  MOVLW  2F
03602:  MOVWF  xD8
03604:  MOVLW  04
03606:  MOVWF  xDB
03608:  MOVLW  15
0360A:  MOVWF  xDA
0360C:  MOVLB  0
0360E:  RCALL  3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(48, INDUCKROUTER_SELECT0);     // INDUCKROUTER_SELECT0 
03610:  MOVLB  6
03612:  CLRF   xD9
03614:  MOVLW  30
03616:  MOVWF  xD8
03618:  MOVLW  02
0361A:  MOVWF  xDB
0361C:  MOVLW  0E
0361E:  MOVWF  xDA
03620:  MOVLB  0
03622:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(49, INDUCKROUTER_SELECT1);     // INDUCKROUTER_SELECT1 
03624:  MOVLB  6
03626:  CLRF   xD9
03628:  MOVLW  31
0362A:  MOVWF  xD8
0362C:  MOVLW  02
0362E:  MOVWF  xDB
03630:  MOVLW  0F
03632:  MOVWF  xDA
03634:  MOVLB  0
03636:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(50, INDUCKROUTER_SELECT2);     // INDUCKROUTER_SELECT2 
03638:  MOVLB  6
0363A:  CLRF   xD9
0363C:  MOVLW  32
0363E:  MOVWF  xD8
03640:  MOVLW  02
03642:  MOVWF  xDB
03644:  MOVLW  10
03646:  MOVWF  xDA
03648:  MOVLB  0
0364A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(51, INDUCKROUTER_SELECT3);     // INDUCKROUTER_SELECT3 
0364C:  MOVLB  6
0364E:  CLRF   xD9
03650:  MOVLW  33
03652:  MOVWF  xD8
03654:  MOVLW  02
03656:  MOVWF  xDB
03658:  MOVLW  11
0365A:  MOVWF  xDA
0365C:  MOVLB  0
0365E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(52, INDUCKROUTER_SELECT4);     // INDUCKROUTER_SELECT4 
03660:  MOVLB  6
03662:  CLRF   xD9
03664:  MOVLW  34
03666:  MOVWF  xD8
03668:  MOVLW  02
0366A:  MOVWF  xDB
0366C:  MOVLW  12
0366E:  MOVWF  xDA
03670:  MOVLB  0
03672:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(53, INDUCKROUTER_SELECT5);     // INDUCKROUTER_SELECT5 
03674:  MOVLB  6
03676:  CLRF   xD9
03678:  MOVLW  35
0367A:  MOVWF  xD8
0367C:  MOVLW  02
0367E:  MOVWF  xDB
03680:  MOVLW  13
03682:  MOVWF  xDA
03684:  MOVLB  0
03686:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(54, INDUCKROUTER_SELECT6);     // INDUCKROUTER_SELECT6 
03688:  MOVLB  6
0368A:  CLRF   xD9
0368C:  MOVLW  36
0368E:  MOVWF  xD8
03690:  MOVLW  02
03692:  MOVWF  xDB
03694:  MOVLW  14
03696:  MOVWF  xDA
03698:  MOVLB  0
0369A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(55, INDUCKROUTER_SELECT7);     // INDUCKROUTER_SELECT7 
0369C:  MOVLB  6
0369E:  CLRF   xD9
036A0:  MOVLW  37
036A2:  MOVWF  xD8
036A4:  MOVLW  02
036A6:  MOVWF  xDB
036A8:  MOVLW  15
036AA:  MOVWF  xDA
036AC:  MOVLB  0
036AE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(56, OUTDUCKROUTER_SELECT0);     // OUTDUCKROUTER_SELECT0 
036B0:  MOVLB  6
036B2:  CLRF   xD9
036B4:  MOVLW  38
036B6:  MOVWF  xD8
036B8:  MOVLW  02
036BA:  MOVWF  xDB
036BC:  MOVLW  05
036BE:  MOVWF  xDA
036C0:  MOVLB  0
036C2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(57, OUTDUCKROUTER_SELECT1);     // OUTDUCKROUTER_SELECT1 
036C4:  MOVLB  6
036C6:  CLRF   xD9
036C8:  MOVLW  39
036CA:  MOVWF  xD8
036CC:  MOVLW  02
036CE:  MOVWF  xDB
036D0:  MOVLW  06
036D2:  MOVWF  xDA
036D4:  MOVLB  0
036D6:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(58, OUTDUCKROUTER_SELECT2);     // OUTDUCKROUTER_SELECT2 
036D8:  MOVLB  6
036DA:  CLRF   xD9
036DC:  MOVLW  3A
036DE:  MOVWF  xD8
036E0:  MOVLW  02
036E2:  MOVWF  xDB
036E4:  MOVLW  07
036E6:  MOVWF  xDA
036E8:  MOVLB  0
036EA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(59, OUTDUCKROUTER_SELECT3);     // OUTDUCKROUTER_SELECT3 
036EC:  MOVLB  6
036EE:  CLRF   xD9
036F0:  MOVLW  3B
036F2:  MOVWF  xD8
036F4:  MOVLW  02
036F6:  MOVWF  xDB
036F8:  MOVLW  08
036FA:  MOVWF  xDA
036FC:  MOVLB  0
036FE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(60, OUTDUCKROUTER_SELECT4);     // OUTDUCKROUTER_SELECT4 
03700:  MOVLB  6
03702:  CLRF   xD9
03704:  MOVLW  3C
03706:  MOVWF  xD8
03708:  MOVLW  02
0370A:  MOVWF  xDB
0370C:  MOVLW  09
0370E:  MOVWF  xDA
03710:  MOVLB  0
03712:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(61, OUTDUCKROUTER_SELECT5);     // OUTDUCKROUTER_SELECT5 
03714:  MOVLB  6
03716:  CLRF   xD9
03718:  MOVLW  3D
0371A:  MOVWF  xD8
0371C:  MOVLW  02
0371E:  MOVWF  xDB
03720:  MOVLW  0A
03722:  MOVWF  xDA
03724:  MOVLB  0
03726:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(62, OUTDUCKROUTER_SELECT6);     // OUTDUCKROUTER_SELECT6 
03728:  MOVLB  6
0372A:  CLRF   xD9
0372C:  MOVLW  3E
0372E:  MOVWF  xD8
03730:  MOVLW  02
03732:  MOVWF  xDB
03734:  MOVLW  0B
03736:  MOVWF  xDA
03738:  MOVLB  0
0373A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(63, OUTDUCKROUTER_SELECT7);     // OUTDUCKROUTER_SELECT7 
0373C:  MOVLB  6
0373E:  CLRF   xD9
03740:  MOVLW  3F
03742:  MOVWF  xD8
03744:  MOVLW  02
03746:  MOVWF  xDB
03748:  MOVLW  0C
0374A:  MOVWF  xDA
0374C:  MOVLB  0
0374E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(64, DUCKER_THRESHOLD);     // DUCKER_THRESHOLD 
03750:  MOVLB  6
03752:  CLRF   xD9
03754:  MOVLW  40
03756:  MOVWF  xD8
03758:  MOVLW  02
0375A:  MOVWF  xDB
0375C:  MOVLW  76
0375E:  MOVWF  xDA
03760:  MOVLB  0
03762:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(65, DUCKER_HOLD);     // DUCKER_HOLD 
03764:  MOVLB  6
03766:  CLRF   xD9
03768:  MOVLW  41
0376A:  MOVWF  xD8
0376C:  MOVLW  02
0376E:  MOVWF  xDB
03770:  MOVLW  77
03772:  MOVWF  xDA
03774:  MOVLB  0
03776:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(66, DUCKER_DEPTH);     // DUCKER_DEPTH 
03778:  MOVLB  6
0377A:  CLRF   xD9
0377C:  MOVLW  42
0377E:  MOVWF  xD8
03780:  MOVLW  02
03782:  MOVWF  xDB
03784:  MOVLW  78
03786:  MOVWF  xDA
03788:  MOVLB  0
0378A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(67, DUCKER_ATTACK);     // DUCKER_ATTACK 
0378C:  MOVLB  6
0378E:  CLRF   xD9
03790:  MOVLW  43
03792:  MOVWF  xD8
03794:  MOVLW  02
03796:  MOVWF  xDB
03798:  MOVLW  79
0379A:  MOVWF  xDA
0379C:  MOVLB  0
0379E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(68, DUCKER_RELEASE);     // DUCKER_RELEASE 
037A0:  MOVLB  6
037A2:  CLRF   xD9
037A4:  MOVLW  44
037A6:  MOVWF  xD8
037A8:  MOVLW  02
037AA:  MOVWF  xDB
037AC:  MOVLW  7A
037AE:  MOVWF  xDA
037B0:  MOVLB  0
037B2:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(69, DUCKER_BYPASS);     // DUCKER_BYPASS 
037B4:  MOVLB  6
037B6:  CLRF   xD9
037B8:  MOVLW  45
037BA:  MOVWF  xD8
037BC:  MOVLW  02
037BE:  MOVWF  xDB
037C0:  MOVLW  7B
037C2:  MOVWF  xDA
037C4:  MOVLB  0
037C6:  RCALL  3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(70, IN_1_1_FILTER_B0);     // IN_1_1_FILTER_B0 
037C8:  MOVLB  6
037CA:  CLRF   xD9
037CC:  MOVLW  46
037CE:  MOVWF  xD8
037D0:  MOVLW  03
037D2:  MOVWF  xDB
037D4:  MOVLW  6D
037D6:  MOVWF  xDA
037D8:  MOVLB  0
037DA:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(71, IN_1_1_FILTER_B1);     // IN_1_1_FILTER_B1 
037DC:  MOVLB  6
037DE:  CLRF   xD9
037E0:  MOVLW  47
037E2:  MOVWF  xD8
037E4:  MOVLW  03
037E6:  MOVWF  xDB
037E8:  MOVLW  6E
037EA:  MOVWF  xDA
037EC:  MOVLB  0
037EE:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(72, IN_1_1_FILTER_B2);     // IN_1_1_FILTER_B2 
037F0:  MOVLB  6
037F2:  CLRF   xD9
037F4:  MOVLW  48
037F6:  MOVWF  xD8
037F8:  MOVLW  03
037FA:  MOVWF  xDB
037FC:  MOVLW  6F
037FE:  MOVWF  xDA
03800:  MOVLB  0
03802:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(73, IN_1_1_FILTER_MINUSA1);     // IN_1_1_FILTER_MINUSA1 
03804:  MOVLB  6
03806:  CLRF   xD9
03808:  MOVLW  49
0380A:  MOVWF  xD8
0380C:  MOVLW  03
0380E:  MOVWF  xDB
03810:  MOVLW  70
03812:  MOVWF  xDA
03814:  MOVLB  0
03816:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(74, IN_1_1_FILTER_MINUSA2);     // IN_1_1_FILTER_MINUSA2 
03818:  MOVLB  6
0381A:  CLRF   xD9
0381C:  MOVLW  4A
0381E:  MOVWF  xD8
03820:  MOVLW  03
03822:  MOVWF  xDB
03824:  MOVLW  71
03826:  MOVWF  xDA
03828:  MOVLB  0
0382A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(75, IN_1_2_FILTER_B0);     // IN_1_2_FILTER_B0 
0382C:  MOVLB  6
0382E:  CLRF   xD9
03830:  MOVLW  4B
03832:  MOVWF  xD8
03834:  MOVLW  03
03836:  MOVWF  xDB
03838:  MOVLW  68
0383A:  MOVWF  xDA
0383C:  MOVLB  0
0383E:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(76, IN_1_2_FILTER_B1);     // IN_1_2_FILTER_B1 
03840:  MOVLB  6
03842:  CLRF   xD9
03844:  MOVLW  4C
03846:  MOVWF  xD8
03848:  MOVLW  03
0384A:  MOVWF  xDB
0384C:  MOVLW  69
0384E:  MOVWF  xDA
03850:  MOVLB  0
03852:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(77, IN_1_2_FILTER_B2);     // IN_1_2_FILTER_B2 
03854:  MOVLB  6
03856:  CLRF   xD9
03858:  MOVLW  4D
0385A:  MOVWF  xD8
0385C:  MOVLW  03
0385E:  MOVWF  xDB
03860:  MOVLW  6A
03862:  MOVWF  xDA
03864:  MOVLB  0
03866:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(78, IN_1_2_FILTER_MINUSA1);     // IN_1_2_FILTER_MINUSA1 
03868:  MOVLB  6
0386A:  CLRF   xD9
0386C:  MOVLW  4E
0386E:  MOVWF  xD8
03870:  MOVLW  03
03872:  MOVWF  xDB
03874:  MOVLW  6B
03876:  MOVWF  xDA
03878:  MOVLB  0
0387A:  RCALL  3080
.................... 	WRITE_CONFIG_ADDRESS(79, IN_1_2_FILTER_MINUSA2);     // IN_1_2_FILTER_MINUSA2 
0387C:  MOVLB  6
0387E:  CLRF   xD9
03880:  MOVLW  4F
03882:  MOVWF  xD8
03884:  MOVLW  03
03886:  MOVWF  xDB
03888:  MOVLW  6C
0388A:  MOVWF  xDA
0388C:  MOVLB  0
0388E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(80, IN_1_3_FILTER_B0);     // IN_1_3_FILTER_B0 
03892:  MOVLB  6
03894:  CLRF   xD9
03896:  MOVLW  50
03898:  MOVWF  xD8
0389A:  MOVLW  03
0389C:  MOVWF  xDB
0389E:  MOVLW  63
038A0:  MOVWF  xDA
038A2:  MOVLB  0
038A4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(81, IN_1_3_FILTER_B1);     // IN_1_3_FILTER_B1 
038A8:  MOVLB  6
038AA:  CLRF   xD9
038AC:  MOVLW  51
038AE:  MOVWF  xD8
038B0:  MOVLW  03
038B2:  MOVWF  xDB
038B4:  MOVLW  64
038B6:  MOVWF  xDA
038B8:  MOVLB  0
038BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(82, IN_1_3_FILTER_B2);     // IN_1_3_FILTER_B2 
038BE:  MOVLB  6
038C0:  CLRF   xD9
038C2:  MOVLW  52
038C4:  MOVWF  xD8
038C6:  MOVLW  03
038C8:  MOVWF  xDB
038CA:  MOVLW  65
038CC:  MOVWF  xDA
038CE:  MOVLB  0
038D0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(83, IN_1_3_FILTER_MINUSA1);     // IN_1_3_FILTER_MINUSA1 
038D4:  MOVLB  6
038D6:  CLRF   xD9
038D8:  MOVLW  53
038DA:  MOVWF  xD8
038DC:  MOVLW  03
038DE:  MOVWF  xDB
038E0:  MOVLW  66
038E2:  MOVWF  xDA
038E4:  MOVLB  0
038E6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(84, IN_1_3_FILTER_MINUSA2);     // IN_1_3_FILTER_MINUSA2 
038EA:  MOVLB  6
038EC:  CLRF   xD9
038EE:  MOVLW  54
038F0:  MOVWF  xD8
038F2:  MOVLW  03
038F4:  MOVWF  xDB
038F6:  MOVLW  67
038F8:  MOVWF  xDA
038FA:  MOVLB  0
038FC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(85, IN_2_1_FILTER_B0);     // IN_2_1_FILTER_B0 
03900:  MOVLB  6
03902:  CLRF   xD9
03904:  MOVLW  55
03906:  MOVWF  xD8
03908:  MOVLW  03
0390A:  MOVWF  xDB
0390C:  MOVLW  5E
0390E:  MOVWF  xDA
03910:  MOVLB  0
03912:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(86, IN_2_1_FILTER_B1);     // IN_2_1_FILTER_B1 
03916:  MOVLB  6
03918:  CLRF   xD9
0391A:  MOVLW  56
0391C:  MOVWF  xD8
0391E:  MOVLW  03
03920:  MOVWF  xDB
03922:  MOVLW  5F
03924:  MOVWF  xDA
03926:  MOVLB  0
03928:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(87, IN_2_1_FILTER_B2);     // IN_2_1_FILTER_B2 
0392C:  MOVLB  6
0392E:  CLRF   xD9
03930:  MOVLW  57
03932:  MOVWF  xD8
03934:  MOVLW  03
03936:  MOVWF  xDB
03938:  MOVLW  60
0393A:  MOVWF  xDA
0393C:  MOVLB  0
0393E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(88, IN_2_1_FILTER_MINUSA1);     // IN_2_1_FILTER_MINUSA1 
03942:  MOVLB  6
03944:  CLRF   xD9
03946:  MOVLW  58
03948:  MOVWF  xD8
0394A:  MOVLW  03
0394C:  MOVWF  xDB
0394E:  MOVLW  61
03950:  MOVWF  xDA
03952:  MOVLB  0
03954:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(89, IN_2_1_FILTER_MINUSA2);     // IN_2_1_FILTER_MINUSA2 
03958:  MOVLB  6
0395A:  CLRF   xD9
0395C:  MOVLW  59
0395E:  MOVWF  xD8
03960:  MOVLW  03
03962:  MOVWF  xDB
03964:  MOVLW  62
03966:  MOVWF  xDA
03968:  MOVLB  0
0396A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(90, IN_2_2_FILTER_B0);     // IN_2_2_FILTER_B0 
0396E:  MOVLB  6
03970:  CLRF   xD9
03972:  MOVLW  5A
03974:  MOVWF  xD8
03976:  MOVLW  03
03978:  MOVWF  xDB
0397A:  MOVLW  59
0397C:  MOVWF  xDA
0397E:  MOVLB  0
03980:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(91, IN_2_2_FILTER_B1);     // IN_2_2_FILTER_B1 
03984:  MOVLB  6
03986:  CLRF   xD9
03988:  MOVLW  5B
0398A:  MOVWF  xD8
0398C:  MOVLW  03
0398E:  MOVWF  xDB
03990:  MOVLW  5A
03992:  MOVWF  xDA
03994:  MOVLB  0
03996:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(92, IN_2_2_FILTER_B2);     // IN_2_2_FILTER_B2 
0399A:  MOVLB  6
0399C:  CLRF   xD9
0399E:  MOVLW  5C
039A0:  MOVWF  xD8
039A2:  MOVLW  03
039A4:  MOVWF  xDB
039A6:  MOVLW  5B
039A8:  MOVWF  xDA
039AA:  MOVLB  0
039AC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(93, IN_2_2_FILTER_MINUSA1);     // IN_2_2_FILTER_MINUSA1 
039B0:  MOVLB  6
039B2:  CLRF   xD9
039B4:  MOVLW  5D
039B6:  MOVWF  xD8
039B8:  MOVLW  03
039BA:  MOVWF  xDB
039BC:  MOVLW  5C
039BE:  MOVWF  xDA
039C0:  MOVLB  0
039C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(94, IN_2_2_FILTER_MINUSA2);     // IN_2_2_FILTER_MINUSA2 
039C6:  MOVLB  6
039C8:  CLRF   xD9
039CA:  MOVLW  5E
039CC:  MOVWF  xD8
039CE:  MOVLW  03
039D0:  MOVWF  xDB
039D2:  MOVLW  5D
039D4:  MOVWF  xDA
039D6:  MOVLB  0
039D8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(95, IN_2_3_FILTER_B0);     // IN_2_3_FILTER_B0 
039DC:  MOVLB  6
039DE:  CLRF   xD9
039E0:  MOVLW  5F
039E2:  MOVWF  xD8
039E4:  MOVLW  03
039E6:  MOVWF  xDB
039E8:  MOVLW  54
039EA:  MOVWF  xDA
039EC:  MOVLB  0
039EE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(96, IN_2_3_FILTER_B1);     // IN_2_3_FILTER_B1 
039F2:  MOVLB  6
039F4:  CLRF   xD9
039F6:  MOVLW  60
039F8:  MOVWF  xD8
039FA:  MOVLW  03
039FC:  MOVWF  xDB
039FE:  MOVLW  55
03A00:  MOVWF  xDA
03A02:  MOVLB  0
03A04:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(97, IN_2_3_FILTER_B2);     // IN_2_3_FILTER_B2 
03A08:  MOVLB  6
03A0A:  CLRF   xD9
03A0C:  MOVLW  61
03A0E:  MOVWF  xD8
03A10:  MOVLW  03
03A12:  MOVWF  xDB
03A14:  MOVLW  56
03A16:  MOVWF  xDA
03A18:  MOVLB  0
03A1A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(98, IN_2_3_FILTER_MINUSA1);     // IN_2_3_FILTER_MINUSA1 
03A1E:  MOVLB  6
03A20:  CLRF   xD9
03A22:  MOVLW  62
03A24:  MOVWF  xD8
03A26:  MOVLW  03
03A28:  MOVWF  xDB
03A2A:  MOVLW  57
03A2C:  MOVWF  xDA
03A2E:  MOVLB  0
03A30:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(99, IN_2_3_FILTER_MINUSA2);     // IN_2_3_FILTER_MINUSA2 
03A34:  MOVLB  6
03A36:  CLRF   xD9
03A38:  MOVLW  63
03A3A:  MOVWF  xD8
03A3C:  MOVLW  03
03A3E:  MOVWF  xDB
03A40:  MOVLW  58
03A42:  MOVWF  xDA
03A44:  MOVLB  0
03A46:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(100, IN_3_1_FILTER_B0);     // IN_3_1_FILTER_B0 
03A4A:  MOVLB  6
03A4C:  CLRF   xD9
03A4E:  MOVLW  64
03A50:  MOVWF  xD8
03A52:  MOVLW  03
03A54:  MOVWF  xDB
03A56:  MOVLW  4F
03A58:  MOVWF  xDA
03A5A:  MOVLB  0
03A5C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(101, IN_3_1_FILTER_B1);     // IN_3_1_FILTER_B1 
03A60:  MOVLB  6
03A62:  CLRF   xD9
03A64:  MOVLW  65
03A66:  MOVWF  xD8
03A68:  MOVLW  03
03A6A:  MOVWF  xDB
03A6C:  MOVLW  50
03A6E:  MOVWF  xDA
03A70:  MOVLB  0
03A72:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(102, IN_3_1_FILTER_B2);     // IN_3_1_FILTER_B2 
03A76:  MOVLB  6
03A78:  CLRF   xD9
03A7A:  MOVLW  66
03A7C:  MOVWF  xD8
03A7E:  MOVLW  03
03A80:  MOVWF  xDB
03A82:  MOVLW  51
03A84:  MOVWF  xDA
03A86:  MOVLB  0
03A88:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(103, IN_3_1_FILTER_MINUSA1);     // IN_3_1_FILTER_MINUSA1 
03A8C:  MOVLB  6
03A8E:  CLRF   xD9
03A90:  MOVLW  67
03A92:  MOVWF  xD8
03A94:  MOVLW  03
03A96:  MOVWF  xDB
03A98:  MOVLW  52
03A9A:  MOVWF  xDA
03A9C:  MOVLB  0
03A9E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(104, IN_3_1_FILTER_MINUSA2);     // IN_3_1_FILTER_MINUSA2 
03AA2:  MOVLB  6
03AA4:  CLRF   xD9
03AA6:  MOVLW  68
03AA8:  MOVWF  xD8
03AAA:  MOVLW  03
03AAC:  MOVWF  xDB
03AAE:  MOVLW  53
03AB0:  MOVWF  xDA
03AB2:  MOVLB  0
03AB4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(105, IN_3_2_FILTER_B0);     // IN_3_2_FILTER_B0 
03AB8:  MOVLB  6
03ABA:  CLRF   xD9
03ABC:  MOVLW  69
03ABE:  MOVWF  xD8
03AC0:  MOVLW  03
03AC2:  MOVWF  xDB
03AC4:  MOVLW  4A
03AC6:  MOVWF  xDA
03AC8:  MOVLB  0
03ACA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(106, IN_3_2_FILTER_B1);     // IN_3_2_FILTER_B1 
03ACE:  MOVLB  6
03AD0:  CLRF   xD9
03AD2:  MOVLW  6A
03AD4:  MOVWF  xD8
03AD6:  MOVLW  03
03AD8:  MOVWF  xDB
03ADA:  MOVLW  4B
03ADC:  MOVWF  xDA
03ADE:  MOVLB  0
03AE0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(107, IN_3_2_FILTER_B2);     // IN_3_2_FILTER_B2 
03AE4:  MOVLB  6
03AE6:  CLRF   xD9
03AE8:  MOVLW  6B
03AEA:  MOVWF  xD8
03AEC:  MOVLW  03
03AEE:  MOVWF  xDB
03AF0:  MOVLW  4C
03AF2:  MOVWF  xDA
03AF4:  MOVLB  0
03AF6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(108, IN_3_2_FILTER_MINUSA1);     // IN_3_2_FILTER_MINUSA1 
03AFA:  MOVLB  6
03AFC:  CLRF   xD9
03AFE:  MOVLW  6C
03B00:  MOVWF  xD8
03B02:  MOVLW  03
03B04:  MOVWF  xDB
03B06:  MOVLW  4D
03B08:  MOVWF  xDA
03B0A:  MOVLB  0
03B0C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(109, IN_3_2_FILTER_MINUSA2);     // IN_3_2_FILTER_MINUSA2 
03B10:  MOVLB  6
03B12:  CLRF   xD9
03B14:  MOVLW  6D
03B16:  MOVWF  xD8
03B18:  MOVLW  03
03B1A:  MOVWF  xDB
03B1C:  MOVLW  4E
03B1E:  MOVWF  xDA
03B20:  MOVLB  0
03B22:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(110, IN_3_3_FILTER_B0);     // IN_3_3_FILTER_B0 
03B26:  MOVLB  6
03B28:  CLRF   xD9
03B2A:  MOVLW  6E
03B2C:  MOVWF  xD8
03B2E:  MOVLW  03
03B30:  MOVWF  xDB
03B32:  MOVLW  45
03B34:  MOVWF  xDA
03B36:  MOVLB  0
03B38:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(111, IN_3_3_FILTER_B1);     // IN_3_3_FILTER_B1 
03B3C:  MOVLB  6
03B3E:  CLRF   xD9
03B40:  MOVLW  6F
03B42:  MOVWF  xD8
03B44:  MOVLW  03
03B46:  MOVWF  xDB
03B48:  MOVLW  46
03B4A:  MOVWF  xDA
03B4C:  MOVLB  0
03B4E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(112, IN_3_3_FILTER_B2);     // IN_3_3_FILTER_B2 
03B52:  MOVLB  6
03B54:  CLRF   xD9
03B56:  MOVLW  70
03B58:  MOVWF  xD8
03B5A:  MOVLW  03
03B5C:  MOVWF  xDB
03B5E:  MOVLW  47
03B60:  MOVWF  xDA
03B62:  MOVLB  0
03B64:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(113, IN_3_3_FILTER_MINUSA1);     // IN_3_3_FILTER_MINUSA1 
03B68:  MOVLB  6
03B6A:  CLRF   xD9
03B6C:  MOVLW  71
03B6E:  MOVWF  xD8
03B70:  MOVLW  03
03B72:  MOVWF  xDB
03B74:  MOVLW  48
03B76:  MOVWF  xDA
03B78:  MOVLB  0
03B7A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(114, IN_3_3_FILTER_MINUSA2);     // IN_3_3_FILTER_MINUSA2 
03B7E:  MOVLB  6
03B80:  CLRF   xD9
03B82:  MOVLW  72
03B84:  MOVWF  xD8
03B86:  MOVLW  03
03B88:  MOVWF  xDB
03B8A:  MOVLW  49
03B8C:  MOVWF  xDA
03B8E:  MOVLB  0
03B90:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(115, IN_4_1_FILTER_B0);     // IN_4_1_FILTER_B0 
03B94:  MOVLB  6
03B96:  CLRF   xD9
03B98:  MOVLW  73
03B9A:  MOVWF  xD8
03B9C:  MOVLW  03
03B9E:  MOVWF  xDB
03BA0:  MOVLW  40
03BA2:  MOVWF  xDA
03BA4:  MOVLB  0
03BA6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(116, IN_4_1_FILTER_B1);     // IN_4_1_FILTER_B1 
03BAA:  MOVLB  6
03BAC:  CLRF   xD9
03BAE:  MOVLW  74
03BB0:  MOVWF  xD8
03BB2:  MOVLW  03
03BB4:  MOVWF  xDB
03BB6:  MOVLW  41
03BB8:  MOVWF  xDA
03BBA:  MOVLB  0
03BBC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(117, IN_4_1_FILTER_B2);     // IN_4_1_FILTER_B2 
03BC0:  MOVLB  6
03BC2:  CLRF   xD9
03BC4:  MOVLW  75
03BC6:  MOVWF  xD8
03BC8:  MOVLW  03
03BCA:  MOVWF  xDB
03BCC:  MOVLW  42
03BCE:  MOVWF  xDA
03BD0:  MOVLB  0
03BD2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(118, IN_4_1_FILTER_MINUSA1);     // IN_4_1_FILTER_MINUSA1 
03BD6:  MOVLB  6
03BD8:  CLRF   xD9
03BDA:  MOVLW  76
03BDC:  MOVWF  xD8
03BDE:  MOVLW  03
03BE0:  MOVWF  xDB
03BE2:  MOVLW  43
03BE4:  MOVWF  xDA
03BE6:  MOVLB  0
03BE8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(119, IN_4_1_FILTER_MINUSA2);     // IN_4_1_FILTER_MINUSA2 
03BEC:  MOVLB  6
03BEE:  CLRF   xD9
03BF0:  MOVLW  77
03BF2:  MOVWF  xD8
03BF4:  MOVLW  03
03BF6:  MOVWF  xDB
03BF8:  MOVLW  44
03BFA:  MOVWF  xDA
03BFC:  MOVLB  0
03BFE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(120, IN_4_2_FILTER_B0);     // IN_4_2_FILTER_B0 
03C02:  MOVLB  6
03C04:  CLRF   xD9
03C06:  MOVLW  78
03C08:  MOVWF  xD8
03C0A:  MOVLW  03
03C0C:  MOVWF  xDB
03C0E:  MOVLW  3B
03C10:  MOVWF  xDA
03C12:  MOVLB  0
03C14:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(121, IN_4_2_FILTER_B1);     // IN_4_2_FILTER_B1 
03C18:  MOVLB  6
03C1A:  CLRF   xD9
03C1C:  MOVLW  79
03C1E:  MOVWF  xD8
03C20:  MOVLW  03
03C22:  MOVWF  xDB
03C24:  MOVLW  3C
03C26:  MOVWF  xDA
03C28:  MOVLB  0
03C2A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(122, IN_4_2_FILTER_B2);     // IN_4_2_FILTER_B2 
03C2E:  MOVLB  6
03C30:  CLRF   xD9
03C32:  MOVLW  7A
03C34:  MOVWF  xD8
03C36:  MOVLW  03
03C38:  MOVWF  xDB
03C3A:  MOVLW  3D
03C3C:  MOVWF  xDA
03C3E:  MOVLB  0
03C40:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(123, IN_4_2_FILTER_MINUSA1);     // IN_4_2_FILTER_MINUSA1 
03C44:  MOVLB  6
03C46:  CLRF   xD9
03C48:  MOVLW  7B
03C4A:  MOVWF  xD8
03C4C:  MOVLW  03
03C4E:  MOVWF  xDB
03C50:  MOVLW  3E
03C52:  MOVWF  xDA
03C54:  MOVLB  0
03C56:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(124, IN_4_2_FILTER_MINUSA2);     // IN_4_2_FILTER_MINUSA2 
03C5A:  MOVLB  6
03C5C:  CLRF   xD9
03C5E:  MOVLW  7C
03C60:  MOVWF  xD8
03C62:  MOVLW  03
03C64:  MOVWF  xDB
03C66:  MOVLW  3F
03C68:  MOVWF  xDA
03C6A:  MOVLB  0
03C6C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(125, IN_4_3_FILTER_B0);     // IN_4_3_FILTER_B0 
03C70:  MOVLB  6
03C72:  CLRF   xD9
03C74:  MOVLW  7D
03C76:  MOVWF  xD8
03C78:  MOVLW  03
03C7A:  MOVWF  xDB
03C7C:  MOVLW  36
03C7E:  MOVWF  xDA
03C80:  MOVLB  0
03C82:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(126, IN_4_3_FILTER_B1);     // IN_4_3_FILTER_B1 
03C86:  MOVLB  6
03C88:  CLRF   xD9
03C8A:  MOVLW  7E
03C8C:  MOVWF  xD8
03C8E:  MOVLW  03
03C90:  MOVWF  xDB
03C92:  MOVLW  37
03C94:  MOVWF  xDA
03C96:  MOVLB  0
03C98:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(127, IN_4_3_FILTER_B2);     // IN_4_3_FILTER_B2 
03C9C:  MOVLB  6
03C9E:  CLRF   xD9
03CA0:  MOVLW  7F
03CA2:  MOVWF  xD8
03CA4:  MOVLW  03
03CA6:  MOVWF  xDB
03CA8:  MOVLW  38
03CAA:  MOVWF  xDA
03CAC:  MOVLB  0
03CAE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(128, IN_4_3_FILTER_MINUSA1);     // IN_4_3_FILTER_MINUSA1 
03CB2:  MOVLB  6
03CB4:  CLRF   xD9
03CB6:  MOVLW  80
03CB8:  MOVWF  xD8
03CBA:  MOVLW  03
03CBC:  MOVWF  xDB
03CBE:  MOVLW  39
03CC0:  MOVWF  xDA
03CC2:  MOVLB  0
03CC4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(129, IN_4_3_FILTER_MINUSA2);     // IN_4_3_FILTER_MINUSA2 
03CC8:  MOVLB  6
03CCA:  CLRF   xD9
03CCC:  MOVLW  81
03CCE:  MOVWF  xD8
03CD0:  MOVLW  03
03CD2:  MOVWF  xDB
03CD4:  MOVLW  3A
03CD6:  MOVWF  xDA
03CD8:  MOVLB  0
03CDA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(130, IN_5_1_FILTER_B0);     // IN_5_1_FILTER_B0 
03CDE:  MOVLB  6
03CE0:  CLRF   xD9
03CE2:  MOVLW  82
03CE4:  MOVWF  xD8
03CE6:  MOVLW  03
03CE8:  MOVWF  xDB
03CEA:  MOVLW  31
03CEC:  MOVWF  xDA
03CEE:  MOVLB  0
03CF0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(131, IN_5_1_FILTER_B1);     // IN_5_1_FILTER_B1 
03CF4:  MOVLB  6
03CF6:  CLRF   xD9
03CF8:  MOVLW  83
03CFA:  MOVWF  xD8
03CFC:  MOVLW  03
03CFE:  MOVWF  xDB
03D00:  MOVLW  32
03D02:  MOVWF  xDA
03D04:  MOVLB  0
03D06:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(132, IN_5_1_FILTER_B2);     // IN_5_1_FILTER_B2 
03D0A:  MOVLB  6
03D0C:  CLRF   xD9
03D0E:  MOVLW  84
03D10:  MOVWF  xD8
03D12:  MOVLW  03
03D14:  MOVWF  xDB
03D16:  MOVLW  33
03D18:  MOVWF  xDA
03D1A:  MOVLB  0
03D1C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(133, IN_5_1_FILTER_MINUSA1);     // IN_5_1_FILTER_MINUSA1 
03D20:  MOVLB  6
03D22:  CLRF   xD9
03D24:  MOVLW  85
03D26:  MOVWF  xD8
03D28:  MOVLW  03
03D2A:  MOVWF  xDB
03D2C:  MOVLW  34
03D2E:  MOVWF  xDA
03D30:  MOVLB  0
03D32:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(134, IN_5_1_FILTER_MINUSA2);     // IN_5_1_FILTER_MINUSA2 
03D36:  MOVLB  6
03D38:  CLRF   xD9
03D3A:  MOVLW  86
03D3C:  MOVWF  xD8
03D3E:  MOVLW  03
03D40:  MOVWF  xDB
03D42:  MOVLW  35
03D44:  MOVWF  xDA
03D46:  MOVLB  0
03D48:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(135, IN_5_2_FILTER_B0);     // IN_5_2_FILTER_B0 
03D4C:  MOVLB  6
03D4E:  CLRF   xD9
03D50:  MOVLW  87
03D52:  MOVWF  xD8
03D54:  MOVLW  03
03D56:  MOVWF  xDB
03D58:  MOVLW  2C
03D5A:  MOVWF  xDA
03D5C:  MOVLB  0
03D5E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(136, IN_5_2_FILTER_B1);     // IN_5_2_FILTER_B1 
03D62:  MOVLB  6
03D64:  CLRF   xD9
03D66:  MOVLW  88
03D68:  MOVWF  xD8
03D6A:  MOVLW  03
03D6C:  MOVWF  xDB
03D6E:  MOVLW  2D
03D70:  MOVWF  xDA
03D72:  MOVLB  0
03D74:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(137, IN_5_2_FILTER_B2);     // IN_5_2_FILTER_B2 
03D78:  MOVLB  6
03D7A:  CLRF   xD9
03D7C:  MOVLW  89
03D7E:  MOVWF  xD8
03D80:  MOVLW  03
03D82:  MOVWF  xDB
03D84:  MOVLW  2E
03D86:  MOVWF  xDA
03D88:  MOVLB  0
03D8A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(138, IN_5_2_FILTER_MINUSA1);     // IN_5_2_FILTER_MINUSA1 
03D8E:  MOVLB  6
03D90:  CLRF   xD9
03D92:  MOVLW  8A
03D94:  MOVWF  xD8
03D96:  MOVLW  03
03D98:  MOVWF  xDB
03D9A:  MOVLW  2F
03D9C:  MOVWF  xDA
03D9E:  MOVLB  0
03DA0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(139, IN_5_2_FILTER_MINUSA2);     // IN_5_2_FILTER_MINUSA2 
03DA4:  MOVLB  6
03DA6:  CLRF   xD9
03DA8:  MOVLW  8B
03DAA:  MOVWF  xD8
03DAC:  MOVLW  03
03DAE:  MOVWF  xDB
03DB0:  MOVLW  30
03DB2:  MOVWF  xDA
03DB4:  MOVLB  0
03DB6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(140, IN_5_3_FILTER_B0);     // IN_5_3_FILTER_B0 
03DBA:  MOVLB  6
03DBC:  CLRF   xD9
03DBE:  MOVLW  8C
03DC0:  MOVWF  xD8
03DC2:  MOVLW  03
03DC4:  MOVWF  xDB
03DC6:  MOVLW  27
03DC8:  MOVWF  xDA
03DCA:  MOVLB  0
03DCC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(141, IN_5_3_FILTER_B1);     // IN_5_3_FILTER_B1 
03DD0:  MOVLB  6
03DD2:  CLRF   xD9
03DD4:  MOVLW  8D
03DD6:  MOVWF  xD8
03DD8:  MOVLW  03
03DDA:  MOVWF  xDB
03DDC:  MOVLW  28
03DDE:  MOVWF  xDA
03DE0:  MOVLB  0
03DE2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(142, IN_5_3_FILTER_B2);     // IN_5_3_FILTER_B2 
03DE6:  MOVLB  6
03DE8:  CLRF   xD9
03DEA:  MOVLW  8E
03DEC:  MOVWF  xD8
03DEE:  MOVLW  03
03DF0:  MOVWF  xDB
03DF2:  MOVLW  29
03DF4:  MOVWF  xDA
03DF6:  MOVLB  0
03DF8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(143, IN_5_3_FILTER_MINUSA1);     // IN_5_3_FILTER_MINUSA1 
03DFC:  MOVLB  6
03DFE:  CLRF   xD9
03E00:  MOVLW  8F
03E02:  MOVWF  xD8
03E04:  MOVLW  03
03E06:  MOVWF  xDB
03E08:  MOVLW  2A
03E0A:  MOVWF  xDA
03E0C:  MOVLB  0
03E0E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(144, IN_5_3_FILTER_MINUSA2);     // IN_5_3_FILTER_MINUSA2 
03E12:  MOVLB  6
03E14:  CLRF   xD9
03E16:  MOVLW  90
03E18:  MOVWF  xD8
03E1A:  MOVLW  03
03E1C:  MOVWF  xDB
03E1E:  MOVLW  2B
03E20:  MOVWF  xDA
03E22:  MOVLB  0
03E24:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(145, IN_6_1_FILTER_B0);     // IN_6_1_FILTER_B0 
03E28:  MOVLB  6
03E2A:  CLRF   xD9
03E2C:  MOVLW  91
03E2E:  MOVWF  xD8
03E30:  MOVLW  03
03E32:  MOVWF  xDB
03E34:  MOVLW  22
03E36:  MOVWF  xDA
03E38:  MOVLB  0
03E3A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(146, IN_6_1_FILTER_B1);     // IN_6_1_FILTER_B1 
03E3E:  MOVLB  6
03E40:  CLRF   xD9
03E42:  MOVLW  92
03E44:  MOVWF  xD8
03E46:  MOVLW  03
03E48:  MOVWF  xDB
03E4A:  MOVLW  23
03E4C:  MOVWF  xDA
03E4E:  MOVLB  0
03E50:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(147, IN_6_1_FILTER_B2);     // IN_6_1_FILTER_B2 
03E54:  MOVLB  6
03E56:  CLRF   xD9
03E58:  MOVLW  93
03E5A:  MOVWF  xD8
03E5C:  MOVLW  03
03E5E:  MOVWF  xDB
03E60:  MOVLW  24
03E62:  MOVWF  xDA
03E64:  MOVLB  0
03E66:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(148, IN_6_1_FILTER_MINUSA1);     // IN_6_1_FILTER_MINUSA1 
03E6A:  MOVLB  6
03E6C:  CLRF   xD9
03E6E:  MOVLW  94
03E70:  MOVWF  xD8
03E72:  MOVLW  03
03E74:  MOVWF  xDB
03E76:  MOVLW  25
03E78:  MOVWF  xDA
03E7A:  MOVLB  0
03E7C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(149, IN_6_1_FILTER_MINUSA2);     // IN_6_1_FILTER_MINUSA2 
03E80:  MOVLB  6
03E82:  CLRF   xD9
03E84:  MOVLW  95
03E86:  MOVWF  xD8
03E88:  MOVLW  03
03E8A:  MOVWF  xDB
03E8C:  MOVLW  26
03E8E:  MOVWF  xDA
03E90:  MOVLB  0
03E92:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(150, IN_6_2_FILTER_B0);     // IN_6_2_FILTER_B0 
03E96:  MOVLB  6
03E98:  CLRF   xD9
03E9A:  MOVLW  96
03E9C:  MOVWF  xD8
03E9E:  MOVLW  03
03EA0:  MOVWF  xDB
03EA2:  MOVLW  1D
03EA4:  MOVWF  xDA
03EA6:  MOVLB  0
03EA8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(151, IN_6_2_FILTER_B1);     // IN_6_2_FILTER_B1 
03EAC:  MOVLB  6
03EAE:  CLRF   xD9
03EB0:  MOVLW  97
03EB2:  MOVWF  xD8
03EB4:  MOVLW  03
03EB6:  MOVWF  xDB
03EB8:  MOVLW  1E
03EBA:  MOVWF  xDA
03EBC:  MOVLB  0
03EBE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(152, IN_6_2_FILTER_B2);     // IN_6_2_FILTER_B2 
03EC2:  MOVLB  6
03EC4:  CLRF   xD9
03EC6:  MOVLW  98
03EC8:  MOVWF  xD8
03ECA:  MOVLW  03
03ECC:  MOVWF  xDB
03ECE:  MOVLW  1F
03ED0:  MOVWF  xDA
03ED2:  MOVLB  0
03ED4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(153, IN_6_2_FILTER_MINUSA1);     // IN_6_2_FILTER_MINUSA1 
03ED8:  MOVLB  6
03EDA:  CLRF   xD9
03EDC:  MOVLW  99
03EDE:  MOVWF  xD8
03EE0:  MOVLW  03
03EE2:  MOVWF  xDB
03EE4:  MOVLW  20
03EE6:  MOVWF  xDA
03EE8:  MOVLB  0
03EEA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(154, IN_6_2_FILTER_MINUSA2);     // IN_6_2_FILTER_MINUSA2 
03EEE:  MOVLB  6
03EF0:  CLRF   xD9
03EF2:  MOVLW  9A
03EF4:  MOVWF  xD8
03EF6:  MOVLW  03
03EF8:  MOVWF  xDB
03EFA:  MOVLW  21
03EFC:  MOVWF  xDA
03EFE:  MOVLB  0
03F00:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(155, IN_6_3_FILTER_B0);     // IN_6_3_FILTER_B0 
03F04:  MOVLB  6
03F06:  CLRF   xD9
03F08:  MOVLW  9B
03F0A:  MOVWF  xD8
03F0C:  MOVLW  03
03F0E:  MOVWF  xDB
03F10:  MOVLW  18
03F12:  MOVWF  xDA
03F14:  MOVLB  0
03F16:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(156, IN_6_3_FILTER_B1);     // IN_6_3_FILTER_B1 
03F1A:  MOVLB  6
03F1C:  CLRF   xD9
03F1E:  MOVLW  9C
03F20:  MOVWF  xD8
03F22:  MOVLW  03
03F24:  MOVWF  xDB
03F26:  MOVLW  19
03F28:  MOVWF  xDA
03F2A:  MOVLB  0
03F2C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(157, IN_6_3_FILTER_B2);     // IN_6_3_FILTER_B2 
03F30:  MOVLB  6
03F32:  CLRF   xD9
03F34:  MOVLW  9D
03F36:  MOVWF  xD8
03F38:  MOVLW  03
03F3A:  MOVWF  xDB
03F3C:  MOVLW  1A
03F3E:  MOVWF  xDA
03F40:  MOVLB  0
03F42:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(158, IN_6_3_FILTER_MINUSA1);     // IN_6_3_FILTER_MINUSA1 
03F46:  MOVLB  6
03F48:  CLRF   xD9
03F4A:  MOVLW  9E
03F4C:  MOVWF  xD8
03F4E:  MOVLW  03
03F50:  MOVWF  xDB
03F52:  MOVLW  1B
03F54:  MOVWF  xDA
03F56:  MOVLB  0
03F58:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(159, IN_6_3_FILTER_MINUSA2);     // IN_6_3_FILTER_MINUSA2 
03F5C:  MOVLB  6
03F5E:  CLRF   xD9
03F60:  MOVLW  9F
03F62:  MOVWF  xD8
03F64:  MOVLW  03
03F66:  MOVWF  xDB
03F68:  MOVLW  1C
03F6A:  MOVWF  xDA
03F6C:  MOVLB  0
03F6E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(160, IN_7_1_FILTER_B0);     // IN_7_1_FILTER_B0 
03F72:  MOVLB  6
03F74:  CLRF   xD9
03F76:  MOVLW  A0
03F78:  MOVWF  xD8
03F7A:  MOVLW  03
03F7C:  MOVWF  xDB
03F7E:  MOVLW  13
03F80:  MOVWF  xDA
03F82:  MOVLB  0
03F84:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(161, IN_7_1_FILTER_B1);     // IN_7_1_FILTER_B1 
03F88:  MOVLB  6
03F8A:  CLRF   xD9
03F8C:  MOVLW  A1
03F8E:  MOVWF  xD8
03F90:  MOVLW  03
03F92:  MOVWF  xDB
03F94:  MOVLW  14
03F96:  MOVWF  xDA
03F98:  MOVLB  0
03F9A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(162, IN_7_1_FILTER_B2);     // IN_7_1_FILTER_B2 
03F9E:  MOVLB  6
03FA0:  CLRF   xD9
03FA2:  MOVLW  A2
03FA4:  MOVWF  xD8
03FA6:  MOVLW  03
03FA8:  MOVWF  xDB
03FAA:  MOVLW  15
03FAC:  MOVWF  xDA
03FAE:  MOVLB  0
03FB0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(163, IN_7_1_FILTER_MINUSA1);     // IN_7_1_FILTER_MINUSA1 
03FB4:  MOVLB  6
03FB6:  CLRF   xD9
03FB8:  MOVLW  A3
03FBA:  MOVWF  xD8
03FBC:  MOVLW  03
03FBE:  MOVWF  xDB
03FC0:  MOVLW  16
03FC2:  MOVWF  xDA
03FC4:  MOVLB  0
03FC6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(164, IN_7_1_FILTER_MINUSA2);     // IN_7_1_FILTER_MINUSA2 
03FCA:  MOVLB  6
03FCC:  CLRF   xD9
03FCE:  MOVLW  A4
03FD0:  MOVWF  xD8
03FD2:  MOVLW  03
03FD4:  MOVWF  xDB
03FD6:  MOVLW  17
03FD8:  MOVWF  xDA
03FDA:  MOVLB  0
03FDC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(165, IN_7_2_FILTER_B0);     // IN_7_2_FILTER_B0 
03FE0:  MOVLB  6
03FE2:  CLRF   xD9
03FE4:  MOVLW  A5
03FE6:  MOVWF  xD8
03FE8:  MOVLW  03
03FEA:  MOVWF  xDB
03FEC:  MOVLW  0E
03FEE:  MOVWF  xDA
03FF0:  MOVLB  0
03FF2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(166, IN_7_2_FILTER_B1);     // IN_7_2_FILTER_B1 
03FF6:  MOVLB  6
03FF8:  CLRF   xD9
03FFA:  MOVLW  A6
03FFC:  MOVWF  xD8
03FFE:  MOVLW  03
04000:  MOVWF  xDB
04002:  MOVLW  0F
04004:  MOVWF  xDA
04006:  MOVLB  0
04008:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(167, IN_7_2_FILTER_B2);     // IN_7_2_FILTER_B2 
0400C:  MOVLB  6
0400E:  CLRF   xD9
04010:  MOVLW  A7
04012:  MOVWF  xD8
04014:  MOVLW  03
04016:  MOVWF  xDB
04018:  MOVLW  10
0401A:  MOVWF  xDA
0401C:  MOVLB  0
0401E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(168, IN_7_2_FILTER_MINUSA1);     // IN_7_2_FILTER_MINUSA1 
04022:  MOVLB  6
04024:  CLRF   xD9
04026:  MOVLW  A8
04028:  MOVWF  xD8
0402A:  MOVLW  03
0402C:  MOVWF  xDB
0402E:  MOVLW  11
04030:  MOVWF  xDA
04032:  MOVLB  0
04034:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(169, IN_7_2_FILTER_MINUSA2);     // IN_7_2_FILTER_MINUSA2 
04038:  MOVLB  6
0403A:  CLRF   xD9
0403C:  MOVLW  A9
0403E:  MOVWF  xD8
04040:  MOVLW  03
04042:  MOVWF  xDB
04044:  MOVLW  12
04046:  MOVWF  xDA
04048:  MOVLB  0
0404A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(170, IN_7_3_FILTER_B0);     // IN_7_3_FILTER_B0 
0404E:  MOVLB  6
04050:  CLRF   xD9
04052:  MOVLW  AA
04054:  MOVWF  xD8
04056:  MOVLW  03
04058:  MOVWF  xDB
0405A:  MOVLW  09
0405C:  MOVWF  xDA
0405E:  MOVLB  0
04060:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(171, IN_7_3_FILTER_B1);     // IN_7_3_FILTER_B1 
04064:  MOVLB  6
04066:  CLRF   xD9
04068:  MOVLW  AB
0406A:  MOVWF  xD8
0406C:  MOVLW  03
0406E:  MOVWF  xDB
04070:  MOVLW  0A
04072:  MOVWF  xDA
04074:  MOVLB  0
04076:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(172, IN_7_3_FILTER_B2);     // IN_7_3_FILTER_B2 
0407A:  MOVLB  6
0407C:  CLRF   xD9
0407E:  MOVLW  AC
04080:  MOVWF  xD8
04082:  MOVLW  03
04084:  MOVWF  xDB
04086:  MOVLW  0B
04088:  MOVWF  xDA
0408A:  MOVLB  0
0408C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(173, IN_7_3_FILTER_MINUSA1);     // IN_7_3_FILTER_MINUSA1 
04090:  MOVLB  6
04092:  CLRF   xD9
04094:  MOVLW  AD
04096:  MOVWF  xD8
04098:  MOVLW  03
0409A:  MOVWF  xDB
0409C:  MOVLW  0C
0409E:  MOVWF  xDA
040A0:  MOVLB  0
040A2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(174, IN_7_3_FILTER_MINUSA2);     // IN_7_3_FILTER_MINUSA2 
040A6:  MOVLB  6
040A8:  CLRF   xD9
040AA:  MOVLW  AE
040AC:  MOVWF  xD8
040AE:  MOVLW  03
040B0:  MOVWF  xDB
040B2:  MOVLW  0D
040B4:  MOVWF  xDA
040B6:  MOVLB  0
040B8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(175, IN_8_1_FILTER_B0);     // IN_8_1_FILTER_B0 
040BC:  MOVLB  6
040BE:  CLRF   xD9
040C0:  MOVLW  AF
040C2:  MOVWF  xD8
040C4:  MOVLW  03
040C6:  MOVWF  xDB
040C8:  MOVLW  04
040CA:  MOVWF  xDA
040CC:  MOVLB  0
040CE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(176, IN_8_1_FILTER_B1);     // IN_8_1_FILTER_B1 
040D2:  MOVLB  6
040D4:  CLRF   xD9
040D6:  MOVLW  B0
040D8:  MOVWF  xD8
040DA:  MOVLW  03
040DC:  MOVWF  xDB
040DE:  MOVLW  05
040E0:  MOVWF  xDA
040E2:  MOVLB  0
040E4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(177, IN_8_1_FILTER_B2);     // IN_8_1_FILTER_B2 
040E8:  MOVLB  6
040EA:  CLRF   xD9
040EC:  MOVLW  B1
040EE:  MOVWF  xD8
040F0:  MOVLW  03
040F2:  MOVWF  xDB
040F4:  MOVLW  06
040F6:  MOVWF  xDA
040F8:  MOVLB  0
040FA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(178, IN_8_1_FILTER_MINUSA1);     // IN_8_1_FILTER_MINUSA1 
040FE:  MOVLB  6
04100:  CLRF   xD9
04102:  MOVLW  B2
04104:  MOVWF  xD8
04106:  MOVLW  03
04108:  MOVWF  xDB
0410A:  MOVLW  07
0410C:  MOVWF  xDA
0410E:  MOVLB  0
04110:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(179, IN_8_1_FILTER_MINUSA2);     // IN_8_1_FILTER_MINUSA2 
04114:  MOVLB  6
04116:  CLRF   xD9
04118:  MOVLW  B3
0411A:  MOVWF  xD8
0411C:  MOVLW  03
0411E:  MOVWF  xDB
04120:  MOVLW  08
04122:  MOVWF  xDA
04124:  MOVLB  0
04126:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(180, IN_8_2_FILTER_B0);     // IN_8_2_FILTER_B0 
0412A:  MOVLB  6
0412C:  CLRF   xD9
0412E:  MOVLW  B4
04130:  MOVWF  xD8
04132:  MOVLW  02
04134:  MOVWF  xDB
04136:  SETF   xDA
04138:  MOVLB  0
0413A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(181, IN_8_2_FILTER_B1);     // IN_8_2_FILTER_B1 
0413E:  MOVLB  6
04140:  CLRF   xD9
04142:  MOVLW  B5
04144:  MOVWF  xD8
04146:  MOVLW  03
04148:  MOVWF  xDB
0414A:  CLRF   xDA
0414C:  MOVLB  0
0414E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(182, IN_8_2_FILTER_B2);     // IN_8_2_FILTER_B2 
04152:  MOVLB  6
04154:  CLRF   xD9
04156:  MOVLW  B6
04158:  MOVWF  xD8
0415A:  MOVLW  03
0415C:  MOVWF  xDB
0415E:  MOVLW  01
04160:  MOVWF  xDA
04162:  MOVLB  0
04164:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(183, IN_8_2_FILTER_MINUSA1);     // IN_8_2_FILTER_MINUSA1 
04168:  MOVLB  6
0416A:  CLRF   xD9
0416C:  MOVLW  B7
0416E:  MOVWF  xD8
04170:  MOVLW  03
04172:  MOVWF  xDB
04174:  MOVLW  02
04176:  MOVWF  xDA
04178:  MOVLB  0
0417A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(184, IN_8_2_FILTER_MINUSA2);     // IN_8_2_FILTER_MINUSA2 
0417E:  MOVLB  6
04180:  CLRF   xD9
04182:  MOVLW  B8
04184:  MOVWF  xD8
04186:  MOVLW  03
04188:  MOVWF  xDB
0418A:  MOVWF  xDA
0418C:  MOVLB  0
0418E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(185, IN_8_3_FILTER_B0);     // IN_8_3_FILTER_B0 
04192:  MOVLB  6
04194:  CLRF   xD9
04196:  MOVLW  B9
04198:  MOVWF  xD8
0419A:  MOVLW  02
0419C:  MOVWF  xDB
0419E:  MOVLW  FA
041A0:  MOVWF  xDA
041A2:  MOVLB  0
041A4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(186, IN_8_3_FILTER_B1);     // IN_8_3_FILTER_B1 
041A8:  MOVLB  6
041AA:  CLRF   xD9
041AC:  MOVLW  BA
041AE:  MOVWF  xD8
041B0:  MOVLW  02
041B2:  MOVWF  xDB
041B4:  MOVLW  FB
041B6:  MOVWF  xDA
041B8:  MOVLB  0
041BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(187, IN_8_3_FILTER_B2);     // IN_8_3_FILTER_B2 
041BE:  MOVLB  6
041C0:  CLRF   xD9
041C2:  MOVLW  BB
041C4:  MOVWF  xD8
041C6:  MOVLW  02
041C8:  MOVWF  xDB
041CA:  MOVLW  FC
041CC:  MOVWF  xDA
041CE:  MOVLB  0
041D0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(188, IN_8_3_FILTER_MINUSA1);     // IN_8_3_FILTER_MINUSA1 
041D4:  MOVLB  6
041D6:  CLRF   xD9
041D8:  MOVLW  BC
041DA:  MOVWF  xD8
041DC:  MOVLW  02
041DE:  MOVWF  xDB
041E0:  MOVLW  FD
041E2:  MOVWF  xDA
041E4:  MOVLB  0
041E6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(189, IN_8_3_FILTER_MINUSA2);     // IN_8_3_FILTER_MINUSA2 
041EA:  MOVLB  6
041EC:  CLRF   xD9
041EE:  MOVLW  BD
041F0:  MOVWF  xD8
041F2:  MOVLW  02
041F4:  MOVWF  xDB
041F6:  MOVLW  FE
041F8:  MOVWF  xDA
041FA:  MOVLB  0
041FC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(190, CH1COMP_THRESHOLD);     // CH1COMP_THRESHOLD 
04200:  MOVLB  6
04202:  CLRF   xD9
04204:  MOVLW  BE
04206:  MOVWF  xD8
04208:  MOVLW  02
0420A:  MOVWF  xDB
0420C:  MOVLW  6E
0420E:  MOVWF  xDA
04210:  MOVLB  0
04212:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(191, CH1COMP_KNEE);     // CH1COMP_KNEE 
04216:  MOVLB  6
04218:  CLRF   xD9
0421A:  MOVLW  BF
0421C:  MOVWF  xD8
0421E:  MOVLW  02
04220:  MOVWF  xDB
04222:  MOVLW  6F
04224:  MOVWF  xDA
04226:  MOVLB  0
04228:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(192, CH1COMP_RATIO);     // CH1COMP_RATIO 
0422C:  MOVLB  6
0422E:  CLRF   xD9
04230:  MOVLW  C0
04232:  MOVWF  xD8
04234:  MOVLW  02
04236:  MOVWF  xDB
04238:  MOVLW  70
0423A:  MOVWF  xDA
0423C:  MOVLB  0
0423E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(193, CH1COMP_ATTACK);     // CH1COMP_ATTACK 
04242:  MOVLB  6
04244:  CLRF   xD9
04246:  MOVLW  C1
04248:  MOVWF  xD8
0424A:  MOVLW  02
0424C:  MOVWF  xDB
0424E:  MOVLW  71
04250:  MOVWF  xDA
04252:  MOVLB  0
04254:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(194, CH1COMP_RELEASE);     // CH1COMP_RELEASE 
04258:  MOVLB  6
0425A:  CLRF   xD9
0425C:  MOVLW  C2
0425E:  MOVWF  xD8
04260:  MOVLW  02
04262:  MOVWF  xDB
04264:  MOVLW  72
04266:  MOVWF  xDA
04268:  MOVLB  0
0426A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(195, CH1COMP_BYPASS);     // CH1COMP_BYPASS 
0426E:  MOVLB  6
04270:  CLRF   xD9
04272:  MOVLW  C3
04274:  MOVWF  xD8
04276:  MOVLW  02
04278:  MOVWF  xDB
0427A:  MOVLW  73
0427C:  MOVWF  xDA
0427E:  MOVLB  0
04280:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(196, CH2COMP_THRESHOLD);     // CH2COMP_THRESHOLD 
04284:  MOVLB  6
04286:  CLRF   xD9
04288:  MOVLW  C4
0428A:  MOVWF  xD8
0428C:  MOVLW  02
0428E:  MOVWF  xDB
04290:  MOVLW  66
04292:  MOVWF  xDA
04294:  MOVLB  0
04296:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(197, CH2COMP_KNEE);     // CH2COMP_KNEE 
0429A:  MOVLB  6
0429C:  CLRF   xD9
0429E:  MOVLW  C5
042A0:  MOVWF  xD8
042A2:  MOVLW  02
042A4:  MOVWF  xDB
042A6:  MOVLW  67
042A8:  MOVWF  xDA
042AA:  MOVLB  0
042AC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(198, CH2COMP_RATIO);     // CH2COMP_RATIO 
042B0:  MOVLB  6
042B2:  CLRF   xD9
042B4:  MOVLW  C6
042B6:  MOVWF  xD8
042B8:  MOVLW  02
042BA:  MOVWF  xDB
042BC:  MOVLW  68
042BE:  MOVWF  xDA
042C0:  MOVLB  0
042C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(199, CH2COMP_ATTACK);     // CH2COMP_ATTACK 
042C6:  MOVLB  6
042C8:  CLRF   xD9
042CA:  MOVLW  C7
042CC:  MOVWF  xD8
042CE:  MOVLW  02
042D0:  MOVWF  xDB
042D2:  MOVLW  69
042D4:  MOVWF  xDA
042D6:  MOVLB  0
042D8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(200, CH2COMP_RELEASE);     // CH2COMP_RELEASE 
042DC:  MOVLB  6
042DE:  CLRF   xD9
042E0:  MOVLW  C8
042E2:  MOVWF  xD8
042E4:  MOVLW  02
042E6:  MOVWF  xDB
042E8:  MOVLW  6A
042EA:  MOVWF  xDA
042EC:  MOVLB  0
042EE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(201, CH2COMP_BYPASS);     // CH2COMP_BYPASS 
042F2:  MOVLB  6
042F4:  CLRF   xD9
042F6:  MOVLW  C9
042F8:  MOVWF  xD8
042FA:  MOVLW  02
042FC:  MOVWF  xDB
042FE:  MOVLW  6B
04300:  MOVWF  xDA
04302:  MOVLB  0
04304:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(202, CH3COMP_THRESHOLD);     // CH3COMP_THRESHOLD 
04308:  MOVLB  6
0430A:  CLRF   xD9
0430C:  MOVLW  CA
0430E:  MOVWF  xD8
04310:  MOVLW  02
04312:  MOVWF  xDB
04314:  MOVLW  5E
04316:  MOVWF  xDA
04318:  MOVLB  0
0431A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(203, CH3COMP_KNEE);     // CH3COMP_KNEE 
0431E:  MOVLB  6
04320:  CLRF   xD9
04322:  MOVLW  CB
04324:  MOVWF  xD8
04326:  MOVLW  02
04328:  MOVWF  xDB
0432A:  MOVLW  5F
0432C:  MOVWF  xDA
0432E:  MOVLB  0
04330:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(204, CH3COMP_RATIO);     // CH3COMP_RATIO 
04334:  MOVLB  6
04336:  CLRF   xD9
04338:  MOVLW  CC
0433A:  MOVWF  xD8
0433C:  MOVLW  02
0433E:  MOVWF  xDB
04340:  MOVLW  60
04342:  MOVWF  xDA
04344:  MOVLB  0
04346:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(205, CH3COMP_ATTACK);     // CH3COMP_ATTACK 
0434A:  MOVLB  6
0434C:  CLRF   xD9
0434E:  MOVLW  CD
04350:  MOVWF  xD8
04352:  MOVLW  02
04354:  MOVWF  xDB
04356:  MOVLW  61
04358:  MOVWF  xDA
0435A:  MOVLB  0
0435C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(206, CH3COMP_RELEASE);     // CH3COMP_RELEASE 
04360:  MOVLB  6
04362:  CLRF   xD9
04364:  MOVLW  CE
04366:  MOVWF  xD8
04368:  MOVLW  02
0436A:  MOVWF  xDB
0436C:  MOVLW  62
0436E:  MOVWF  xDA
04370:  MOVLB  0
04372:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(207, CH3COMP_BYPASS);     // CH3COMP_BYPASS 
04376:  MOVLB  6
04378:  CLRF   xD9
0437A:  MOVLW  CF
0437C:  MOVWF  xD8
0437E:  MOVLW  02
04380:  MOVWF  xDB
04382:  MOVLW  63
04384:  MOVWF  xDA
04386:  MOVLB  0
04388:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(208, CH4COMP_THRESHOLD);     // CH4COMP_THRESHOLD 
0438C:  MOVLB  6
0438E:  CLRF   xD9
04390:  MOVLW  D0
04392:  MOVWF  xD8
04394:  MOVLW  02
04396:  MOVWF  xDB
04398:  MOVLW  56
0439A:  MOVWF  xDA
0439C:  MOVLB  0
0439E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(209, CH4COMP_KNEE);     // CH4COMP_KNEE 
043A2:  MOVLB  6
043A4:  CLRF   xD9
043A6:  MOVLW  D1
043A8:  MOVWF  xD8
043AA:  MOVLW  02
043AC:  MOVWF  xDB
043AE:  MOVLW  57
043B0:  MOVWF  xDA
043B2:  MOVLB  0
043B4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(210, CH4COMP_RATIO);     // CH4COMP_RATIO 
043B8:  MOVLB  6
043BA:  CLRF   xD9
043BC:  MOVLW  D2
043BE:  MOVWF  xD8
043C0:  MOVLW  02
043C2:  MOVWF  xDB
043C4:  MOVLW  58
043C6:  MOVWF  xDA
043C8:  MOVLB  0
043CA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(211, CH4COMP_ATTACK);     // CH4COMP_ATTACK 
043CE:  MOVLB  6
043D0:  CLRF   xD9
043D2:  MOVLW  D3
043D4:  MOVWF  xD8
043D6:  MOVLW  02
043D8:  MOVWF  xDB
043DA:  MOVLW  59
043DC:  MOVWF  xDA
043DE:  MOVLB  0
043E0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(212, CH4COMP_RELEASE);     // CH4COMP_RELEASE 
043E4:  MOVLB  6
043E6:  CLRF   xD9
043E8:  MOVLW  D4
043EA:  MOVWF  xD8
043EC:  MOVLW  02
043EE:  MOVWF  xDB
043F0:  MOVLW  5A
043F2:  MOVWF  xDA
043F4:  MOVLB  0
043F6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(213, CH4COMP_BYPASS);     // CH4COMP_BYPASS 
043FA:  MOVLB  6
043FC:  CLRF   xD9
043FE:  MOVLW  D5
04400:  MOVWF  xD8
04402:  MOVLW  02
04404:  MOVWF  xDB
04406:  MOVLW  5B
04408:  MOVWF  xDA
0440A:  MOVLB  0
0440C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(214, CH5COMP_THRESHOLD);     // CH5COMP_THRESHOLD 
04410:  MOVLB  6
04412:  CLRF   xD9
04414:  MOVLW  D6
04416:  MOVWF  xD8
04418:  MOVLW  02
0441A:  MOVWF  xDB
0441C:  MOVLW  4E
0441E:  MOVWF  xDA
04420:  MOVLB  0
04422:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(215, CH5COMP_KNEE);     // CH5COMP_KNEE 
04426:  MOVLB  6
04428:  CLRF   xD9
0442A:  MOVLW  D7
0442C:  MOVWF  xD8
0442E:  MOVLW  02
04430:  MOVWF  xDB
04432:  MOVLW  4F
04434:  MOVWF  xDA
04436:  MOVLB  0
04438:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(216, CH5COMP_RATIO);     // CH5COMP_RATIO 
0443C:  MOVLB  6
0443E:  CLRF   xD9
04440:  MOVLW  D8
04442:  MOVWF  xD8
04444:  MOVLW  02
04446:  MOVWF  xDB
04448:  MOVLW  50
0444A:  MOVWF  xDA
0444C:  MOVLB  0
0444E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(217, CH5COMP_ATTACK);     // CH5COMP_ATTACK 
04452:  MOVLB  6
04454:  CLRF   xD9
04456:  MOVLW  D9
04458:  MOVWF  xD8
0445A:  MOVLW  02
0445C:  MOVWF  xDB
0445E:  MOVLW  51
04460:  MOVWF  xDA
04462:  MOVLB  0
04464:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(218, CH5COMP_RELEASE);     // CH5COMP_RELEASE 
04468:  MOVLB  6
0446A:  CLRF   xD9
0446C:  MOVLW  DA
0446E:  MOVWF  xD8
04470:  MOVLW  02
04472:  MOVWF  xDB
04474:  MOVLW  52
04476:  MOVWF  xDA
04478:  MOVLB  0
0447A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(219, CH5COMP_BYPASS);     // CH5COMP_BYPASS 
0447E:  MOVLB  6
04480:  CLRF   xD9
04482:  MOVLW  DB
04484:  MOVWF  xD8
04486:  MOVLW  02
04488:  MOVWF  xDB
0448A:  MOVLW  53
0448C:  MOVWF  xDA
0448E:  MOVLB  0
04490:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(220, CH6COMP_THRESHOLD);     // CH6COMP_THRESHOLD 
04494:  MOVLB  6
04496:  CLRF   xD9
04498:  MOVLW  DC
0449A:  MOVWF  xD8
0449C:  MOVLW  02
0449E:  MOVWF  xDB
044A0:  MOVLW  46
044A2:  MOVWF  xDA
044A4:  MOVLB  0
044A6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(221, CH6COMP_KNEE);     // CH6COMP_KNEE 
044AA:  MOVLB  6
044AC:  CLRF   xD9
044AE:  MOVLW  DD
044B0:  MOVWF  xD8
044B2:  MOVLW  02
044B4:  MOVWF  xDB
044B6:  MOVLW  47
044B8:  MOVWF  xDA
044BA:  MOVLB  0
044BC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(222, CH6COMP_RATIO);     // CH6COMP_RATIO 
044C0:  MOVLB  6
044C2:  CLRF   xD9
044C4:  MOVLW  DE
044C6:  MOVWF  xD8
044C8:  MOVLW  02
044CA:  MOVWF  xDB
044CC:  MOVLW  48
044CE:  MOVWF  xDA
044D0:  MOVLB  0
044D2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(223, CH6COMP_ATTACK);     // CH6COMP_ATTACK 
044D6:  MOVLB  6
044D8:  CLRF   xD9
044DA:  MOVLW  DF
044DC:  MOVWF  xD8
044DE:  MOVLW  02
044E0:  MOVWF  xDB
044E2:  MOVLW  49
044E4:  MOVWF  xDA
044E6:  MOVLB  0
044E8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(224, CH6COMP_RELEASE);     // CH6COMP_RELEASE 
044EC:  MOVLB  6
044EE:  CLRF   xD9
044F0:  MOVLW  E0
044F2:  MOVWF  xD8
044F4:  MOVLW  02
044F6:  MOVWF  xDB
044F8:  MOVLW  4A
044FA:  MOVWF  xDA
044FC:  MOVLB  0
044FE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(225, CH6COMP_BYPASS);     // CH6COMP_BYPASS 
04502:  MOVLB  6
04504:  CLRF   xD9
04506:  MOVLW  E1
04508:  MOVWF  xD8
0450A:  MOVLW  02
0450C:  MOVWF  xDB
0450E:  MOVLW  4B
04510:  MOVWF  xDA
04512:  MOVLB  0
04514:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(226, CH7COMP_THRESHOLD);     // CH7COMP_THRESHOLD 
04518:  MOVLB  6
0451A:  CLRF   xD9
0451C:  MOVLW  E2
0451E:  MOVWF  xD8
04520:  MOVLW  02
04522:  MOVWF  xDB
04524:  MOVLW  3E
04526:  MOVWF  xDA
04528:  MOVLB  0
0452A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(227, CH7COMP_KNEE);     // CH7COMP_KNEE 
0452E:  MOVLB  6
04530:  CLRF   xD9
04532:  MOVLW  E3
04534:  MOVWF  xD8
04536:  MOVLW  02
04538:  MOVWF  xDB
0453A:  MOVLW  3F
0453C:  MOVWF  xDA
0453E:  MOVLB  0
04540:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(228, CH7COMP_RATIO);     // CH7COMP_RATIO 
04544:  MOVLB  6
04546:  CLRF   xD9
04548:  MOVLW  E4
0454A:  MOVWF  xD8
0454C:  MOVLW  02
0454E:  MOVWF  xDB
04550:  MOVLW  40
04552:  MOVWF  xDA
04554:  MOVLB  0
04556:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(229, CH7COMP_ATTACK);     // CH7COMP_ATTACK 
0455A:  MOVLB  6
0455C:  CLRF   xD9
0455E:  MOVLW  E5
04560:  MOVWF  xD8
04562:  MOVLW  02
04564:  MOVWF  xDB
04566:  MOVLW  41
04568:  MOVWF  xDA
0456A:  MOVLB  0
0456C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(230, CH7COMP_RELEASE);     // CH7COMP_RELEASE 
04570:  MOVLB  6
04572:  CLRF   xD9
04574:  MOVLW  E6
04576:  MOVWF  xD8
04578:  MOVLW  02
0457A:  MOVWF  xDB
0457C:  MOVLW  42
0457E:  MOVWF  xDA
04580:  MOVLB  0
04582:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(231, CH7COMP_BYPASS);     // CH7COMP_BYPASS 
04586:  MOVLB  6
04588:  CLRF   xD9
0458A:  MOVLW  E7
0458C:  MOVWF  xD8
0458E:  MOVLW  02
04590:  MOVWF  xDB
04592:  MOVLW  43
04594:  MOVWF  xDA
04596:  MOVLB  0
04598:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(232, CH8COMP_THRESHOLD);     // CH8COMP_THRESHOLD 
0459C:  MOVLB  6
0459E:  CLRF   xD9
045A0:  MOVLW  E8
045A2:  MOVWF  xD8
045A4:  MOVLW  02
045A6:  MOVWF  xDB
045A8:  MOVLW  36
045AA:  MOVWF  xDA
045AC:  MOVLB  0
045AE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(233, CH8COMP_KNEE);     // CH8COMP_KNEE 
045B2:  MOVLB  6
045B4:  CLRF   xD9
045B6:  MOVLW  E9
045B8:  MOVWF  xD8
045BA:  MOVLW  02
045BC:  MOVWF  xDB
045BE:  MOVLW  37
045C0:  MOVWF  xDA
045C2:  MOVLB  0
045C4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(234, CH8COMP_RATIO);     // CH8COMP_RATIO 
045C8:  MOVLB  6
045CA:  CLRF   xD9
045CC:  MOVLW  EA
045CE:  MOVWF  xD8
045D0:  MOVLW  02
045D2:  MOVWF  xDB
045D4:  MOVLW  38
045D6:  MOVWF  xDA
045D8:  MOVLB  0
045DA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(235, CH8COMP_ATTACK);     // CH8COMP_ATTACK 
045DE:  MOVLB  6
045E0:  CLRF   xD9
045E2:  MOVLW  EB
045E4:  MOVWF  xD8
045E6:  MOVLW  02
045E8:  MOVWF  xDB
045EA:  MOVLW  39
045EC:  MOVWF  xDA
045EE:  MOVLB  0
045F0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(236, CH8COMP_RELEASE);     // CH8COMP_RELEASE 
045F4:  MOVLB  6
045F6:  CLRF   xD9
045F8:  MOVLW  EC
045FA:  MOVWF  xD8
045FC:  MOVLW  02
045FE:  MOVWF  xDB
04600:  MOVLW  3A
04602:  MOVWF  xDA
04604:  MOVLB  0
04606:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(237, CH8COMP_BYPASS);     // CH8COMP_BYPASS 
0460A:  MOVLB  6
0460C:  CLRF   xD9
0460E:  MOVLW  ED
04610:  MOVWF  xD8
04612:  MOVLW  02
04614:  MOVWF  xDB
04616:  MOVLW  3B
04618:  MOVWF  xDA
0461A:  MOVLB  0
0461C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(238, MIXER_SELECT0);     // MIXER_SELECT0 
04620:  MOVLB  6
04622:  CLRF   xD9
04624:  MOVLW  EE
04626:  MOVWF  xD8
04628:  CLRF   xDB
0462A:  MOVLW  03
0462C:  MOVWF  xDA
0462E:  MOVLB  0
04630:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(239, MIXER_SELECT1);     // MIXER_SELECT1 
04634:  MOVLB  6
04636:  CLRF   xD9
04638:  MOVLW  EF
0463A:  MOVWF  xD8
0463C:  CLRF   xDB
0463E:  MOVLW  04
04640:  MOVWF  xDA
04642:  MOVLB  0
04644:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(240, MIXER_SELECT2);     // MIXER_SELECT2 
04648:  MOVLB  6
0464A:  CLRF   xD9
0464C:  MOVLW  F0
0464E:  MOVWF  xD8
04650:  CLRF   xDB
04652:  MOVLW  05
04654:  MOVWF  xDA
04656:  MOVLB  0
04658:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(241, MIXER_SELECT3);     // MIXER_SELECT3 
0465C:  MOVLB  6
0465E:  CLRF   xD9
04660:  MOVLW  F1
04662:  MOVWF  xD8
04664:  CLRF   xDB
04666:  MOVLW  06
04668:  MOVWF  xDA
0466A:  MOVLB  0
0466C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(242, MIXER_SELECT4);     // MIXER_SELECT4 
04670:  MOVLB  6
04672:  CLRF   xD9
04674:  MOVLW  F2
04676:  MOVWF  xD8
04678:  CLRF   xDB
0467A:  MOVLW  07
0467C:  MOVWF  xDA
0467E:  MOVLB  0
04680:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(243, MIXER_SELECT5);     // MIXER_SELECT5 
04684:  MOVLB  6
04686:  CLRF   xD9
04688:  MOVLW  F3
0468A:  MOVWF  xD8
0468C:  CLRF   xDB
0468E:  MOVLW  08
04690:  MOVWF  xDA
04692:  MOVLB  0
04694:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(244, MIXER_SELECT6);     // MIXER_SELECT6 
04698:  MOVLB  6
0469A:  CLRF   xD9
0469C:  MOVLW  F4
0469E:  MOVWF  xD8
046A0:  CLRF   xDB
046A2:  MOVLW  09
046A4:  MOVWF  xDA
046A6:  MOVLB  0
046A8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(245, MIXER_SELECT7);     // MIXER_SELECT7 
046AC:  MOVLB  6
046AE:  CLRF   xD9
046B0:  MOVLW  F5
046B2:  MOVWF  xD8
046B4:  CLRF   xDB
046B6:  MOVLW  0A
046B8:  MOVWF  xDA
046BA:  MOVLB  0
046BC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(246, MIXER_SELECT8);     // MIXER_SELECT8 
046C0:  MOVLB  6
046C2:  CLRF   xD9
046C4:  MOVLW  F6
046C6:  MOVWF  xD8
046C8:  CLRF   xDB
046CA:  MOVLW  0B
046CC:  MOVWF  xDA
046CE:  MOVLB  0
046D0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(247, MIXER_SELECT9);     // MIXER_SELECT9 
046D4:  MOVLB  6
046D6:  CLRF   xD9
046D8:  MOVLW  F7
046DA:  MOVWF  xD8
046DC:  CLRF   xDB
046DE:  MOVLW  0C
046E0:  MOVWF  xDA
046E2:  MOVLB  0
046E4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(248, MIXER_SELECT10);     // MIXER_SELECT10 
046E8:  MOVLB  6
046EA:  CLRF   xD9
046EC:  MOVLW  F8
046EE:  MOVWF  xD8
046F0:  CLRF   xDB
046F2:  MOVLW  0D
046F4:  MOVWF  xDA
046F6:  MOVLB  0
046F8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(249, MIXER_SELECT11);     // MIXER_SELECT11 
046FC:  MOVLB  6
046FE:  CLRF   xD9
04700:  MOVLW  F9
04702:  MOVWF  xD8
04704:  CLRF   xDB
04706:  MOVLW  0E
04708:  MOVWF  xDA
0470A:  MOVLB  0
0470C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(250, MIXER_SELECT12);     // MIXER_SELECT12 
04710:  MOVLB  6
04712:  CLRF   xD9
04714:  MOVLW  FA
04716:  MOVWF  xD8
04718:  CLRF   xDB
0471A:  MOVLW  0F
0471C:  MOVWF  xDA
0471E:  MOVLB  0
04720:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(251, MIXER_SELECT13);     // MIXER_SELECT13 
04724:  MOVLB  6
04726:  CLRF   xD9
04728:  MOVLW  FB
0472A:  MOVWF  xD8
0472C:  CLRF   xDB
0472E:  MOVLW  10
04730:  MOVWF  xDA
04732:  MOVLB  0
04734:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(252, MIXER_SELECT14);     // MIXER_SELECT14 
04738:  MOVLB  6
0473A:  CLRF   xD9
0473C:  MOVLW  FC
0473E:  MOVWF  xD8
04740:  CLRF   xDB
04742:  MOVLW  11
04744:  MOVWF  xDA
04746:  MOVLB  0
04748:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(253, MIXER_SELECT15);     // MIXER_SELECT15 
0474C:  MOVLB  6
0474E:  CLRF   xD9
04750:  MOVLW  FD
04752:  MOVWF  xD8
04754:  CLRF   xDB
04756:  MOVLW  12
04758:  MOVWF  xDA
0475A:  MOVLB  0
0475C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(254, MIXER_SELECT16);     // MIXER_SELECT16 
04760:  MOVLB  6
04762:  CLRF   xD9
04764:  MOVLW  FE
04766:  MOVWF  xD8
04768:  CLRF   xDB
0476A:  MOVLW  13
0476C:  MOVWF  xDA
0476E:  MOVLB  0
04770:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(255, MIXER_SELECT17);     // MIXER_SELECT17 
04774:  MOVLB  6
04776:  CLRF   xD9
04778:  SETF   xD8
0477A:  CLRF   xDB
0477C:  MOVLW  14
0477E:  MOVWF  xDA
04780:  MOVLB  0
04782:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(256, MIXER_SELECT18);     // MIXER_SELECT18 
04786:  MOVLW  01
04788:  MOVLB  6
0478A:  MOVWF  xD9
0478C:  CLRF   xD8
0478E:  CLRF   xDB
04790:  MOVLW  15
04792:  MOVWF  xDA
04794:  MOVLB  0
04796:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(257, MIXER_SELECT19);     // MIXER_SELECT19 
0479A:  MOVLW  01
0479C:  MOVLB  6
0479E:  MOVWF  xD9
047A0:  MOVWF  xD8
047A2:  CLRF   xDB
047A4:  MOVLW  16
047A6:  MOVWF  xDA
047A8:  MOVLB  0
047AA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(258, MIXER_SELECT20);     // MIXER_SELECT20 
047AE:  MOVLW  01
047B0:  MOVLB  6
047B2:  MOVWF  xD9
047B4:  MOVLW  02
047B6:  MOVWF  xD8
047B8:  CLRF   xDB
047BA:  MOVLW  17
047BC:  MOVWF  xDA
047BE:  MOVLB  0
047C0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(259, MIXER_SELECT21);     // MIXER_SELECT21 
047C4:  MOVLW  01
047C6:  MOVLB  6
047C8:  MOVWF  xD9
047CA:  MOVLW  03
047CC:  MOVWF  xD8
047CE:  CLRF   xDB
047D0:  MOVLW  18
047D2:  MOVWF  xDA
047D4:  MOVLB  0
047D6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(260, MIXER_SELECT22);     // MIXER_SELECT22 
047DA:  MOVLW  01
047DC:  MOVLB  6
047DE:  MOVWF  xD9
047E0:  MOVLW  04
047E2:  MOVWF  xD8
047E4:  CLRF   xDB
047E6:  MOVLW  19
047E8:  MOVWF  xDA
047EA:  MOVLB  0
047EC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(261, MIXER_SELECT23);     // MIXER_SELECT23 
047F0:  MOVLW  01
047F2:  MOVLB  6
047F4:  MOVWF  xD9
047F6:  MOVLW  05
047F8:  MOVWF  xD8
047FA:  CLRF   xDB
047FC:  MOVLW  1A
047FE:  MOVWF  xDA
04800:  MOVLB  0
04802:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(262, MIXER_SELECT24);     // MIXER_SELECT24 
04806:  MOVLW  01
04808:  MOVLB  6
0480A:  MOVWF  xD9
0480C:  MOVLW  06
0480E:  MOVWF  xD8
04810:  CLRF   xDB
04812:  MOVLW  1B
04814:  MOVWF  xDA
04816:  MOVLB  0
04818:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(263, MIXER_SELECT25);     // MIXER_SELECT25 
0481C:  MOVLW  01
0481E:  MOVLB  6
04820:  MOVWF  xD9
04822:  MOVLW  07
04824:  MOVWF  xD8
04826:  CLRF   xDB
04828:  MOVLW  1C
0482A:  MOVWF  xDA
0482C:  MOVLB  0
0482E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(264, MIXER_SELECT26);     // MIXER_SELECT26 
04832:  MOVLW  01
04834:  MOVLB  6
04836:  MOVWF  xD9
04838:  MOVLW  08
0483A:  MOVWF  xD8
0483C:  CLRF   xDB
0483E:  MOVLW  1D
04840:  MOVWF  xDA
04842:  MOVLB  0
04844:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(265, MIXER_SELECT27);     // MIXER_SELECT27 
04848:  MOVLW  01
0484A:  MOVLB  6
0484C:  MOVWF  xD9
0484E:  MOVLW  09
04850:  MOVWF  xD8
04852:  CLRF   xDB
04854:  MOVLW  1E
04856:  MOVWF  xDA
04858:  MOVLB  0
0485A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(266, MIXER_SELECT28);     // MIXER_SELECT28 
0485E:  MOVLW  01
04860:  MOVLB  6
04862:  MOVWF  xD9
04864:  MOVLW  0A
04866:  MOVWF  xD8
04868:  CLRF   xDB
0486A:  MOVLW  1F
0486C:  MOVWF  xDA
0486E:  MOVLB  0
04870:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(267, MIXER_SELECT29);     // MIXER_SELECT29 
04874:  MOVLW  01
04876:  MOVLB  6
04878:  MOVWF  xD9
0487A:  MOVLW  0B
0487C:  MOVWF  xD8
0487E:  CLRF   xDB
04880:  MOVLW  20
04882:  MOVWF  xDA
04884:  MOVLB  0
04886:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(268, MIXER_SELECT30);     // MIXER_SELECT30 
0488A:  MOVLW  01
0488C:  MOVLB  6
0488E:  MOVWF  xD9
04890:  MOVLW  0C
04892:  MOVWF  xD8
04894:  CLRF   xDB
04896:  MOVLW  21
04898:  MOVWF  xDA
0489A:  MOVLB  0
0489C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(269, MIXER_SELECT31);     // MIXER_SELECT31 
048A0:  MOVLW  01
048A2:  MOVLB  6
048A4:  MOVWF  xD9
048A6:  MOVLW  0D
048A8:  MOVWF  xD8
048AA:  CLRF   xDB
048AC:  MOVLW  22
048AE:  MOVWF  xDA
048B0:  MOVLB  0
048B2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(270, MIXER_SELECT32);     // MIXER_SELECT32 
048B6:  MOVLW  01
048B8:  MOVLB  6
048BA:  MOVWF  xD9
048BC:  MOVLW  0E
048BE:  MOVWF  xD8
048C0:  CLRF   xDB
048C2:  MOVLW  23
048C4:  MOVWF  xDA
048C6:  MOVLB  0
048C8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(271, MIXER_SELECT33);     // MIXER_SELECT33 
048CC:  MOVLW  01
048CE:  MOVLB  6
048D0:  MOVWF  xD9
048D2:  MOVLW  0F
048D4:  MOVWF  xD8
048D6:  CLRF   xDB
048D8:  MOVLW  24
048DA:  MOVWF  xDA
048DC:  MOVLB  0
048DE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(272, MIXER_SELECT34);     // MIXER_SELECT34 
048E2:  MOVLW  01
048E4:  MOVLB  6
048E6:  MOVWF  xD9
048E8:  MOVLW  10
048EA:  MOVWF  xD8
048EC:  CLRF   xDB
048EE:  MOVLW  25
048F0:  MOVWF  xDA
048F2:  MOVLB  0
048F4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(273, MIXER_SELECT35);     // MIXER_SELECT35 
048F8:  MOVLW  01
048FA:  MOVLB  6
048FC:  MOVWF  xD9
048FE:  MOVLW  11
04900:  MOVWF  xD8
04902:  CLRF   xDB
04904:  MOVLW  26
04906:  MOVWF  xDA
04908:  MOVLB  0
0490A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(274, MIXER_SELECT36);     // MIXER_SELECT36 
0490E:  MOVLW  01
04910:  MOVLB  6
04912:  MOVWF  xD9
04914:  MOVLW  12
04916:  MOVWF  xD8
04918:  CLRF   xDB
0491A:  MOVLW  27
0491C:  MOVWF  xDA
0491E:  MOVLB  0
04920:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(275, MIXER_SELECT37);     // MIXER_SELECT37 
04924:  MOVLW  01
04926:  MOVLB  6
04928:  MOVWF  xD9
0492A:  MOVLW  13
0492C:  MOVWF  xD8
0492E:  CLRF   xDB
04930:  MOVLW  28
04932:  MOVWF  xDA
04934:  MOVLB  0
04936:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(276, MIXER_SELECT38);     // MIXER_SELECT38 
0493A:  MOVLW  01
0493C:  MOVLB  6
0493E:  MOVWF  xD9
04940:  MOVLW  14
04942:  MOVWF  xD8
04944:  CLRF   xDB
04946:  MOVLW  29
04948:  MOVWF  xDA
0494A:  MOVLB  0
0494C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(277, MIXER_SELECT39);     // MIXER_SELECT39 
04950:  MOVLW  01
04952:  MOVLB  6
04954:  MOVWF  xD9
04956:  MOVLW  15
04958:  MOVWF  xD8
0495A:  CLRF   xDB
0495C:  MOVLW  2A
0495E:  MOVWF  xDA
04960:  MOVLB  0
04962:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(278, MIXER_SELECT40);     // MIXER_SELECT40 
04966:  MOVLW  01
04968:  MOVLB  6
0496A:  MOVWF  xD9
0496C:  MOVLW  16
0496E:  MOVWF  xD8
04970:  CLRF   xDB
04972:  MOVLW  2B
04974:  MOVWF  xDA
04976:  MOVLB  0
04978:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(279, MIXER_SELECT41);     // MIXER_SELECT41 
0497C:  MOVLW  01
0497E:  MOVLB  6
04980:  MOVWF  xD9
04982:  MOVLW  17
04984:  MOVWF  xD8
04986:  CLRF   xDB
04988:  MOVLW  2C
0498A:  MOVWF  xDA
0498C:  MOVLB  0
0498E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(280, MIXER_SELECT42);     // MIXER_SELECT42 
04992:  MOVLW  01
04994:  MOVLB  6
04996:  MOVWF  xD9
04998:  MOVLW  18
0499A:  MOVWF  xD8
0499C:  CLRF   xDB
0499E:  MOVLW  2D
049A0:  MOVWF  xDA
049A2:  MOVLB  0
049A4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(281, MIXER_SELECT43);     // MIXER_SELECT43 
049A8:  MOVLW  01
049AA:  MOVLB  6
049AC:  MOVWF  xD9
049AE:  MOVLW  19
049B0:  MOVWF  xD8
049B2:  CLRF   xDB
049B4:  MOVLW  2E
049B6:  MOVWF  xDA
049B8:  MOVLB  0
049BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(282, MIXER_SELECT44);     // MIXER_SELECT44 
049BE:  MOVLW  01
049C0:  MOVLB  6
049C2:  MOVWF  xD9
049C4:  MOVLW  1A
049C6:  MOVWF  xD8
049C8:  CLRF   xDB
049CA:  MOVLW  2F
049CC:  MOVWF  xDA
049CE:  MOVLB  0
049D0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(283, MIXER_SELECT45);     // MIXER_SELECT45 
049D4:  MOVLW  01
049D6:  MOVLB  6
049D8:  MOVWF  xD9
049DA:  MOVLW  1B
049DC:  MOVWF  xD8
049DE:  CLRF   xDB
049E0:  MOVLW  30
049E2:  MOVWF  xDA
049E4:  MOVLB  0
049E6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(284, MIXER_SELECT46);     // MIXER_SELECT46 
049EA:  MOVLW  01
049EC:  MOVLB  6
049EE:  MOVWF  xD9
049F0:  MOVLW  1C
049F2:  MOVWF  xD8
049F4:  CLRF   xDB
049F6:  MOVLW  31
049F8:  MOVWF  xDA
049FA:  MOVLB  0
049FC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(285, MIXER_SELECT47);     // MIXER_SELECT47 
04A00:  MOVLW  01
04A02:  MOVLB  6
04A04:  MOVWF  xD9
04A06:  MOVLW  1D
04A08:  MOVWF  xD8
04A0A:  CLRF   xDB
04A0C:  MOVLW  32
04A0E:  MOVWF  xDA
04A10:  MOVLB  0
04A12:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(286, MIXER_SELECT48);     // MIXER_SELECT48 
04A16:  MOVLW  01
04A18:  MOVLB  6
04A1A:  MOVWF  xD9
04A1C:  MOVLW  1E
04A1E:  MOVWF  xD8
04A20:  CLRF   xDB
04A22:  MOVLW  33
04A24:  MOVWF  xDA
04A26:  MOVLB  0
04A28:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(287, MIXER_SELECT49);     // MIXER_SELECT49 
04A2C:  MOVLW  01
04A2E:  MOVLB  6
04A30:  MOVWF  xD9
04A32:  MOVLW  1F
04A34:  MOVWF  xD8
04A36:  CLRF   xDB
04A38:  MOVLW  34
04A3A:  MOVWF  xDA
04A3C:  MOVLB  0
04A3E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(288, MIXER_SELECT50);     // MIXER_SELECT50 
04A42:  MOVLW  01
04A44:  MOVLB  6
04A46:  MOVWF  xD9
04A48:  MOVLW  20
04A4A:  MOVWF  xD8
04A4C:  CLRF   xDB
04A4E:  MOVLW  35
04A50:  MOVWF  xDA
04A52:  MOVLB  0
04A54:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(289, MIXER_SELECT51);     // MIXER_SELECT51 
04A58:  MOVLW  01
04A5A:  MOVLB  6
04A5C:  MOVWF  xD9
04A5E:  MOVLW  21
04A60:  MOVWF  xD8
04A62:  CLRF   xDB
04A64:  MOVLW  36
04A66:  MOVWF  xDA
04A68:  MOVLB  0
04A6A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(290, MIXER_SELECT52);     // MIXER_SELECT52 
04A6E:  MOVLW  01
04A70:  MOVLB  6
04A72:  MOVWF  xD9
04A74:  MOVLW  22
04A76:  MOVWF  xD8
04A78:  CLRF   xDB
04A7A:  MOVLW  37
04A7C:  MOVWF  xDA
04A7E:  MOVLB  0
04A80:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(291, MIXER_SELECT53);     // MIXER_SELECT53 
04A84:  MOVLW  01
04A86:  MOVLB  6
04A88:  MOVWF  xD9
04A8A:  MOVLW  23
04A8C:  MOVWF  xD8
04A8E:  CLRF   xDB
04A90:  MOVLW  38
04A92:  MOVWF  xDA
04A94:  MOVLB  0
04A96:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(292, MIXER_SELECT54);     // MIXER_SELECT54 
04A9A:  MOVLW  01
04A9C:  MOVLB  6
04A9E:  MOVWF  xD9
04AA0:  MOVLW  24
04AA2:  MOVWF  xD8
04AA4:  CLRF   xDB
04AA6:  MOVLW  39
04AA8:  MOVWF  xDA
04AAA:  MOVLB  0
04AAC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(293, MIXER_SELECT55);     // MIXER_SELECT55 
04AB0:  MOVLW  01
04AB2:  MOVLB  6
04AB4:  MOVWF  xD9
04AB6:  MOVLW  25
04AB8:  MOVWF  xD8
04ABA:  CLRF   xDB
04ABC:  MOVLW  3A
04ABE:  MOVWF  xDA
04AC0:  MOVLB  0
04AC2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(294, MIXER_SELECT56);     // MIXER_SELECT56 
04AC6:  MOVLW  01
04AC8:  MOVLB  6
04ACA:  MOVWF  xD9
04ACC:  MOVLW  26
04ACE:  MOVWF  xD8
04AD0:  CLRF   xDB
04AD2:  MOVLW  3B
04AD4:  MOVWF  xDA
04AD6:  MOVLB  0
04AD8:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(295, MIXER_SELECT57);     // MIXER_SELECT57 
04ADC:  MOVLW  01
04ADE:  MOVLB  6
04AE0:  MOVWF  xD9
04AE2:  MOVLW  27
04AE4:  MOVWF  xD8
04AE6:  CLRF   xDB
04AE8:  MOVLW  3C
04AEA:  MOVWF  xDA
04AEC:  MOVLB  0
04AEE:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(296, MIXER_SELECT58);     // MIXER_SELECT58 
04AF2:  MOVLW  01
04AF4:  MOVLB  6
04AF6:  MOVWF  xD9
04AF8:  MOVLW  28
04AFA:  MOVWF  xD8
04AFC:  CLRF   xDB
04AFE:  MOVLW  3D
04B00:  MOVWF  xDA
04B02:  MOVLB  0
04B04:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(297, MIXER_SELECT59);     // MIXER_SELECT59 
04B08:  MOVLW  01
04B0A:  MOVLB  6
04B0C:  MOVWF  xD9
04B0E:  MOVLW  29
04B10:  MOVWF  xD8
04B12:  CLRF   xDB
04B14:  MOVLW  3E
04B16:  MOVWF  xDA
04B18:  MOVLB  0
04B1A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(298, MIXER_SELECT60);     // MIXER_SELECT60 
04B1E:  MOVLW  01
04B20:  MOVLB  6
04B22:  MOVWF  xD9
04B24:  MOVLW  2A
04B26:  MOVWF  xD8
04B28:  CLRF   xDB
04B2A:  MOVLW  3F
04B2C:  MOVWF  xDA
04B2E:  MOVLB  0
04B30:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(299, MIXER_SELECT61);     // MIXER_SELECT61 
04B34:  MOVLW  01
04B36:  MOVLB  6
04B38:  MOVWF  xD9
04B3A:  MOVLW  2B
04B3C:  MOVWF  xD8
04B3E:  CLRF   xDB
04B40:  MOVLW  40
04B42:  MOVWF  xDA
04B44:  MOVLB  0
04B46:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(300, MIXER_SELECT62);     // MIXER_SELECT62 
04B4A:  MOVLW  01
04B4C:  MOVLB  6
04B4E:  MOVWF  xD9
04B50:  MOVLW  2C
04B52:  MOVWF  xD8
04B54:  CLRF   xDB
04B56:  MOVLW  41
04B58:  MOVWF  xDA
04B5A:  MOVLB  0
04B5C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(301, MIXER_SELECT63);     // MIXER_SELECT63 
04B60:  MOVLW  01
04B62:  MOVLB  6
04B64:  MOVWF  xD9
04B66:  MOVLW  2D
04B68:  MOVWF  xD8
04B6A:  CLRF   xDB
04B6C:  MOVLW  42
04B6E:  MOVWF  xDA
04B70:  MOVLB  0
04B72:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(302, MIXER_SELECT64);     // MIXER_SELECT64 
04B76:  MOVLW  01
04B78:  MOVLB  6
04B7A:  MOVWF  xD9
04B7C:  MOVLW  2E
04B7E:  MOVWF  xD8
04B80:  CLRF   xDB
04B82:  MOVLW  43
04B84:  MOVWF  xDA
04B86:  MOVLB  0
04B88:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(303, MIXER_SELECT65);     // MIXER_SELECT65 
04B8C:  MOVLW  01
04B8E:  MOVLB  6
04B90:  MOVWF  xD9
04B92:  MOVLW  2F
04B94:  MOVWF  xD8
04B96:  CLRF   xDB
04B98:  MOVLW  44
04B9A:  MOVWF  xDA
04B9C:  MOVLB  0
04B9E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(304, MIXER_SELECT66);     // MIXER_SELECT66 
04BA2:  MOVLW  01
04BA4:  MOVLB  6
04BA6:  MOVWF  xD9
04BA8:  MOVLW  30
04BAA:  MOVWF  xD8
04BAC:  CLRF   xDB
04BAE:  MOVLW  45
04BB0:  MOVWF  xDA
04BB2:  MOVLB  0
04BB4:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(305, MIXER_SELECT67);     // MIXER_SELECT67 
04BB8:  MOVLW  01
04BBA:  MOVLB  6
04BBC:  MOVWF  xD9
04BBE:  MOVLW  31
04BC0:  MOVWF  xD8
04BC2:  CLRF   xDB
04BC4:  MOVLW  46
04BC6:  MOVWF  xDA
04BC8:  MOVLB  0
04BCA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(306, MIXER_SELECT68);     // MIXER_SELECT68 
04BCE:  MOVLW  01
04BD0:  MOVLB  6
04BD2:  MOVWF  xD9
04BD4:  MOVLW  32
04BD6:  MOVWF  xD8
04BD8:  CLRF   xDB
04BDA:  MOVLW  47
04BDC:  MOVWF  xDA
04BDE:  MOVLB  0
04BE0:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(307, MIXER_SELECT69);     // MIXER_SELECT69 
04BE4:  MOVLW  01
04BE6:  MOVLB  6
04BE8:  MOVWF  xD9
04BEA:  MOVLW  33
04BEC:  MOVWF  xD8
04BEE:  CLRF   xDB
04BF0:  MOVLW  48
04BF2:  MOVWF  xDA
04BF4:  MOVLB  0
04BF6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(308, MIXER_SELECT70);     // MIXER_SELECT70 
04BFA:  MOVLW  01
04BFC:  MOVLB  6
04BFE:  MOVWF  xD9
04C00:  MOVLW  34
04C02:  MOVWF  xD8
04C04:  CLRF   xDB
04C06:  MOVLW  49
04C08:  MOVWF  xDA
04C0A:  MOVLB  0
04C0C:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(309, MIXER_SELECT71);     // MIXER_SELECT71 
04C10:  MOVLW  01
04C12:  MOVLB  6
04C14:  MOVWF  xD9
04C16:  MOVLW  35
04C18:  MOVWF  xD8
04C1A:  CLRF   xDB
04C1C:  MOVLW  4A
04C1E:  MOVWF  xDA
04C20:  MOVLB  0
04C22:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(310, MIXER_SELECT72);     // MIXER_SELECT72 
04C26:  MOVLW  01
04C28:  MOVLB  6
04C2A:  MOVWF  xD9
04C2C:  MOVLW  36
04C2E:  MOVWF  xD8
04C30:  CLRF   xDB
04C32:  MOVLW  4B
04C34:  MOVWF  xDA
04C36:  MOVLB  0
04C38:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(311, MIXER_SELECT73);     // MIXER_SELECT73 
04C3C:  MOVLW  01
04C3E:  MOVLB  6
04C40:  MOVWF  xD9
04C42:  MOVLW  37
04C44:  MOVWF  xD8
04C46:  CLRF   xDB
04C48:  MOVLW  4C
04C4A:  MOVWF  xDA
04C4C:  MOVLB  0
04C4E:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(312, MIXER_SELECT74);     // MIXER_SELECT74 
04C52:  MOVLW  01
04C54:  MOVLB  6
04C56:  MOVWF  xD9
04C58:  MOVLW  38
04C5A:  MOVWF  xD8
04C5C:  CLRF   xDB
04C5E:  MOVLW  4D
04C60:  MOVWF  xDA
04C62:  MOVLB  0
04C64:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(313, MIXER_SELECT75);     // MIXER_SELECT75 
04C68:  MOVLW  01
04C6A:  MOVLB  6
04C6C:  MOVWF  xD9
04C6E:  MOVLW  39
04C70:  MOVWF  xD8
04C72:  CLRF   xDB
04C74:  MOVLW  4E
04C76:  MOVWF  xDA
04C78:  MOVLB  0
04C7A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(314, MIXER_SELECT76);     // MIXER_SELECT76 
04C7E:  MOVLW  01
04C80:  MOVLB  6
04C82:  MOVWF  xD9
04C84:  MOVLW  3A
04C86:  MOVWF  xD8
04C88:  CLRF   xDB
04C8A:  MOVLW  4F
04C8C:  MOVWF  xDA
04C8E:  MOVLB  0
04C90:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(315, MIXER_SELECT77);     // MIXER_SELECT77 
04C94:  MOVLW  01
04C96:  MOVLB  6
04C98:  MOVWF  xD9
04C9A:  MOVLW  3B
04C9C:  MOVWF  xD8
04C9E:  CLRF   xDB
04CA0:  MOVLW  50
04CA2:  MOVWF  xDA
04CA4:  MOVLB  0
04CA6:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(316, MIXER_SELECT78);     // MIXER_SELECT78 
04CAA:  MOVLW  01
04CAC:  MOVLB  6
04CAE:  MOVWF  xD9
04CB0:  MOVLW  3C
04CB2:  MOVWF  xD8
04CB4:  CLRF   xDB
04CB6:  MOVLW  51
04CB8:  MOVWF  xDA
04CBA:  MOVLB  0
04CBC:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(317, MIXER_SELECT79);     // MIXER_SELECT79 
04CC0:  MOVLW  01
04CC2:  MOVLB  6
04CC4:  MOVWF  xD9
04CC6:  MOVLW  3D
04CC8:  MOVWF  xD8
04CCA:  CLRF   xDB
04CCC:  MOVLW  52
04CCE:  MOVWF  xDA
04CD0:  MOVLB  0
04CD2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(318, OUT_1_1_FILTER_B0);     // OUT_1_1_FILTER_B0 
04CD6:  MOVLW  01
04CD8:  MOVLB  6
04CDA:  MOVWF  xD9
04CDC:  MOVLW  3E
04CDE:  MOVWF  xD8
04CE0:  MOVLW  02
04CE2:  MOVWF  xDB
04CE4:  MOVLW  F5
04CE6:  MOVWF  xDA
04CE8:  MOVLB  0
04CEA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(319, OUT_1_1_FILTER_B1);     // OUT_1_1_FILTER_B1 
04CEE:  MOVLW  01
04CF0:  MOVLB  6
04CF2:  MOVWF  xD9
04CF4:  MOVLW  3F
04CF6:  MOVWF  xD8
04CF8:  MOVLW  02
04CFA:  MOVWF  xDB
04CFC:  MOVLW  F6
04CFE:  MOVWF  xDA
04D00:  MOVLB  0
04D02:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(320, OUT_1_1_FILTER_B2);     // OUT_1_1_FILTER_B2 
04D06:  MOVLW  01
04D08:  MOVLB  6
04D0A:  MOVWF  xD9
04D0C:  MOVLW  40
04D0E:  MOVWF  xD8
04D10:  MOVLW  02
04D12:  MOVWF  xDB
04D14:  MOVLW  F7
04D16:  MOVWF  xDA
04D18:  MOVLB  0
04D1A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(321, OUT_1_1_FILTER_NEGATIVEA1);     // OUT_1_1_FILTER_NEGATIVEA1 
04D1E:  MOVLW  01
04D20:  MOVLB  6
04D22:  MOVWF  xD9
04D24:  MOVLW  41
04D26:  MOVWF  xD8
04D28:  MOVLW  02
04D2A:  MOVWF  xDB
04D2C:  MOVLW  F8
04D2E:  MOVWF  xDA
04D30:  MOVLB  0
04D32:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(322, OUT_1_1_FILTER_NEGATIVEA2);     // OUT_1_1_FILTER_NEGATIVEA2 
04D36:  MOVLW  01
04D38:  MOVLB  6
04D3A:  MOVWF  xD9
04D3C:  MOVLW  42
04D3E:  MOVWF  xD8
04D40:  MOVLW  02
04D42:  MOVWF  xDB
04D44:  MOVLW  F9
04D46:  MOVWF  xDA
04D48:  MOVLB  0
04D4A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(323, OUT_1_2_FILTER_B0);     // OUT_1_2_FILTER_B0 
04D4E:  MOVLW  01
04D50:  MOVLB  6
04D52:  MOVWF  xD9
04D54:  MOVLW  43
04D56:  MOVWF  xD8
04D58:  MOVLW  02
04D5A:  MOVWF  xDB
04D5C:  MOVLW  F0
04D5E:  MOVWF  xDA
04D60:  MOVLB  0
04D62:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(324, OUT_1_2_FILTER_B1);     // OUT_1_2_FILTER_B1 
04D66:  MOVLW  01
04D68:  MOVLB  6
04D6A:  MOVWF  xD9
04D6C:  MOVLW  44
04D6E:  MOVWF  xD8
04D70:  MOVLW  02
04D72:  MOVWF  xDB
04D74:  MOVLW  F1
04D76:  MOVWF  xDA
04D78:  MOVLB  0
04D7A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(325, OUT_1_2_FILTER_B2);     // OUT_1_2_FILTER_B2 
04D7E:  MOVLW  01
04D80:  MOVLB  6
04D82:  MOVWF  xD9
04D84:  MOVLW  45
04D86:  MOVWF  xD8
04D88:  MOVLW  02
04D8A:  MOVWF  xDB
04D8C:  MOVLW  F2
04D8E:  MOVWF  xDA
04D90:  MOVLB  0
04D92:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(326, OUT_1_2_FILTER_NEGATIVEA1);     // OUT_1_2_FILTER_NEGATIVEA1 
04D96:  MOVLW  01
04D98:  MOVLB  6
04D9A:  MOVWF  xD9
04D9C:  MOVLW  46
04D9E:  MOVWF  xD8
04DA0:  MOVLW  02
04DA2:  MOVWF  xDB
04DA4:  MOVLW  F3
04DA6:  MOVWF  xDA
04DA8:  MOVLB  0
04DAA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(327, OUT_1_2_FILTER_NEGATIVEA2);     // OUT_1_2_FILTER_NEGATIVEA2 
04DAE:  MOVLW  01
04DB0:  MOVLB  6
04DB2:  MOVWF  xD9
04DB4:  MOVLW  47
04DB6:  MOVWF  xD8
04DB8:  MOVLW  02
04DBA:  MOVWF  xDB
04DBC:  MOVLW  F4
04DBE:  MOVWF  xDA
04DC0:  MOVLB  0
04DC2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(328, OUT_1_3_FILTER_B0);     // OUT_1_3_FILTER_B0 
04DC6:  MOVLW  01
04DC8:  MOVLB  6
04DCA:  MOVWF  xD9
04DCC:  MOVLW  48
04DCE:  MOVWF  xD8
04DD0:  MOVLW  02
04DD2:  MOVWF  xDB
04DD4:  MOVLW  EB
04DD6:  MOVWF  xDA
04DD8:  MOVLB  0
04DDA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(329, OUT_1_3_FILTER_B1);     // OUT_1_3_FILTER_B1 
04DDE:  MOVLW  01
04DE0:  MOVLB  6
04DE2:  MOVWF  xD9
04DE4:  MOVLW  49
04DE6:  MOVWF  xD8
04DE8:  MOVLW  02
04DEA:  MOVWF  xDB
04DEC:  MOVLW  EC
04DEE:  MOVWF  xDA
04DF0:  MOVLB  0
04DF2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(330, OUT_1_3_FILTER_B2);     // OUT_1_3_FILTER_B2 
04DF6:  MOVLW  01
04DF8:  MOVLB  6
04DFA:  MOVWF  xD9
04DFC:  MOVLW  4A
04DFE:  MOVWF  xD8
04E00:  MOVLW  02
04E02:  MOVWF  xDB
04E04:  MOVLW  ED
04E06:  MOVWF  xDA
04E08:  MOVLB  0
04E0A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(331, OUT_1_3_FILTER_NEGATIVEA1);     // OUT_1_3_FILTER_NEGATIVEA1 
04E0E:  MOVLW  01
04E10:  MOVLB  6
04E12:  MOVWF  xD9
04E14:  MOVLW  4B
04E16:  MOVWF  xD8
04E18:  MOVLW  02
04E1A:  MOVWF  xDB
04E1C:  MOVLW  EE
04E1E:  MOVWF  xDA
04E20:  MOVLB  0
04E22:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(332, OUT_1_3_FILTER_NEGATIVEA2);     // OUT_1_3_FILTER_NEGATIVEA2 
04E26:  MOVLW  01
04E28:  MOVLB  6
04E2A:  MOVWF  xD9
04E2C:  MOVLW  4C
04E2E:  MOVWF  xD8
04E30:  MOVLW  02
04E32:  MOVWF  xDB
04E34:  MOVLW  EF
04E36:  MOVWF  xDA
04E38:  MOVLB  0
04E3A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(333, OUT_1_4_FILTER_B0);     // OUT_1_4_FILTER_B0 
04E3E:  MOVLW  01
04E40:  MOVLB  6
04E42:  MOVWF  xD9
04E44:  MOVLW  4D
04E46:  MOVWF  xD8
04E48:  MOVLW  02
04E4A:  MOVWF  xDB
04E4C:  MOVLW  B9
04E4E:  MOVWF  xDA
04E50:  MOVLB  0
04E52:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(334, OUT_1_4_FILTER_B1);     // OUT_1_4_FILTER_B1 
04E56:  MOVLW  01
04E58:  MOVLB  6
04E5A:  MOVWF  xD9
04E5C:  MOVLW  4E
04E5E:  MOVWF  xD8
04E60:  MOVLW  02
04E62:  MOVWF  xDB
04E64:  MOVLW  BA
04E66:  MOVWF  xDA
04E68:  MOVLB  0
04E6A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(335, OUT_1_4_FILTER_B2);     // OUT_1_4_FILTER_B2 
04E6E:  MOVLW  01
04E70:  MOVLB  6
04E72:  MOVWF  xD9
04E74:  MOVLW  4F
04E76:  MOVWF  xD8
04E78:  MOVLW  02
04E7A:  MOVWF  xDB
04E7C:  MOVLW  BB
04E7E:  MOVWF  xDA
04E80:  MOVLB  0
04E82:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(336, OUT_1_4_FILTER_NEGATIVEA1);     // OUT_1_4_FILTER_NEGATIVEA1 
04E86:  MOVLW  01
04E88:  MOVLB  6
04E8A:  MOVWF  xD9
04E8C:  MOVLW  50
04E8E:  MOVWF  xD8
04E90:  MOVLW  02
04E92:  MOVWF  xDB
04E94:  MOVLW  BC
04E96:  MOVWF  xDA
04E98:  MOVLB  0
04E9A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(337, OUT_1_4_FILTER_NEGATIVEA2);     // OUT_1_4_FILTER_NEGATIVEA2 
04E9E:  MOVLW  01
04EA0:  MOVLB  6
04EA2:  MOVWF  xD9
04EA4:  MOVLW  51
04EA6:  MOVWF  xD8
04EA8:  MOVLW  02
04EAA:  MOVWF  xDB
04EAC:  MOVLW  BD
04EAE:  MOVWF  xDA
04EB0:  MOVLB  0
04EB2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(338, OUT_1_5_FILTER_B0);     // OUT_1_5_FILTER_B0 
04EB6:  MOVLW  01
04EB8:  MOVLB  6
04EBA:  MOVWF  xD9
04EBC:  MOVLW  52
04EBE:  MOVWF  xD8
04EC0:  MOVLW  02
04EC2:  MOVWF  xDB
04EC4:  MOVLW  B4
04EC6:  MOVWF  xDA
04EC8:  MOVLB  0
04ECA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(339, OUT_1_5_FILTER_B1);     // OUT_1_5_FILTER_B1 
04ECE:  MOVLW  01
04ED0:  MOVLB  6
04ED2:  MOVWF  xD9
04ED4:  MOVLW  53
04ED6:  MOVWF  xD8
04ED8:  MOVLW  02
04EDA:  MOVWF  xDB
04EDC:  MOVLW  B5
04EDE:  MOVWF  xDA
04EE0:  MOVLB  0
04EE2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(340, OUT_1_5_FILTER_B2);     // OUT_1_5_FILTER_B2 
04EE6:  MOVLW  01
04EE8:  MOVLB  6
04EEA:  MOVWF  xD9
04EEC:  MOVLW  54
04EEE:  MOVWF  xD8
04EF0:  MOVLW  02
04EF2:  MOVWF  xDB
04EF4:  MOVLW  B6
04EF6:  MOVWF  xDA
04EF8:  MOVLB  0
04EFA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(341, OUT_1_5_FILTER_NEGATIVEA1);     // OUT_1_5_FILTER_NEGATIVEA1 
04EFE:  MOVLW  01
04F00:  MOVLB  6
04F02:  MOVWF  xD9
04F04:  MOVLW  55
04F06:  MOVWF  xD8
04F08:  MOVLW  02
04F0A:  MOVWF  xDB
04F0C:  MOVLW  B7
04F0E:  MOVWF  xDA
04F10:  MOVLB  0
04F12:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(342, OUT_1_5_FILTER_NEGATIVEA2);     // OUT_1_5_FILTER_NEGATIVEA2 
04F16:  MOVLW  01
04F18:  MOVLB  6
04F1A:  MOVWF  xD9
04F1C:  MOVLW  56
04F1E:  MOVWF  xD8
04F20:  MOVLW  02
04F22:  MOVWF  xDB
04F24:  MOVLW  B8
04F26:  MOVWF  xDA
04F28:  MOVLB  0
04F2A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(343, OUT_1_6_FILTER_B0);     // OUT_1_6_FILTER_B0 
04F2E:  MOVLW  01
04F30:  MOVLB  6
04F32:  MOVWF  xD9
04F34:  MOVLW  57
04F36:  MOVWF  xD8
04F38:  MOVLW  02
04F3A:  MOVWF  xDB
04F3C:  MOVLW  AF
04F3E:  MOVWF  xDA
04F40:  MOVLB  0
04F42:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(344, OUT_1_6_FILTER_B1);     // OUT_1_6_FILTER_B1 
04F46:  MOVLW  01
04F48:  MOVLB  6
04F4A:  MOVWF  xD9
04F4C:  MOVLW  58
04F4E:  MOVWF  xD8
04F50:  MOVLW  02
04F52:  MOVWF  xDB
04F54:  MOVLW  B0
04F56:  MOVWF  xDA
04F58:  MOVLB  0
04F5A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(345, OUT_1_6_FILTER_B2);     // OUT_1_6_FILTER_B2 
04F5E:  MOVLW  01
04F60:  MOVLB  6
04F62:  MOVWF  xD9
04F64:  MOVLW  59
04F66:  MOVWF  xD8
04F68:  MOVLW  02
04F6A:  MOVWF  xDB
04F6C:  MOVLW  B1
04F6E:  MOVWF  xDA
04F70:  MOVLB  0
04F72:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(346, OUT_1_6_FILTER_NEGATIVEA1);     // OUT_1_6_FILTER_NEGATIVEA1 
04F76:  MOVLW  01
04F78:  MOVLB  6
04F7A:  MOVWF  xD9
04F7C:  MOVLW  5A
04F7E:  MOVWF  xD8
04F80:  MOVLW  02
04F82:  MOVWF  xDB
04F84:  MOVLW  B2
04F86:  MOVWF  xDA
04F88:  MOVLB  0
04F8A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(347, OUT_1_6_FILTER_NEGATIVEA2);     // OUT_1_6_FILTER_NEGATIVEA2 
04F8E:  MOVLW  01
04F90:  MOVLB  6
04F92:  MOVWF  xD9
04F94:  MOVLW  5B
04F96:  MOVWF  xD8
04F98:  MOVLW  02
04F9A:  MOVWF  xDB
04F9C:  MOVLW  B3
04F9E:  MOVWF  xDA
04FA0:  MOVLB  0
04FA2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(348, OUT_2_1_FILTER_B0);     // OUT_2_1_FILTER_B0 
04FA6:  MOVLW  01
04FA8:  MOVLB  6
04FAA:  MOVWF  xD9
04FAC:  MOVLW  5C
04FAE:  MOVWF  xD8
04FB0:  MOVLW  02
04FB2:  MOVWF  xDB
04FB4:  MOVLW  E6
04FB6:  MOVWF  xDA
04FB8:  MOVLB  0
04FBA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(349, OUT_2_1_FILTER_B1);     // OUT_2_1_FILTER_B1 
04FBE:  MOVLW  01
04FC0:  MOVLB  6
04FC2:  MOVWF  xD9
04FC4:  MOVLW  5D
04FC6:  MOVWF  xD8
04FC8:  MOVLW  02
04FCA:  MOVWF  xDB
04FCC:  MOVLW  E7
04FCE:  MOVWF  xDA
04FD0:  MOVLB  0
04FD2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(350, OUT_2_1_FILTER_B2);     // OUT_2_1_FILTER_B2 
04FD6:  MOVLW  01
04FD8:  MOVLB  6
04FDA:  MOVWF  xD9
04FDC:  MOVLW  5E
04FDE:  MOVWF  xD8
04FE0:  MOVLW  02
04FE2:  MOVWF  xDB
04FE4:  MOVLW  E8
04FE6:  MOVWF  xDA
04FE8:  MOVLB  0
04FEA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(351, OUT_2_1_FILTER_NEGATIVEA1);     // OUT_2_1_FILTER_NEGATIVEA1 
04FEE:  MOVLW  01
04FF0:  MOVLB  6
04FF2:  MOVWF  xD9
04FF4:  MOVLW  5F
04FF6:  MOVWF  xD8
04FF8:  MOVLW  02
04FFA:  MOVWF  xDB
04FFC:  MOVLW  E9
04FFE:  MOVWF  xDA
05000:  MOVLB  0
05002:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(352, OUT_2_1_FILTER_NEGATIVEA2);     // OUT_2_1_FILTER_NEGATIVEA2 
05006:  MOVLW  01
05008:  MOVLB  6
0500A:  MOVWF  xD9
0500C:  MOVLW  60
0500E:  MOVWF  xD8
05010:  MOVLW  02
05012:  MOVWF  xDB
05014:  MOVLW  EA
05016:  MOVWF  xDA
05018:  MOVLB  0
0501A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(353, OUT_2_2_FILTER_B0);     // OUT_2_2_FILTER_B0 
0501E:  MOVLW  01
05020:  MOVLB  6
05022:  MOVWF  xD9
05024:  MOVLW  61
05026:  MOVWF  xD8
05028:  MOVLW  02
0502A:  MOVWF  xDB
0502C:  MOVLW  E1
0502E:  MOVWF  xDA
05030:  MOVLB  0
05032:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(354, OUT_2_2_FILTER_B1);     // OUT_2_2_FILTER_B1 
05036:  MOVLW  01
05038:  MOVLB  6
0503A:  MOVWF  xD9
0503C:  MOVLW  62
0503E:  MOVWF  xD8
05040:  MOVLW  02
05042:  MOVWF  xDB
05044:  MOVLW  E2
05046:  MOVWF  xDA
05048:  MOVLB  0
0504A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(355, OUT_2_2_FILTER_B2);     // OUT_2_2_FILTER_B2 
0504E:  MOVLW  01
05050:  MOVLB  6
05052:  MOVWF  xD9
05054:  MOVLW  63
05056:  MOVWF  xD8
05058:  MOVLW  02
0505A:  MOVWF  xDB
0505C:  MOVLW  E3
0505E:  MOVWF  xDA
05060:  MOVLB  0
05062:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(356, OUT_2_2_FILTER_NEGATIVEA1);     // OUT_2_2_FILTER_NEGATIVEA1 
05066:  MOVLW  01
05068:  MOVLB  6
0506A:  MOVWF  xD9
0506C:  MOVLW  64
0506E:  MOVWF  xD8
05070:  MOVLW  02
05072:  MOVWF  xDB
05074:  MOVLW  E4
05076:  MOVWF  xDA
05078:  MOVLB  0
0507A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(357, OUT_2_2_FILTER_NEGATIVEA2);     // OUT_2_2_FILTER_NEGATIVEA2 
0507E:  MOVLW  01
05080:  MOVLB  6
05082:  MOVWF  xD9
05084:  MOVLW  65
05086:  MOVWF  xD8
05088:  MOVLW  02
0508A:  MOVWF  xDB
0508C:  MOVLW  E5
0508E:  MOVWF  xDA
05090:  MOVLB  0
05092:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(358, OUT_2_3_FILTER_B0);     // OUT_2_3_FILTER_B0 
05096:  MOVLW  01
05098:  MOVLB  6
0509A:  MOVWF  xD9
0509C:  MOVLW  66
0509E:  MOVWF  xD8
050A0:  MOVLW  02
050A2:  MOVWF  xDB
050A4:  MOVLW  DC
050A6:  MOVWF  xDA
050A8:  MOVLB  0
050AA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(359, OUT_2_3_FILTER_B1);     // OUT_2_3_FILTER_B1 
050AE:  MOVLW  01
050B0:  MOVLB  6
050B2:  MOVWF  xD9
050B4:  MOVLW  67
050B6:  MOVWF  xD8
050B8:  MOVLW  02
050BA:  MOVWF  xDB
050BC:  MOVLW  DD
050BE:  MOVWF  xDA
050C0:  MOVLB  0
050C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(360, OUT_2_3_FILTER_B2);     // OUT_2_3_FILTER_B2 
050C6:  MOVLW  01
050C8:  MOVLB  6
050CA:  MOVWF  xD9
050CC:  MOVLW  68
050CE:  MOVWF  xD8
050D0:  MOVLW  02
050D2:  MOVWF  xDB
050D4:  MOVLW  DE
050D6:  MOVWF  xDA
050D8:  MOVLB  0
050DA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(361, OUT_2_3_FILTER_NEGATIVEA1);     // OUT_2_3_FILTER_NEGATIVEA1 
050DE:  MOVLW  01
050E0:  MOVLB  6
050E2:  MOVWF  xD9
050E4:  MOVLW  69
050E6:  MOVWF  xD8
050E8:  MOVLW  02
050EA:  MOVWF  xDB
050EC:  MOVLW  DF
050EE:  MOVWF  xDA
050F0:  MOVLB  0
050F2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(362, OUT_2_3_FILTER_NEGATIVEA2);     // OUT_2_3_FILTER_NEGATIVEA2 
050F6:  MOVLW  01
050F8:  MOVLB  6
050FA:  MOVWF  xD9
050FC:  MOVLW  6A
050FE:  MOVWF  xD8
05100:  MOVLW  02
05102:  MOVWF  xDB
05104:  MOVLW  E0
05106:  MOVWF  xDA
05108:  MOVLB  0
0510A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(363, OUT_2_4_FILTER_B0);     // OUT_2_4_FILTER_B0 
0510E:  MOVLW  01
05110:  MOVLB  6
05112:  MOVWF  xD9
05114:  MOVLW  6B
05116:  MOVWF  xD8
05118:  MOVLW  02
0511A:  MOVWF  xDB
0511C:  MOVLW  AA
0511E:  MOVWF  xDA
05120:  MOVLB  0
05122:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(364, OUT_2_4_FILTER_B1);     // OUT_2_4_FILTER_B1 
05126:  MOVLW  01
05128:  MOVLB  6
0512A:  MOVWF  xD9
0512C:  MOVLW  6C
0512E:  MOVWF  xD8
05130:  MOVLW  02
05132:  MOVWF  xDB
05134:  MOVLW  AB
05136:  MOVWF  xDA
05138:  MOVLB  0
0513A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(365, OUT_2_4_FILTER_B2);     // OUT_2_4_FILTER_B2 
0513E:  MOVLW  01
05140:  MOVLB  6
05142:  MOVWF  xD9
05144:  MOVLW  6D
05146:  MOVWF  xD8
05148:  MOVLW  02
0514A:  MOVWF  xDB
0514C:  MOVLW  AC
0514E:  MOVWF  xDA
05150:  MOVLB  0
05152:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(366, OUT_2_4_FILTER_NEGATIVEA1);     // OUT_2_4_FILTER_NEGATIVEA1 
05156:  MOVLW  01
05158:  MOVLB  6
0515A:  MOVWF  xD9
0515C:  MOVLW  6E
0515E:  MOVWF  xD8
05160:  MOVLW  02
05162:  MOVWF  xDB
05164:  MOVLW  AD
05166:  MOVWF  xDA
05168:  MOVLB  0
0516A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(367, OUT_2_4_FILTER_NEGATIVEA2);     // OUT_2_4_FILTER_NEGATIVEA2 
0516E:  MOVLW  01
05170:  MOVLB  6
05172:  MOVWF  xD9
05174:  MOVLW  6F
05176:  MOVWF  xD8
05178:  MOVLW  02
0517A:  MOVWF  xDB
0517C:  MOVLW  AE
0517E:  MOVWF  xDA
05180:  MOVLB  0
05182:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(368, OUT_2_5_FILTER_B0);     // OUT_2_5_FILTER_B0 
05186:  MOVLW  01
05188:  MOVLB  6
0518A:  MOVWF  xD9
0518C:  MOVLW  70
0518E:  MOVWF  xD8
05190:  MOVLW  02
05192:  MOVWF  xDB
05194:  MOVLW  A5
05196:  MOVWF  xDA
05198:  MOVLB  0
0519A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(369, OUT_2_5_FILTER_B1);     // OUT_2_5_FILTER_B1 
0519E:  MOVLW  01
051A0:  MOVLB  6
051A2:  MOVWF  xD9
051A4:  MOVLW  71
051A6:  MOVWF  xD8
051A8:  MOVLW  02
051AA:  MOVWF  xDB
051AC:  MOVLW  A6
051AE:  MOVWF  xDA
051B0:  MOVLB  0
051B2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(370, OUT_2_5_FILTER_B2);     // OUT_2_5_FILTER_B2 
051B6:  MOVLW  01
051B8:  MOVLB  6
051BA:  MOVWF  xD9
051BC:  MOVLW  72
051BE:  MOVWF  xD8
051C0:  MOVLW  02
051C2:  MOVWF  xDB
051C4:  MOVLW  A7
051C6:  MOVWF  xDA
051C8:  MOVLB  0
051CA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(371, OUT_2_5_FILTER_NEGATIVEA1);     // OUT_2_5_FILTER_NEGATIVEA1 
051CE:  MOVLW  01
051D0:  MOVLB  6
051D2:  MOVWF  xD9
051D4:  MOVLW  73
051D6:  MOVWF  xD8
051D8:  MOVLW  02
051DA:  MOVWF  xDB
051DC:  MOVLW  A8
051DE:  MOVWF  xDA
051E0:  MOVLB  0
051E2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(372, OUT_2_5_FILTER_NEGATIVEA2);     // OUT_2_5_FILTER_NEGATIVEA2 
051E6:  MOVLW  01
051E8:  MOVLB  6
051EA:  MOVWF  xD9
051EC:  MOVLW  74
051EE:  MOVWF  xD8
051F0:  MOVLW  02
051F2:  MOVWF  xDB
051F4:  MOVLW  A9
051F6:  MOVWF  xDA
051F8:  MOVLB  0
051FA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(373, OUT_2_6_FILTER_B0);     // OUT_2_6_FILTER_B0 
051FE:  MOVLW  01
05200:  MOVLB  6
05202:  MOVWF  xD9
05204:  MOVLW  75
05206:  MOVWF  xD8
05208:  MOVLW  02
0520A:  MOVWF  xDB
0520C:  MOVLW  A0
0520E:  MOVWF  xDA
05210:  MOVLB  0
05212:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(374, OUT_2_6_FILTER_B1);     // OUT_2_6_FILTER_B1 
05216:  MOVLW  01
05218:  MOVLB  6
0521A:  MOVWF  xD9
0521C:  MOVLW  76
0521E:  MOVWF  xD8
05220:  MOVLW  02
05222:  MOVWF  xDB
05224:  MOVLW  A1
05226:  MOVWF  xDA
05228:  MOVLB  0
0522A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(375, OUT_2_6_FILTER_B2);     // OUT_2_6_FILTER_B2 
0522E:  MOVLW  01
05230:  MOVLB  6
05232:  MOVWF  xD9
05234:  MOVLW  77
05236:  MOVWF  xD8
05238:  MOVLW  02
0523A:  MOVWF  xDB
0523C:  MOVLW  A2
0523E:  MOVWF  xDA
05240:  MOVLB  0
05242:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(376, OUT_2_6_FILTER_NEGATIVEA1);     // OUT_2_6_FILTER_NEGATIVEA1 
05246:  MOVLW  01
05248:  MOVLB  6
0524A:  MOVWF  xD9
0524C:  MOVLW  78
0524E:  MOVWF  xD8
05250:  MOVLW  02
05252:  MOVWF  xDB
05254:  MOVLW  A3
05256:  MOVWF  xDA
05258:  MOVLB  0
0525A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(377, OUT_2_6_FILTER_NEGATIVEA2);     // OUT_2_6_FILTER_NEGATIVEA2 
0525E:  MOVLW  01
05260:  MOVLB  6
05262:  MOVWF  xD9
05264:  MOVLW  79
05266:  MOVWF  xD8
05268:  MOVLW  02
0526A:  MOVWF  xDB
0526C:  MOVLW  A4
0526E:  MOVWF  xDA
05270:  MOVLB  0
05272:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(378, OUT_3_1_FILTER_B0);     // OUT_3_1_FILTER_B0 
05276:  MOVLW  01
05278:  MOVLB  6
0527A:  MOVWF  xD9
0527C:  MOVLW  7A
0527E:  MOVWF  xD8
05280:  MOVLW  02
05282:  MOVWF  xDB
05284:  MOVLW  D7
05286:  MOVWF  xDA
05288:  MOVLB  0
0528A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(379, OUT_3_1_FILTER_B1);     // OUT_3_1_FILTER_B1 
0528E:  MOVLW  01
05290:  MOVLB  6
05292:  MOVWF  xD9
05294:  MOVLW  7B
05296:  MOVWF  xD8
05298:  MOVLW  02
0529A:  MOVWF  xDB
0529C:  MOVLW  D8
0529E:  MOVWF  xDA
052A0:  MOVLB  0
052A2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(380, OUT_3_1_FILTER_B2);     // OUT_3_1_FILTER_B2 
052A6:  MOVLW  01
052A8:  MOVLB  6
052AA:  MOVWF  xD9
052AC:  MOVLW  7C
052AE:  MOVWF  xD8
052B0:  MOVLW  02
052B2:  MOVWF  xDB
052B4:  MOVLW  D9
052B6:  MOVWF  xDA
052B8:  MOVLB  0
052BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(381, OUT_3_1_FILTER_NEGATIVEA1);     // OUT_3_1_FILTER_NEGATIVEA1 
052BE:  MOVLW  01
052C0:  MOVLB  6
052C2:  MOVWF  xD9
052C4:  MOVLW  7D
052C6:  MOVWF  xD8
052C8:  MOVLW  02
052CA:  MOVWF  xDB
052CC:  MOVLW  DA
052CE:  MOVWF  xDA
052D0:  MOVLB  0
052D2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(382, OUT_3_1_FILTER_NEGATIVEA2);     // OUT_3_1_FILTER_NEGATIVEA2 
052D6:  MOVLW  01
052D8:  MOVLB  6
052DA:  MOVWF  xD9
052DC:  MOVLW  7E
052DE:  MOVWF  xD8
052E0:  MOVLW  02
052E2:  MOVWF  xDB
052E4:  MOVLW  DB
052E6:  MOVWF  xDA
052E8:  MOVLB  0
052EA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(383, OUT_3_2_FILTER_B0);     // OUT_3_2_FILTER_B0 
052EE:  MOVLW  01
052F0:  MOVLB  6
052F2:  MOVWF  xD9
052F4:  MOVLW  7F
052F6:  MOVWF  xD8
052F8:  MOVLW  02
052FA:  MOVWF  xDB
052FC:  MOVLW  D2
052FE:  MOVWF  xDA
05300:  MOVLB  0
05302:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(384, OUT_3_2_FILTER_B1);     // OUT_3_2_FILTER_B1 
05306:  MOVLW  01
05308:  MOVLB  6
0530A:  MOVWF  xD9
0530C:  MOVLW  80
0530E:  MOVWF  xD8
05310:  MOVLW  02
05312:  MOVWF  xDB
05314:  MOVLW  D3
05316:  MOVWF  xDA
05318:  MOVLB  0
0531A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(385, OUT_3_2_FILTER_B2);     // OUT_3_2_FILTER_B2 
0531E:  MOVLW  01
05320:  MOVLB  6
05322:  MOVWF  xD9
05324:  MOVLW  81
05326:  MOVWF  xD8
05328:  MOVLW  02
0532A:  MOVWF  xDB
0532C:  MOVLW  D4
0532E:  MOVWF  xDA
05330:  MOVLB  0
05332:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(386, OUT_3_2_FILTER_NEGATIVEA1);     // OUT_3_2_FILTER_NEGATIVEA1 
05336:  MOVLW  01
05338:  MOVLB  6
0533A:  MOVWF  xD9
0533C:  MOVLW  82
0533E:  MOVWF  xD8
05340:  MOVLW  02
05342:  MOVWF  xDB
05344:  MOVLW  D5
05346:  MOVWF  xDA
05348:  MOVLB  0
0534A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(387, OUT_3_2_FILTER_NEGATIVEA2);     // OUT_3_2_FILTER_NEGATIVEA2 
0534E:  MOVLW  01
05350:  MOVLB  6
05352:  MOVWF  xD9
05354:  MOVLW  83
05356:  MOVWF  xD8
05358:  MOVLW  02
0535A:  MOVWF  xDB
0535C:  MOVLW  D6
0535E:  MOVWF  xDA
05360:  MOVLB  0
05362:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(388, OUT_3_3_FILTER_B0);     // OUT_3_3_FILTER_B0 
05366:  MOVLW  01
05368:  MOVLB  6
0536A:  MOVWF  xD9
0536C:  MOVLW  84
0536E:  MOVWF  xD8
05370:  MOVLW  02
05372:  MOVWF  xDB
05374:  MOVLW  CD
05376:  MOVWF  xDA
05378:  MOVLB  0
0537A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(389, OUT_3_3_FILTER_B1);     // OUT_3_3_FILTER_B1 
0537E:  MOVLW  01
05380:  MOVLB  6
05382:  MOVWF  xD9
05384:  MOVLW  85
05386:  MOVWF  xD8
05388:  MOVLW  02
0538A:  MOVWF  xDB
0538C:  MOVLW  CE
0538E:  MOVWF  xDA
05390:  MOVLB  0
05392:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(390, OUT_3_3_FILTER_B2);     // OUT_3_3_FILTER_B2 
05396:  MOVLW  01
05398:  MOVLB  6
0539A:  MOVWF  xD9
0539C:  MOVLW  86
0539E:  MOVWF  xD8
053A0:  MOVLW  02
053A2:  MOVWF  xDB
053A4:  MOVLW  CF
053A6:  MOVWF  xDA
053A8:  MOVLB  0
053AA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(391, OUT_3_3_FILTER_NEGATIVEA1);     // OUT_3_3_FILTER_NEGATIVEA1 
053AE:  MOVLW  01
053B0:  MOVLB  6
053B2:  MOVWF  xD9
053B4:  MOVLW  87
053B6:  MOVWF  xD8
053B8:  MOVLW  02
053BA:  MOVWF  xDB
053BC:  MOVLW  D0
053BE:  MOVWF  xDA
053C0:  MOVLB  0
053C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(392, OUT_3_3_FILTER_NEGATIVEA2);     // OUT_3_3_FILTER_NEGATIVEA2 
053C6:  MOVLW  01
053C8:  MOVLB  6
053CA:  MOVWF  xD9
053CC:  MOVLW  88
053CE:  MOVWF  xD8
053D0:  MOVLW  02
053D2:  MOVWF  xDB
053D4:  MOVLW  D1
053D6:  MOVWF  xDA
053D8:  MOVLB  0
053DA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(393, OUT_3_4_FILTER_B0);     // OUT_3_4_FILTER_B0 
053DE:  MOVLW  01
053E0:  MOVLB  6
053E2:  MOVWF  xD9
053E4:  MOVLW  89
053E6:  MOVWF  xD8
053E8:  MOVLW  02
053EA:  MOVWF  xDB
053EC:  MOVLW  9B
053EE:  MOVWF  xDA
053F0:  MOVLB  0
053F2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(394, OUT_3_4_FILTER_B1);     // OUT_3_4_FILTER_B1 
053F6:  MOVLW  01
053F8:  MOVLB  6
053FA:  MOVWF  xD9
053FC:  MOVLW  8A
053FE:  MOVWF  xD8
05400:  MOVLW  02
05402:  MOVWF  xDB
05404:  MOVLW  9C
05406:  MOVWF  xDA
05408:  MOVLB  0
0540A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(395, OUT_3_4_FILTER_B2);     // OUT_3_4_FILTER_B2 
0540E:  MOVLW  01
05410:  MOVLB  6
05412:  MOVWF  xD9
05414:  MOVLW  8B
05416:  MOVWF  xD8
05418:  MOVLW  02
0541A:  MOVWF  xDB
0541C:  MOVLW  9D
0541E:  MOVWF  xDA
05420:  MOVLB  0
05422:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(396, OUT_3_4_FILTER_NEGATIVEA1);     // OUT_3_4_FILTER_NEGATIVEA1 
05426:  MOVLW  01
05428:  MOVLB  6
0542A:  MOVWF  xD9
0542C:  MOVLW  8C
0542E:  MOVWF  xD8
05430:  MOVLW  02
05432:  MOVWF  xDB
05434:  MOVLW  9E
05436:  MOVWF  xDA
05438:  MOVLB  0
0543A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(397, OUT_3_4_FILTER_NEGATIVEA2);     // OUT_3_4_FILTER_NEGATIVEA2 
0543E:  MOVLW  01
05440:  MOVLB  6
05442:  MOVWF  xD9
05444:  MOVLW  8D
05446:  MOVWF  xD8
05448:  MOVLW  02
0544A:  MOVWF  xDB
0544C:  MOVLW  9F
0544E:  MOVWF  xDA
05450:  MOVLB  0
05452:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(398, OUT_3_5_FILTER_B0);     // OUT_3_5_FILTER_B0 
05456:  MOVLW  01
05458:  MOVLB  6
0545A:  MOVWF  xD9
0545C:  MOVLW  8E
0545E:  MOVWF  xD8
05460:  MOVLW  02
05462:  MOVWF  xDB
05464:  MOVLW  96
05466:  MOVWF  xDA
05468:  MOVLB  0
0546A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(399, OUT_3_5_FILTER_B1);     // OUT_3_5_FILTER_B1 
0546E:  MOVLW  01
05470:  MOVLB  6
05472:  MOVWF  xD9
05474:  MOVLW  8F
05476:  MOVWF  xD8
05478:  MOVLW  02
0547A:  MOVWF  xDB
0547C:  MOVLW  97
0547E:  MOVWF  xDA
05480:  MOVLB  0
05482:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(400, OUT_3_5_FILTER_B2);     // OUT_3_5_FILTER_B2 
05486:  MOVLW  01
05488:  MOVLB  6
0548A:  MOVWF  xD9
0548C:  MOVLW  90
0548E:  MOVWF  xD8
05490:  MOVLW  02
05492:  MOVWF  xDB
05494:  MOVLW  98
05496:  MOVWF  xDA
05498:  MOVLB  0
0549A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(401, OUT_3_5_FILTER_NEGATIVEA1);     // OUT_3_5_FILTER_NEGATIVEA1 
0549E:  MOVLW  01
054A0:  MOVLB  6
054A2:  MOVWF  xD9
054A4:  MOVLW  91
054A6:  MOVWF  xD8
054A8:  MOVLW  02
054AA:  MOVWF  xDB
054AC:  MOVLW  99
054AE:  MOVWF  xDA
054B0:  MOVLB  0
054B2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(402, OUT_3_5_FILTER_NEGATIVEA2);     // OUT_3_5_FILTER_NEGATIVEA2 
054B6:  MOVLW  01
054B8:  MOVLB  6
054BA:  MOVWF  xD9
054BC:  MOVLW  92
054BE:  MOVWF  xD8
054C0:  MOVLW  02
054C2:  MOVWF  xDB
054C4:  MOVLW  9A
054C6:  MOVWF  xDA
054C8:  MOVLB  0
054CA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(403, OUT_3_6_FILTER_B0);     // OUT_3_6_FILTER_B0 
054CE:  MOVLW  01
054D0:  MOVLB  6
054D2:  MOVWF  xD9
054D4:  MOVLW  93
054D6:  MOVWF  xD8
054D8:  MOVLW  02
054DA:  MOVWF  xDB
054DC:  MOVLW  91
054DE:  MOVWF  xDA
054E0:  MOVLB  0
054E2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(404, OUT_3_6_FILTER_B1);     // OUT_3_6_FILTER_B1 
054E6:  MOVLW  01
054E8:  MOVLB  6
054EA:  MOVWF  xD9
054EC:  MOVLW  94
054EE:  MOVWF  xD8
054F0:  MOVLW  02
054F2:  MOVWF  xDB
054F4:  MOVLW  92
054F6:  MOVWF  xDA
054F8:  MOVLB  0
054FA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(405, OUT_3_6_FILTER_B2);     // OUT_3_6_FILTER_B2 
054FE:  MOVLW  01
05500:  MOVLB  6
05502:  MOVWF  xD9
05504:  MOVLW  95
05506:  MOVWF  xD8
05508:  MOVLW  02
0550A:  MOVWF  xDB
0550C:  MOVLW  93
0550E:  MOVWF  xDA
05510:  MOVLB  0
05512:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(406, OUT_3_6_FILTER_NEGATIVEA1);     // OUT_3_6_FILTER_NEGATIVEA1 
05516:  MOVLW  01
05518:  MOVLB  6
0551A:  MOVWF  xD9
0551C:  MOVLW  96
0551E:  MOVWF  xD8
05520:  MOVLW  02
05522:  MOVWF  xDB
05524:  MOVLW  94
05526:  MOVWF  xDA
05528:  MOVLB  0
0552A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(407, OUT_3_6_FILTER_NEGATIVEA2);     // OUT_3_6_FILTER_NEGATIVEA2 
0552E:  MOVLW  01
05530:  MOVLB  6
05532:  MOVWF  xD9
05534:  MOVLW  97
05536:  MOVWF  xD8
05538:  MOVLW  02
0553A:  MOVWF  xDB
0553C:  MOVLW  95
0553E:  MOVWF  xDA
05540:  MOVLB  0
05542:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(408, OUT_4_1_FILTER_B0);     // OUT_4_1_FILTER_B0 
05546:  MOVLW  01
05548:  MOVLB  6
0554A:  MOVWF  xD9
0554C:  MOVLW  98
0554E:  MOVWF  xD8
05550:  MOVLW  02
05552:  MOVWF  xDB
05554:  MOVLW  C8
05556:  MOVWF  xDA
05558:  MOVLB  0
0555A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(409, OUT_4_1_FILTER_B1);     // OUT_4_1_FILTER_B1 
0555E:  MOVLW  01
05560:  MOVLB  6
05562:  MOVWF  xD9
05564:  MOVLW  99
05566:  MOVWF  xD8
05568:  MOVLW  02
0556A:  MOVWF  xDB
0556C:  MOVLW  C9
0556E:  MOVWF  xDA
05570:  MOVLB  0
05572:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(410, OUT_4_1_FILTER_B2);     // OUT_4_1_FILTER_B2 
05576:  MOVLW  01
05578:  MOVLB  6
0557A:  MOVWF  xD9
0557C:  MOVLW  9A
0557E:  MOVWF  xD8
05580:  MOVLW  02
05582:  MOVWF  xDB
05584:  MOVLW  CA
05586:  MOVWF  xDA
05588:  MOVLB  0
0558A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(411, OUT_4_1_FILTER_NEGATIVEA1);     // OUT_4_1_FILTER_NEGATIVEA1 
0558E:  MOVLW  01
05590:  MOVLB  6
05592:  MOVWF  xD9
05594:  MOVLW  9B
05596:  MOVWF  xD8
05598:  MOVLW  02
0559A:  MOVWF  xDB
0559C:  MOVLW  CB
0559E:  MOVWF  xDA
055A0:  MOVLB  0
055A2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(412, OUT_4_1_FILTER_NEGATIVEA2);     // OUT_4_1_FILTER_NEGATIVEA2 
055A6:  MOVLW  01
055A8:  MOVLB  6
055AA:  MOVWF  xD9
055AC:  MOVLW  9C
055AE:  MOVWF  xD8
055B0:  MOVLW  02
055B2:  MOVWF  xDB
055B4:  MOVLW  CC
055B6:  MOVWF  xDA
055B8:  MOVLB  0
055BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(413, OUT_4_2_FILTER_B0);     // OUT_4_2_FILTER_B0 
055BE:  MOVLW  01
055C0:  MOVLB  6
055C2:  MOVWF  xD9
055C4:  MOVLW  9D
055C6:  MOVWF  xD8
055C8:  MOVLW  02
055CA:  MOVWF  xDB
055CC:  MOVLW  C3
055CE:  MOVWF  xDA
055D0:  MOVLB  0
055D2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(414, OUT_4_2_FILTER_B1);     // OUT_4_2_FILTER_B1 
055D6:  MOVLW  01
055D8:  MOVLB  6
055DA:  MOVWF  xD9
055DC:  MOVLW  9E
055DE:  MOVWF  xD8
055E0:  MOVLW  02
055E2:  MOVWF  xDB
055E4:  MOVLW  C4
055E6:  MOVWF  xDA
055E8:  MOVLB  0
055EA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(415, OUT_4_2_FILTER_B2);     // OUT_4_2_FILTER_B2 
055EE:  MOVLW  01
055F0:  MOVLB  6
055F2:  MOVWF  xD9
055F4:  MOVLW  9F
055F6:  MOVWF  xD8
055F8:  MOVLW  02
055FA:  MOVWF  xDB
055FC:  MOVLW  C5
055FE:  MOVWF  xDA
05600:  MOVLB  0
05602:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(416, OUT_4_2_FILTER_NEGATIVEA1);     // OUT_4_2_FILTER_NEGATIVEA1 
05606:  MOVLW  01
05608:  MOVLB  6
0560A:  MOVWF  xD9
0560C:  MOVLW  A0
0560E:  MOVWF  xD8
05610:  MOVLW  02
05612:  MOVWF  xDB
05614:  MOVLW  C6
05616:  MOVWF  xDA
05618:  MOVLB  0
0561A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(417, OUT_4_2_FILTER_NEGATIVEA2);     // OUT_4_2_FILTER_NEGATIVEA2 
0561E:  MOVLW  01
05620:  MOVLB  6
05622:  MOVWF  xD9
05624:  MOVLW  A1
05626:  MOVWF  xD8
05628:  MOVLW  02
0562A:  MOVWF  xDB
0562C:  MOVLW  C7
0562E:  MOVWF  xDA
05630:  MOVLB  0
05632:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(418, OUT_4_3_FILTER_B0);     // OUT_4_3_FILTER_B0 
05636:  MOVLW  01
05638:  MOVLB  6
0563A:  MOVWF  xD9
0563C:  MOVLW  A2
0563E:  MOVWF  xD8
05640:  MOVLW  02
05642:  MOVWF  xDB
05644:  MOVLW  BE
05646:  MOVWF  xDA
05648:  MOVLB  0
0564A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(419, OUT_4_3_FILTER_B1);     // OUT_4_3_FILTER_B1 
0564E:  MOVLW  01
05650:  MOVLB  6
05652:  MOVWF  xD9
05654:  MOVLW  A3
05656:  MOVWF  xD8
05658:  MOVLW  02
0565A:  MOVWF  xDB
0565C:  MOVLW  BF
0565E:  MOVWF  xDA
05660:  MOVLB  0
05662:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(420, OUT_4_3_FILTER_B2);     // OUT_4_3_FILTER_B2 
05666:  MOVLW  01
05668:  MOVLB  6
0566A:  MOVWF  xD9
0566C:  MOVLW  A4
0566E:  MOVWF  xD8
05670:  MOVLW  02
05672:  MOVWF  xDB
05674:  MOVLW  C0
05676:  MOVWF  xDA
05678:  MOVLB  0
0567A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(421, OUT_4_3_FILTER_NEGATIVEA1);     // OUT_4_3_FILTER_NEGATIVEA1 
0567E:  MOVLW  01
05680:  MOVLB  6
05682:  MOVWF  xD9
05684:  MOVLW  A5
05686:  MOVWF  xD8
05688:  MOVLW  02
0568A:  MOVWF  xDB
0568C:  MOVLW  C1
0568E:  MOVWF  xDA
05690:  MOVLB  0
05692:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(422, OUT_4_3_FILTER_NEGATIVEA2);     // OUT_4_3_FILTER_NEGATIVEA2 
05696:  MOVLW  01
05698:  MOVLB  6
0569A:  MOVWF  xD9
0569C:  MOVLW  A6
0569E:  MOVWF  xD8
056A0:  MOVLW  02
056A2:  MOVWF  xDB
056A4:  MOVLW  C2
056A6:  MOVWF  xDA
056A8:  MOVLB  0
056AA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(423, OUT_4_4_FILTER_B0);     // OUT_4_4_FILTER_B0 
056AE:  MOVLW  01
056B0:  MOVLB  6
056B2:  MOVWF  xD9
056B4:  MOVLW  A7
056B6:  MOVWF  xD8
056B8:  MOVLW  02
056BA:  MOVWF  xDB
056BC:  MOVLW  8C
056BE:  MOVWF  xDA
056C0:  MOVLB  0
056C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(424, OUT_4_4_FILTER_B1);     // OUT_4_4_FILTER_B1 
056C6:  MOVLW  01
056C8:  MOVLB  6
056CA:  MOVWF  xD9
056CC:  MOVLW  A8
056CE:  MOVWF  xD8
056D0:  MOVLW  02
056D2:  MOVWF  xDB
056D4:  MOVLW  8D
056D6:  MOVWF  xDA
056D8:  MOVLB  0
056DA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(425, OUT_4_4_FILTER_B2);     // OUT_4_4_FILTER_B2 
056DE:  MOVLW  01
056E0:  MOVLB  6
056E2:  MOVWF  xD9
056E4:  MOVLW  A9
056E6:  MOVWF  xD8
056E8:  MOVLW  02
056EA:  MOVWF  xDB
056EC:  MOVLW  8E
056EE:  MOVWF  xDA
056F0:  MOVLB  0
056F2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(426, OUT_4_4_FILTER_NEGATIVEA1);     // OUT_4_4_FILTER_NEGATIVEA1 
056F6:  MOVLW  01
056F8:  MOVLB  6
056FA:  MOVWF  xD9
056FC:  MOVLW  AA
056FE:  MOVWF  xD8
05700:  MOVLW  02
05702:  MOVWF  xDB
05704:  MOVLW  8F
05706:  MOVWF  xDA
05708:  MOVLB  0
0570A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(427, OUT_4_4_FILTER_NEGATIVEA2);     // OUT_4_4_FILTER_NEGATIVEA2 
0570E:  MOVLW  01
05710:  MOVLB  6
05712:  MOVWF  xD9
05714:  MOVLW  AB
05716:  MOVWF  xD8
05718:  MOVLW  02
0571A:  MOVWF  xDB
0571C:  MOVLW  90
0571E:  MOVWF  xDA
05720:  MOVLB  0
05722:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(428, OUT_4_5_FILTER_B0);     // OUT_4_5_FILTER_B0 
05726:  MOVLW  01
05728:  MOVLB  6
0572A:  MOVWF  xD9
0572C:  MOVLW  AC
0572E:  MOVWF  xD8
05730:  MOVLW  02
05732:  MOVWF  xDB
05734:  MOVLW  87
05736:  MOVWF  xDA
05738:  MOVLB  0
0573A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(429, OUT_4_5_FILTER_B1);     // OUT_4_5_FILTER_B1 
0573E:  MOVLW  01
05740:  MOVLB  6
05742:  MOVWF  xD9
05744:  MOVLW  AD
05746:  MOVWF  xD8
05748:  MOVLW  02
0574A:  MOVWF  xDB
0574C:  MOVLW  88
0574E:  MOVWF  xDA
05750:  MOVLB  0
05752:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(430, OUT_4_5_FILTER_B2);     // OUT_4_5_FILTER_B2 
05756:  MOVLW  01
05758:  MOVLB  6
0575A:  MOVWF  xD9
0575C:  MOVLW  AE
0575E:  MOVWF  xD8
05760:  MOVLW  02
05762:  MOVWF  xDB
05764:  MOVLW  89
05766:  MOVWF  xDA
05768:  MOVLB  0
0576A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(431, OUT_4_5_FILTER_NEGATIVEA1);     // OUT_4_5_FILTER_NEGATIVEA1 
0576E:  MOVLW  01
05770:  MOVLB  6
05772:  MOVWF  xD9
05774:  MOVLW  AF
05776:  MOVWF  xD8
05778:  MOVLW  02
0577A:  MOVWF  xDB
0577C:  MOVLW  8A
0577E:  MOVWF  xDA
05780:  MOVLB  0
05782:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(432, OUT_4_5_FILTER_NEGATIVEA2);     // OUT_4_5_FILTER_NEGATIVEA2 
05786:  MOVLW  01
05788:  MOVLB  6
0578A:  MOVWF  xD9
0578C:  MOVLW  B0
0578E:  MOVWF  xD8
05790:  MOVLW  02
05792:  MOVWF  xDB
05794:  MOVLW  8B
05796:  MOVWF  xDA
05798:  MOVLB  0
0579A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(433, OUT_4_6_FILTER_B0);     // OUT_4_6_FILTER_B0 
0579E:  MOVLW  01
057A0:  MOVLB  6
057A2:  MOVWF  xD9
057A4:  MOVLW  B1
057A6:  MOVWF  xD8
057A8:  MOVLW  02
057AA:  MOVWF  xDB
057AC:  MOVLW  82
057AE:  MOVWF  xDA
057B0:  MOVLB  0
057B2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(434, OUT_4_6_FILTER_B1);     // OUT_4_6_FILTER_B1 
057B6:  MOVLW  01
057B8:  MOVLB  6
057BA:  MOVWF  xD9
057BC:  MOVLW  B2
057BE:  MOVWF  xD8
057C0:  MOVLW  02
057C2:  MOVWF  xDB
057C4:  MOVLW  83
057C6:  MOVWF  xDA
057C8:  MOVLB  0
057CA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(435, OUT_4_6_FILTER_B2);     // OUT_4_6_FILTER_B2 
057CE:  MOVLW  01
057D0:  MOVLB  6
057D2:  MOVWF  xD9
057D4:  MOVLW  B3
057D6:  MOVWF  xD8
057D8:  MOVLW  02
057DA:  MOVWF  xDB
057DC:  MOVLW  84
057DE:  MOVWF  xDA
057E0:  MOVLB  0
057E2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(436, OUT_4_6_FILTER_NEGATIVEA1);     // OUT_4_6_FILTER_NEGATIVEA1 
057E6:  MOVLW  01
057E8:  MOVLB  6
057EA:  MOVWF  xD9
057EC:  MOVLW  B4
057EE:  MOVWF  xD8
057F0:  MOVLW  02
057F2:  MOVWF  xDB
057F4:  MOVLW  85
057F6:  MOVWF  xDA
057F8:  MOVLB  0
057FA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(437, OUT_4_6_FILTER_NEGATIVEA2);     // OUT_4_6_FILTER_NEGATIVEA2 
057FE:  MOVLW  01
05800:  MOVLB  6
05802:  MOVWF  xD9
05804:  MOVLW  B5
05806:  MOVWF  xD8
05808:  MOVLW  02
0580A:  MOVWF  xDB
0580C:  MOVLW  86
0580E:  MOVWF  xDA
05810:  MOVLB  0
05812:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(438, CH1LIM_THRESHOLD);     // CH1LIM_THRESHOLD 
05816:  MOVLW  01
05818:  MOVLB  6
0581A:  MOVWF  xD9
0581C:  MOVLW  B6
0581E:  MOVWF  xD8
05820:  MOVLW  02
05822:  MOVWF  xDB
05824:  MOVLW  2E
05826:  MOVWF  xDA
05828:  MOVLB  0
0582A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(439, CH1LIM_KNEE);     // CH1LIM_KNEE 
0582E:  MOVLW  01
05830:  MOVLB  6
05832:  MOVWF  xD9
05834:  MOVLW  B7
05836:  MOVWF  xD8
05838:  MOVLW  02
0583A:  MOVWF  xDB
0583C:  MOVLW  2F
0583E:  MOVWF  xDA
05840:  MOVLB  0
05842:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(440, CH1LIM_RATIO);     // CH1LIM_RATIO 
05846:  MOVLW  01
05848:  MOVLB  6
0584A:  MOVWF  xD9
0584C:  MOVLW  B8
0584E:  MOVWF  xD8
05850:  MOVLW  02
05852:  MOVWF  xDB
05854:  MOVLW  30
05856:  MOVWF  xDA
05858:  MOVLB  0
0585A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(441, CH1LIM_ATTACK);     // CH1LIM_ATTACK 
0585E:  MOVLW  01
05860:  MOVLB  6
05862:  MOVWF  xD9
05864:  MOVLW  B9
05866:  MOVWF  xD8
05868:  MOVLW  02
0586A:  MOVWF  xDB
0586C:  MOVLW  31
0586E:  MOVWF  xDA
05870:  MOVLB  0
05872:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(442, CH1LIM_RELEASE);     // CH1LIM_RELEASE 
05876:  MOVLW  01
05878:  MOVLB  6
0587A:  MOVWF  xD9
0587C:  MOVLW  BA
0587E:  MOVWF  xD8
05880:  MOVLW  02
05882:  MOVWF  xDB
05884:  MOVLW  32
05886:  MOVWF  xDA
05888:  MOVLB  0
0588A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(443, CH1LIM_BYPASS);     // CH1LIM_BYPASS 
0588E:  MOVLW  01
05890:  MOVLB  6
05892:  MOVWF  xD9
05894:  MOVLW  BB
05896:  MOVWF  xD8
05898:  MOVLW  02
0589A:  MOVWF  xDB
0589C:  MOVLW  33
0589E:  MOVWF  xDA
058A0:  MOVLB  0
058A2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(444, CH2LIM_THRESHOLD);     // CH2LIM_THRESHOLD 
058A6:  MOVLW  01
058A8:  MOVLB  6
058AA:  MOVWF  xD9
058AC:  MOVLW  BC
058AE:  MOVWF  xD8
058B0:  MOVLW  02
058B2:  MOVWF  xDB
058B4:  MOVLW  26
058B6:  MOVWF  xDA
058B8:  MOVLB  0
058BA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(445, CH2LIM_KNEE);     // CH2LIM_KNEE 
058BE:  MOVLW  01
058C0:  MOVLB  6
058C2:  MOVWF  xD9
058C4:  MOVLW  BD
058C6:  MOVWF  xD8
058C8:  MOVLW  02
058CA:  MOVWF  xDB
058CC:  MOVLW  27
058CE:  MOVWF  xDA
058D0:  MOVLB  0
058D2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(446, CH2LIM_RATIO);     // CH2LIM_RATIO 
058D6:  MOVLW  01
058D8:  MOVLB  6
058DA:  MOVWF  xD9
058DC:  MOVLW  BE
058DE:  MOVWF  xD8
058E0:  MOVLW  02
058E2:  MOVWF  xDB
058E4:  MOVLW  28
058E6:  MOVWF  xDA
058E8:  MOVLB  0
058EA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(447, CH2LIM_ATTACK);     // CH2LIM_ATTACK 
058EE:  MOVLW  01
058F0:  MOVLB  6
058F2:  MOVWF  xD9
058F4:  MOVLW  BF
058F6:  MOVWF  xD8
058F8:  MOVLW  02
058FA:  MOVWF  xDB
058FC:  MOVLW  29
058FE:  MOVWF  xDA
05900:  MOVLB  0
05902:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(448, CH2LIM_RELEASE);     // CH2LIM_RELEASE 
05906:  MOVLW  01
05908:  MOVLB  6
0590A:  MOVWF  xD9
0590C:  MOVLW  C0
0590E:  MOVWF  xD8
05910:  MOVLW  02
05912:  MOVWF  xDB
05914:  MOVLW  2A
05916:  MOVWF  xDA
05918:  MOVLB  0
0591A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(449, CH2LIM_BYPASS);     // CH2LIM_BYPASS 
0591E:  MOVLW  01
05920:  MOVLB  6
05922:  MOVWF  xD9
05924:  MOVLW  C1
05926:  MOVWF  xD8
05928:  MOVLW  02
0592A:  MOVWF  xDB
0592C:  MOVLW  2B
0592E:  MOVWF  xDA
05930:  MOVLB  0
05932:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(450, CH3LIM_THRESHOLD);     // CH3LIM_THRESHOLD 
05936:  MOVLW  01
05938:  MOVLB  6
0593A:  MOVWF  xD9
0593C:  MOVLW  C2
0593E:  MOVWF  xD8
05940:  MOVLW  02
05942:  MOVWF  xDB
05944:  MOVLW  1E
05946:  MOVWF  xDA
05948:  MOVLB  0
0594A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(451, CH3LIM_KNEE);     // CH3LIM_KNEE 
0594E:  MOVLW  01
05950:  MOVLB  6
05952:  MOVWF  xD9
05954:  MOVLW  C3
05956:  MOVWF  xD8
05958:  MOVLW  02
0595A:  MOVWF  xDB
0595C:  MOVLW  1F
0595E:  MOVWF  xDA
05960:  MOVLB  0
05962:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(452, CH3LIM_RATIO);     // CH3LIM_RATIO 
05966:  MOVLW  01
05968:  MOVLB  6
0596A:  MOVWF  xD9
0596C:  MOVLW  C4
0596E:  MOVWF  xD8
05970:  MOVLW  02
05972:  MOVWF  xDB
05974:  MOVLW  20
05976:  MOVWF  xDA
05978:  MOVLB  0
0597A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(453, CH3LIM_ATTACK);     // CH3LIM_ATTACK 
0597E:  MOVLW  01
05980:  MOVLB  6
05982:  MOVWF  xD9
05984:  MOVLW  C5
05986:  MOVWF  xD8
05988:  MOVLW  02
0598A:  MOVWF  xDB
0598C:  MOVLW  21
0598E:  MOVWF  xDA
05990:  MOVLB  0
05992:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(454, CH3LIM_RELEASE);     // CH3LIM_RELEASE 
05996:  MOVLW  01
05998:  MOVLB  6
0599A:  MOVWF  xD9
0599C:  MOVLW  C6
0599E:  MOVWF  xD8
059A0:  MOVLW  02
059A2:  MOVWF  xDB
059A4:  MOVLW  22
059A6:  MOVWF  xDA
059A8:  MOVLB  0
059AA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(455, CH3LIM_BYPASS);     // CH3LIM_BYPASS 
059AE:  MOVLW  01
059B0:  MOVLB  6
059B2:  MOVWF  xD9
059B4:  MOVLW  C7
059B6:  MOVWF  xD8
059B8:  MOVLW  02
059BA:  MOVWF  xDB
059BC:  MOVLW  23
059BE:  MOVWF  xDA
059C0:  MOVLB  0
059C2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(456, CH4LIM_THRESHOLD);     // CH4LIM_THRESHOLD 
059C6:  MOVLW  01
059C8:  MOVLB  6
059CA:  MOVWF  xD9
059CC:  MOVLW  C8
059CE:  MOVWF  xD8
059D0:  MOVLW  02
059D2:  MOVWF  xDB
059D4:  MOVLW  16
059D6:  MOVWF  xDA
059D8:  MOVLB  0
059DA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(457, CH4LIM_KNEE);     // CH4LIM_KNEE 
059DE:  MOVLW  01
059E0:  MOVLB  6
059E2:  MOVWF  xD9
059E4:  MOVLW  C9
059E6:  MOVWF  xD8
059E8:  MOVLW  02
059EA:  MOVWF  xDB
059EC:  MOVLW  17
059EE:  MOVWF  xDA
059F0:  MOVLB  0
059F2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(458, CH4LIM_RATIO);     // CH4LIM_RATIO 
059F6:  MOVLW  01
059F8:  MOVLB  6
059FA:  MOVWF  xD9
059FC:  MOVLW  CA
059FE:  MOVWF  xD8
05A00:  MOVLW  02
05A02:  MOVWF  xDB
05A04:  MOVLW  18
05A06:  MOVWF  xDA
05A08:  MOVLB  0
05A0A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(459, CH4LIM_ATTACK);     // CH4LIM_ATTACK 
05A0E:  MOVLW  01
05A10:  MOVLB  6
05A12:  MOVWF  xD9
05A14:  MOVLW  CB
05A16:  MOVWF  xD8
05A18:  MOVLW  02
05A1A:  MOVWF  xDB
05A1C:  MOVLW  19
05A1E:  MOVWF  xDA
05A20:  MOVLB  0
05A22:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(460, CH4LIM_RELEASE);     // CH4LIM_RELEASE 
05A26:  MOVLW  01
05A28:  MOVLB  6
05A2A:  MOVWF  xD9
05A2C:  MOVLW  CC
05A2E:  MOVWF  xD8
05A30:  MOVLW  02
05A32:  MOVWF  xDB
05A34:  MOVLW  1A
05A36:  MOVWF  xDA
05A38:  MOVLB  0
05A3A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(461, CH4LIM_BYPASS);     // CH4LIM_BYPASS 
05A3E:  MOVLW  01
05A40:  MOVLB  6
05A42:  MOVWF  xD9
05A44:  MOVLW  CD
05A46:  MOVWF  xD8
05A48:  MOVLW  02
05A4A:  MOVWF  xDB
05A4C:  MOVLW  1B
05A4E:  MOVWF  xDA
05A50:  MOVLB  0
05A52:  CALL   3080
....................  
.................... 	WRITE_CONFIG_ADDRESS(462, DELAY_CH1);     // DELAY_CH1 
05A56:  MOVLW  01
05A58:  MOVLB  6
05A5A:  MOVWF  xD9
05A5C:  MOVLW  CE
05A5E:  MOVWF  xD8
05A60:  MOVLW  03
05A62:  MOVWF  xDB
05A64:  MOVLW  DD
05A66:  MOVWF  xDA
05A68:  MOVLB  0
05A6A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(463, DELAY_BYPASS_CH1);     // DELAY_BYPASS_CH1 
05A6E:  MOVLW  01
05A70:  MOVLB  6
05A72:  MOVWF  xD9
05A74:  MOVLW  CF
05A76:  MOVWF  xD8
05A78:  MOVLW  04
05A7A:  MOVWF  xDB
05A7C:  MOVLW  48
05A7E:  MOVWF  xDA
05A80:  MOVLB  0
05A82:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(464, DELAY_CH2);     // DELAY_CH2 
05A86:  MOVLW  01
05A88:  MOVLB  6
05A8A:  MOVWF  xD9
05A8C:  MOVLW  D0
05A8E:  MOVWF  xD8
05A90:  MOVLW  03
05A92:  MOVWF  xDB
05A94:  MOVLW  DA
05A96:  MOVWF  xDA
05A98:  MOVLB  0
05A9A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(465, DELAY_BYPASS_CH2);     // DELAY_BYPASS_CH2 
05A9E:  MOVLW  01
05AA0:  MOVLB  6
05AA2:  MOVWF  xD9
05AA4:  MOVLW  D1
05AA6:  MOVWF  xD8
05AA8:  MOVLW  04
05AAA:  MOVWF  xDB
05AAC:  MOVLW  47
05AAE:  MOVWF  xDA
05AB0:  MOVLB  0
05AB2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(466, DELAY_CH3);     // DELAY_CH3 
05AB6:  MOVLW  01
05AB8:  MOVLB  6
05ABA:  MOVWF  xD9
05ABC:  MOVLW  D2
05ABE:  MOVWF  xD8
05AC0:  MOVLW  03
05AC2:  MOVWF  xDB
05AC4:  MOVLW  D7
05AC6:  MOVWF  xDA
05AC8:  MOVLB  0
05ACA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(467, DELAY_BYPASS_CH3);     // DELAY_BYPASS_CH3 
05ACE:  MOVLW  01
05AD0:  MOVLB  6
05AD2:  MOVWF  xD9
05AD4:  MOVLW  D3
05AD6:  MOVWF  xD8
05AD8:  MOVLW  04
05ADA:  MOVWF  xDB
05ADC:  MOVLW  46
05ADE:  MOVWF  xDA
05AE0:  MOVLB  0
05AE2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(468, DELAY_CH4);     // DELAY_CH4 
05AE6:  MOVLW  01
05AE8:  MOVLB  6
05AEA:  MOVWF  xD9
05AEC:  MOVLW  D4
05AEE:  MOVWF  xD8
05AF0:  MOVLW  03
05AF2:  MOVWF  xDB
05AF4:  MOVLW  D4
05AF6:  MOVWF  xDA
05AF8:  MOVLB  0
05AFA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(469, DELAY_BYPASS_CH4);     // DELAY_BYPASS_CH4 
05AFE:  MOVLW  01
05B00:  MOVLB  6
05B02:  MOVWF  xD9
05B04:  MOVLW  D5
05B06:  MOVWF  xD8
05B08:  MOVLW  04
05B0A:  MOVWF  xDB
05B0C:  MOVLW  45
05B0E:  MOVWF  xDA
05B10:  MOVLB  0
05B12:  CALL   3080
.................... 	 
.................... 	WRITE_CONFIG_ADDRESS(470, BRIDGEROUTER_SELECT0);     // BRIDGEROUTER_SELECT0 
05B16:  MOVLW  01
05B18:  MOVLB  6
05B1A:  MOVWF  xD9
05B1C:  MOVLW  D6
05B1E:  MOVWF  xD8
05B20:  MOVLW  02
05B22:  MOVWF  xDB
05B24:  MOVLW  7E
05B26:  MOVWF  xDA
05B28:  MOVLB  0
05B2A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(471, BRIDGEROUTER_SELECT1);     // BRIDGEROUTER_SELECT1 
05B2E:  MOVLW  01
05B30:  MOVLB  6
05B32:  MOVWF  xD9
05B34:  MOVLW  D7
05B36:  MOVWF  xD8
05B38:  MOVLW  02
05B3A:  MOVWF  xDB
05B3C:  MOVLW  7F
05B3E:  MOVWF  xDA
05B40:  MOVLB  0
05B42:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(472, BRIDGEROUTER_SELECT2);     // BRIDGEROUTER_SELECT2 
05B46:  MOVLW  01
05B48:  MOVLB  6
05B4A:  MOVWF  xD9
05B4C:  MOVLW  D8
05B4E:  MOVWF  xD8
05B50:  MOVLW  02
05B52:  MOVWF  xDB
05B54:  MOVLW  80
05B56:  MOVWF  xDA
05B58:  MOVLB  0
05B5A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(473, BRIDGEROUTER_SELECT3);     // BRIDGEROUTER_SELECT3 
05B5E:  MOVLW  01
05B60:  MOVLB  6
05B62:  MOVWF  xD9
05B64:  MOVLW  D9
05B66:  MOVWF  xD8
05B68:  MOVLW  02
05B6A:  MOVWF  xDB
05B6C:  MOVLW  81
05B6E:  MOVWF  xDA
05B70:  MOVLB  0
05B72:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(474, GEN_PINK_GAIN);     // GEN_PINK_GAIN 
05B76:  MOVLW  01
05B78:  MOVLB  6
05B7A:  MOVWF  xD9
05B7C:  MOVLW  DA
05B7E:  MOVWF  xD8
05B80:  MOVLW  04
05B82:  MOVWF  xDB
05B84:  MOVLW  11
05B86:  MOVWF  xDA
05B88:  MOVLB  0
05B8A:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(475, GEN_SINE_OMEGA);     // GEN_SINE_OMEGA 
05B8E:  MOVLW  01
05B90:  MOVLB  6
05B92:  MOVWF  xD9
05B94:  MOVLW  DB
05B96:  MOVWF  xD8
05B98:  MOVLW  03
05B9A:  MOVWF  xDB
05B9C:  MOVLW  EB
05B9E:  MOVWF  xDA
05BA0:  MOVLB  0
05BA2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(476, GEN_SINE_GAIN);     // GEN_SINE_GAIN 
05BA6:  MOVLW  01
05BA8:  MOVLB  6
05BAA:  MOVWF  xD9
05BAC:  MOVLW  DC
05BAE:  MOVWF  xD8
05BB0:  MOVLW  03
05BB2:  MOVWF  xDB
05BB4:  MOVLW  EC
05BB6:  MOVWF  xDA
05BB8:  MOVLB  0
05BBA:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(477, SEVENTYVHP_BYPASS);     // 70VHP_BYPASS 
05BBE:  MOVLW  01
05BC0:  MOVLB  6
05BC2:  MOVWF  xD9
05BC4:  MOVLW  DD
05BC6:  MOVWF  xD8
05BC8:  MOVLW  04
05BCA:  MOVWF  xDB
05BCC:  MOVLW  44
05BCE:  MOVWF  xDA
05BD0:  MOVLB  0
05BD2:  CALL   3080
.................... 	WRITE_CONFIG_ADDRESS(478, MUTE_OUTPUTS);     // MUTE_OUTPUTS 
05BD6:  MOVLW  01
05BD8:  MOVLB  6
05BDA:  MOVWF  xD9
05BDC:  MOVLW  DE
05BDE:  MOVWF  xD8
05BE0:  MOVLW  04
05BE2:  MOVWF  xDB
05BE4:  MOVLW  13
05BE6:  MOVWF  xDA
05BE8:  MOVLB  0
05BEA:  CALL   3080
....................  
.................... } 
05BEE:  GOTO   948E (RETURN)
....................  
.................... #include <phantom.c> 
.................... void update_phantom_power() 
.................... { 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
*
06CB8:  MOVLB  7
06CBA:  CLRF   x2B
06CBC:  MOVLW  7A
06CBE:  MOVWF  x2A
06CC0:  MOVFF  79,72C
06CC4:  MOVLW  08
06CC6:  MOVWF  x2D
06CC8:  MOVLB  0
06CCA:  CALL   63F8
....................  
.................... 	int32 phantom_mask = PAGE_BUFFER_A[54]; 
06CCE:  MOVFF  155,728
06CD2:  MOVFF  154,727
06CD6:  MOVFF  153,726
06CDA:  MOVFF  152,725
....................  
.................... 	if((phantom_mask & 0x03) > 0) { 
06CDE:  MOVLB  7
06CE0:  MOVF   x25,W
06CE2:  ANDLW  03
06CE4:  MOVWF  x29
06CE6:  CLRF   x2A
06CE8:  CLRF   x2B
06CEA:  CLRF   x2C
06CEC:  MOVF   x29,F
06CEE:  BNZ   6CFC
06CF0:  MOVF   x2A,F
06CF2:  BNZ   6CFC
06CF4:  MOVF   x2B,F
06CF6:  BNZ   6CFC
06CF8:  MOVF   x2C,F
06CFA:  BZ    6D02
.................... 		output_high(PIN_PHANTOM_ENABLE); 
06CFC:  BCF    F95.5
06CFE:  BSF    F8C.5
.................... 	} else { 
06D00:  BRA    6D06
.................... 		output_low(PIN_PHANTOM_ENABLE); 
06D02:  BCF    F95.5
06D04:  BCF    F8C.5
.................... 	} 
....................  
....................  
.................... 	output_bit(PIN_PHANTOM_CH1,bit_test(phantom_mask,0)); 
06D06:  BTFSC  x25.0
06D08:  BRA    6D0E
06D0A:  BCF    F8A.4
06D0C:  BRA    6D10
06D0E:  BSF    F8A.4
06D10:  BCF    F93.4
.................... 	output_bit(PIN_PHANTOM_CH2,bit_test(phantom_mask,1)); 
06D12:  BTFSC  x25.1
06D14:  BRA    6D1A
06D16:  BCF    F8A.5
06D18:  BRA    6D1C
06D1A:  BSF    F8A.5
06D1C:  BCF    F93.5
....................  
.................... } 
06D1E:  MOVLB  0
06D20:  RETURN 0
....................  
.................... #include <presets.c> 
.................... // presets.c 
....................  
.................... void softboot(); 
....................  
.................... void save_flash_program() 
.................... { 
.................... 	//FLASH_PROGRAM_WRITE(CURRENT_PRESET); 
.................... } 
*
07564:  GOTO   88F8 (RETURN)
....................  
.................... void switch_flash_program(int new_index) 
.................... { 
.................... 	CURRENT_FLASH_PROGRAM = new_index; 
*
07520:  MOVFF  720,79
....................  
.................... 	softboot(); 
07524:  CALL   6D22
....................  
.................... 	write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
07528:  CLRF   FAA
0752A:  MOVLW  10
0752C:  MOVWF  FA9
0752E:  MOVFF  79,FA8
07532:  BCF    FA6.6
07534:  BCF    FA6.7
07536:  BSF    FA6.2
07538:  MOVF   FF2,W
0753A:  MOVWF  00
0753C:  BCF    FF2.7
0753E:  MOVLB  F
07540:  MOVLW  55
07542:  MOVWF  FA7
07544:  MOVLW  AA
07546:  MOVWF  FA7
07548:  BSF    FA6.1
0754A:  BTFSC  FA6.1
0754C:  BRA    754A
0754E:  BCF    FA6.2
07550:  MOVF   00,W
07552:  IORWF  FF2,F
....................  
.................... 	delay_ms(5); 
07554:  MOVLW  05
07556:  MOVLB  7
07558:  MOVWF  x2B
0755A:  MOVLB  0
0755C:  CALL   5FEA
.................... } 
07560:  GOTO   88C0 (RETURN)
....................  
.................... #include <adc.c> 
.................... // ADC 
....................  
.................... double RVC_to_dsp_value(unsigned int read_value) 
.................... { 
.................... 	return pow(10.0,(-60.0+(60.0*((read_value-30.0)/225.0)))/20.0); 
*
02986:  MOVLB  7
02988:  CLRF   xA5
0298A:  MOVFF  76F,7A4
0298E:  MOVLB  0
02990:  CALL   13FC
02994:  BSF    FD8.1
02996:  MOVFF  03,7A7
0299A:  MOVFF  02,7A6
0299E:  MOVFF  01,7A5
029A2:  MOVFF  00,7A4
029A6:  MOVLB  7
029A8:  CLRF   xAB
029AA:  CLRF   xAA
029AC:  MOVLW  70
029AE:  MOVWF  xA9
029B0:  MOVLW  83
029B2:  MOVWF  xA8
029B4:  MOVLB  0
029B6:  CALL   1432
029BA:  MOVFF  00,770
029BE:  MOVFF  01,771
029C2:  MOVFF  02,772
029C6:  MOVFF  03,773
029CA:  MOVFF  03,79C
029CE:  MOVFF  02,79B
029D2:  MOVFF  01,79A
029D6:  MOVFF  00,799
029DA:  MOVLB  7
029DC:  CLRF   xA0
029DE:  CLRF   x9F
029E0:  MOVLW  61
029E2:  MOVWF  x9E
029E4:  MOVLW  86
029E6:  MOVWF  x9D
029E8:  MOVLB  0
029EA:  CALL   16AA
029EE:  MOVLB  7
029F0:  CLRF   xA3
029F2:  CLRF   xA2
029F4:  MOVLW  70
029F6:  MOVWF  xA1
029F8:  MOVLW  84
029FA:  MOVWF  xA0
029FC:  MOVFF  03,7A7
02A00:  MOVFF  02,7A6
02A04:  MOVFF  01,7A5
02A08:  MOVFF  00,7A4
02A0C:  MOVLB  0
02A0E:  CALL   1808
02A12:  BCF    FD8.1
02A14:  MOVLB  7
02A16:  CLRF   xA7
02A18:  CLRF   xA6
02A1A:  MOVLW  F0
02A1C:  MOVWF  xA5
02A1E:  MOVLW  84
02A20:  MOVWF  xA4
02A22:  MOVFF  03,7AB
02A26:  MOVFF  02,7AA
02A2A:  MOVFF  01,7A9
02A2E:  MOVFF  00,7A8
02A32:  MOVLB  0
02A34:  CALL   1432
02A38:  MOVFF  00,770
02A3C:  MOVFF  01,771
02A40:  MOVFF  02,772
02A44:  MOVFF  03,773
02A48:  MOVFF  03,79C
02A4C:  MOVFF  02,79B
02A50:  MOVFF  01,79A
02A54:  MOVFF  00,799
02A58:  MOVLB  7
02A5A:  CLRF   xA0
02A5C:  CLRF   x9F
02A5E:  MOVLW  20
02A60:  MOVWF  x9E
02A62:  MOVLW  83
02A64:  MOVWF  x9D
02A66:  MOVLB  0
02A68:  CALL   16AA
02A6C:  MOVFF  00,770
02A70:  MOVFF  01,771
02A74:  MOVFF  02,772
02A78:  MOVFF  03,773
02A7C:  MOVLB  7
02A7E:  CLRF   x77
02A80:  CLRF   x76
02A82:  MOVLW  20
02A84:  MOVWF  x75
02A86:  MOVLW  82
02A88:  MOVWF  x74
02A8A:  MOVFF  03,77B
02A8E:  MOVFF  02,77A
02A92:  MOVFF  01,779
02A96:  MOVFF  00,778
02A9A:  MOVLB  0
02A9C:  RCALL  267A
....................  
.................... } 
02A9E:  RETURN 0
....................  
.................... double RVC_to_decibel(unsigned int read_value) 
.................... { 
*
07CF6:  CLRF   19
07CF8:  BTFSC  FF2.7
07CFA:  BSF    19.7
07CFC:  BCF    FF2.7
.................... 	return -60.0 + (60.0*((read_value-30.0)/225.0)); 
07CFE:  MOVLB  7
07D00:  CLRF   xA5
07D02:  MOVFF  720,7A4
07D06:  MOVLB  0
07D08:  CALL   13FC
07D0C:  BTFSC  19.7
07D0E:  BSF    FF2.7
07D10:  BSF    FD8.1
07D12:  CLRF   19
07D14:  BTFSC  FF2.7
07D16:  BSF    19.7
07D18:  BCF    FF2.7
07D1A:  MOVFF  03,7A7
07D1E:  MOVFF  02,7A6
07D22:  MOVFF  01,7A5
07D26:  MOVFF  00,7A4
07D2A:  MOVLB  7
07D2C:  CLRF   xAB
07D2E:  CLRF   xAA
07D30:  MOVLW  70
07D32:  MOVWF  xA9
07D34:  MOVLW  83
07D36:  MOVWF  xA8
07D38:  MOVLB  0
07D3A:  CALL   1432
07D3E:  BTFSC  19.7
07D40:  BSF    FF2.7
07D42:  MOVFF  00,721
07D46:  MOVFF  01,722
07D4A:  MOVFF  02,723
07D4E:  MOVFF  03,724
07D52:  CLRF   19
07D54:  BTFSC  FF2.7
07D56:  BSF    19.7
07D58:  BCF    FF2.7
07D5A:  MOVFF  03,79C
07D5E:  MOVFF  02,79B
07D62:  MOVFF  01,79A
07D66:  MOVFF  00,799
07D6A:  MOVLB  7
07D6C:  CLRF   xA0
07D6E:  CLRF   x9F
07D70:  MOVLW  61
07D72:  MOVWF  x9E
07D74:  MOVLW  86
07D76:  MOVWF  x9D
07D78:  MOVLB  0
07D7A:  CALL   16AA
07D7E:  BTFSC  19.7
07D80:  BSF    FF2.7
07D82:  CLRF   19
07D84:  BTFSC  FF2.7
07D86:  BSF    19.7
07D88:  BCF    FF2.7
07D8A:  MOVLB  7
07D8C:  CLRF   xA3
07D8E:  CLRF   xA2
07D90:  MOVLW  70
07D92:  MOVWF  xA1
07D94:  MOVLW  84
07D96:  MOVWF  xA0
07D98:  MOVFF  03,7A7
07D9C:  MOVFF  02,7A6
07DA0:  MOVFF  01,7A5
07DA4:  MOVFF  00,7A4
07DA8:  MOVLB  0
07DAA:  CALL   1808
07DAE:  BTFSC  19.7
07DB0:  BSF    FF2.7
07DB2:  BCF    FD8.1
07DB4:  CLRF   19
07DB6:  BTFSC  FF2.7
07DB8:  BSF    19.7
07DBA:  BCF    FF2.7
07DBC:  MOVLB  7
07DBE:  CLRF   xA7
07DC0:  CLRF   xA6
07DC2:  MOVLW  F0
07DC4:  MOVWF  xA5
07DC6:  MOVLW  84
07DC8:  MOVWF  xA4
07DCA:  MOVFF  03,7AB
07DCE:  MOVFF  02,7AA
07DD2:  MOVFF  01,7A9
07DD6:  MOVFF  00,7A8
07DDA:  MOVLB  0
07DDC:  CALL   1432
07DE0:  BTFSC  19.7
07DE2:  BSF    FF2.7
.................... } 
07DE4:  GOTO   92EC (RETURN)
....................  
....................  
.................... int ADC_calibrate_min(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
*
07B08:  MOVLW  00
07B0A:  MOVWF  01
07B0C:  MOVF   FC2,W
07B0E:  ANDLW  83
07B10:  IORWF  01,W
07B12:  MOVWF  FC2
.................... 	delay_us(10); 
07B14:  MOVLW  0B
07B16:  MOVWF  00
07B18:  DECFSZ 00,F
07B1A:  BRA    7B18
07B1C:  BRA    7B1E
.................... 	int current_adc = read_adc(); 
07B1E:  BSF    FC2.1
07B20:  BTFSC  FC2.1
07B22:  BRA    7B20
07B24:  MOVFF  FC4,721
07B28:  MOVLB  7
07B2A:  CLRF   19
07B2C:  BTFSC  FF2.7
07B2E:  BSF    19.7
07B30:  BCF    FF2.7
.................... 	 
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new minimum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = (double)current_adc; 
07B32:  CLRF   xA5
07B34:  MOVFF  721,7A4
07B38:  MOVLB  0
07B3A:  CALL   13FC
07B3E:  BTFSC  19.7
07B40:  BSF    FF2.7
07B42:  MOVFF  03,38
07B46:  MOVFF  02,37
07B4A:  MOVFF  01,36
07B4E:  MOVFF  00,35
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07B52:  MOVLB  7
07B54:  CLRF   x23
07B56:  MOVLW  33
07B58:  MOVWF  x22
07B5A:  CLRF   x25
07B5C:  MOVLW  28
07B5E:  MOVWF  x24
07B60:  CLRF   x27
07B62:  MOVLW  64
07B64:  MOVWF  x26
07B66:  MOVLB  0
07B68:  CALL   6388
.................... 	delay_ms(10); 
07B6C:  MOVLW  0A
07B6E:  MOVLB  7
07B70:  MOVWF  x2B
07B72:  MOVLB  0
07B74:  CALL   5FEA
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07B78:  MOVLB  7
07B7A:  MOVFF  721,01
.................... } 
07B7E:  MOVLB  0
07B80:  GOTO   8BCA (RETURN)
....................  
.................... int ADC_calibrate_max(int is_usb = 0) 
.................... { 
.................... 	set_adc_channel(0); 
07B84:  MOVLW  00
07B86:  MOVWF  01
07B88:  MOVF   FC2,W
07B8A:  ANDLW  83
07B8C:  IORWF  01,W
07B8E:  MOVWF  FC2
.................... 	delay_us(10); 
07B90:  MOVLW  0B
07B92:  MOVWF  00
07B94:  DECFSZ 00,F
07B96:  BRA    7B94
07B98:  BRA    7B9A
.................... 	int current_adc = read_adc(); 
07B9A:  BSF    FC2.1
07B9C:  BTFSC  FC2.1
07B9E:  BRA    7B9C
07BA0:  MOVFF  FC4,721
07BA4:  MOVLB  7
07BA6:  CLRF   19
07BA8:  BTFSC  FF2.7
07BAA:  BSF    19.7
07BAC:  BCF    FF2.7
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Read a value of %u, saving as new maximum...",current_adc); 
.................... 	} 
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX= (double)current_adc; 
07BAE:  CLRF   xA5
07BB0:  MOVFF  721,7A4
07BB4:  MOVLB  0
07BB6:  CALL   13FC
07BBA:  BTFSC  19.7
07BBC:  BSF    FF2.7
07BBE:  MOVFF  03,3C
07BC2:  MOVFF  02,3B
07BC6:  MOVFF  01,3A
07BCA:  MOVFF  00,39
....................  
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
07BCE:  MOVLB  7
07BD0:  CLRF   x23
07BD2:  MOVLW  33
07BD4:  MOVWF  x22
07BD6:  CLRF   x25
07BD8:  MOVLW  28
07BDA:  MOVWF  x24
07BDC:  CLRF   x27
07BDE:  MOVLW  64
07BE0:  MOVWF  x26
07BE2:  MOVLB  0
07BE4:  CALL   6388
.................... 	delay_ms(10); 
07BE8:  MOVLW  0A
07BEA:  MOVLB  7
07BEC:  MOVWF  x2B
07BEE:  MOVLB  0
07BF0:  CALL   5FEA
....................  
.................... 	if(DEBUG && (is_usb==0)) { 
.................... 		fprintf(RS232,"[DEBUG] Done!\r\n"); 
.................... 	} 
....................  
.................... 	return current_adc; 
07BF4:  MOVLB  7
07BF6:  MOVFF  721,01
.................... } 
07BFA:  MOVLB  0
07BFC:  GOTO   8C14 (RETURN)
....................  
.................... #include <device_boot.c> 
.................... void softboot(); 
.................... void initialize_first_boot(); 
....................  
.................... void default_device_config() 
.................... { 
.................... 	for(int x = 0; x < 20; x++) { 
*
065FA:  MOVLB  6
065FC:  CLRF   xDA
065FE:  MOVF   xDA,W
06600:  SUBLW  13
06602:  BNC   6618
.................... 		DEVICE_CONFIG.SERIAL[x] = 0xFF; 
06604:  CLRF   03
06606:  MOVF   xDA,W
06608:  ADDLW  47
0660A:  MOVWF  FE9
0660C:  MOVLW  00
0660E:  ADDWFC 03,W
06610:  MOVWF  FEA
06612:  SETF   FEF
.................... 	} 
06614:  INCF   xDA,F
06616:  BRA    65FE
....................  
.................... 	DEVICE_CONFIG.SERIAL[0] = 'N'; 
06618:  MOVLW  4E
0661A:  MOVWF  47
.................... 	DEVICE_CONFIG.SERIAL[1] = 'O'; 
0661C:  MOVLW  4F
0661E:  MOVWF  48
.................... 	DEVICE_CONFIG.SERIAL[2] = 'N'; 
06620:  MOVLW  4E
06622:  MOVWF  49
.................... 	DEVICE_CONFIG.SERIAL[3] = 'E'; 
06624:  MOVLW  45
06626:  MOVWF  4A
....................  
.................... 	DEVICE_CONFIG.AMP_MODE = 				DEFAULT_AMP_MODE; 
06628:  MOVFF  27,33
.................... 	DEVICE_CONFIG.IS_70V = 					DEFAULT_IS_70V; 
0662C:  MOVFF  28,34
....................  
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MIN = 	DEFAULT_ADC_CALIBRATION_MIN; 
06630:  MOVFF  22,38
06634:  MOVFF  21,37
06638:  MOVFF  20,36
0663C:  MOVFF  1F,35
.................... 	DEVICE_CONFIG.ADC_CALIBRATION_MAX = 	DEFAULT_ADC_CALIBRATION_MAX; 
06640:  MOVFF  26,3C
06644:  MOVFF  25,3B
06648:  MOVFF  24,3A
0664C:  MOVFF  23,39
....................  
.................... 	DEVICE_CONFIG.RVC_ENABLE = 				DEFAULT_RVC_ENABLE; 
06650:  MOVFF  29,3D
.................... 	DEVICE_CONFIG.USBDETECT_ENABLE = 		DEFAULT_USBDETECT_ENABLE; 
06654:  MOVFF  2A,3E
.................... 	DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = 	DEFAULT_AMPBOOT_DELAY_ENABLE; 
06658:  MOVFF  2B,3F
.................... 	DEVICE_CONFIG.PS_PIN_ENABLE = 			DEFAULT_PS_PIN_ENABLE; 
0665C:  MOVFF  2C,40
.................... 	DEVICE_CONFIG.DSP_VALUESEND_ENABLE = 	DEFAULT_DSP_VALUESEND_ENABLE; 
06660:  MOVFF  2D,41
.................... 	 
.................... 	DEVICE_CONFIG.SLEEP_ENABLE		= 		DEFAULT_SLEEP_ENABLE; 
06664:  MOVFF  2E,42
.................... 	DEVICE_CONFIG.SLEEP_SECONDS		= 		DEFAULT_SLEEP_SECONDS; 
06668:  MOVFF  30,44
0666C:  MOVFF  2F,43
.................... 	DEVICE_CONFIG.SLEEP_HOLDTIME	= 		DEFAULT_SLEEP_HOLDTIME; 
06670:  MOVFF  32,46
06674:  MOVFF  31,45
.................... 	delay_ms(10); 
06678:  MOVLW  0A
0667A:  MOVLB  7
0667C:  MOVWF  x2B
0667E:  MOVLB  0
06680:  RCALL  5FEA
.................... 	 
.................... 	INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),IEEPROM_DEVICE_CONFIG_LOC); 
06682:  MOVLB  7
06684:  CLRF   x23
06686:  MOVLW  33
06688:  MOVWF  x22
0668A:  CLRF   x25
0668C:  MOVLW  28
0668E:  MOVWF  x24
06690:  CLRF   x27
06692:  MOVLW  64
06694:  MOVWF  x26
06696:  MOVLB  0
06698:  RCALL  6388
....................  
.................... 	 
.................... 	read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
0669A:  MOVLB  7
0669C:  CLRF   x2B
0669E:  MOVLW  7A
066A0:  MOVWF  x2A
066A2:  MOVFF  79,72C
066A6:  MOVLW  08
066A8:  MOVWF  x2D
066AA:  MOVLB  0
066AC:  RCALL  63F8
.................... 	PAGE_BUFFER_A[57] = 0; 
066AE:  MOVLB  1
066B0:  CLRF   x61
066B2:  CLRF   x60
066B4:  CLRF   x5F
066B6:  CLRF   x5E
.................... 	write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,8); 
066B8:  MOVLB  7
066BA:  CLRF   x29
066BC:  MOVLW  7A
066BE:  MOVWF  x28
066C0:  MOVFF  79,72A
066C4:  MOVLW  08
066C6:  MOVWF  x2B
066C8:  MOVLB  0
066CA:  RCALL  64E4
.................... 	 
.................... } 
066CC:  GOTO   6804 (RETURN)
....................  
.................... void print_device_config() 
.................... { 
.................... 	char name_buffer[20]; 
....................  
.................... 	memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
....................  
.................... 	fprintf(RS232,"[CONFIG] SERIAL = "); 
....................  
.................... 	for(int y = 0; y < 20; y++) { 
.................... 		if(name_buffer[y] == 0xFF) { 
.................... 			break; 
.................... 		} 
....................  
.................... 		fputc(name_buffer[y],RS232); 
....................  
.................... 	}  
....................  
.................... 	fprintf(RS232,"\r\n"); 
....................  
.................... 	 
....................  
.................... 	if(DEVICE_CONFIG.AMP_MODE == 0) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 4CH\r\n"); 
.................... 	} else if(DEVICE_CONFIG.AMP_MODE == 1) { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 2CH\r\n"); 
.................... 	} else { 
.................... 		fprintf(RS232,"[CONFIG] AMP_MODE = 1CH\r\n"); 
.................... 	} 
....................  
.................... 	 
.................... 	fprintf(RS232,"[CONFIG] IS_70V = %u\r\n",DEVICE_CONFIG.IS_70V); 
....................  
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MIN = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
.................... 	fprintf(RS232,"[CONFIG] ADC_CALIBRATION_MAX = %f\r\n",DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
....................  
.................... 	fprintf(RS232,"[CONFIG] RVC_ENABLE = %u\r\n",DEVICE_CONFIG.RVC_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] USBDETECT_ENABLE = %u\r\n",DEVICE_CONFIG.USBDETECT_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] AMPBOOT_DELAY_ENABLE = %u\r\n",DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] PS_PIN_ENABLE = %u\r\n",DEVICE_CONFIG.PS_PIN_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] DSP_VALUESEND_ENABLE = %u\r\n",DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_ENABLE = %u\r\n",DEVICE_CONFIG.SLEEP_ENABLE); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_SECONDS = %ld\r\n",DEVICE_CONFIG.SLEEP_SECONDS); 
.................... 	fprintf(RS232,"[CONFIG] SLEEP_HOLDTIME = %ld\r\n",DEVICE_CONFIG.SLEEP_HOLDTIME); 
....................  
.................... } 
....................  
.................... void device_boot() 
.................... { 
.................... 	/* POWER STARTUP SEQUENCE */ 
.................... 	delay_ms(POWERUP_DELAY); 
066D0:  MOVLW  C8
066D2:  MOVLB  7
066D4:  MOVWF  x2B
066D6:  MOVLB  0
066D8:  RCALL  5FEA
.................... 	 
.................... 	fprintf(RS232,"Booting into main application built on "); 
066DA:  MOVLW  54
066DC:  MOVWF  FF6
066DE:  MOVLW  0C
066E0:  MOVWF  FF7
066E2:  RCALL  6012
.................... 	fprintf(RS232,__DATE__); 
066E4:  MOVLW  7C
066E6:  MOVWF  FF6
066E8:  MOVLW  0C
066EA:  MOVWF  FF7
066EC:  RCALL  6012
.................... 	fprintf(RS232," "); 
066EE:  MOVLW  20
066F0:  BTFSS  FA4.4
066F2:  BRA    66F0
066F4:  MOVWF  F73
.................... 	fprintf(RS232,__TIME__); 
066F6:  MOVLW  86
066F8:  MOVWF  FF6
066FA:  MOVLW  0C
066FC:  MOVWF  FF7
066FE:  RCALL  6012
.................... 	fprintf(RS232,"\r"); 
06700:  MOVLW  0D
06702:  BTFSS  FA4.4
06704:  BRA    6702
06706:  MOVWF  F73
....................  
.................... 	fprintf(RS232,"Device firmware is v%u.%u%s\r",MAJOR_REVISION,MINOR_REVISION,REVISION_TEXT); 
06708:  MOVLW  90
0670A:  MOVWF  FF6
0670C:  MOVLW  0C
0670E:  MOVWF  FF7
06710:  MOVLW  14
06712:  MOVLB  7
06714:  MOVWF  x2E
06716:  MOVLB  0
06718:  RCALL  6034
0671A:  MOVFF  61,72E
0671E:  MOVLW  1B
06720:  MOVLB  7
06722:  MOVWF  x2F
06724:  MOVLB  0
06726:  RCALL  608A
06728:  MOVLW  2E
0672A:  BTFSS  FA4.4
0672C:  BRA    672A
0672E:  MOVWF  F73
06730:  MOVFF  62,72E
06734:  MOVLW  1B
06736:  MOVLB  7
06738:  MOVWF  x2F
0673A:  MOVLB  0
0673C:  RCALL  608A
0673E:  CLRF   FEA
06740:  MOVLW  63
06742:  MOVWF  FE9
06744:  BRA    6108
06746:  MOVLW  0D
06748:  BTFSS  FA4.4
0674A:  BRA    6748
0674C:  MOVWF  F73
.................... 	delay_ms(10); 
0674E:  MOVLW  0A
06750:  MOVLB  7
06752:  MOVWF  x2B
06754:  MOVLB  0
06756:  RCALL  5FEA
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Reading DSP addresses from flash into memory... "); 
.................... 	} 
....................  
.................... 	FLASH_ADDR_READ(); 
06758:  BRA    6130
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"Done!\r\n"); 
.................... 	} 
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Checking if EEPROM is configured... "); 
.................... 	} 
....................  
.................... 	int eeprom_preset_number = read_eeprom(IEEPROM_PRESET_LOC); 
0675A:  MOVFF  FF2,6DA
0675E:  BCF    FF2.7
06760:  CLRF   FAA
06762:  MOVLW  10
06764:  MOVWF  FA9
06766:  BCF    FA6.6
06768:  BCF    FA6.7
0676A:  BSF    FA6.0
0676C:  MOVF   FA8,W
0676E:  MOVLB  6
06770:  BTFSC  xDA.7
06772:  BSF    FF2.7
06774:  MOVWF  xD8
....................  
.................... 	//TODO - Re-implement 
.................... 	if(eeprom_preset_number == 0xFF) { 
06776:  INCFSZ xD8,W
06778:  BRA    67AE
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"NO PRESET IN EEPROM, GOING TO DEFAULT\r\n"); 
.................... 		} 
.................... 		//switch_flash_program(DEFAULT_PRESET); 
.................... 		CURRENT_FLASH_PROGRAM = DEFAULT_PRESET; 
0677A:  MOVLB  0
0677C:  CLRF   x79
.................... 		write_eeprom(IEEPROM_PRESET_LOC,CURRENT_FLASH_PROGRAM); 
0677E:  CLRF   FAA
06780:  MOVLW  10
06782:  MOVWF  FA9
06784:  MOVFF  79,FA8
06788:  BCF    FA6.6
0678A:  BCF    FA6.7
0678C:  BSF    FA6.2
0678E:  MOVF   FF2,W
06790:  MOVWF  00
06792:  BCF    FF2.7
06794:  MOVLB  F
06796:  MOVLW  55
06798:  MOVWF  FA7
0679A:  MOVLW  AA
0679C:  MOVWF  FA7
0679E:  BSF    FA6.1
067A0:  BTFSC  FA6.1
067A2:  BRA    67A0
067A4:  BCF    FA6.2
067A6:  MOVF   00,W
067A8:  IORWF  FF2,F
.................... 	} else { 
067AA:  BRA    67B2
067AC:  MOVLB  6
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"BOOTING FROM STORED PRESET - %U\r\n",eeprom_preset_number); 
.................... 		} 
.................... 		//switch_flash_program(eeprom_preset_number); 
.................... 		CURRENT_FLASH_PROGRAM = eeprom_preset_number; 
067AE:  MOVFF  6D8,79
.................... 	} 
....................  
.................... 	delay_ms(10); 
067B2:  MOVLW  0A
067B4:  MOVLB  7
067B6:  MOVWF  x2B
067B8:  MOVLB  0
067BA:  RCALL  5FEA
....................  
.................... 	int programmed_flag = read_eeprom(IEEPROM_FLAG_LOC); 
067BC:  MOVFF  FF2,6DA
067C0:  BCF    FF2.7
067C2:  CLRF   FAA
067C4:  MOVLW  20
067C6:  MOVWF  FA9
067C8:  BCF    FA6.6
067CA:  BCF    FA6.7
067CC:  BSF    FA6.0
067CE:  MOVF   FA8,W
067D0:  MOVLB  6
067D2:  BTFSC  xDA.7
067D4:  BSF    FF2.7
067D6:  MOVWF  xD9
....................  
.................... 	INTEEPROM_GET(&DEVICE_CONFIG,sizeof(device_configuration),IEEPROM_DEVICE_CONFIG_LOC); 
067D8:  CLRF   xDB
067DA:  MOVLW  33
067DC:  MOVWF  xDA
067DE:  CLRF   xDD
067E0:  MOVLW  28
067E2:  MOVWF  xDC
067E4:  CLRF   xDF
067E6:  MOVLW  64
067E8:  MOVWF  xDE
067EA:  MOVLB  0
067EC:  BRA    62AA
....................  
.................... 	delay_ms(10); 
067EE:  MOVLW  0A
067F0:  MOVLB  7
067F2:  MOVWF  x2B
067F4:  MOVLB  0
067F6:  CALL   5FEA
....................  
.................... 	if(DEBUG) { 
.................... 		print_device_config(); 
.................... 	} 
....................  
.................... 	if(programmed_flag == 0xFF) { 
067FA:  MOVLB  6
067FC:  INCFSZ xD9,W
067FE:  BRA    683E
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Starting first boot routine\r\n"); 
.................... 		} 
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Saving default device properties..."); 
.................... 		} 
.................... 		default_device_config(); 
06800:  MOVLB  0
06802:  BRA    65FA
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Done!\r\n"); 
.................... 		} 
....................  
.................... 		 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] New device config below...\r\n"); 
.................... 			print_device_config(); 
.................... 		} 
.................... 		//initialize_first_boot(); 
....................  
....................  
.................... 		write_eeprom(IEEPROM_FLAG_LOC,0x01); 
06804:  CLRF   FAA
06806:  MOVLW  20
06808:  MOVWF  FA9
0680A:  MOVLW  01
0680C:  MOVWF  FA8
0680E:  BCF    FA6.6
06810:  BCF    FA6.7
06812:  BSF    FA6.2
06814:  MOVF   FF2,W
06816:  MOVWF  00
06818:  BCF    FF2.7
0681A:  MOVLB  F
0681C:  MOVLW  55
0681E:  MOVWF  FA7
06820:  MOVLW  AA
06822:  MOVWF  FA7
06824:  BSF    FA6.1
06826:  BTFSC  FA6.1
06828:  BRA    6826
0682A:  BCF    FA6.2
0682C:  MOVF   00,W
0682E:  IORWF  FF2,F
.................... 		delay_ms(10); 
06830:  MOVLW  0A
06832:  MOVLB  7
06834:  MOVWF  x2B
06836:  MOVLB  0
06838:  CALL   5FEA
0683C:  MOVLB  6
.................... 	}	 
.................... 	/* INIT RS232 volumes and mutes */ 
....................  
....................  
.................... } 
0683E:  MOVLB  0
06840:  GOTO   949E (RETURN)
....................  
.................... void softboot() 
.................... { 
.................... 	delay_ms(50); 
*
06D22:  MOVLW  32
06D24:  MOVLB  7
06D26:  MOVWF  x2B
06D28:  MOVLB  0
06D2A:  CALL   5FEA
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP and Amp reset LOW\r\n"); 
.................... 	} 
....................  
.................... 	// TODO - Mute transistors 
....................  
.................... 	output_high(AUD_MUTE); 
06D2E:  BCF    F95.3
06D30:  BSF    F8C.3
....................  
.................... 	output_low(PIN_DSP_nRESET); 
06D32:  BCF    F92.4
06D34:  BCF    F89.4
.................... 	output_low(PIN_AMP_nRESET); 
06D36:  BCF    F92.5
06D38:  BCF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.PS_PIN_ENABLE) { 
06D3A:  MOVF   40,F
06D3C:  BZ    6D42
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling Power Supply\r\n"); 
.................... 		}	 
....................  
.................... 		output_high(PIN_PSON); 
06D3E:  BCF    F93.4
06D40:  BSF    F8A.4
.................... 	} 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Muting DSP Output (NOT YET IMPLEMENTED)\r\n"); 
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Putting amplifier into 2 CH mode\r\n"); 
.................... 	} 
....................  
.................... 	output_low(PIN_AMP_M1);  // TI Chip - Mode Pin 1 
06D42:  BCF    F92.1
06D44:  BCF    F89.1
.................... 	output_high(PIN_AMP_M2); // TI Chip - Mode Pin 2 
06D46:  BCF    F92.2
06D48:  BSF    F89.2
.................... 	output_low(PIN_AMP_M3);  // TI Chip - Mode Pin 3 
06D4A:  BCF    F92.3
06D4C:  BCF    F89.3
....................  
.................... 	delay_ms(DELAY_AMP_MODE_SETTLE); 
06D4E:  MOVLW  04
06D50:  MOVLB  7
06D52:  MOVWF  x25
06D54:  MOVLW  FA
06D56:  MOVWF  x2B
06D58:  MOVLB  0
06D5A:  CALL   5FEA
06D5E:  MOVLB  7
06D60:  DECFSZ x25,F
06D62:  BRA    6D54
....................  
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling AMP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_AMP_nRESET); 
06D64:  BCF    F92.5
06D66:  BSF    F89.5
....................  
.................... 	if(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE) { 
06D68:  MOVF   3F,F
06D6A:  BZ    6D74
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Waiting for AMP ready....\r\n"); 
.................... 		} 
.................... 		while(!input(PIN_AMP_READY)) { 
06D6C:  BSF    F96.2
06D6E:  BTFSC  F84.2
06D70:  BRA    6D74
.................... 	 
.................... 		} 
06D72:  BRA    6D6C
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] AMP is ready!\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	 
.................... 	delay_ms(50); 
06D74:  MOVLW  32
06D76:  MOVWF  x2B
06D78:  MOVLB  0
06D7A:  CALL   5FEA
....................  
.................... 	 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Pulling DSP reset HIGH\r\n"); 
.................... 	} 
....................  
.................... 	output_high(PIN_DSP_nRESET);// DSP Reset 
06D7E:  BCF    F92.4
06D80:  BSF    F89.4
.................... 	 
.................... 	delay_ms(DELAY_DSP_RESET_SETTLE); 
06D82:  MOVLW  32
06D84:  MOVLB  7
06D86:  MOVWF  x2B
06D88:  MOVLB  0
06D8A:  CALL   5FEA
....................  
.................... 	if(DEVICE_CONFIG.IS_70V == 0) { 
06D8E:  MOVF   34,F
06D90:  BNZ   6DB0
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Not a 70V amp. Disabling 100Hz HP Filter\r\n"); 
.................... 		} 
....................  
.................... 		send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,SEVENTYVHP_BYPASS,0x00000001); 
06D92:  MOVLW  F0
06D94:  MOVLB  7
06D96:  MOVWF  x31
06D98:  CLRF   x30
06D9A:  MOVLW  04
06D9C:  MOVWF  x33
06D9E:  MOVLW  44
06DA0:  MOVWF  x32
06DA2:  CLRF   x37
06DA4:  CLRF   x36
06DA6:  CLRF   x35
06DA8:  MOVLW  01
06DAA:  MOVWF  x34
06DAC:  MOVLB  0
06DAE:  RCALL  6844
.................... 	} 
.................... 		 
....................  
.................... 	//2CH 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG] Putting DSP into DSP100-2 mode\r\n"); 
.................... 	} 
....................  
.................... 	send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT0,0x00000001); 
06DB0:  MOVLW  F0
06DB2:  MOVLB  7
06DB4:  MOVWF  x31
06DB6:  CLRF   x30
06DB8:  MOVLW  02
06DBA:  MOVWF  x33
06DBC:  MOVLW  7E
06DBE:  MOVWF  x32
06DC0:  CLRF   x37
06DC2:  CLRF   x36
06DC4:  CLRF   x35
06DC6:  MOVLW  01
06DC8:  MOVWF  x34
06DCA:  MOVLB  0
06DCC:  RCALL  6844
.................... 	send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT1,0x00000002); 
06DCE:  MOVLW  F0
06DD0:  MOVLB  7
06DD2:  MOVWF  x31
06DD4:  CLRF   x30
06DD6:  MOVLW  02
06DD8:  MOVWF  x33
06DDA:  MOVLW  7F
06DDC:  MOVWF  x32
06DDE:  CLRF   x37
06DE0:  CLRF   x36
06DE2:  CLRF   x35
06DE4:  MOVLW  02
06DE6:  MOVWF  x34
06DE8:  MOVLB  0
06DEA:  RCALL  6844
.................... 	send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT2,0x00000003); 
06DEC:  MOVLW  F0
06DEE:  MOVLB  7
06DF0:  MOVWF  x31
06DF2:  CLRF   x30
06DF4:  MOVLW  02
06DF6:  MOVWF  x33
06DF8:  MOVLW  80
06DFA:  MOVWF  x32
06DFC:  CLRF   x37
06DFE:  CLRF   x36
06E00:  CLRF   x35
06E02:  MOVLW  03
06E04:  MOVWF  x34
06E06:  MOVLB  0
06E08:  RCALL  6844
.................... 	send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,BRIDGEROUTER_SELECT3,0x00000004); 
06E0A:  MOVLW  F0
06E0C:  MOVLB  7
06E0E:  MOVWF  x31
06E10:  CLRF   x30
06E12:  MOVLW  02
06E14:  MOVWF  x33
06E16:  MOVLW  81
06E18:  MOVWF  x32
06E1A:  CLRF   x37
06E1C:  CLRF   x36
06E1E:  CLRF   x35
06E20:  MOVLW  04
06E22:  MOVWF  x34
06E24:  MOVLB  0
06E26:  RCALL  6844
....................  
.................... 	if(DEVICE_CONFIG.DSP_VALUESEND_ENABLE) 
06E28:  MOVF   41,F
06E2A:  BZ    6E4A
.................... 	{ 
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Sending DSP values from program %u\r\n",CURRENT_FLASH_PROGRAM); 
.................... 		} 
.................... 		 
.................... 		dsp_mute_outputs(); 
06E2C:  BRA    6906
....................  
.................... 		send_flash_program_to_dsp_buffered(CURRENT_FLASH_PROGRAM); 
06E2E:  MOVFF  79,725
06E32:  BRA    6B14
....................  
.................... 		// We will have an RVC value to read. Keep this muted. We'll unmute later 
.................... 		if(DEVICE_CONFIG.RVC_ENABLE != 1) { 
06E34:  DECFSZ 3D,W
06E36:  BRA    6E3A
06E38:  BRA    6E3C
.................... 			dsp_unmute_outputs(); 
06E3A:  RCALL  6C8E
.................... 		} 
....................  
.................... 		delay_ms(100); 
06E3C:  MOVLW  64
06E3E:  MOVLB  7
06E40:  MOVWF  x2B
06E42:  MOVLB  0
06E44:  CALL   5FEA
....................  
.................... 	} else { 
06E48:  BRA    6E4A
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NOT sending DSP values\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
06E4A:  DECFSZ 3D,W
06E4C:  BRA    7190
....................  
.................... 		pin_in_mute_state = !input(PIN_AMP_nMUTE); 
06E4E:  BSF    F94.1
06E50:  MOVLB  1
06E52:  CLRF   x7D
06E54:  BTFSS  F82.1
06E56:  INCF   x7D,F
.................... 	 
.................... 		set_adc_channel(0); 
06E58:  MOVLW  00
06E5A:  MOVWF  01
06E5C:  MOVF   FC2,W
06E5E:  ANDLW  83
06E60:  IORWF  01,W
06E62:  MOVWF  FC2
.................... 		delay_us(10); 
06E64:  MOVLW  0B
06E66:  MOVWF  00
06E68:  DECFSZ 00,F
06E6A:  BRA    6E68
06E6C:  BRA    6E6E
.................... 		current_adc = read_adc(); 
06E6E:  BSF    FC2.1
06E70:  BTFSC  FC2.1
06E72:  BRA    6E70
06E74:  MOVFF  FC4,17B
.................... 		 
.................... 		if(pin_in_mute_state) { 
06E78:  MOVF   x7D,F
06E7A:  BZ    6F2E
.................... 			is_muted = true; 
06E7C:  MOVLW  01
06E7E:  MOVWF  x7C
06E80:  CLRF   19
06E82:  BTFSC  FF2.7
06E84:  BSF    19.7
06E86:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
06E88:  MOVLW  83
06E8A:  MOVLB  7
06E8C:  MOVWF  x76
06E8E:  CLRF   x75
06E90:  CLRF   x74
06E92:  MOVLW  0A
06E94:  MOVWF  x73
06E96:  CLRF   x7A
06E98:  CLRF   x79
06E9A:  CLRF   x78
06E9C:  CLRF   x77
06E9E:  MOVLB  0
06EA0:  CALL   1388
06EA4:  BTFSC  19.7
06EA6:  BSF    FF2.7
06EA8:  CLRF   19
06EAA:  BTFSC  FF2.7
06EAC:  BSF    19.7
06EAE:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
06EB0:  MOVLW  83
06EB2:  MOVLB  7
06EB4:  MOVWF  x76
06EB6:  CLRF   x75
06EB8:  CLRF   x74
06EBA:  MOVLW  0B
06EBC:  MOVWF  x73
06EBE:  CLRF   x7A
06EC0:  CLRF   x79
06EC2:  CLRF   x78
06EC4:  CLRF   x77
06EC6:  MOVLB  0
06EC8:  CALL   1388
06ECC:  BTFSC  19.7
06ECE:  BSF    FF2.7
06ED0:  CLRF   19
06ED2:  BTFSC  FF2.7
06ED4:  BSF    19.7
06ED6:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
06ED8:  MOVLW  83
06EDA:  MOVLB  7
06EDC:  MOVWF  x76
06EDE:  CLRF   x75
06EE0:  CLRF   x74
06EE2:  MOVLW  0C
06EE4:  MOVWF  x73
06EE6:  CLRF   x7A
06EE8:  CLRF   x79
06EEA:  CLRF   x78
06EEC:  CLRF   x77
06EEE:  MOVLB  0
06EF0:  CALL   1388
06EF4:  BTFSC  19.7
06EF6:  BSF    FF2.7
06EF8:  CLRF   19
06EFA:  BTFSC  FF2.7
06EFC:  BSF    19.7
06EFE:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
06F00:  MOVLW  83
06F02:  MOVLB  7
06F04:  MOVWF  x76
06F06:  CLRF   x75
06F08:  CLRF   x74
06F0A:  MOVLW  0D
06F0C:  MOVWF  x73
06F0E:  CLRF   x7A
06F10:  CLRF   x79
06F12:  CLRF   x78
06F14:  CLRF   x77
06F16:  MOVLB  0
06F18:  CALL   1388
06F1C:  BTFSC  19.7
06F1E:  BSF    FF2.7
.................... 			set_timer1(15550); 
06F20:  MOVLW  3C
06F22:  MOVWF  FCF
06F24:  MOVLW  BE
06F26:  MOVWF  FCE
.................... 			clear_interrupt(INT_TIMER1); 
06F28:  BCF    F9E.0
.................... 	 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - Muted\r\n"); 
.................... 			} 
.................... 		} else { 
06F2A:  BRA    718C
06F2C:  MOVLB  1
06F2E:  CLRF   19
06F30:  BTFSC  FF2.7
06F32:  BSF    19.7
06F34:  BCF    FF2.7
.................... 			double dsp_value = RVC_to_dsp_value(current_adc); 
06F36:  MOVFF  17B,76F
06F3A:  MOVLB  0
06F3C:  CALL   2986
06F40:  BTFSC  19.7
06F42:  BSF    FF2.7
06F44:  MOVFF  03,724
06F48:  MOVFF  02,723
06F4C:  MOVFF  01,722
06F50:  MOVFF  00,721
06F54:  CLRF   19
06F56:  BTFSC  FF2.7
06F58:  BSF    19.7
06F5A:  BCF    FF2.7
....................  
.................... 			send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
06F5C:  MOVFF  724,7A3
06F60:  MOVFF  723,7A2
06F64:  MOVFF  722,7A1
06F68:  MOVFF  721,7A0
06F6C:  MOVLB  7
06F6E:  CLRF   xA7
06F70:  CLRF   xA6
06F72:  CLRF   xA5
06F74:  MOVLW  9E
06F76:  MOVWF  xA4
06F78:  MOVLB  0
06F7A:  CALL   1808
06F7E:  BTFSC  19.7
06F80:  BSF    FF2.7
06F82:  CLRF   19
06F84:  BTFSC  FF2.7
06F86:  BSF    19.7
06F88:  BCF    FF2.7
06F8A:  MOVFF  03,772
06F8E:  MOVFF  02,771
06F92:  MOVFF  01,770
06F96:  MOVFF  00,76F
06F9A:  CALL   2AA0
06F9E:  BTFSC  19.7
06FA0:  BSF    FF2.7
06FA2:  MOVFF  03,728
06FA6:  MOVFF  02,727
06FAA:  MOVFF  01,726
06FAE:  MOVFF  00,725
06FB2:  CLRF   19
06FB4:  BTFSC  FF2.7
06FB6:  BSF    19.7
06FB8:  BCF    FF2.7
06FBA:  MOVLW  83
06FBC:  MOVLB  7
06FBE:  MOVWF  x76
06FC0:  CLRF   x75
06FC2:  CLRF   x74
06FC4:  MOVLW  0A
06FC6:  MOVWF  x73
06FC8:  MOVFF  03,77A
06FCC:  MOVFF  02,779
06FD0:  MOVFF  01,778
06FD4:  MOVFF  00,777
06FD8:  MOVLB  0
06FDA:  CALL   1388
06FDE:  BTFSC  19.7
06FE0:  BSF    FF2.7
06FE2:  CLRF   19
06FE4:  BTFSC  FF2.7
06FE6:  BSF    19.7
06FE8:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
06FEA:  MOVFF  724,7A3
06FEE:  MOVFF  723,7A2
06FF2:  MOVFF  722,7A1
06FF6:  MOVFF  721,7A0
06FFA:  MOVLB  7
06FFC:  CLRF   xA7
06FFE:  CLRF   xA6
07000:  CLRF   xA5
07002:  MOVLW  9E
07004:  MOVWF  xA4
07006:  MOVLB  0
07008:  CALL   1808
0700C:  BTFSC  19.7
0700E:  BSF    FF2.7
07010:  CLRF   19
07012:  BTFSC  FF2.7
07014:  BSF    19.7
07016:  BCF    FF2.7
07018:  MOVFF  03,772
0701C:  MOVFF  02,771
07020:  MOVFF  01,770
07024:  MOVFF  00,76F
07028:  CALL   2AA0
0702C:  BTFSC  19.7
0702E:  BSF    FF2.7
07030:  MOVFF  03,728
07034:  MOVFF  02,727
07038:  MOVFF  01,726
0703C:  MOVFF  00,725
07040:  CLRF   19
07042:  BTFSC  FF2.7
07044:  BSF    19.7
07046:  BCF    FF2.7
07048:  MOVLW  83
0704A:  MOVLB  7
0704C:  MOVWF  x76
0704E:  CLRF   x75
07050:  CLRF   x74
07052:  MOVLW  0B
07054:  MOVWF  x73
07056:  MOVFF  03,77A
0705A:  MOVFF  02,779
0705E:  MOVFF  01,778
07062:  MOVFF  00,777
07066:  MOVLB  0
07068:  CALL   1388
0706C:  BTFSC  19.7
0706E:  BSF    FF2.7
07070:  CLRF   19
07072:  BTFSC  FF2.7
07074:  BSF    19.7
07076:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
07078:  MOVFF  724,7A3
0707C:  MOVFF  723,7A2
07080:  MOVFF  722,7A1
07084:  MOVFF  721,7A0
07088:  MOVLB  7
0708A:  CLRF   xA7
0708C:  CLRF   xA6
0708E:  CLRF   xA5
07090:  MOVLW  9E
07092:  MOVWF  xA4
07094:  MOVLB  0
07096:  CALL   1808
0709A:  BTFSC  19.7
0709C:  BSF    FF2.7
0709E:  CLRF   19
070A0:  BTFSC  FF2.7
070A2:  BSF    19.7
070A4:  BCF    FF2.7
070A6:  MOVFF  03,772
070AA:  MOVFF  02,771
070AE:  MOVFF  01,770
070B2:  MOVFF  00,76F
070B6:  CALL   2AA0
070BA:  BTFSC  19.7
070BC:  BSF    FF2.7
070BE:  MOVFF  03,728
070C2:  MOVFF  02,727
070C6:  MOVFF  01,726
070CA:  MOVFF  00,725
070CE:  CLRF   19
070D0:  BTFSC  FF2.7
070D2:  BSF    19.7
070D4:  BCF    FF2.7
070D6:  MOVLW  83
070D8:  MOVLB  7
070DA:  MOVWF  x76
070DC:  CLRF   x75
070DE:  CLRF   x74
070E0:  MOVLW  0C
070E2:  MOVWF  x73
070E4:  MOVFF  03,77A
070E8:  MOVFF  02,779
070EC:  MOVFF  01,778
070F0:  MOVFF  00,777
070F4:  MOVLB  0
070F6:  CALL   1388
070FA:  BTFSC  19.7
070FC:  BSF    FF2.7
070FE:  CLRF   19
07100:  BTFSC  FF2.7
07102:  BSF    19.7
07104:  BCF    FF2.7
.................... 			send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
07106:  MOVFF  724,7A3
0710A:  MOVFF  723,7A2
0710E:  MOVFF  722,7A1
07112:  MOVFF  721,7A0
07116:  MOVLB  7
07118:  CLRF   xA7
0711A:  CLRF   xA6
0711C:  CLRF   xA5
0711E:  MOVLW  9E
07120:  MOVWF  xA4
07122:  MOVLB  0
07124:  CALL   1808
07128:  BTFSC  19.7
0712A:  BSF    FF2.7
0712C:  CLRF   19
0712E:  BTFSC  FF2.7
07130:  BSF    19.7
07132:  BCF    FF2.7
07134:  MOVFF  03,772
07138:  MOVFF  02,771
0713C:  MOVFF  01,770
07140:  MOVFF  00,76F
07144:  CALL   2AA0
07148:  BTFSC  19.7
0714A:  BSF    FF2.7
0714C:  MOVFF  03,728
07150:  MOVFF  02,727
07154:  MOVFF  01,726
07158:  MOVFF  00,725
0715C:  CLRF   19
0715E:  BTFSC  FF2.7
07160:  BSF    19.7
07162:  BCF    FF2.7
07164:  MOVLW  83
07166:  MOVLB  7
07168:  MOVWF  x76
0716A:  CLRF   x75
0716C:  CLRF   x74
0716E:  MOVLW  0D
07170:  MOVWF  x73
07172:  MOVFF  03,77A
07176:  MOVFF  02,779
0717A:  MOVFF  01,778
0717E:  MOVFF  00,777
07182:  MOVLB  0
07184:  CALL   1388
07188:  BTFSC  19.7
0718A:  BSF    FF2.7
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] Startup RVC - ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		dsp_unmute_outputs(); 
0718C:  RCALL  6C8E
....................  
.................... 	} else { 
0718E:  BRA    7190
.................... 		if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] DEVICE_CONFIG.RVC_ENABLE == 0\r\n"); 
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	output_low(AUD_MUTE); 
07190:  BCF    F95.3
07192:  BCF    F8C.3
....................  
.................... 	update_phantom_power(); 
07194:  RCALL  6CB8
....................  
.................... } 
07196:  RETURN 0
....................  
.................... void setup_interrupts() 
.................... { 
.................... 	if(DEVICE_CONFIG.RVC_ENABLE == 1) { 
*
02EEE:  DECFSZ 3D,W
02EF0:  BRA    2EFE
....................  
.................... 		set_timer1(15550); 
02EF2:  MOVLW  3C
02EF4:  MOVWF  FCF
02EF6:  MOVLW  BE
02EF8:  MOVWF  FCE
.................... 		enable_interrupts(INT_TIMER1);  
02EFA:  BSF    F9D.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Enabling RVC\r\n"); 
.................... 		} 
.................... 	} else { 
02EFC:  BRA    2EFE
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] Disabling RVC\r\n"); 
.................... 		} 
.................... 	} 
.................... 	if(DEBUG) { 
.................... 		fprintf(RS232,"[DEBUG]: Enabling global interrupts\r\n"); 
.................... 	} 
.................... 	enable_interrupts(GLOBAL); 
02EFE:  MOVLW  C0
02F00:  IORWF  FF2,F
....................  
.................... 	 
.................... 	enable_interrupts(INT_RDA2); 
02F02:  BSF    FA3.5
.................... 	 
.................... 	 
....................  
.................... 	disable_interrupts(INT_EXT);  
02F04:  BCF    FF2.4
....................  
.................... 	if(DEVICE_CONFIG.SLEEP_ENABLE == 1) { 
02F06:  DECFSZ 42,W
02F08:  BRA    2F36
.................... 		// Sleep timer enabled.. check initial state 
.................... 		if(DEBUG){ 
.................... 			fprintf(RS232,"[DEBUG] Sleep detect enabled... checking current state..."); 
.................... 		} 
....................  
.................... 		if(input(PIN_AUDIODETECT)) { 
02F0A:  BSF    F93.0
02F0C:  BTFSS  F81.0
02F0E:  BRA    2F20
.................... 			// We currently have audio 
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will disable sleep timer and wait for audiodetect to go low\r\n"); 
.................... 			} 
....................  
.................... 				ext_int_edge(0,H_TO_L);  
02F10:  BCF    FF1.6
.................... 				enable_interrupts(INT_EXT); 
02F12:  BSF    FF2.4
.................... 				disable_interrupts(INT_TIMER0); 
02F14:  BCF    FF2.5
.................... 				sleep_timer_active = 0; 
02F16:  MOVLB  1
02F18:  CLRF   x83
.................... 				is_in_sleep = 0; 
02F1A:  CLRF   x82
.................... 		} else { 
02F1C:  BRA    2F34
02F1E:  MOVLB  0
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"NO AUDIO PRESENT\r\n"); 
.................... 				fprintf(RS232,"[DEBUG] Will start sleep timer and wait for audiodetect to go high\r\n"); 
.................... 			} 
....................  
.................... 			ext_int_edge(0,L_TO_H);  
02F20:  BSF    FF1.6
.................... 			enable_interrupts(INT_EXT); 
02F22:  BSF    FF2.4
....................  
.................... 			set_timer0(7936); 
02F24:  MOVLW  1F
02F26:  MOVWF  FD7
02F28:  CLRF   FD6
.................... 			enable_interrupts(INT_TIMER0); 
02F2A:  BSF    FF2.5
.................... 			sleep_timer_active = 1; 
02F2C:  MOVLW  01
02F2E:  MOVLB  1
02F30:  MOVWF  x83
.................... 			is_in_sleep = 0; 
02F32:  CLRF   x82
02F34:  MOVLB  0
.................... 				 
.................... 		}				 
....................  
.................... 	} 
....................  
.................... 	if(DEVICE_CONFIG.USBDETECT_ENABLE == 0) { 
02F36:  MOVF   3E,F
02F38:  BNZ   2F42
.................... 		IS_USB_CONNECTED = true; 
02F3A:  MOVLW  01
02F3C:  MOVWF  x78
.................... 		disable_interrupts(INT_EXT1);  
02F3E:  BCF    FF0.3
.................... 	} else { 
02F40:  BRA    2F58
.................... 		// Check initial plug state 
.................... 		if(input(PIN_B1)) { 
02F42:  BSF    F93.1
02F44:  BTFSS  F81.1
02F46:  BRA    2F50
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is high. Setting IS_USB_CONNECTED to true\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = true; 
02F48:  MOVLW  01
02F4A:  MOVWF  x78
.................... 			ext_int_edge(1,H_TO_L);  
02F4C:  BCF    FF1.5
.................... 		} else { 
02F4E:  BRA    2F54
.................... 			if(DEBUG){ 
.................... 				fprintf(RS232,"[DEBUG] Initial state of USB is low. Setting IS_USB_CONNECTED to false\r\n"); 
.................... 			} 
.................... 			IS_USB_CONNECTED = false; 
02F50:  CLRF   x78
.................... 			ext_int_edge(1,L_TO_H);  
02F52:  BSF    FF1.5
.................... 		} 
....................  
.................... 		clear_interrupt(INT_EXT1);  
02F54:  BCF    FF0.0
....................    		enable_interrupts(INT_EXT1); 
02F56:  BSF    FF0.3
.................... 	 
.................... 	} 
.................... } 
02F58:  RETURN 0
....................  
....................  
.................... void setup_peripherals() 
.................... { 
....................  
.................... 	setup_adc( ADC_CLOCK_INTERNAL ); 
*
03028:  MOVF   FC0,W
0302A:  ANDLW  C0
0302C:  IORLW  07
0302E:  MOVWF  FC0
03030:  BCF    FC0.7
03032:  BSF    FC2.0
....................  
.................... 	setup_adc_ports( sAN0 | sAN9 ); 
03034:  MOVF   FC1,W
03036:  ANDLW  F0
03038:  MOVWF  FC1
0303A:  MOVLW  01
0303C:  MOVLB  F
0303E:  MOVWF  x38
03040:  MOVLW  00
03042:  MOVWF  x3C
03044:  MOVLW  08
03046:  MOVWF  x39
03048:  MOVLW  00
0304A:  MOVWF  x3A
0304C:  MOVWF  x3B
....................  
.................... 	set_adc_channel(0); 
0304E:  MOVWF  01
03050:  MOVF   FC2,W
03052:  ANDLW  83
03054:  IORWF  01,W
03056:  MOVWF  FC2
....................  
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
03058:  MOVLW  85
0305A:  MOVWF  FD5
....................  
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0305C:  MOVLW  37
0305E:  MOVWF  FCD
03060:  CLRF   FCC
....................  
.................... 	setup_timer_3(T3_DISABLED | T3_DIV_BY_1); 
03062:  CLRF   FB4
03064:  CLRF   FB1
....................    	setup_timer_4(T4_DISABLED,0,1); 
03066:  MOVLW  00
03068:  MOVWF  x51
0306A:  MOVLW  00
0306C:  MOVWF  x52
....................    	setup_timer_5(T5_DISABLED | T5_DIV_BY_1); 
0306E:  CLRF   x4D
03070:  CLRF   x4E
....................    	setup_timer_6(T6_DISABLED,0,1); 
03072:  MOVWF  x4A
03074:  MOVLW  00
03076:  MOVWF  x4B
....................  
.................... 	setup_wdt(WDT_OFF);  
03078:  BCF    FD1.0
....................  
.................... } 
0307A:  MOVLB  0
0307C:  GOTO   948A (RETURN)
....................  
....................  
....................  
.................... #include <timed_getc.c> 
.................... //timed_getc.c 
.................... int timeout_error; 
....................  
.................... short data_available_usb() 
.................... { 
.................... 	return kbhit(USB); 
....................  
....................  
.................... } 
.................... char timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
07296:  MOVLB  5
07298:  CLRF   x8C
.................... 	timeout = 0; 
0729A:  MOVLB  7
0729C:  CLRF   x29
0729E:  CLRF   x28
....................  
.................... 	while(!kbhit(USB)&&(++timeout<50000)) { // half a second 
072A0:  BTFSS  F82.4
072A2:  BRA    72C4
072A4:  INCF   x28,F
072A6:  BTFSC  FD8.2
072A8:  INCF   x29,F
072AA:  MOVF   x29,W
072AC:  SUBLW  C3
072AE:  BNC   72C4
072B0:  BNZ   72B8
072B2:  MOVF   x28,W
072B4:  SUBLW  4F
072B6:  BNC   72C4
.................... 		delay_us(5); // this polls at 10x the 9600 baud rate 
072B8:  MOVLW  05
072BA:  MOVWF  00
072BC:  DECFSZ 00,F
072BE:  BRA    72BC
072C0:  BRA    72C2
.................... 	} 
072C2:  BRA    72A0
....................  
.................... 	if(kbhit()) { 
072C4:  BTFSC  F82.4
072C6:  BRA    72D8
.................... 		timeout_error = FALSE; 
072C8:  MOVLB  5
072CA:  CLRF   x8C
.................... 		return(fgetc(USB)); 
072CC:  MOVLB  0
072CE:  RCALL  7198
072D0:  MOVF   01,W
072D2:  BRA    72E6
.................... 	} else { 
072D4:  BRA    72E6
072D6:  MOVLB  7
.................... 		timeout_error = TRUE; 
072D8:  MOVLW  01
072DA:  MOVLB  5
072DC:  MOVWF  x8C
.................... 		return(0); 
072DE:  MOVLW  00
072E0:  MOVWF  01
072E2:  MOVLB  0
072E4:  BRA    72E6
.................... 	} 
.................... } 
072E6:  RETURN 0
....................  
.................... char fast_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
*
071E2:  MOVLB  5
071E4:  CLRF   x8C
.................... 	timeout = 0; 
071E6:  MOVLB  7
071E8:  CLRF   x21
071EA:  CLRF   x20
....................  
.................... 	while(!kbhit(USB)&&(++timeout<10000)) { // tenth of a second 
071EC:  BTFSS  F82.4
071EE:  BRA    7210
071F0:  INCF   x20,F
071F2:  BTFSC  FD8.2
071F4:  INCF   x21,F
071F6:  MOVF   x21,W
071F8:  SUBLW  27
071FA:  BNC   7210
071FC:  BNZ   7204
071FE:  MOVF   x20,W
07200:  SUBLW  0F
07202:  BNC   7210
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
07204:  MOVLW  0B
07206:  MOVWF  00
07208:  DECFSZ 00,F
0720A:  BRA    7208
0720C:  BRA    720E
.................... 	} 
0720E:  BRA    71EC
....................  
.................... 	if(kbhit()) { 
07210:  BTFSC  F82.4
07212:  BRA    7224
.................... 		timeout_error = FALSE; 
07214:  MOVLB  5
07216:  CLRF   x8C
.................... 		return(getc()); 
07218:  MOVLB  0
0721A:  RCALL  7198
0721C:  MOVF   01,W
0721E:  BRA    7232
.................... 	} else { 
07220:  BRA    7232
07222:  MOVLB  7
.................... 		timeout_error = TRUE; 
07224:  MOVLW  01
07226:  MOVLB  5
07228:  MOVWF  x8C
.................... 		return(0); 
0722A:  MOVLW  00
0722C:  MOVWF  01
0722E:  MOVLB  0
07230:  BRA    7232
.................... 	} 
.................... } 
07232:  RETURN 0
....................  
.................... char slow_timed_getc() { 
....................  
.................... 	long timeout; 
....................  
.................... 	timeout_error = FALSE; 
.................... 	timeout = 0; 
....................  
.................... 	while(!kbhit(USB)&&(++timeout<20000)) { // fifth of a second 
.................... 		delay_us(10); // this polls at 10x the 9600 baud rate 
.................... 	} 
....................  
.................... 	if(kbhit()) { 
.................... 		timeout_error = FALSE; 
.................... 		return(getc()); 
.................... 	} else { 
.................... 		timeout_error = TRUE; 
.................... 		return(0); 
.................... 	} 
.................... } 
....................  
.................... #include <streaming.c> 
.................... // streaming.c 
....................  
.................... #define NIBBLE_SIZE 32 
....................  
.................... /* VARIABLES FOR STREAMING */ 
.................... byte STREAMING_BUFFER[256]; 
....................  
.................... byte STREAM_NIBBLE_BUFFER[32]; 
....................  
.................... int16 streaming_buffer_index = 0; 
.................... int16 bytes_in_stream = 0; 
....................  
.................... int16 num_bytes_added = 0; 
....................  
.................... int stream_target_program = 0; 
.................... int stream_target_page = 0; 
....................  
.................... short is_streaming = 0; 
....................  
.................... int16 total_bytes_so_far = 0; 
....................  
.................... unsigned int nibble_crc = 0; 
....................  
.................... unsigned int verified_bytes = 0; 
.................... int nibble_index = 0; // 0-31 (local in STREAM_NIBBLE_BUFFER) 
....................  
....................  
.................... void flush_nibble_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
07974:  MOVLB  6
07976:  CLRF   xAE
07978:  CLRF   xAD
.................... 	for(int j = 0; j < 32; j++) { 
0797A:  MOVLB  7
0797C:  CLRF   x28
0797E:  MOVF   x28,W
07980:  SUBLW  1F
07982:  BNC   7998
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
07984:  CLRF   03
07986:  MOVF   x28,W
07988:  ADDLW  8D
0798A:  MOVWF  FE9
0798C:  MOVLW  06
0798E:  ADDWFC 03,W
07990:  MOVWF  FEA
07992:  SETF   FEF
.................... 	} 
07994:  INCF   x28,F
07996:  BRA    797E
....................  
.................... } 
07998:  MOVLB  0
0799A:  GOTO   7AB4 (RETURN)
....................  
....................  
.................... void flush_stream_buffer() { 
....................  
.................... 	streaming_buffer_index = 0; 
*
07838:  MOVLB  6
0783A:  CLRF   xAE
0783C:  CLRF   xAD
....................  
.................... 	for(int16 i = 0; i < 256; i++) { 
0783E:  MOVLB  7
07840:  CLRF   x29
07842:  CLRF   x28
07844:  MOVF   x29,W
07846:  SUBLW  00
07848:  BNC   7860
.................... 		STREAMING_BUFFER[i] = 0xFF; 
0784A:  MOVLW  8D
0784C:  ADDWF  x28,W
0784E:  MOVWF  FE9
07850:  MOVLW  05
07852:  ADDWFC x29,W
07854:  MOVWF  FEA
07856:  SETF   FEF
.................... 	} 
07858:  INCF   x28,F
0785A:  BTFSC  FD8.2
0785C:  INCF   x29,F
0785E:  BRA    7844
....................  
.................... 	for(int j = 0; j < 32; j++) { 
07860:  CLRF   x2A
07862:  MOVF   x2A,W
07864:  SUBLW  1F
07866:  BNC   787C
.................... 		STREAM_NIBBLE_BUFFER[j] = 0xFF; 
07868:  CLRF   03
0786A:  MOVF   x2A,W
0786C:  ADDLW  8D
0786E:  MOVWF  FE9
07870:  MOVLW  06
07872:  ADDWFC 03,W
07874:  MOVWF  FEA
07876:  SETF   FEF
.................... 	} 
07878:  INCF   x2A,F
0787A:  BRA    7862
....................  
.................... } 
0787C:  MOVLB  0
0787E:  RETURN 0
....................  
....................  
....................  
....................  
.................... int calc_crc_int(int *Buffer, int16 Len)  
.................... {  
*
078CA:  MOVLB  7
078CC:  SETF   x2F
078CE:  SETF   x2E
078D0:  CLRF   x30
....................    int16 x;  
....................    int16 crc = 0xFFFF;  
....................    int return_int = 0; 
....................  
....................    while(Len--)  
....................    {  
078D2:  MOVFF  72B,03
078D6:  MOVF   x2A,W
078D8:  BTFSC  FD8.2
078DA:  DECF   x2B,F
078DC:  DECF   x2A,F
078DE:  IORWF  03,W
078E0:  BZ    7966
....................       x = make8(crc,1) ^ *Buffer++;  
078E2:  MOVFF  729,03
078E6:  MOVF   x28,W
078E8:  INCF   x28,F
078EA:  BTFSC  FD8.2
078EC:  INCF   x29,F
078EE:  MOVWF  FE9
078F0:  MOVFF  03,FEA
078F4:  MOVF   FEF,W
078F6:  XORWF  x2F,W
078F8:  MOVWF  x2C
078FA:  CLRF   x2D
....................       x ^= x>>4;  
078FC:  RRCF   x2D,W
078FE:  MOVWF  03
07900:  RRCF   x2C,W
07902:  MOVWF  02
07904:  RRCF   03,F
07906:  RRCF   02,F
07908:  RRCF   03,F
0790A:  RRCF   02,F
0790C:  RRCF   03,F
0790E:  RRCF   02,F
07910:  MOVLW  0F
07912:  ANDWF  03,F
07914:  MOVF   02,W
07916:  XORWF  x2C,F
07918:  MOVF   03,W
0791A:  XORWF  x2D,F
....................        
....................       crc = (crc << 8) ^ (x << 12) ^ (x <<5) ^ x;  
0791C:  MOVFF  72E,732
07920:  CLRF   x31
07922:  SWAPF  x2C,W
07924:  MOVWF  03
07926:  CLRF   02
07928:  MOVLW  F0
0792A:  ANDWF  03,F
0792C:  MOVF   02,W
0792E:  XORWF  x31,F
07930:  MOVF   03,W
07932:  XORWF  x32,F
07934:  RLCF   x2C,W
07936:  MOVWF  02
07938:  RLCF   x2D,W
0793A:  MOVWF  03
0793C:  RLCF   02,F
0793E:  RLCF   03,F
07940:  RLCF   02,F
07942:  RLCF   03,F
07944:  RLCF   02,F
07946:  RLCF   03,F
07948:  RLCF   02,F
0794A:  RLCF   03,F
0794C:  MOVLW  E0
0794E:  ANDWF  02,F
07950:  MOVF   02,W
07952:  XORWF  x31,F
07954:  MOVF   03,W
07956:  XORWF  x32,F
07958:  MOVF   x31,W
0795A:  XORWF  x2C,W
0795C:  MOVWF  x2E
0795E:  MOVF   x32,W
07960:  XORWF  x2D,W
07962:  MOVWF  x2F
....................    }  
07964:  BRA    78D2
....................  
.................... 	return_int = crc & 0xFF; 
07966:  MOVFF  72E,730
....................  
....................    	return return_int;  
0796A:  MOVFF  730,01
.................... }  
0796E:  MOVLB  0
07970:  GOTO   7A54 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... void clear_nibble() 
.................... { 
.................... 	for(int n = 0; n < NIBBLE_SIZE; n++) { 
*
07880:  MOVLB  7
07882:  CLRF   x28
07884:  MOVF   x28,W
07886:  SUBLW  1F
07888:  BNC   789E
.................... 		STREAM_NIBBLE_BUFFER[n] = 0xFF; 
0788A:  CLRF   03
0788C:  MOVF   x28,W
0788E:  ADDLW  8D
07890:  MOVWF  FE9
07892:  MOVLW  06
07894:  ADDWFC 03,W
07896:  MOVWF  FEA
07898:  SETF   FEF
.................... 	} 
0789A:  INCF   x28,F
0789C:  BRA    7884
....................  
.................... 	nibble_index = 0; 
0789E:  MOVLB  6
078A0:  CLRF   xBA
.................... } 
078A2:  MOVLB  0
078A4:  GOTO   78B0 (RETURN)
....................  
.................... void add_nibble_to_buffer() 
.................... { 
.................... 	for(int m = 0; m < NIBBLE_SIZE; m++) { 
.................... 		STREAMING_BUFFER[verified_bytes++] = STREAM_NIBBLE_BUFFER[m]; 
.................... 	} 
....................  
.................... 	nibble_index = 0; 
.................... } 
....................  
.................... void kill_stream() 
.................... { 
.................... 	is_streaming = false; 
078A8:  MOVLB  6
078AA:  BCF    xB5.0
.................... 	clear_nibble(); 
078AC:  MOVLB  0
078AE:  BRA    7880
.................... 	flush_stream_buffer(); 
078B0:  RCALL  7838
.................... 	streaming_buffer_index = 0; 
078B2:  MOVLB  6
078B4:  CLRF   xAE
078B6:  CLRF   xAD
.................... 	streaming_buffer_index = 0; 
078B8:  CLRF   xAE
078BA:  CLRF   xAD
.................... 	nibble_index = 0; 
078BC:  CLRF   xBA
.................... 	verified_bytes = 0; 
078BE:  CLRF   xB9
.................... 	total_bytes_so_far = 0; 
078C0:  CLRF   xB7
078C2:  CLRF   xB6
....................  
.................... } 
078C4:  MOVLB  0
078C6:  GOTO   7A3A (RETURN)
....................  
.................... void print_stream_to_rs232() 
.................... { 
.................... 	for(int i = 0; i < 32; i++) { 
.................... 		fprintf(RS232,"%u ",STREAM_NIBBLE_BUFFER[i]); 
.................... 	} 
....................  
.................... 	char nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
....................  
.................... 	fprintf(RS232,"CRC = %u\r\n",nibble_crc); 
....................  
.................... 	 
....................  
.................... } 
....................  
.................... void perform_stream(int target_program, int target_page, int16 num_bytes) 
.................... { 
.................... 	 
....................  
.................... 	char streamed_char; 
....................  
.................... 	stream_target_program = target_program; 
*
0799E:  MOVFF  720,6B3
.................... 	stream_target_page = target_page; 
079A2:  MOVFF  721,6B4
.................... 	bytes_in_stream = num_bytes; 
079A6:  MOVFF  723,6B0
079AA:  MOVFF  722,6AF
....................  
.................... 	streaming_buffer_index = 0; 
079AE:  MOVLB  6
079B0:  CLRF   xAE
079B2:  CLRF   xAD
.................... 	streaming_buffer_index = 0; 
079B4:  CLRF   xAE
079B6:  CLRF   xAD
.................... 	nibble_index = 0; 
079B8:  CLRF   xBA
.................... 	verified_bytes = 0; 
079BA:  CLRF   xB9
.................... 	total_bytes_so_far = 0; 
079BC:  CLRF   xB7
079BE:  CLRF   xB6
....................  
.................... 	num_bytes_added = 0; 
079C0:  CLRF   xB2
079C2:  CLRF   xB1
.................... 	total_bytes_so_far = 0; 
079C4:  CLRF   xB7
079C6:  CLRF   xB6
....................  
....................  
.................... 	is_streaming = true; 
079C8:  BSF    xB5.0
.................... 	flush_stream_buffer(); 
079CA:  MOVLB  0
079CC:  RCALL  7838
....................  
.................... 	fputc(0x06,USB); 
079CE:  MOVLW  06
079D0:  MOVLB  7
079D2:  MOVWF  x29
079D4:  MOVLB  0
079D6:  RCALL  7234
.................... 	fputc(target_program,USB); 
079D8:  MOVFF  720,729
079DC:  RCALL  7234
.................... 	fputc(target_page,USB); 
079DE:  MOVFF  721,729
079E2:  RCALL  7234
.................... 	fputc(0x03,USB); 
079E4:  MOVLW  03
079E6:  MOVLB  7
079E8:  MOVWF  x29
079EA:  MOVLB  0
079EC:  RCALL  7234
....................  
.................... 	int nibble_byte_counter = 0; 
079EE:  MOVLB  7
079F0:  CLRF   x25
....................  
.................... 	for(int nibble_counter = 0; nibble_counter <8; nibble_counter++) 
079F2:  CLRF   x26
079F4:  MOVF   x26,W
079F6:  SUBLW  07
079F8:  BNC   7ABA
.................... 	{ 
.................... 		nibble_index = 0; 
079FA:  MOVLB  6
079FC:  CLRF   xBA
....................  
.................... 		for(nibble_byte_counter = 0; nibble_byte_counter < 32; nibble_byte_counter++) { 
079FE:  MOVLB  7
07A00:  CLRF   x25
07A02:  MOVF   x25,W
07A04:  SUBLW  1F
07A06:  BNC   7A30
....................  
.................... 			streamed_char = timed_getc(); 
07A08:  MOVLB  0
07A0A:  RCALL  7296
07A0C:  MOVFF  01,724
.................... 	 
.................... 			total_bytes_so_far++; 
07A10:  MOVLB  6
07A12:  INCF   xB6,F
07A14:  BTFSC  FD8.2
07A16:  INCF   xB7,F
....................  
.................... 			STREAM_NIBBLE_BUFFER[nibble_byte_counter] = streamed_char;	 
07A18:  CLRF   03
07A1A:  MOVLB  7
07A1C:  MOVF   x25,W
07A1E:  ADDLW  8D
07A20:  MOVWF  FE9
07A22:  MOVLW  06
07A24:  ADDWFC 03,W
07A26:  MOVWF  FEA
07A28:  MOVFF  724,FEF
.................... 		} 
07A2C:  INCF   x25,F
07A2E:  BRA    7A02
.................... 	 
.................... 		if(TIMEOUT_ERROR == true) { 
07A30:  MOVLB  5
07A32:  DECFSZ x8C,W
07A34:  BRA    7A40
....................  
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"Timed out after having read %lu bytes\r\n",total_bytes_so_far); 
.................... 				fprintf(RS232,"So far we have received: "); 
.................... 				print_stream_to_rs232(); 
.................... 			} 
.................... 			//send_error(ERR_COMMAND_TIMEOUT); 
.................... 			kill_stream(); 
07A36:  MOVLB  0
07A38:  BRA    78A8
.................... 			return; 
07A3A:  BRA    7B04
.................... 		} else { 
07A3C:  BRA    7AB4
07A3E:  MOVLB  5
.................... 			 
.................... 			nibble_crc = calc_crc_int(STREAM_NIBBLE_BUFFER,sizeof(STREAM_NIBBLE_BUFFER)); 
07A40:  MOVLW  06
07A42:  MOVLB  7
07A44:  MOVWF  x29
07A46:  MOVLW  8D
07A48:  MOVWF  x28
07A4A:  CLRF   x2B
07A4C:  MOVLW  20
07A4E:  MOVWF  x2A
07A50:  MOVLB  0
07A52:  BRA    78CA
07A54:  MOVFF  01,6B8
.................... 			//fprintf(RS232,"GOT FULL NIBBLE. So far %lu. Sending %u CRC\r\n",total_bytes_so_far,nibble_crc); 
.................... 			fputc(nibble_crc,USB); 
07A58:  MOVFF  6B8,729
07A5C:  CALL   7234
....................  
.................... 			for(int x = 0; x < 32; x++) { 
07A60:  MOVLB  7
07A62:  CLRF   x27
07A64:  MOVF   x27,W
07A66:  SUBLW  1F
07A68:  BNC   7AB0
.................... 				STREAMING_BUFFER[num_bytes_added++] = STREAM_NIBBLE_BUFFER[x]; 
07A6A:  MOVLB  6
07A6C:  MOVFF  6B2,03
07A70:  MOVF   xB1,W
07A72:  INCF   xB1,F
07A74:  BTFSC  FD8.2
07A76:  INCF   xB2,F
07A78:  MOVLB  7
07A7A:  MOVWF  x28
07A7C:  MOVFF  03,729
07A80:  MOVLW  8D
07A82:  ADDWF  x28,W
07A84:  MOVWF  01
07A86:  MOVLW  05
07A88:  ADDWFC 03,W
07A8A:  MOVWF  03
07A8C:  MOVWF  x2B
07A8E:  CLRF   03
07A90:  MOVF   x27,W
07A92:  ADDLW  8D
07A94:  MOVWF  FE9
07A96:  MOVLW  06
07A98:  ADDWFC 03,W
07A9A:  MOVWF  FEA
07A9C:  MOVFF  FEF,72C
07AA0:  MOVFF  72B,FEA
07AA4:  MOVFF  01,FE9
07AA8:  MOVFF  72C,FEF
.................... 			} 
07AAC:  INCF   x27,F
07AAE:  BRA    7A64
....................  
.................... 			flush_nibble_buffer(); 
07AB0:  MOVLB  0
07AB2:  BRA    7974
.................... 		} 
.................... 	} 
07AB4:  MOVLB  7
07AB6:  INCF   x26,F
07AB8:  BRA    79F4
....................  
.................... 	write_buffer_to_flash_page(&STREAMING_BUFFER,target_program, target_page); 
07ABA:  MOVLW  05
07ABC:  MOVWF  x29
07ABE:  MOVLW  8D
07AC0:  MOVWF  x28
07AC2:  MOVFF  720,72A
07AC6:  MOVFF  721,72B
07ACA:  MOVLB  0
07ACC:  CALL   64E4
....................  
.................... 	fputc(0x06,USB); 
07AD0:  MOVLW  06
07AD2:  MOVLB  7
07AD4:  MOVWF  x29
07AD6:  MOVLB  0
07AD8:  CALL   7234
.................... 	fputc(0x01,USB); 
07ADC:  MOVLW  01
07ADE:  MOVLB  7
07AE0:  MOVWF  x29
07AE2:  MOVLB  0
07AE4:  CALL   7234
.................... 	fputc(target_program,USB); 
07AE8:  MOVFF  720,729
07AEC:  CALL   7234
.................... 	fputc(target_page,USB); 
07AF0:  MOVFF  721,729
07AF4:  CALL   7234
.................... 	fputc(0x03,USB); 
07AF8:  MOVLW  03
07AFA:  MOVLB  7
07AFC:  MOVWF  x29
07AFE:  MOVLB  0
07B00:  CALL   7234
....................  
.................... } 
07B04:  GOTO   8A72 (RETURN)
....................  
.................... #include <sa_usb.c> 
.................... char last_byte1,last_byte2,last_byte3,last_byte4,last_address; 
.................... int finished; 
.................... int temp_byte; 
.................... char name_buffer[20]; 
.................... int x, y; 
....................  
.................... void send_error(char error_code) 
.................... { 
.................... 	fputc(ERR_START,USB); 
*
0727A:  MOVLW  15
0727C:  MOVLB  7
0727E:  MOVWF  x29
07280:  MOVLB  0
07282:  RCALL  7234
.................... 	fputc(error_code,USB); 
07284:  MOVFF  720,729
07288:  RCALL  7234
.................... 	fputc(0x03,USB); 
0728A:  MOVLW  03
0728C:  MOVLB  7
0728E:  MOVWF  x29
07290:  MOVLB  0
07292:  RCALL  7234
.................... } 
07294:  RETURN 0
....................  
.................... void process_usb_data()  { 
....................  
.................... 	char start_char,command_char,dummy_char,byte1,byte2,byte3,byte4,channel; 
.................... 	int16 addr_lsb, addr_msb; 
.................... 	int16 final_address, last_address; 
....................  
....................  
.................... 	/*if(is_streaming) { 
.................... 		process_stream_byte(); 
.................... 		return; 
.................... 	} 
.................... */ 
.................... 	// Wait until we get a starting char. Escapes after timeout to allow program to continue processing 
....................  
.................... 	start_char = fast_timed_getc(); 
*
07DE8:  CALL   71E2
07DEC:  MOVFF  01,6D8
....................  
.................... 	if(TIMEOUT_ERROR == true) { 
07DF0:  MOVLB  5
07DF2:  DECFSZ x8C,W
07DF4:  BRA    7DFA
.................... 		return; 
07DF6:  GOTO   9392
.................... 	} 
.................... 	 
.................... 	/* THIS LIST MUST BE UPDATED WHENEVER WE ADD A NEW START CHARACTER */ 
.................... 	if( 
.................... 		(start_char != 0x02) && // GENERAL 
.................... 		(start_char != 0x04) && // WRITE_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x05) && // GET_DSP_CONFIG_VALUE 
.................... 		(start_char != 0x07) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x08) && // READ_DSP_VALUE 
.................... 		(start_char != 0x09) && // UTILITY 
.................... 		(start_char != 0x10) && // FLASH_PROGRAM_ACTIONS 
.................... 		(start_char != 0x14) && // SET_DEVICE_PROPERTY 
.................... 		(start_char != 0x17) && // SEND_DSP_VALUE_DEBUG 
.................... 		(start_char != 0x15)    // GET_DEVICE_PROPERTY 
.................... 		) 
07DFA:  MOVLB  6
07DFC:  MOVF   xD8,W
07DFE:  SUBLW  02
07E00:  BZ    7E4C
07E02:  MOVF   xD8,W
07E04:  SUBLW  04
07E06:  BZ    7E4C
07E08:  MOVF   xD8,W
07E0A:  SUBLW  05
07E0C:  BZ    7E4C
07E0E:  MOVF   xD8,W
07E10:  SUBLW  07
07E12:  BZ    7E4C
07E14:  MOVF   xD8,W
07E16:  SUBLW  08
07E18:  BZ    7E4C
07E1A:  MOVF   xD8,W
07E1C:  SUBLW  09
07E1E:  BZ    7E4C
07E20:  MOVF   xD8,W
07E22:  SUBLW  10
07E24:  BZ    7E4C
07E26:  MOVF   xD8,W
07E28:  SUBLW  14
07E2A:  BZ    7E4C
07E2C:  MOVF   xD8,W
07E2E:  SUBLW  17
07E30:  BZ    7E4C
07E32:  MOVF   xD8,W
07E34:  SUBLW  15
07E36:  BZ    7E4C
.................... 	{ 
.................... 		send_error(ERR_INVALID_START); 
07E38:  MOVLW  02
07E3A:  MOVLB  7
07E3C:  MOVWF  x20
07E3E:  MOVLB  0
07E40:  CALL   727A
.................... 		return; 
07E44:  MOVLB  5
07E46:  GOTO   9392
07E4A:  MOVLB  6
.................... 	} 
....................  
....................  
.................... 	if(start_char == 0x02) { 
07E4C:  MOVF   xD8,W
07E4E:  SUBLW  02
07E50:  BNZ   7E54
.................... 		goto GENERAL; 
07E52:  BRA    7E94
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x04) { 
07E54:  MOVF   xD8,W
07E56:  SUBLW  04
07E58:  BNZ   7E5C
.................... 		goto WRITE_DSP_CONFIG_VALUE; 
07E5A:  BRA    8100
.................... 	} 
....................  
.................... 	if(start_char == 0x05) { 
07E5C:  MOVF   xD8,W
07E5E:  SUBLW  05
07E60:  BNZ   7E64
.................... 		goto GET_DSP_CONFIG_VALUE; 
07E62:  BRA    838A
.................... 	} 
.................... 	 
.................... 	if(start_char == 0x07) { 
07E64:  MOVF   xD8,W
07E66:  SUBLW  07
07E68:  BNZ   7E6C
.................... 		goto SEND_DSP_VALUE; 
07E6A:  BRA    84E4
.................... 	} 
....................  
.................... 	if(start_char == 0x08) { 
07E6C:  MOVF   xD8,W
07E6E:  SUBLW  08
07E70:  BNZ   7E76
.................... 		goto READ_DSP_VALUE; 
07E72:  GOTO   86AE
.................... 	} 
....................  
.................... 	//if(start_char == 0x09) { 
.................... 		//goto UTILITY; 
.................... 	//} 
....................  
.................... 	if(start_char == 0x10) { 
07E76:  MOVF   xD8,W
07E78:  SUBLW  10
07E7A:  BNZ   7E80
.................... 		goto FLASH_PROGRAM_ACTIONS; 
07E7C:  GOTO   87D6
.................... 	} 
.................... /* 
.................... 	if(start_char == 0x11) { 
.................... 		goto PHANTOM_POWER_ACTIONS; 
.................... 	} 
.................... */ 
....................  
.................... 	if(start_char == 0x14) { 
07E80:  MOVF   xD8,W
07E82:  SUBLW  14
07E84:  BNZ   7E8A
.................... 		goto SET_DEVICE_PROPERTY; 
07E86:  GOTO   8A8E
.................... 	} 
....................  
.................... 	if(start_char == 0x15) { 
07E8A:  MOVF   xD8,W
07E8C:  SUBLW  15
07E8E:  BNZ   7E94
.................... 		goto GET_DEVICE_PROPERTY; 
07E90:  GOTO   8F0E
.................... 	} 
.................... 	 
....................  
.................... 	/* IF YOU ADD A NEW START CHARACTER, UPDATE THE VALID LIST ABOVE */ 
....................  
....................  
.................... GENERAL: 
.................... 	 
.................... 		command_char = timed_getc(); 
07E94:  MOVLB  0
07E96:  CALL   7296
07E9A:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
07E9E:  MOVLB  5
07EA0:  DECFSZ x8C,W
07EA2:  BRA    7EB6
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
07EA4:  MOVLW  10
07EA6:  MOVLB  7
07EA8:  MOVWF  x20
07EAA:  MOVLB  0
07EAC:  CALL   727A
.................... 			return; 
07EB0:  MOVLB  5
07EB2:  GOTO   9392
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
07EB6:  MOVLB  0
07EB8:  CALL   7296
07EBC:  MOVFF  01,6DA
.................... 	 
.................... 		if(timeout_error == true) { 
07EC0:  MOVLB  5
07EC2:  DECFSZ x8C,W
07EC4:  BRA    7ED8
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
07EC6:  MOVLW  11
07EC8:  MOVLB  7
07ECA:  MOVWF  x20
07ECC:  MOVLB  0
07ECE:  CALL   727A
.................... 			return; 
07ED2:  MOVLB  5
07ED4:  GOTO   9392
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
07ED8:  MOVLB  6
07EDA:  MOVF   xDA,W
07EDC:  SUBLW  03
07EDE:  BZ    7EF4
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
07EE0:  MOVLW  12
07EE2:  MOVLB  7
07EE4:  MOVWF  x20
07EE6:  MOVLB  0
07EE8:  CALL   727A
.................... 			return; 
07EEC:  MOVLB  5
07EEE:  GOTO   9392
07EF2:  MOVLB  6
.................... 		} 
....................  
.................... 		switch(command_char) 
.................... 		{ 
07EF4:  MOVF   xD9,W
07EF6:  XORLW  01
07EF8:  MOVLB  0
07EFA:  BZ    7F28
07EFC:  XORLW  05
07EFE:  BZ    7F54
07F00:  XORLW  01
07F02:  BZ    7F96
07F04:  XORLW  02
07F06:  BZ    7FC6
07F08:  XORLW  0F
07F0A:  BTFSC  FD8.2
07F0C:  BRA    8002
07F0E:  XORLW  01
07F10:  BTFSC  FD8.2
07F12:  BRA    802A
07F14:  XORLW  19
07F16:  BTFSC  FD8.2
07F18:  BRA    8056
07F1A:  XORLW  01
07F1C:  BTFSC  FD8.2
07F1E:  BRA    8088
07F20:  XORLW  31
07F22:  BTFSC  FD8.2
07F24:  BRA    80C2
07F26:  BRA    80EC
.................... 			case 0x01 : 
.................... 				// RTS 
.................... 				fputc(0x06,USB); 
07F28:  MOVLW  06
07F2A:  MOVLB  7
07F2C:  MOVWF  x29
07F2E:  MOVLB  0
07F30:  CALL   7234
.................... 				fputc(0x01,USB); 
07F34:  MOVLW  01
07F36:  MOVLB  7
07F38:  MOVWF  x29
07F3A:  MOVLB  0
07F3C:  CALL   7234
.................... 				fputc(0x03,USB); 
07F40:  MOVLW  03
07F42:  MOVLB  7
07F44:  MOVWF  x29
07F46:  MOVLB  0
07F48:  CALL   7234
.................... 				return; 
07F4C:  MOVLB  5
07F4E:  GOTO   9392
.................... 			break; 
07F52:  BRA    8100
....................  
.................... 			case 0x04 : 
.................... 				// DEVICE ID 
.................... 				fputc(0x06,USB); 
07F54:  MOVLW  06
07F56:  MOVLB  7
07F58:  MOVWF  x29
07F5A:  MOVLB  0
07F5C:  CALL   7234
.................... 				fputc(0x04,USB); 
07F60:  MOVLW  04
07F62:  MOVLB  7
07F64:  MOVWF  x29
07F66:  MOVLB  0
07F68:  CALL   7234
.................... 				fputc(DEVICE_ID_MSB,USB); 
07F6C:  MOVLB  7
07F6E:  CLRF   x29
07F70:  MOVLB  0
07F72:  CALL   7234
.................... 				fputc(DEVICE_ID_LSB,USB); 
07F76:  MOVLW  1F
07F78:  MOVLB  7
07F7A:  MOVWF  x29
07F7C:  MOVLB  0
07F7E:  CALL   7234
.................... 				fputc(0x03,USB); 
07F82:  MOVLW  03
07F84:  MOVLB  7
07F86:  MOVWF  x29
07F88:  MOVLB  0
07F8A:  CALL   7234
.................... 				return; 
07F8E:  MOVLB  5
07F90:  GOTO   9392
.................... 			break; 
07F94:  BRA    8100
....................  
.................... 			case 0x05 : 
.................... 				// SOFT REBOOT 
.................... 				softboot(); 
07F96:  CALL   6D22
.................... 				fputc(0x06,USB); 
07F9A:  MOVLW  06
07F9C:  MOVLB  7
07F9E:  MOVWF  x29
07FA0:  MOVLB  0
07FA2:  CALL   7234
.................... 				fputc(0x05,USB); 
07FA6:  MOVLW  05
07FA8:  MOVLB  7
07FAA:  MOVWF  x29
07FAC:  MOVLB  0
07FAE:  CALL   7234
.................... 				fputc(0x03,USB); 
07FB2:  MOVLW  03
07FB4:  MOVLB  7
07FB6:  MOVWF  x29
07FB8:  MOVLB  0
07FBA:  CALL   7234
.................... 				return; 
07FBE:  MOVLB  5
07FC0:  GOTO   9392
.................... 			break; 
07FC4:  BRA    8100
....................  
.................... 			case 0x07 : 
.................... 				// Firmware Version 
....................  
.................... 				fputc(0x06,USB); 
07FC6:  MOVLW  06
07FC8:  MOVLB  7
07FCA:  MOVWF  x29
07FCC:  MOVLB  0
07FCE:  CALL   7234
.................... 				fputc(0x07,USB); 
07FD2:  MOVLW  07
07FD4:  MOVLB  7
07FD6:  MOVWF  x29
07FD8:  MOVLB  0
07FDA:  CALL   7234
.................... 				fputc(MAJOR_REVISION,USB); 
07FDE:  MOVFF  61,729
07FE2:  CALL   7234
.................... 				fputc(MINOR_REVISION,USB); 
07FE6:  MOVFF  62,729
07FEA:  CALL   7234
.................... 				fputc(0x03,USB); 
07FEE:  MOVLW  03
07FF0:  MOVLB  7
07FF2:  MOVWF  x29
07FF4:  MOVLB  0
07FF6:  CALL   7234
.................... 				return; 
07FFA:  MOVLB  5
07FFC:  GOTO   9392
.................... 			break; 
08000:  BRA    8100
....................  
.................... 			case 0x08 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				fputc(0x06,USB); 
08002:  MOVLW  06
08004:  MOVLB  7
08006:  MOVWF  x29
08008:  MOVLB  0
0800A:  CALL   7234
.................... 				fputc(0x08,USB); 
0800E:  MOVLW  08
08010:  MOVLB  7
08012:  MOVWF  x29
08014:  MOVLB  0
08016:  CALL   7234
.................... 				fputc(0x03,USB); 
0801A:  MOVLW  03
0801C:  MOVLB  7
0801E:  MOVWF  x29
08020:  MOVLB  0
08022:  CALL   7234
.................... 			break; 
08026:  MOVLB  5
08028:  BRA    8100
....................  
.................... 			case 0x09 : 
.................... 				 
.................... 				// TODO - Not yet implemented 
....................  
.................... 				update_phantom_power(); 
0802A:  CALL   6CB8
....................  
.................... 				fputc(0x06,USB); 
0802E:  MOVLW  06
08030:  MOVLB  7
08032:  MOVWF  x29
08034:  MOVLB  0
08036:  CALL   7234
.................... 				fputc(0x09,USB); 
0803A:  MOVLW  09
0803C:  MOVLB  7
0803E:  MOVWF  x29
08040:  MOVLB  0
08042:  CALL   7234
.................... 				fputc(0x03,USB); 
08046:  MOVLW  03
08048:  MOVLB  7
0804A:  MOVWF  x29
0804C:  MOVLB  0
0804E:  CALL   7234
.................... 			break; 
08052:  MOVLB  5
08054:  BRA    8100
....................  
....................  
.................... 			case 0x10 : 
.................... 				// DISABLE TIMERS 
....................  
.................... 				SETUP_TIMER_0(RTCC_OFF); 
08056:  CLRF   FD5
.................... 				setup_timer_1(T1_DISABLED); 
08058:  CLRF   FCD
0805A:  CLRF   FCC
....................  
.................... 				fputc(0x06,USB); 
0805C:  MOVLW  06
0805E:  MOVLB  7
08060:  MOVWF  x29
08062:  MOVLB  0
08064:  CALL   7234
.................... 				fputc(0x10,USB); 
08068:  MOVLW  10
0806A:  MOVLB  7
0806C:  MOVWF  x29
0806E:  MOVLB  0
08070:  CALL   7234
.................... 				fputc(0x03,USB); 
08074:  MOVLW  03
08076:  MOVLB  7
08078:  MOVWF  x29
0807A:  MOVLB  0
0807C:  CALL   7234
.................... 				return; 
08080:  MOVLB  5
08082:  GOTO   9392
.................... 			break; 
08086:  BRA    8100
....................  
.................... 			case 0x11 : 
.................... 				// ENABLE TIMERS 
....................  
.................... 				setup_timer_0(T0_INTERNAL|T0_DIV_64); 
08088:  MOVLW  85
0808A:  MOVWF  FD5
.................... 				setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0808C:  MOVLW  37
0808E:  MOVWF  FCD
08090:  CLRF   FCC
....................  
.................... 				setup_interrupts(); 
08092:  CALL   2EEE
....................  
.................... 				fputc(0x06,USB); 
08096:  MOVLW  06
08098:  MOVLB  7
0809A:  MOVWF  x29
0809C:  MOVLB  0
0809E:  CALL   7234
.................... 				fputc(0x11,USB); 
080A2:  MOVLW  11
080A4:  MOVLB  7
080A6:  MOVWF  x29
080A8:  MOVLB  0
080AA:  CALL   7234
.................... 				fputc(0x03,USB); 
080AE:  MOVLW  03
080B0:  MOVLB  7
080B2:  MOVWF  x29
080B4:  MOVLB  0
080B6:  CALL   7234
.................... 				return; 
080BA:  MOVLB  5
080BC:  GOTO   9392
.................... 			break; 
080C0:  BRA    8100
....................  
....................  
.................... 			case 0x20 : 
.................... 				// Reboot for firmware update 
.................... 				fputc(0x06,USB); 
080C2:  MOVLW  06
080C4:  MOVLB  7
080C6:  MOVWF  x29
080C8:  MOVLB  0
080CA:  CALL   7234
.................... 				fputc(0x20,USB); 
080CE:  MOVLW  20
080D0:  MOVLB  7
080D2:  MOVWF  x29
080D4:  MOVLB  0
080D6:  CALL   7234
.................... 				fputc(0x03,USB); 
080DA:  MOVLW  03
080DC:  MOVLB  7
080DE:  MOVWF  x29
080E0:  MOVLB  0
080E2:  CALL   7234
.................... 				reset_cpu(); 
080E6:  RESET
....................  
.................... 			break; 
080E8:  MOVLB  5
080EA:  BRA    8100
....................  
....................  
.................... 			default : 
.................... 				send_error(ERR_COMMAND_INVALID); 
080EC:  MOVLW  13
080EE:  MOVLB  7
080F0:  MOVWF  x20
080F2:  MOVLB  0
080F4:  CALL   727A
.................... 				return; 
080F8:  MOVLB  5
080FA:  GOTO   9392
.................... 			break; 
080FE:  BRA    8100
.................... 		} 
....................  
.................... WRITE_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
08100:  MOVLB  0
08102:  CALL   7296
08106:  MOVLB  6
08108:  CLRF   xE3
0810A:  MOVFF  01,6E2
....................  
.................... 		if(timeout_error == true) { 
0810E:  MOVLB  5
08110:  DECFSZ x8C,W
08112:  BRA    8126
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
08114:  MOVLW  14
08116:  MOVLB  7
08118:  MOVWF  x20
0811A:  MOVLB  0
0811C:  CALL   727A
.................... 			return; 
08120:  MOVLB  5
08122:  GOTO   9392
.................... 		} 
....................  
.................... 		addr_lsb = timed_getc(); 
08126:  MOVLB  0
08128:  CALL   7296
0812C:  MOVLB  6
0812E:  CLRF   xE1
08130:  MOVFF  01,6E0
....................  
.................... 		if(timeout_error == true) { 
08134:  MOVLB  5
08136:  DECFSZ x8C,W
08138:  BRA    814C
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
0813A:  MOVLW  14
0813C:  MOVLB  7
0813E:  MOVWF  x20
08140:  MOVLB  0
08142:  CALL   727A
.................... 			return; 
08146:  MOVLB  5
08148:  GOTO   9392
.................... 		} 
....................  
....................  
.................... 		if(addr_msb > 0) { 
0814C:  MOVLB  6
0814E:  MOVF   xE2,F
08150:  BNZ   8156
08152:  MOVF   xE3,F
08154:  BZ    8172
.................... 			final_address = 0; 
08156:  CLRF   xE5
08158:  CLRF   xE4
.................... 			final_address = addr_msb; 
0815A:  MOVFF  6E3,6E5
0815E:  MOVFF  6E2,6E4
.................... 			final_address <<= 8; 
08162:  MOVFF  6E4,6E5
08166:  CLRF   xE4
.................... 			final_address |= addr_lsb; 
08168:  MOVF   xE0,W
0816A:  IORWF  xE4,F
0816C:  MOVF   xE1,W
0816E:  IORWF  xE5,F
.................... 		} else { 
08170:  BRA    817A
.................... 			final_address = addr_lsb; 
08172:  MOVFF  6E1,6E5
08176:  MOVFF  6E0,6E4
.................... 		} 
....................  
.................... 		//if((final_address >= 0) && (final_address <= num_dsp_values)) { 
....................  
.................... 			// byte1 is MSB 
.................... 			byte1 = fast_timed_getc(); 
0817A:  MOVLB  0
0817C:  CALL   71E2
08180:  MOVFF  01,6DB
.................... 			byte2 = fast_timed_getc(); 
08184:  CALL   71E2
08188:  MOVFF  01,6DC
.................... 			byte3 = fast_timed_getc(); 
0818C:  CALL   71E2
08190:  MOVFF  01,6DD
.................... 			byte4 = fast_timed_getc(); 
08194:  CALL   71E2
08198:  MOVFF  01,6DE
....................  
.................... 			if(timeout_error == true) { 
0819C:  MOVLB  5
0819E:  DECFSZ x8C,W
081A0:  BRA    81CC
.................... 				// Timed out on one of the bytes 
.................... 				fputc(0x15,USB); 
081A2:  MOVLW  15
081A4:  MOVLB  7
081A6:  MOVWF  x29
081A8:  MOVLB  0
081AA:  CALL   7234
.................... 				fputc(ERR_DATA_TIMEOUT,USB); 
081AE:  MOVLW  17
081B0:  MOVLB  7
081B2:  MOVWF  x29
081B4:  MOVLB  0
081B6:  CALL   7234
.................... 				fputc(0x03,USB); 
081BA:  MOVLW  03
081BC:  MOVLB  7
081BE:  MOVWF  x29
081C0:  MOVLB  0
081C2:  CALL   7234
.................... 				return; 
081C6:  MOVLB  5
081C8:  GOTO   9392
.................... 			}	 
.................... 			 
.................... 			dummy_char = timed_getc(); 
081CC:  MOVLB  0
081CE:  CALL   7296
081D2:  MOVFF  01,6DA
.................... 	 
.................... 			if(timeout_error == true) { 
081D6:  MOVLB  5
081D8:  DECFSZ x8C,W
081DA:  BRA    8206
.................... 				// Timed out. No command. Start over. 
.................... 				fputc(0x15,USB); 
081DC:  MOVLW  15
081DE:  MOVLB  7
081E0:  MOVWF  x29
081E2:  MOVLB  0
081E4:  CALL   7234
.................... 				fputc(ERR_END_TIMEOUT,USB); 
081E8:  MOVLW  11
081EA:  MOVLB  7
081EC:  MOVWF  x29
081EE:  MOVLB  0
081F0:  CALL   7234
.................... 				fputc(0x03,USB); 
081F4:  MOVLW  03
081F6:  MOVLB  7
081F8:  MOVWF  x29
081FA:  MOVLB  0
081FC:  CALL   7234
.................... 				return; 
08200:  MOVLB  5
08202:  GOTO   9392
.................... 			} 
.................... 	 
.................... 			if(dummy_char != 0x03) { 
08206:  MOVLB  6
08208:  MOVF   xDA,W
0820A:  SUBLW  03
0820C:  BZ    823A
.................... 				// Ending char not 0x03 
.................... 				fputc(0x15,USB); 
0820E:  MOVLW  15
08210:  MOVLB  7
08212:  MOVWF  x29
08214:  MOVLB  0
08216:  CALL   7234
.................... 				fputc(ERR_END_INVALID,USB); 
0821A:  MOVLW  12
0821C:  MOVLB  7
0821E:  MOVWF  x29
08220:  MOVLB  0
08222:  CALL   7234
.................... 				fputc(0x03,USB); 
08226:  MOVLW  03
08228:  MOVLB  7
0822A:  MOVWF  x29
0822C:  MOVLB  0
0822E:  CALL   7234
.................... 				return; 
08232:  MOVLB  5
08234:  GOTO   9392
08238:  MOVLB  6
.................... 			} 
.................... 			 
.................... 			last_address = final_address; 
0823A:  MOVFF  6E5,6E7
0823E:  MOVFF  6E4,6E6
.................... 			last_byte1 = byte1; 
08242:  MOVFF  6DB,6BB
.................... 			last_byte2 = byte2; 
08246:  MOVFF  6DC,6BC
.................... 			last_byte3 = byte3; 
0824A:  MOVFF  6DD,6BD
.................... 			last_byte4 = byte4; 
0824E:  MOVFF  6DE,6BE
....................  
.................... 			read_flash_page_into_buffer(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
08252:  MOVFF  6E5,721
08256:  MOVFF  6E4,720
0825A:  MOVLB  0
0825C:  CALL   72E8
08260:  MOVFF  01,720
08264:  MOVLB  7
08266:  CLRF   x2B
08268:  MOVLW  7A
0826A:  MOVWF  x2A
0826C:  MOVFF  79,72C
08270:  MOVFF  01,72D
08274:  MOVLB  0
08276:  CALL   63F8
....................  
.................... 			int32 new_dsp_value = 0x00000000 | byte1; 
0827A:  MOVLB  6
0827C:  MOVFF  6DB,6E8
08280:  CLRF   xE9
08282:  CLRF   xEA
08284:  CLRF   xEB
.................... 			new_dsp_value = new_dsp_value << 8; 
08286:  MOVFF  6EA,6EB
0828A:  MOVFF  6E9,6EA
0828E:  MOVFF  6E8,6E9
08292:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte2; 
08294:  MOVF   xDC,W
08296:  IORWF  xE8,F
.................... 			new_dsp_value = new_dsp_value << 8; 
08298:  MOVFF  6EA,6EB
0829C:  MOVFF  6E9,6EA
082A0:  MOVFF  6E8,6E9
082A4:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte3; 
082A6:  MOVF   xDD,W
082A8:  IORWF  xE8,F
.................... 			new_dsp_value = new_dsp_value << 8; 
082AA:  MOVFF  6EA,6EB
082AE:  MOVFF  6E9,6EA
082B2:  MOVFF  6E8,6E9
082B6:  CLRF   xE8
.................... 			new_dsp_value = new_dsp_value | byte4; 
082B8:  MOVF   xDE,W
082BA:  IORWF  xE8,F
....................  
....................  
.................... 			if(final_address < num_dsp_values) { 
082BC:  MOVF   xE5,W
082BE:  SUBWF  1B,W
082C0:  BNC   8306
082C2:  BNZ   82CA
082C4:  MOVF   1A,W
082C6:  SUBWF  xE4,W
082C8:  BC    8306
.................... 				send_prefixed_dsp_command(DSP_ADDRESS_WRITE_PREFIX,READ_CONFIG_ADDRESS(final_address),new_dsp_value); 
082CA:  MOVFF  6E5,72B
082CE:  MOVFF  6E4,72A
082D2:  MOVLB  0
082D4:  CALL   6930
082D8:  MOVFF  02,721
082DC:  MOVFF  01,720
082E0:  MOVLW  F0
082E2:  MOVLB  7
082E4:  MOVWF  x31
082E6:  CLRF   x30
082E8:  MOVFF  02,733
082EC:  MOVFF  01,732
082F0:  MOVFF  6EB,737
082F4:  MOVFF  6EA,736
082F8:  MOVFF  6E9,735
082FC:  MOVFF  6E8,734
08300:  MOVLB  0
08302:  CALL   6844
.................... 			} 
.................... 			PAGE_BUFFER_A[addr_index_to_buffer_index(final_address)] = new_dsp_value; 
08306:  MOVFF  6E5,721
0830A:  MOVFF  6E4,720
0830E:  MOVLB  0
08310:  GOTO   7312
08314:  MOVF   01,W
08316:  MULLW  04
08318:  MOVF   FF3,W
0831A:  CLRF   03
0831C:  ADDLW  7A
0831E:  MOVWF  FE9
08320:  MOVLW  00
08322:  ADDWFC 03,W
08324:  MOVWF  FEA
08326:  MOVFF  6E8,FEF
0832A:  MOVFF  6E9,FEC
0832E:  MOVFF  6EA,FEC
08332:  MOVFF  6EB,FEC
....................  
.................... 			write_buffer_to_flash_page(&PAGE_BUFFER_A,CURRENT_FLASH_PROGRAM,addr_index_to_page_index(final_address)); 
08336:  MOVFF  6E5,721
0833A:  MOVFF  6E4,720
0833E:  CALL   72E8
08342:  MOVFF  01,720
08346:  MOVLB  7
08348:  CLRF   x29
0834A:  MOVLW  7A
0834C:  MOVWF  x28
0834E:  MOVFF  79,72A
08352:  MOVFF  01,72B
08356:  MOVLB  0
08358:  CALL   64E4
....................  
.................... 			// Send ACK 
.................... 			fputc(0x06,USB); 
0835C:  MOVLW  06
0835E:  MOVLB  7
08360:  MOVWF  x29
08362:  MOVLB  0
08364:  CALL   7234
.................... 			fputc(addr_msb,USB); 
08368:  MOVFF  6E2,729
0836C:  CALL   7234
.................... 			fputc(addr_lsb,USB); 
08370:  MOVFF  6E0,729
08374:  CALL   7234
.................... 			fputc(0x03,USB);	 
08378:  MOVLW  03
0837A:  MOVLB  7
0837C:  MOVWF  x29
0837E:  MOVLB  0
08380:  CALL   7234
.................... 			return; 
08384:  MOVLB  5
08386:  GOTO   9392
....................  
.................... 		//} else { 
.................... 		//	// Invalid address 
.................... 		//	send_error(ERR_ADDR_INVALID); 
.................... 		//	return; 
.................... 		//} 
....................  
.................... GET_DSP_CONFIG_VALUE: 
....................  
.................... 		addr_msb = timed_getc(); 
0838A:  MOVLB  0
0838C:  CALL   7296
08390:  MOVLB  6
08392:  CLRF   xE3
08394:  MOVFF  01,6E2
....................  
.................... 		if(timeout_error == true) { 
08398:  MOVLB  5
0839A:  DECFSZ x8C,W
0839C:  BRA    83B0
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
0839E:  MOVLW  14
083A0:  MOVLB  7
083A2:  MOVWF  x20
083A4:  MOVLB  0
083A6:  CALL   727A
.................... 			return; 
083AA:  MOVLB  5
083AC:  GOTO   9392
.................... 		} 
....................  
.................... 		//printf("Got address 1 %u\r\n",addr_index); 
....................  
.................... 		addr_lsb = timed_getc(); 
083B0:  MOVLB  0
083B2:  CALL   7296
083B6:  MOVLB  6
083B8:  CLRF   xE1
083BA:  MOVFF  01,6E0
....................  
.................... 		if(timeout_error == true) { 
083BE:  MOVLB  5
083C0:  DECFSZ x8C,W
083C2:  BRA    83D6
.................... 			// Timed out. No address. Start over. 
.................... 			send_error(ERR_ADDR_TIMEOUT); 
083C4:  MOVLW  14
083C6:  MOVLB  7
083C8:  MOVWF  x20
083CA:  MOVLB  0
083CC:  CALL   727A
.................... 			return; 
083D0:  MOVLB  5
083D2:  GOTO   9392
.................... 		} 
....................  
.................... 		//printf("Got address 2 %u\r\n",addr_index); 
....................  
.................... 		if(addr_lsb == 255) { 
083D6:  MOVLB  6
083D8:  INCFSZ xE0,W
083DA:  BRA    83F6
083DC:  MOVF   xE1,F
083DE:  BNZ   83F6
.................... 			final_address = 0; 
083E0:  CLRF   xE5
083E2:  CLRF   xE4
.................... 			final_address += addr_msb; 
083E4:  MOVF   xE2,W
083E6:  ADDWF  xE4,F
083E8:  MOVF   xE3,W
083EA:  ADDWFC xE5,F
.................... 			final_address += addr_lsb; 
083EC:  MOVF   xE0,W
083EE:  ADDWF  xE4,F
083F0:  MOVF   xE1,W
083F2:  ADDWFC xE5,F
.................... 		} else { 
083F4:  BRA    83FE
.................... 			final_address = addr_lsb; 
083F6:  MOVFF  6E1,6E5
083FA:  MOVFF  6E0,6E4
.................... 		} 
....................  
.................... 		dummy_char = timed_getc(); 
083FE:  MOVLB  0
08400:  CALL   7296
08404:  MOVFF  01,6DA
....................  
....................  
.................... 		if(timeout_error == true) { 
08408:  MOVLB  5
0840A:  DECFSZ x8C,W
0840C:  BRA    8420
.................... 			// Timed out. No end char. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
0840E:  MOVLW  11
08410:  MOVLB  7
08412:  MOVWF  x20
08414:  MOVLB  0
08416:  CALL   727A
.................... 			return; 
0841A:  MOVLB  5
0841C:  GOTO   9392
.................... 		} 
.................... 		 
.................... 		if(dummy_char != 0x03) { 
08420:  MOVLB  6
08422:  MOVF   xDA,W
08424:  SUBLW  03
08426:  BZ    843C
.................... 			// Ending char not 0x03 
.................... 			send_error(ERR_END_INVALID); 
08428:  MOVLW  12
0842A:  MOVLB  7
0842C:  MOVWF  x20
0842E:  MOVLB  0
08430:  CALL   727A
.................... 			return; 
08434:  MOVLB  5
08436:  GOTO   9392
0843A:  MOVLB  6
.................... 		} 
....................  
.................... 		if((final_address >= 0) && (final_address <= num_dsp_values)) { 
0843C:  MOVF   xE5,W
0843E:  SUBWF  1B,W
08440:  BNC   84D0
08442:  BNZ   844A
08444:  MOVF   xE4,W
08446:  SUBWF  1A,W
08448:  BNC   84D0
....................  
.................... 			// TODO - Re-implement 
.................... 			//int32 value = READ_CONFIG_VALUE(final_address); 
.................... 	 
.................... 			int32 value = 0; 
....................  
.................... 			char byte4 = value & 0xFF; 
0844A:  CLRF   xEF
0844C:  CLRF   xEE
0844E:  CLRF   xED
08450:  CLRF   xEC
08452:  MOVFF  6EC,6F0
.................... 			value = value >> 8; 
08456:  MOVFF  6ED,6EC
0845A:  MOVFF  6EE,6ED
0845E:  MOVFF  6EF,6EE
08462:  CLRF   xEF
.................... 		 
.................... 			char byte3 = value & 0xFF; 
08464:  MOVFF  6EC,6F1
.................... 			value = value >> 8; 
08468:  MOVFF  6ED,6EC
0846C:  MOVFF  6EE,6ED
08470:  MOVFF  6EF,6EE
08474:  CLRF   xEF
.................... 			 
.................... 			char byte2 = value & 0xFF; 
.................... 			char byte1 = value >> 8; 
08476:  MOVFF  6EC,6F2
0847A:  MOVFF  6ED,6F3
.................... 		 
.................... 			fputc(0x06,USB); 
0847E:  MOVLW  06
08480:  MOVLB  7
08482:  MOVWF  x29
08484:  MOVLB  0
08486:  CALL   7234
.................... 			fputc(addr_msb,USB); 
0848A:  MOVFF  6E2,729
0848E:  CALL   7234
.................... 			fputc(addr_lsb,USB); 
08492:  MOVFF  6E0,729
08496:  CALL   7234
.................... 			fputc(byte1,USB); 
0849A:  MOVFF  6F3,729
0849E:  CALL   7234
.................... 			fputc(byte2,USB); 
084A2:  MOVFF  6F2,729
084A6:  CALL   7234
.................... 			fputc(byte3,USB); 
084AA:  MOVFF  6F1,729
084AE:  CALL   7234
.................... 			fputc(byte4,USB); 
084B2:  MOVFF  6F0,729
084B6:  CALL   7234
.................... 			fputc(0x03,USB); 
084BA:  MOVLW  03
084BC:  MOVLB  7
084BE:  MOVWF  x29
084C0:  MOVLB  0
084C2:  CALL   7234
.................... 			return; 
084C6:  MOVLB  5
084C8:  GOTO   9392
.................... 	 
.................... 		} else { 
084CC:  BRA    84E2
084CE:  MOVLB  6
.................... 			// Invalid address 
.................... 			send_error(ERR_ADDR_INVALID); 
084D0:  MOVLW  16
084D2:  MOVLB  7
084D4:  MOVWF  x20
084D6:  MOVLB  0
084D8:  CALL   727A
.................... 			return; 
084DC:  MOVLB  5
084DE:  GOTO   9392
084E2:  MOVLB  6
.................... 		} 
....................  
.................... 	// END GET_VALUE label 
....................  
.................... SEND_DSP_VALUE: 
....................  
.................... 		byte addr_byte1,addr_byte2,addr_byte3,addr_byte4; 
.................... 		byte val_byte1,val_byte2,val_byte3,val_byte4; 
....................  
.................... 		addr_byte1 = fast_timed_getc(); 
084E4:  MOVLB  0
084E6:  CALL   71E2
084EA:  MOVFF  01,6F4
.................... 		addr_byte2 = fast_timed_getc(); 
084EE:  CALL   71E2
084F2:  MOVFF  01,6F5
.................... 		addr_byte3 = fast_timed_getc(); 
084F6:  CALL   71E2
084FA:  MOVFF  01,6F6
.................... 		addr_byte4 = fast_timed_getc(); 
084FE:  CALL   71E2
08502:  MOVFF  01,6F7
....................  
.................... 		val_byte1 = fast_timed_getc(); 
08506:  CALL   71E2
0850A:  MOVFF  01,6F8
.................... 		val_byte2 = fast_timed_getc(); 
0850E:  CALL   71E2
08512:  MOVFF  01,6F9
.................... 		val_byte3 = fast_timed_getc(); 
08516:  CALL   71E2
0851A:  MOVFF  01,6FA
.................... 		val_byte4 = fast_timed_getc(); 
0851E:  CALL   71E2
08522:  MOVFF  01,6FB
....................  
.................... 		if(timeout_error == true) { 
08526:  MOVLB  5
08528:  DECFSZ x8C,W
0852A:  BRA    8556
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
0852C:  MOVLW  15
0852E:  MOVLB  7
08530:  MOVWF  x29
08532:  MOVLB  0
08534:  CALL   7234
.................... 			fputc(0x17,USB); 
08538:  MOVLW  17
0853A:  MOVLB  7
0853C:  MOVWF  x29
0853E:  MOVLB  0
08540:  CALL   7234
.................... 			fputc(0x03,USB); 
08544:  MOVLW  03
08546:  MOVLB  7
08548:  MOVWF  x29
0854A:  MOVLB  0
0854C:  CALL   7234
.................... 			return; 
08550:  MOVLB  5
08552:  GOTO   9392
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08556:  MOVLB  0
08558:  CALL   7296
0855C:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
08560:  MOVLB  5
08562:  DECFSZ x8C,W
08564:  BRA    8590
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
08566:  MOVLW  15
08568:  MOVLB  7
0856A:  MOVWF  x29
0856C:  MOVLB  0
0856E:  CALL   7234
.................... 			fputc(ERR_END_TIMEOUT,USB); 
08572:  MOVLW  11
08574:  MOVLB  7
08576:  MOVWF  x29
08578:  MOVLB  0
0857A:  CALL   7234
.................... 			fputc(0x03,USB); 
0857E:  MOVLW  03
08580:  MOVLB  7
08582:  MOVWF  x29
08584:  MOVLB  0
08586:  CALL   7234
.................... 			return; 
0858A:  MOVLB  5
0858C:  GOTO   9392
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
08590:  MOVLB  6
08592:  MOVF   xDA,W
08594:  SUBLW  03
08596:  BZ    85C4
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
08598:  MOVLW  15
0859A:  MOVLB  7
0859C:  MOVWF  x29
0859E:  MOVLB  0
085A0:  CALL   7234
.................... 			fputc(0x13,USB); 
085A4:  MOVLW  13
085A6:  MOVLB  7
085A8:  MOVWF  x29
085AA:  MOVLB  0
085AC:  CALL   7234
.................... 			fputc(0x03,USB); 
085B0:  MOVLW  03
085B2:  MOVLB  7
085B4:  MOVWF  x29
085B6:  MOVLB  0
085B8:  CALL   7234
.................... 			return; 
085BC:  MOVLB  5
085BE:  GOTO   9392
085C2:  MOVLB  6
.................... 		} 
....................  
.................... 		 
....................  
.................... 		int32 debug_address = 0x00000000 | addr_byte1; 
085C4:  MOVFF  6F4,6FC
085C8:  CLRF   xFD
085CA:  CLRF   xFE
085CC:  CLRF   xFF
.................... 		debug_address = debug_address << 8; 
085CE:  MOVFF  6FE,6FF
085D2:  MOVFF  6FD,6FE
085D6:  MOVFF  6FC,6FD
085DA:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte2; 
085DC:  MOVF   xF5,W
085DE:  IORWF  xFC,F
.................... 		debug_address = debug_address << 8; 
085E0:  MOVFF  6FE,6FF
085E4:  MOVFF  6FD,6FE
085E8:  MOVFF  6FC,6FD
085EC:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte3; 
085EE:  MOVF   xF6,W
085F0:  IORWF  xFC,F
.................... 		debug_address = debug_address << 8; 
085F2:  MOVFF  6FE,6FF
085F6:  MOVFF  6FD,6FE
085FA:  MOVFF  6FC,6FD
085FE:  CLRF   xFC
.................... 		debug_address = debug_address | addr_byte4; 
08600:  MOVF   xF7,W
08602:  IORWF  xFC,F
....................  
.................... 		int32 debug_value = 0x00000000 | val_byte1; 
08604:  MOVFF  6F8,700
08608:  MOVLB  7
0860A:  CLRF   x01
0860C:  CLRF   x02
0860E:  CLRF   x03
.................... 		debug_value = debug_value << 8; 
08610:  MOVFF  702,703
08614:  MOVFF  701,702
08618:  MOVFF  700,701
0861C:  CLRF   x00
.................... 		debug_value = debug_value | val_byte2; 
0861E:  MOVLB  6
08620:  MOVF   xF9,W
08622:  MOVLB  7
08624:  IORWF  x00,F
.................... 		debug_value = debug_value << 8; 
08626:  MOVFF  702,703
0862A:  MOVFF  701,702
0862E:  MOVFF  700,701
08632:  CLRF   x00
.................... 		debug_value = debug_value | val_byte3; 
08634:  MOVLB  6
08636:  MOVF   xFA,W
08638:  MOVLB  7
0863A:  IORWF  x00,F
.................... 		debug_value = debug_value << 8; 
0863C:  MOVFF  702,703
08640:  MOVFF  701,702
08644:  MOVFF  700,701
08648:  CLRF   x00
.................... 		debug_value = debug_value | val_byte4; 
0864A:  MOVLB  6
0864C:  MOVF   xFB,W
0864E:  MOVLB  7
08650:  IORWF  x00,F
08652:  CLRF   19
08654:  BTFSC  FF2.7
08656:  BSF    19.7
08658:  BCF    FF2.7
.................... 			 
.................... 		send_dsp_command(debug_address,debug_value); 
0865A:  MOVFF  6FF,776
0865E:  MOVFF  6FE,775
08662:  MOVFF  6FD,774
08666:  MOVFF  6FC,773
0866A:  MOVFF  703,77A
0866E:  MOVFF  702,779
08672:  MOVFF  701,778
08676:  MOVFF  700,777
0867A:  MOVLB  0
0867C:  CALL   1388
08680:  BTFSC  19.7
08682:  BSF    FF2.7
....................  
.................... 		fputc(0x06); 
08684:  MOVLW  06
08686:  MOVLB  7
08688:  MOVWF  x29
0868A:  MOVLB  0
0868C:  CALL   7234
.................... 		fputc(0x07); 
08690:  MOVLW  07
08692:  MOVLB  7
08694:  MOVWF  x29
08696:  MOVLB  0
08698:  CALL   7234
.................... 		fputc(0x03); 
0869C:  MOVLW  03
0869E:  MOVLB  7
086A0:  MOVWF  x29
086A2:  MOVLB  0
086A4:  CALL   7234
....................  
....................  
.................... 		return; 
086A8:  MOVLB  5
086AA:  GOTO   9392
....................  
.................... READ_DSP_VALUE: 
....................  
.................... 		byte1 = fast_timed_getc(); 
086AE:  MOVLB  0
086B0:  CALL   71E2
086B4:  MOVFF  01,6DB
.................... 		byte2 = fast_timed_getc(); 
086B8:  CALL   71E2
086BC:  MOVFF  01,6DC
.................... 		byte3 = fast_timed_getc(); 
086C0:  CALL   71E2
086C4:  MOVFF  01,6DD
.................... 		byte4 = fast_timed_getc(); 
086C8:  CALL   71E2
086CC:  MOVFF  01,6DE
....................  
.................... 		if(timeout_error == true) { 
086D0:  MOVLB  5
086D2:  DECFSZ x8C,W
086D4:  BRA    8700
.................... 			// Timed out on one of the bytes 
.................... 			fputc(0x15,USB); 
086D6:  MOVLW  15
086D8:  MOVLB  7
086DA:  MOVWF  x29
086DC:  MOVLB  0
086DE:  CALL   7234
.................... 			fputc(0x17,USB); 
086E2:  MOVLW  17
086E4:  MOVLB  7
086E6:  MOVWF  x29
086E8:  MOVLB  0
086EA:  CALL   7234
.................... 			fputc(0x03,USB); 
086EE:  MOVLW  03
086F0:  MOVLB  7
086F2:  MOVWF  x29
086F4:  MOVLB  0
086F6:  CALL   7234
.................... 			return; 
086FA:  MOVLB  5
086FC:  GOTO   9392
.................... 		}	 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08700:  MOVLB  0
08702:  CALL   7296
08706:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
0870A:  MOVLB  5
0870C:  DECFSZ x8C,W
0870E:  BRA    873A
.................... 			// Timed out. No command. Start over. 
.................... 			fputc(0x15,USB); 
08710:  MOVLW  15
08712:  MOVLB  7
08714:  MOVWF  x29
08716:  MOVLB  0
08718:  CALL   7234
.................... 			fputc(ERR_END_TIMEOUT,USB); 
0871C:  MOVLW  11
0871E:  MOVLB  7
08720:  MOVWF  x29
08722:  MOVLB  0
08724:  CALL   7234
.................... 			fputc(0x03,USB); 
08728:  MOVLW  03
0872A:  MOVLB  7
0872C:  MOVWF  x29
0872E:  MOVLB  0
08730:  CALL   7234
.................... 			return; 
08734:  MOVLB  5
08736:  GOTO   9392
.................... 		} 
....................  
.................... 		if(dummy_char != 0x03) { 
0873A:  MOVLB  6
0873C:  MOVF   xDA,W
0873E:  SUBLW  03
08740:  BZ    876C
.................... 			// Ending char not 0x03 
.................... 			fputc(0x15,USB); 
08742:  MOVLW  15
08744:  MOVLB  7
08746:  MOVWF  x29
08748:  MOVLB  0
0874A:  CALL   7234
.................... 			fputc(0x13,USB); 
0874E:  MOVLW  13
08750:  MOVLB  7
08752:  MOVWF  x29
08754:  MOVLB  0
08756:  CALL   7234
.................... 			fputc(0x03,USB); 
0875A:  MOVLW  03
0875C:  MOVLB  7
0875E:  MOVWF  x29
08760:  MOVLB  0
08762:  CALL   7234
.................... 			return; 
08766:  MOVLB  5
08768:  GOTO   9392
.................... 		} 
....................  
.................... 		int32 address = 0x00000000 | byte1; 
0876C:  MOVFF  6DB,704
08770:  MOVLB  7
08772:  CLRF   x05
08774:  CLRF   x06
08776:  CLRF   x07
.................... 		address = address << 8; 
08778:  MOVFF  706,707
0877C:  MOVFF  705,706
08780:  MOVFF  704,705
08784:  CLRF   x04
.................... 		address = address | byte2; 
08786:  MOVLB  6
08788:  MOVF   xDC,W
0878A:  MOVLB  7
0878C:  IORWF  x04,F
.................... 		address = address << 8; 
0878E:  MOVFF  706,707
08792:  MOVFF  705,706
08796:  MOVFF  704,705
0879A:  CLRF   x04
.................... 		address = address | byte3; 
0879C:  MOVLB  6
0879E:  MOVF   xDD,W
087A0:  MOVLB  7
087A2:  IORWF  x04,F
.................... 		address = address << 8; 
087A4:  MOVFF  706,707
087A8:  MOVFF  705,706
087AC:  MOVFF  704,705
087B0:  CLRF   x04
.................... 		address = address | byte4; 
087B2:  MOVLB  6
087B4:  MOVF   xDE,W
087B6:  MOVLB  7
087B8:  IORWF  x04,F
.................... 			 
.................... 		read_dsp_and_send_to_usb(address); 
087BA:  MOVFF  707,723
087BE:  MOVFF  706,722
087C2:  MOVFF  705,721
087C6:  MOVFF  704,720
087CA:  MOVLB  0
087CC:  GOTO   738E
....................  
.................... 		return; 
087D0:  MOVLB  5
087D2:  GOTO   9392
....................  
....................  
....................  
.................... FLASH_PROGRAM_ACTIONS: 
....................  
.................... 		command_char = timed_getc(); 
087D6:  MOVLB  0
087D8:  CALL   7296
087DC:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
087E0:  MOVLB  5
087E2:  DECFSZ x8C,W
087E4:  BRA    87F8
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
087E6:  MOVLW  10
087E8:  MOVLB  7
087EA:  MOVWF  x20
087EC:  MOVLB  0
087EE:  CALL   727A
.................... 			return; 
087F2:  MOVLB  5
087F4:  GOTO   9392
.................... 		} 
....................  
.................... 		if(command_char == 0x04 || command_char == 0x05 || command_char == 0x09 || command_char == 0x11) { 
087F8:  MOVLB  6
087FA:  MOVF   xD9,W
087FC:  SUBLW  04
087FE:  BZ    8812
08800:  MOVF   xD9,W
08802:  SUBLW  05
08804:  BZ    8812
08806:  MOVF   xD9,W
08808:  SUBLW  09
0880A:  BZ    8812
0880C:  MOVF   xD9,W
0880E:  SUBLW  11
08810:  BNZ   8830
.................... 			addr_msb = timed_getc(); 
08812:  MOVLB  0
08814:  CALL   7296
08818:  MOVLB  6
0881A:  CLRF   xE3
0881C:  MOVFF  01,6E2
.................... 			addr_lsb = timed_getc(); 
08820:  MOVLB  0
08822:  CALL   7296
08826:  MOVLB  6
08828:  CLRF   xE1
0882A:  MOVFF  01,6E0
.................... 		} else { 
0882E:  BRA    883A
.................... 			temp_byte = timed_getc(); 
08830:  MOVLB  0
08832:  CALL   7296
08836:  MOVFF  01,6C1
....................  
.................... 		} 
.................... 	 
.................... 		if(timeout_error == true) { 
0883A:  MOVLB  5
0883C:  DECFSZ x8C,W
0883E:  BRA    8852
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08840:  MOVLW  17
08842:  MOVLB  7
08844:  MOVWF  x20
08846:  MOVLB  0
08848:  CALL   727A
.................... 			return; 
0884C:  MOVLB  5
0884E:  GOTO   9392
.................... 		} 
.................... 		 
.................... 	 
.................... 		 
....................  
.................... 		char stream_size_msb,stream_size_lsb; 
....................  
.................... 		if(command_char == 0x11) { 
08852:  MOVLB  6
08854:  MOVF   xD9,W
08856:  SUBLW  11
08858:  BNZ   886C
.................... 			stream_size_msb = timed_getc(); 
0885A:  MOVLB  0
0885C:  CALL   7296
08860:  MOVFF  01,708
.................... 			stream_size_lsb = timed_getc(); 
08864:  CALL   7296
08868:  MOVFF  01,709
.................... 		}	 
....................  
.................... 		dummy_char = timed_getc(); 
0886C:  MOVLB  0
0886E:  CALL   7296
08872:  MOVFF  01,6DA
....................  
.................... 		if(timeout_error == true) { 
08876:  MOVLB  5
08878:  DECFSZ x8C,W
0887A:  BRA    888E
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
0887C:  MOVLW  11
0887E:  MOVLB  7
08880:  MOVWF  x20
08882:  MOVLB  0
08884:  CALL   727A
.................... 			return; 
08888:  MOVLB  5
0888A:  GOTO   9392
.................... 		} 
....................  
.................... 		switch(command_char) { 
0888E:  MOVLB  6
08890:  MOVF   xD9,W
08892:  XORLW  01
08894:  MOVLB  0
08896:  BZ    88B8
08898:  XORLW  03
0889A:  BZ    88F4
0889C:  XORLW  06
0889E:  BZ    892C
088A0:  XORLW  01
088A2:  BZ    8968
088A4:  XORLW  0D
088A6:  BTFSC  FD8.2
088A8:  BRA    89B0
088AA:  XORLW  01
088AC:  BTFSC  FD8.2
088AE:  BRA    89E4
088B0:  XORLW  18
088B2:  BTFSC  FD8.2
088B4:  BRA    8A48
088B6:  BRA    8A7A
....................  
.................... 			case 0x01 : 
.................... 				// SWITCH ACTIVE PROGRAM 
.................... 				switch_flash_program(temp_byte); 
088B8:  MOVFF  6C1,720
088BC:  GOTO   7520
.................... 				fputc(0x06,USB); 
088C0:  MOVLW  06
088C2:  MOVLB  7
088C4:  MOVWF  x29
088C6:  MOVLB  0
088C8:  CALL   7234
.................... 				fputc(0x01,USB); 
088CC:  MOVLW  01
088CE:  MOVLB  7
088D0:  MOVWF  x29
088D2:  MOVLB  0
088D4:  CALL   7234
.................... 				fputc(temp_byte,USB); 
088D8:  MOVFF  6C1,729
088DC:  CALL   7234
.................... 				fputc(0x03,USB); 
088E0:  MOVLW  03
088E2:  MOVLB  7
088E4:  MOVWF  x29
088E6:  MOVLB  0
088E8:  CALL   7234
.................... 				return; 
088EC:  MOVLB  5
088EE:  GOTO   9392
.................... 			break; 
088F2:  BRA    8A8E
....................  
.................... 			case 0x02 : 
.................... 				// SAVE ACTIVE PROGRAM 
....................  
.................... 				save_flash_program(); 
088F4:  GOTO   7564
....................  
.................... 				fputc(0x06,USB); 
088F8:  MOVLW  06
088FA:  MOVLB  7
088FC:  MOVWF  x29
088FE:  MOVLB  0
08900:  CALL   7234
.................... 				fputc(0x02,USB); 
08904:  MOVLW  02
08906:  MOVLB  7
08908:  MOVWF  x29
0890A:  MOVLB  0
0890C:  CALL   7234
.................... 				fputc(temp_byte,USB); 
08910:  MOVFF  6C1,729
08914:  CALL   7234
.................... 				fputc(0x03,USB); 
08918:  MOVLW  03
0891A:  MOVLB  7
0891C:  MOVWF  x29
0891E:  MOVLB  0
08920:  CALL   7234
.................... 				return; 
08924:  MOVLB  5
08926:  GOTO   9392
.................... 			break; 
0892A:  BRA    8A8E
....................  
.................... 			case 0x04 : 
....................  
.................... 				// SAVE ACTIVE SECTOR 
....................  
.................... 				fputc(0x06,USB); 
0892C:  MOVLW  06
0892E:  MOVLB  7
08930:  MOVWF  x29
08932:  MOVLB  0
08934:  CALL   7234
.................... 				fputc(0x05,USB); 
08938:  MOVLW  05
0893A:  MOVLB  7
0893C:  MOVWF  x29
0893E:  MOVLB  0
08940:  CALL   7234
.................... 				fputc(addr_msb,USB); 
08944:  MOVFF  6E2,729
08948:  CALL   7234
.................... 				fputc(addr_lsb,USB); 
0894C:  MOVFF  6E0,729
08950:  CALL   7234
.................... 				fputc(0x03,USB); 
08954:  MOVLW  03
08956:  MOVLB  7
08958:  MOVWF  x29
0895A:  MOVLB  0
0895C:  CALL   7234
.................... 				return; 
08960:  MOVLB  5
08962:  GOTO   9392
.................... 			break; 
08966:  BRA    8A8E
....................  
.................... 			case 0x05 : 
....................  
.................... 				FLASH_COPY_PROGRAM(addr_msb,addr_lsb); 
08968:  MOVFF  6E2,720
0896C:  MOVFF  6E0,721
08970:  GOTO   7568
....................  
.................... 				fputc(0x06,USB); 
08974:  MOVLW  06
08976:  MOVLB  7
08978:  MOVWF  x29
0897A:  MOVLB  0
0897C:  CALL   7234
.................... 				fputc(0x05,USB); 
08980:  MOVLW  05
08982:  MOVLB  7
08984:  MOVWF  x29
08986:  MOVLB  0
08988:  CALL   7234
.................... 				fputc(addr_msb,USB); 
0898C:  MOVFF  6E2,729
08990:  CALL   7234
.................... 				fputc(addr_lsb,USB); 
08994:  MOVFF  6E0,729
08998:  CALL   7234
.................... 				fputc(0x03,USB); 
0899C:  MOVLW  03
0899E:  MOVLB  7
089A0:  MOVWF  x29
089A2:  MOVLB  0
089A4:  CALL   7234
.................... 				return; 
089A8:  MOVLB  5
089AA:  GOTO   9392
.................... 			break; 
089AE:  BRA    8A8E
....................  
....................  
.................... 			case 0x08 : 
....................  
.................... 				// GET ACTIVE PROGRAM INDEX 
....................  
.................... 				fputc(0x06,USB); 
089B0:  MOVLW  06
089B2:  MOVLB  7
089B4:  MOVWF  x29
089B6:  MOVLB  0
089B8:  CALL   7234
.................... 				fputc(0x08,USB); 
089BC:  MOVLW  08
089BE:  MOVLB  7
089C0:  MOVWF  x29
089C2:  MOVLB  0
089C4:  CALL   7234
.................... 				fputc(CURRENT_FLASH_PROGRAM,USB); 
089C8:  MOVFF  79,729
089CC:  CALL   7234
.................... 				fputc(0x03,USB); 
089D0:  MOVLW  03
089D2:  MOVLB  7
089D4:  MOVWF  x29
089D6:  MOVLB  0
089D8:  CALL   7234
.................... 				return; 
089DC:  MOVLB  5
089DE:  GOTO   9392
.................... 			break; 
089E2:  BRA    8A8E
....................  
.................... 			case 0x09 : 
....................  
.................... 				// STREAM PROGRAM BLOCK TO USB 
....................  
.................... 				read_flash_page_into_buffer(&PAGE_BUFFER_A,addr_msb,addr_lsb); 
089E4:  MOVLB  7
089E6:  CLRF   x2B
089E8:  MOVLW  7A
089EA:  MOVWF  x2A
089EC:  MOVFF  6E2,72C
089F0:  MOVFF  6E0,72D
089F4:  MOVLB  0
089F6:  CALL   63F8
....................  
.................... 				fputc(0x06,USB); 
089FA:  MOVLW  06
089FC:  MOVLB  7
089FE:  MOVWF  x29
08A00:  MOVLB  0
08A02:  CALL   7234
.................... 				fputc(0x09,USB); 
08A06:  MOVLW  09
08A08:  MOVLB  7
08A0A:  MOVWF  x29
08A0C:  MOVLB  0
08A0E:  CALL   7234
.................... 				fputc(addr_msb,USB); 
08A12:  MOVFF  6E2,729
08A16:  CALL   7234
.................... 				fputc(addr_lsb,USB); 
08A1A:  MOVFF  6E0,729
08A1E:  CALL   7234
....................  
.................... 				write_buffer_to_stream(&PAGE_BUFFER_A); 
08A22:  MOVLB  7
08A24:  CLRF   x21
08A26:  MOVLW  7A
08A28:  MOVWF  x20
08A2A:  MOVLW  01
08A2C:  MOVWF  x22
08A2E:  MOVLB  0
08A30:  GOTO   77E6
....................  
.................... 				fputc(0x03,USB); 
08A34:  MOVLW  03
08A36:  MOVLB  7
08A38:  MOVWF  x29
08A3A:  MOVLB  0
08A3C:  CALL   7234
.................... 				return; 
08A40:  MOVLB  5
08A42:  GOTO   9392
.................... 			break; 
08A46:  BRA    8A8E
....................  
.................... 			case 0x11 : 
.................... 				 
.................... 				 
.................... 				int16 stream_size = 0; 
08A48:  MOVLB  7
08A4A:  CLRF   x0B
08A4C:  CLRF   x0A
.................... 		 
.................... 				//fprintf(RS232,"Stream size MSB = %x, Stream size LSB = %x\r\n",stream_size_msb,stream_size_lsb); 
.................... 				stream_size = stream_size | stream_size_msb; 
08A4E:  MOVF   x08,W
08A50:  IORWF  x0A,F
.................... 				stream_size <<= 8; 
08A52:  MOVFF  70A,70B
08A56:  CLRF   x0A
.................... 				stream_size = stream_size | stream_size_lsb; 
08A58:  MOVF   x09,W
08A5A:  IORWF  x0A,F
....................  
.................... 				/*if(data_available_usb()) { 
.................... 					fprintf(RS232,"Data still available on USB...\r\n"); 
.................... 				} else { 
.................... 					fprintf(RS232,"NO data available on USB...\r\n"); 
.................... 				} 
.................... */ 
.................... 				// initiate_stream(int target_program, int target_page, int16 num_bytes) 
.................... 				//initiate_stream(addr_msb,addr_lsb,stream_size); 
.................... 				perform_stream(addr_msb,addr_lsb,stream_size); 
08A5C:  MOVFF  6E2,720
08A60:  MOVFF  6E0,721
08A64:  MOVFF  70B,723
08A68:  MOVFF  70A,722
08A6C:  MOVLB  0
08A6E:  GOTO   799E
.................... 				return; 
08A72:  MOVLB  5
08A74:  GOTO   9392
.................... 				 
....................  
.................... 			break; 
08A78:  BRA    8A8E
....................  
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
08A7A:  MOVLW  13
08A7C:  MOVLB  7
08A7E:  MOVWF  x20
08A80:  MOVLB  0
08A82:  CALL   727A
.................... 				return; 
08A86:  MOVLB  5
08A88:  GOTO   9392
.................... 			break; 
08A8C:  BRA    8A8E
....................  
.................... 		} 
....................  
.................... SET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
08A8E:  MOVLB  0
08A90:  CALL   7296
08A94:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
08A98:  MOVLB  5
08A9A:  DECFSZ x8C,W
08A9C:  BRA    8AB0
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08A9E:  MOVLW  10
08AA0:  MOVLB  7
08AA2:  MOVWF  x20
08AA4:  MOVLB  0
08AA6:  CALL   727A
.................... 			return; 
08AAA:  MOVLB  5
08AAC:  GOTO   9392
.................... 		} 
....................  
.................... 		unsigned int new_value = timed_getc(); 
08AB0:  MOVLB  0
08AB2:  CALL   7296
08AB6:  MOVFF  01,70C
.................... 	 
.................... 		if(timeout_error == true) { 
08ABA:  MOVLB  5
08ABC:  DECFSZ x8C,W
08ABE:  BRA    8AD2
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 			send_error(ERR_DATA_TIMEOUT); 
08AC0:  MOVLW  17
08AC2:  MOVLB  7
08AC4:  MOVWF  x20
08AC6:  MOVLB  0
08AC8:  CALL   727A
.................... 			return; 
08ACC:  MOVLB  5
08ACE:  GOTO   9392
.................... 		} 
.................... 	 
.................... 		unsigned int new_value2; 
....................  
.................... 		if(command_char == 0x11 || command_char == 0x12) { 
08AD2:  MOVLB  6
08AD4:  MOVF   xD9,W
08AD6:  SUBLW  11
08AD8:  BZ    8AE0
08ADA:  MOVF   xD9,W
08ADC:  SUBLW  12
08ADE:  BNZ   8B02
....................  
.................... 			// SETTING SLEEP_SECONDS OR SLEEP_HOLDTIME 
.................... 			// THESE ARE 16 BIT SO WE NEED TWO CHARS 
.................... 			 
.................... 			new_value2 = timed_getc(); 
08AE0:  MOVLB  0
08AE2:  CALL   7296
08AE6:  MOVFF  01,70D
....................  
.................... 			if(timeout_error == true) { 
08AEA:  MOVLB  5
08AEC:  DECFSZ x8C,W
08AEE:  BRA    8B02
.................... 			// Timed out. Couldn't read on/off. Start over. 
.................... 				send_error(ERR_DATA_TIMEOUT); 
08AF0:  MOVLW  17
08AF2:  MOVLB  7
08AF4:  MOVWF  x20
08AF6:  MOVLB  0
08AF8:  CALL   727A
.................... 				return; 
08AFC:  MOVLB  5
08AFE:  GOTO   9392
.................... 			} 
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08B02:  MOVLB  0
08B04:  CALL   7296
08B08:  MOVFF  01,6DA
.................... 		 
.................... 		if(timeout_error == true) { 
08B0C:  MOVLB  5
08B0E:  DECFSZ x8C,W
08B10:  BRA    8B24
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08B12:  MOVLW  11
08B14:  MOVLB  7
08B16:  MOVWF  x20
08B18:  MOVLB  0
08B1A:  CALL   727A
.................... 			return; 
08B1E:  MOVLB  5
08B20:  GOTO   9392
.................... 		} 
.................... 		 
.................... 		int perform_eeprom_save = 0; 
.................... 		 
.................... 		int16 lsb,msb; 
08B24:  MOVLB  7
08B26:  CLRF   x0E
....................  
.................... 		switch(command_char) { 
08B28:  MOVLB  6
08B2A:  MOVF   xD9,W
08B2C:  XORLW  01
08B2E:  MOVLB  0
08B30:  BZ    8B76
08B32:  XORLW  03
08B34:  BZ    8B9A
08B36:  XORLW  01
08B38:  BZ    8BBE
08B3A:  XORLW  07
08B3C:  BZ    8C08
08B3E:  XORLW  01
08B40:  BTFSC  FD8.2
08B42:  BRA    8C52
08B44:  XORLW  03
08B46:  BTFSC  FD8.2
08B48:  BRA    8C76
08B4A:  XORLW  01
08B4C:  BTFSC  FD8.2
08B4E:  BRA    8C98
08B50:  XORLW  0F
08B52:  BTFSC  FD8.2
08B54:  BRA    8CBA
08B56:  XORLW  01
08B58:  BTFSC  FD8.2
08B5A:  BRA    8CDC
08B5C:  XORLW  19
08B5E:  BTFSC  FD8.2
08B60:  BRA    8CFE
08B62:  XORLW  01
08B64:  BTFSC  FD8.2
08B66:  BRA    8D20
08B68:  XORLW  03
08B6A:  BTFSC  FD8.2
08B6C:  BRA    8D68
08B6E:  XORLW  01
08B70:  BTFSC  FD8.2
08B72:  BRA    8DB0
08B74:  BRA    8EA4
....................  
.................... 			case 0x01 : 
.................... 				// SETTING AMP MODE 
.................... 				 
.................... 				if(new_value>2) { 
08B76:  MOVLB  7
08B78:  MOVF   x0C,W
08B7A:  SUBLW  02
08B7C:  BC    8B90
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08B7E:  MOVLW  30
08B80:  MOVWF  x20
08B82:  MOVLB  0
08B84:  CALL   727A
.................... 					return; 
08B88:  MOVLB  5
08B8A:  GOTO   9392
08B8E:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMP_MODE = new_value; 
08B90:  MOVFF  70C,33
.................... 				perform_eeprom_save = 1; 
08B94:  MOVLW  01
08B96:  MOVWF  x0E
.................... 			break; 
08B98:  BRA    8EB8
.................... 			 
.................... 			case 0x02 : 
.................... 				// SETTING 70V MODE 
.................... 				 
.................... 				if(new_value>1) { 
08B9A:  MOVLB  7
08B9C:  MOVF   x0C,W
08B9E:  SUBLW  01
08BA0:  BC    8BB4
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08BA2:  MOVLW  30
08BA4:  MOVWF  x20
08BA6:  MOVLB  0
08BA8:  CALL   727A
.................... 					return; 
08BAC:  MOVLB  5
08BAE:  GOTO   9392
08BB2:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.IS_70V = new_value; 
08BB4:  MOVFF  70C,34
.................... 				perform_eeprom_save = 1; 
08BB8:  MOVLW  01
08BBA:  MOVWF  x0E
.................... 			break; 
08BBC:  BRA    8EB8
.................... 			 
.................... 			case 0x03 : 
.................... 				// CALIBRATING ADC_MIN 
.................... 				 
.................... 				int new_min = ADC_calibrate_min(1); 
08BBE:  MOVLW  01
08BC0:  MOVLB  7
08BC2:  MOVWF  x20
08BC4:  MOVLB  0
08BC6:  GOTO   7B08
08BCA:  MOVFF  01,713
.................... 				fputc(0x06,USB); 
08BCE:  MOVLW  06
08BD0:  MOVLB  7
08BD2:  MOVWF  x29
08BD4:  MOVLB  0
08BD6:  CALL   7234
.................... 				fputc(0x03,USB); 
08BDA:  MOVLW  03
08BDC:  MOVLB  7
08BDE:  MOVWF  x29
08BE0:  MOVLB  0
08BE2:  CALL   7234
.................... 				fputc(new_min,USB); 
08BE6:  MOVFF  713,729
08BEA:  CALL   7234
.................... 				fputc(0x03,USB); 
08BEE:  MOVLW  03
08BF0:  MOVLB  7
08BF2:  MOVWF  x29
08BF4:  MOVLB  0
08BF6:  CALL   7234
.................... 				perform_eeprom_save = 0; 
08BFA:  MOVLB  7
08BFC:  CLRF   x0E
.................... 				return; 
08BFE:  MOVLB  5
08C00:  GOTO   9392
.................... 			break; 
08C04:  MOVLB  7
08C06:  BRA    8EB8
.................... 			 
.................... 			case 0x04 : 
.................... 				// CALIBRATING ADC_MAX 
.................... 				 
.................... 				int new_max = ADC_calibrate_max(1); 
08C08:  MOVLW  01
08C0A:  MOVLB  7
08C0C:  MOVWF  x20
08C0E:  MOVLB  0
08C10:  GOTO   7B84
08C14:  MOVFF  01,714
....................  
.................... 				fputc(0x06,USB); 
08C18:  MOVLW  06
08C1A:  MOVLB  7
08C1C:  MOVWF  x29
08C1E:  MOVLB  0
08C20:  CALL   7234
.................... 				fputc(0x04,USB); 
08C24:  MOVLW  04
08C26:  MOVLB  7
08C28:  MOVWF  x29
08C2A:  MOVLB  0
08C2C:  CALL   7234
.................... 				fputc(new_max,USB); 
08C30:  MOVFF  714,729
08C34:  CALL   7234
.................... 				fputc(0x03,USB); 
08C38:  MOVLW  03
08C3A:  MOVLB  7
08C3C:  MOVWF  x29
08C3E:  MOVLB  0
08C40:  CALL   7234
.................... 				perform_eeprom_save = 0; 
08C44:  MOVLB  7
08C46:  CLRF   x0E
.................... 				return; 
08C48:  MOVLB  5
08C4A:  GOTO   9392
.................... 			break; 
08C4E:  MOVLB  7
08C50:  BRA    8EB8
.................... 			 
.................... 			case 0x05 : 
.................... 				// SETTING RVC_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08C52:  MOVLB  7
08C54:  MOVF   x0C,W
08C56:  SUBLW  01
08C58:  BC    8C6C
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08C5A:  MOVLW  30
08C5C:  MOVWF  x20
08C5E:  MOVLB  0
08C60:  CALL   727A
.................... 					return; 
08C64:  MOVLB  5
08C66:  GOTO   9392
08C6A:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.RVC_ENABLE = new_value; 
08C6C:  MOVFF  70C,3D
.................... 				perform_eeprom_save = 1; 
08C70:  MOVLW  01
08C72:  MOVWF  x0E
.................... 			break; 
08C74:  BRA    8EB8
.................... 			 
.................... 			case 0x06 : 
.................... 				// SETTING USBDETECT_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08C76:  MOVLB  7
08C78:  MOVF   x0C,W
08C7A:  SUBLW  01
08C7C:  BC    8C8E
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08C7E:  MOVLW  30
08C80:  MOVWF  x20
08C82:  MOVLB  0
08C84:  CALL   727A
.................... 					return; 
08C88:  MOVLB  5
08C8A:  BRA    9392
08C8C:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.USBDETECT_ENABLE = new_value; 
08C8E:  MOVFF  70C,3E
.................... 				perform_eeprom_save = 1; 
08C92:  MOVLW  01
08C94:  MOVWF  x0E
.................... 			break; 
08C96:  BRA    8EB8
.................... 			 
.................... 			case 0x07 : 
.................... 				// SETTING AMPBOOT_DELAY_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08C98:  MOVLB  7
08C9A:  MOVF   x0C,W
08C9C:  SUBLW  01
08C9E:  BC    8CB0
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08CA0:  MOVLW  30
08CA2:  MOVWF  x20
08CA4:  MOVLB  0
08CA6:  CALL   727A
.................... 					return; 
08CAA:  MOVLB  5
08CAC:  BRA    9392
08CAE:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE = new_value; 
08CB0:  MOVFF  70C,3F
.................... 				perform_eeprom_save = 1; 
08CB4:  MOVLW  01
08CB6:  MOVWF  x0E
.................... 			break; 
08CB8:  BRA    8EB8
.................... 			 
.................... 			case 0x08 : 
.................... 				// SETTING PS_PIN_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08CBA:  MOVLB  7
08CBC:  MOVF   x0C,W
08CBE:  SUBLW  01
08CC0:  BC    8CD2
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08CC2:  MOVLW  30
08CC4:  MOVWF  x20
08CC6:  MOVLB  0
08CC8:  CALL   727A
.................... 					return; 
08CCC:  MOVLB  5
08CCE:  BRA    9392
08CD0:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.PS_PIN_ENABLE = new_value; 
08CD2:  MOVFF  70C,40
.................... 				perform_eeprom_save = 1; 
08CD6:  MOVLW  01
08CD8:  MOVWF  x0E
.................... 			break; 
08CDA:  BRA    8EB8
.................... 			 
.................... 			case 0x09 : 
.................... 				// SETTING DSP_VALUESEND_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08CDC:  MOVLB  7
08CDE:  MOVF   x0C,W
08CE0:  SUBLW  01
08CE2:  BC    8CF4
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08CE4:  MOVLW  30
08CE6:  MOVWF  x20
08CE8:  MOVLB  0
08CEA:  CALL   727A
.................... 					return; 
08CEE:  MOVLB  5
08CF0:  BRA    9392
08CF2:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.DSP_VALUESEND_ENABLE = new_value; 
08CF4:  MOVFF  70C,41
.................... 				perform_eeprom_save = 1; 
08CF8:  MOVLW  01
08CFA:  MOVWF  x0E
.................... 			break; 
08CFC:  BRA    8EB8
....................  
.................... 			case 0x10 : 
.................... 				// SETTING SLEEP_ENABLE 
.................... 				 
.................... 				if(new_value>1) { 
08CFE:  MOVLB  7
08D00:  MOVF   x0C,W
08D02:  SUBLW  01
08D04:  BC    8D16
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08D06:  MOVLW  30
08D08:  MOVWF  x20
08D0A:  MOVLB  0
08D0C:  CALL   727A
.................... 					return; 
08D10:  MOVLB  5
08D12:  BRA    9392
08D14:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_ENABLE = new_value; 
08D16:  MOVFF  70C,42
.................... 				perform_eeprom_save = 1; 
08D1A:  MOVLW  01
08D1C:  MOVWF  x0E
.................... 			break; 
08D1E:  BRA    8EB8
....................  
.................... 			case 0x11 : 
.................... 				// SETTING SLEEP_SECONDS 
.................... 				 
.................... 				lsb = (int16)new_value; 
08D20:  MOVLB  7
08D22:  CLRF   x10
08D24:  MOVFF  70C,70F
.................... 				msb = (int16)new_value2; 
08D28:  CLRF   x12
08D2A:  MOVFF  70D,711
....................  
.................... 				int16 new_sleep_seconds = (msb<<8) | (lsb); 
08D2E:  CLRF   x20
08D30:  MOVF   x20,W
08D32:  IORWF  x0F,W
08D34:  MOVWF  x15
08D36:  MOVF   x11,W
08D38:  IORWF  x10,W
08D3A:  MOVWF  x16
....................  
.................... 				if(new_sleep_seconds<DEVICE_CONFIG.SLEEP_HOLDTIME) { 
08D3C:  MOVF   x16,W
08D3E:  SUBWF  46,W
08D40:  BNC   8D5A
08D42:  BNZ   8D4A
08D44:  MOVF   45,W
08D46:  SUBWF  x15,W
08D48:  BC    8D5A
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08D4A:  MOVLW  30
08D4C:  MOVWF  x20
08D4E:  MOVLB  0
08D50:  CALL   727A
.................... 					return; 
08D54:  MOVLB  5
08D56:  BRA    9392
08D58:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_SECONDS = new_sleep_seconds; 
08D5A:  MOVFF  716,44
08D5E:  MOVFF  715,43
.................... 				perform_eeprom_save = 1; 
08D62:  MOVLW  01
08D64:  MOVWF  x0E
.................... 			break; 
08D66:  BRA    8EB8
....................  
.................... 			case 0x12 : 
.................... 				// SETTING SLEEP_HOLDTIME 
.................... 				 
.................... 				lsb = (int16)new_value; 
08D68:  MOVLB  7
08D6A:  CLRF   x10
08D6C:  MOVFF  70C,70F
.................... 				msb = (int16)new_value2; 
08D70:  CLRF   x12
08D72:  MOVFF  70D,711
....................  
.................... 				int16 new_sleep_holdtime = (msb<<8) | (lsb); 
08D76:  CLRF   x20
08D78:  MOVF   x20,W
08D7A:  IORWF  x0F,W
08D7C:  MOVWF  x17
08D7E:  MOVF   x11,W
08D80:  IORWF  x10,W
08D82:  MOVWF  x18
.................... 				//fprintf(RS232,"LSB: %ld, MSB: %ld, INT16 %ld\r\n",lsb, msb, new_sleep_holdtime); 
....................  
.................... 				if(new_sleep_holdtime>DEVICE_CONFIG.SLEEP_SECONDS) { 
08D84:  MOVF   44,W
08D86:  SUBWF  x18,W
08D88:  BNC   8DA2
08D8A:  BNZ   8D92
08D8C:  MOVF   x17,W
08D8E:  SUBWF  43,W
08D90:  BC    8DA2
.................... 					send_error(ERR_DEVICE_CONFIG_INVALID); 
08D92:  MOVLW  30
08D94:  MOVWF  x20
08D96:  MOVLB  0
08D98:  CALL   727A
.................... 					return; 
08D9C:  MOVLB  5
08D9E:  BRA    9392
08DA0:  MOVLB  7
.................... 				} 
.................... 	 
.................... 				DEVICE_CONFIG.SLEEP_HOLDTIME = new_sleep_holdtime; 
08DA2:  MOVFF  718,46
08DA6:  MOVFF  717,45
.................... 				perform_eeprom_save = 1; 
08DAA:  MOVLW  01
08DAC:  MOVWF  x0E
.................... 			break; 
08DAE:  BRA    8EB8
....................  
.................... 			case 0x13 : 
.................... 				// SETTING SERIAL NUMBER 
.................... 			 
.................... 				finished = false; 
08DB0:  MOVLB  6
08DB2:  CLRF   xC0
....................  
.................... 				for(x = 0; x < 20; x++) { 
08DB4:  CLRF   xD6
08DB6:  MOVF   xD6,W
08DB8:  SUBLW  13
08DBA:  BNC   8DD0
.................... 					DEVICE_CONFIG.SERIAL[x] = 0xFF; 
08DBC:  CLRF   03
08DBE:  MOVF   xD6,W
08DC0:  ADDLW  47
08DC2:  MOVWF  FE9
08DC4:  MOVLW  00
08DC6:  ADDWFC 03,W
08DC8:  MOVWF  FEA
08DCA:  SETF   FEF
.................... 				} 
08DCC:  INCF   xD6,F
08DCE:  BRA    8DB6
....................  
....................  
.................... 				int16 char_receive_count = 0; 
08DD0:  MOVLB  7
08DD2:  CLRF   x1A
08DD4:  CLRF   x19
....................  
.................... 				while((char_receive_count < 20)	&& (timeout_error == false)&& (finished == false)) 
.................... 				{ 
08DD6:  MOVF   x1A,F
08DD8:  BNZ   8E2C
08DDA:  MOVF   x19,W
08DDC:  SUBLW  13
08DDE:  BNC   8E2C
08DE0:  MOVLB  5
08DE2:  MOVF   x8C,F
08DE4:  BTFSC  FD8.2
08DE6:  BRA    8DEC
08DE8:  MOVLB  7
08DEA:  BRA    8E2C
08DEC:  MOVLB  6
08DEE:  MOVF   xC0,F
08DF0:  BTFSC  FD8.2
08DF2:  BRA    8DF8
08DF4:  MOVLB  7
08DF6:  BRA    8E2C
.................... 					temp_byte = timed_getc(); 
08DF8:  MOVLB  0
08DFA:  CALL   7296
08DFE:  MOVFF  01,6C1
.................... 					//temp_byte = fgetc(USB); 
.................... 					if(temp_byte == 0x0A) { 
08E02:  MOVLB  6
08E04:  MOVF   xC1,W
08E06:  SUBLW  0A
08E08:  BNZ   8E10
.................... 						finished = true; 
08E0A:  MOVLW  01
08E0C:  MOVWF  xC0
.................... 					} else { 
08E0E:  BRA    8E22
.................... 						DEVICE_CONFIG.SERIAL[char_receive_count] = temp_byte;	 
08E10:  MOVLW  47
08E12:  MOVLB  7
08E14:  ADDWF  x19,W
08E16:  MOVWF  FE9
08E18:  MOVLW  00
08E1A:  ADDWFC x1A,W
08E1C:  MOVWF  FEA
08E1E:  MOVFF  6C1,FEF
....................  
.................... 					} 
.................... 					char_receive_count++; 
08E22:  MOVLB  7
08E24:  INCF   x19,F
08E26:  BTFSC  FD8.2
08E28:  INCF   x1A,F
.................... 				 
.................... 				} 
08E2A:  BRA    8DD6
....................  
.................... 				if(!finished) { 
08E2C:  MOVLB  6
08E2E:  MOVF   xC0,F
08E30:  BNZ   8E9C
.................... 					dummy_char = timed_getc(); 
08E32:  MOVLB  0
08E34:  CALL   7296
08E38:  MOVFF  01,6DA
.................... 					 
.................... 					if(timeout_error == true) { 
08E3C:  MOVLB  5
08E3E:  DECFSZ x8C,W
08E40:  BRA    8E6A
.................... 						// Timed out. No command. Start over. 
.................... 						fputc(0x15,USB); 
08E42:  MOVLW  15
08E44:  MOVLB  7
08E46:  MOVWF  x29
08E48:  MOVLB  0
08E4A:  CALL   7234
.................... 						fputc(ERR_END_TIMEOUT,USB); 
08E4E:  MOVLW  11
08E50:  MOVLB  7
08E52:  MOVWF  x29
08E54:  MOVLB  0
08E56:  CALL   7234
.................... 						fputc(0x03,USB); 
08E5A:  MOVLW  03
08E5C:  MOVLB  7
08E5E:  MOVWF  x29
08E60:  MOVLB  0
08E62:  CALL   7234
.................... 						return; 
08E66:  MOVLB  5
08E68:  BRA    9392
.................... 					} 
.................... 					 
.................... 					if(dummy_char != 0x03) { 
08E6A:  MOVLB  6
08E6C:  MOVF   xDA,W
08E6E:  SUBLW  03
08E70:  BZ    8E9C
.................... 						// Ending char not 0x03 
.................... 						fputc(0x15,USB); 
08E72:  MOVLW  15
08E74:  MOVLB  7
08E76:  MOVWF  x29
08E78:  MOVLB  0
08E7A:  CALL   7234
.................... 						fputc(0x12,USB); 
08E7E:  MOVLW  12
08E80:  MOVLB  7
08E82:  MOVWF  x29
08E84:  MOVLB  0
08E86:  CALL   7234
.................... 						fputc(0x03,USB); 
08E8A:  MOVLW  03
08E8C:  MOVLB  7
08E8E:  MOVWF  x29
08E90:  MOVLB  0
08E92:  CALL   7234
.................... 						return; 
08E96:  MOVLB  5
08E98:  BRA    9392
08E9A:  MOVLB  6
.................... 						 
.................... 					} 
.................... 				} 
....................  
.................... 				perform_eeprom_save = 1; 
08E9C:  MOVLW  01
08E9E:  MOVLB  7
08EA0:  MOVWF  x0E
....................  
.................... 			break; 
08EA2:  BRA    8EB8
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
08EA4:  MOVLW  13
08EA6:  MOVLB  7
08EA8:  MOVWF  x20
08EAA:  MOVLB  0
08EAC:  CALL   727A
.................... 				return; 
08EB0:  MOVLB  5
08EB2:  BRA    9392
.................... 			break; 
08EB4:  MOVLB  7
08EB6:  BRA    8EB8
.................... 		} 
....................  
.................... 		if(perform_eeprom_save == 1) { 
08EB8:  DECFSZ x0E,W
08EBA:  BRA    8F0E
.................... 			INTEEPROM_PUT(&DEVICE_CONFIG,sizeof(DEVICE_CONFIG),100); 
08EBC:  CLRF   x23
08EBE:  MOVLW  33
08EC0:  MOVWF  x22
08EC2:  CLRF   x25
08EC4:  MOVLW  28
08EC6:  MOVWF  x24
08EC8:  CLRF   x27
08ECA:  MOVLW  64
08ECC:  MOVWF  x26
08ECE:  MOVLB  0
08ED0:  CALL   6388
.................... 			delay_ms(10); 
08ED4:  MOVLW  0A
08ED6:  MOVLB  7
08ED8:  MOVWF  x2B
08EDA:  MOVLB  0
08EDC:  CALL   5FEA
....................  
.................... 			fputc(0x06,USB); 
08EE0:  MOVLW  06
08EE2:  MOVLB  7
08EE4:  MOVWF  x29
08EE6:  MOVLB  0
08EE8:  CALL   7234
.................... 			fputc(command_char,USB); 
08EEC:  MOVFF  6D9,729
08EF0:  CALL   7234
.................... 			fputc(new_value,USB); 
08EF4:  MOVFF  70C,729
08EF8:  CALL   7234
.................... 			fputc(0x03,USB); 
08EFC:  MOVLW  03
08EFE:  MOVLB  7
08F00:  MOVWF  x29
08F02:  MOVLB  0
08F04:  CALL   7234
....................  
.................... 			return; 
08F08:  MOVLB  5
08F0A:  BRA    9392
08F0C:  MOVLB  7
.................... 		} 
....................  
.................... GET_DEVICE_PROPERTY:	 
....................  
.................... 		command_char = timed_getc(); 
08F0E:  MOVLB  0
08F10:  CALL   7296
08F14:  MOVFF  01,6D9
.................... 	 
.................... 		if(timeout_error == true) { 
08F18:  MOVLB  5
08F1A:  DECFSZ x8C,W
08F1C:  BRA    8F2E
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_COMMAND_TIMEOUT); 
08F1E:  MOVLW  10
08F20:  MOVLB  7
08F22:  MOVWF  x20
08F24:  MOVLB  0
08F26:  CALL   727A
.................... 			return; 
08F2A:  MOVLB  5
08F2C:  BRA    9392
.................... 		} 
.................... 		 
.................... 		dummy_char = timed_getc(); 
08F2E:  MOVLB  0
08F30:  CALL   7296
08F34:  MOVFF  01,6DA
.................... 		 
.................... 		if(timeout_error == true) { 
08F38:  MOVLB  5
08F3A:  DECFSZ x8C,W
08F3C:  BRA    8F4E
.................... 			// Timed out. No command. Start over. 
.................... 			send_error(ERR_END_TIMEOUT); 
08F3E:  MOVLW  11
08F40:  MOVLB  7
08F42:  MOVWF  x20
08F44:  MOVLB  0
08F46:  CALL   727A
.................... 			return; 
08F4A:  MOVLB  5
08F4C:  BRA    9392
.................... 		} 
....................  
.................... 		switch(command_char) { 
08F4E:  MOVLB  6
08F50:  MOVF   xD9,W
08F52:  XORLW  01
08F54:  MOVLB  0
08F56:  BZ    8FA4
08F58:  XORLW  03
08F5A:  BZ    8FD6
08F5C:  XORLW  01
08F5E:  BZ    9008
08F60:  XORLW  07
08F62:  BTFSC  FD8.2
08F64:  BRA    905E
08F66:  XORLW  01
08F68:  BTFSC  FD8.2
08F6A:  BRA    90B4
08F6C:  XORLW  03
08F6E:  BTFSC  FD8.2
08F70:  BRA    90E6
08F72:  XORLW  01
08F74:  BTFSC  FD8.2
08F76:  BRA    9118
08F78:  XORLW  0F
08F7A:  BTFSC  FD8.2
08F7C:  BRA    914A
08F7E:  XORLW  01
08F80:  BTFSC  FD8.2
08F82:  BRA    917C
08F84:  XORLW  19
08F86:  BTFSC  FD8.2
08F88:  BRA    91AE
08F8A:  XORLW  01
08F8C:  BTFSC  FD8.2
08F8E:  BRA    91E0
08F90:  XORLW  03
08F92:  BTFSC  FD8.2
08F94:  BRA    921A
08F96:  XORLW  01
08F98:  BTFSC  FD8.2
08F9A:  BRA    9254
08F9C:  XORLW  07
08F9E:  BTFSC  FD8.2
08FA0:  BRA    92D8
08FA2:  BRA    935A
....................  
.................... 			case 0x01 : 
.................... 				// GET AMPLIFIER MODE 
....................  
.................... 				fputc(0x06); 
08FA4:  MOVLW  06
08FA6:  MOVLB  7
08FA8:  MOVWF  x29
08FAA:  MOVLB  0
08FAC:  CALL   7234
.................... 				fputc(0x01); 
08FB0:  MOVLW  01
08FB2:  MOVLB  7
08FB4:  MOVWF  x29
08FB6:  MOVLB  0
08FB8:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.AMP_MODE); 
08FBC:  MOVFF  33,729
08FC0:  CALL   7234
.................... 				fputc(0x03); 
08FC4:  MOVLW  03
08FC6:  MOVLB  7
08FC8:  MOVWF  x29
08FCA:  MOVLB  0
08FCC:  CALL   7234
.................... 				return; 
08FD0:  MOVLB  5
08FD2:  BRA    9392
.................... 			break; 
08FD4:  BRA    936C
....................  
.................... 			case 0x02 : 
.................... 				// GET 70V MODE 
.................... 				fputc(0x06); 
08FD6:  MOVLW  06
08FD8:  MOVLB  7
08FDA:  MOVWF  x29
08FDC:  MOVLB  0
08FDE:  CALL   7234
.................... 				fputc(0x02); 
08FE2:  MOVLW  02
08FE4:  MOVLB  7
08FE6:  MOVWF  x29
08FE8:  MOVLB  0
08FEA:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.IS_70V); 
08FEE:  MOVFF  34,729
08FF2:  CALL   7234
.................... 				fputc(0x03); 
08FF6:  MOVLW  03
08FF8:  MOVLB  7
08FFA:  MOVWF  x29
08FFC:  MOVLB  0
08FFE:  CALL   7234
.................... 				return; 
09002:  MOVLB  5
09004:  BRA    9392
.................... 			break; 
09006:  BRA    936C
....................  
.................... 			case 0x03 : 
.................... 				// GET ADC_MIN 
.................... 				fputc(0x06); 
09008:  MOVLW  06
0900A:  MOVLB  7
0900C:  MOVWF  x29
0900E:  MOVLB  0
09010:  CALL   7234
.................... 				fputc(0x03); 
09014:  MOVLW  03
09016:  MOVLB  7
09018:  MOVWF  x29
0901A:  MOVLB  0
0901C:  CALL   7234
09020:  CLRF   19
09022:  BTFSC  FF2.7
09024:  BSF    19.7
09026:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MIN); 
09028:  MOVFF  38,7A3
0902C:  MOVFF  37,7A2
09030:  MOVFF  36,7A1
09034:  MOVFF  35,7A0
09038:  CALL   1978
0903C:  BTFSC  19.7
0903E:  BSF    FF2.7
09040:  MOVFF  01,720
09044:  MOVFF  01,729
09048:  CALL   7234
.................... 				fputc(0x03); 
0904C:  MOVLW  03
0904E:  MOVLB  7
09050:  MOVWF  x29
09052:  MOVLB  0
09054:  CALL   7234
.................... 				return; 
09058:  MOVLB  5
0905A:  BRA    9392
.................... 			break; 
0905C:  BRA    936C
....................  
.................... 			case 0x04 : 
.................... 				// GET ADC_MAX 
.................... 				fputc(0x06); 
0905E:  MOVLW  06
09060:  MOVLB  7
09062:  MOVWF  x29
09064:  MOVLB  0
09066:  CALL   7234
.................... 				fputc(0x04); 
0906A:  MOVLW  04
0906C:  MOVLB  7
0906E:  MOVWF  x29
09070:  MOVLB  0
09072:  CALL   7234
09076:  CLRF   19
09078:  BTFSC  FF2.7
0907A:  BSF    19.7
0907C:  BCF    FF2.7
.................... 				fputc((int)DEVICE_CONFIG.ADC_CALIBRATION_MAX); 
0907E:  MOVFF  3C,7A3
09082:  MOVFF  3B,7A2
09086:  MOVFF  3A,7A1
0908A:  MOVFF  39,7A0
0908E:  CALL   1978
09092:  BTFSC  19.7
09094:  BSF    FF2.7
09096:  MOVFF  01,720
0909A:  MOVFF  01,729
0909E:  CALL   7234
.................... 				fputc(0x03); 
090A2:  MOVLW  03
090A4:  MOVLB  7
090A6:  MOVWF  x29
090A8:  MOVLB  0
090AA:  CALL   7234
.................... 				return; 
090AE:  MOVLB  5
090B0:  BRA    9392
.................... 			break; 
090B2:  BRA    936C
....................  
.................... 			case 0x05 : 
.................... 				// GET RVC_ENABLE 
.................... 				fputc(0x06); 
090B4:  MOVLW  06
090B6:  MOVLB  7
090B8:  MOVWF  x29
090BA:  MOVLB  0
090BC:  CALL   7234
.................... 				fputc(0x05); 
090C0:  MOVLW  05
090C2:  MOVLB  7
090C4:  MOVWF  x29
090C6:  MOVLB  0
090C8:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.RVC_ENABLE); 
090CC:  MOVFF  3D,729
090D0:  CALL   7234
.................... 				fputc(0x03); 
090D4:  MOVLW  03
090D6:  MOVLB  7
090D8:  MOVWF  x29
090DA:  MOVLB  0
090DC:  CALL   7234
.................... 				return; 
090E0:  MOVLB  5
090E2:  BRA    9392
.................... 			break; 
090E4:  BRA    936C
....................  
.................... 			case 0x06 : 
.................... 				// GET USBDETECT 
.................... 				fputc(0x06); 
090E6:  MOVLW  06
090E8:  MOVLB  7
090EA:  MOVWF  x29
090EC:  MOVLB  0
090EE:  CALL   7234
.................... 				fputc(0x06); 
090F2:  MOVLW  06
090F4:  MOVLB  7
090F6:  MOVWF  x29
090F8:  MOVLB  0
090FA:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.USBDETECT_ENABLE); 
090FE:  MOVFF  3E,729
09102:  CALL   7234
.................... 				fputc(0x03); 
09106:  MOVLW  03
09108:  MOVLB  7
0910A:  MOVWF  x29
0910C:  MOVLB  0
0910E:  CALL   7234
.................... 				return; 
09112:  MOVLB  5
09114:  BRA    9392
.................... 			break; 
09116:  BRA    936C
....................  
.................... 			case 0x07 : 
.................... 				// GET AMPBOOT 
.................... 				fputc(0x06); 
09118:  MOVLW  06
0911A:  MOVLB  7
0911C:  MOVWF  x29
0911E:  MOVLB  0
09120:  CALL   7234
.................... 				fputc(0x07); 
09124:  MOVLW  07
09126:  MOVLB  7
09128:  MOVWF  x29
0912A:  MOVLB  0
0912C:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.AMPBOOT_DELAY_ENABLE); 
09130:  MOVFF  3F,729
09134:  CALL   7234
.................... 				fputc(0x03); 
09138:  MOVLW  03
0913A:  MOVLB  7
0913C:  MOVWF  x29
0913E:  MOVLB  0
09140:  CALL   7234
.................... 				return; 
09144:  MOVLB  5
09146:  BRA    9392
.................... 			break; 
09148:  BRA    936C
.................... 	 
.................... 			case 0x08 : 
.................... 				// GET PS_PIN 
.................... 				fputc(0x06); 
0914A:  MOVLW  06
0914C:  MOVLB  7
0914E:  MOVWF  x29
09150:  MOVLB  0
09152:  CALL   7234
.................... 				fputc(0x08); 
09156:  MOVLW  08
09158:  MOVLB  7
0915A:  MOVWF  x29
0915C:  MOVLB  0
0915E:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.PS_PIN_ENABLE); 
09162:  MOVFF  40,729
09166:  CALL   7234
.................... 				fputc(0x03); 
0916A:  MOVLW  03
0916C:  MOVLB  7
0916E:  MOVWF  x29
09170:  MOVLB  0
09172:  CALL   7234
.................... 				return; 
09176:  MOVLB  5
09178:  BRA    9392
.................... 			break; 
0917A:  BRA    936C
....................  
.................... 			case 0x09 : 
.................... 				// DSP_VALUESEND 
.................... 				fputc(0x06); 
0917C:  MOVLW  06
0917E:  MOVLB  7
09180:  MOVWF  x29
09182:  MOVLB  0
09184:  CALL   7234
.................... 				fputc(0x09); 
09188:  MOVLW  09
0918A:  MOVLB  7
0918C:  MOVWF  x29
0918E:  MOVLB  0
09190:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.DSP_VALUESEND_ENABLE); 
09194:  MOVFF  41,729
09198:  CALL   7234
.................... 				fputc(0x03); 
0919C:  MOVLW  03
0919E:  MOVLB  7
091A0:  MOVWF  x29
091A2:  MOVLB  0
091A4:  CALL   7234
.................... 				return; 
091A8:  MOVLB  5
091AA:  BRA    9392
.................... 			break; 
091AC:  BRA    936C
....................  
.................... 			case 0x10 : 
.................... 				// SLEEP_ENABLE 
.................... 				fputc(0x06); 
091AE:  MOVLW  06
091B0:  MOVLB  7
091B2:  MOVWF  x29
091B4:  MOVLB  0
091B6:  CALL   7234
.................... 				fputc(0x10); 
091BA:  MOVLW  10
091BC:  MOVLB  7
091BE:  MOVWF  x29
091C0:  MOVLB  0
091C2:  CALL   7234
.................... 				fputc(DEVICE_CONFIG.SLEEP_ENABLE); 
091C6:  MOVFF  42,729
091CA:  CALL   7234
.................... 				fputc(0x03); 
091CE:  MOVLW  03
091D0:  MOVLB  7
091D2:  MOVWF  x29
091D4:  MOVLB  0
091D6:  CALL   7234
.................... 				return; 
091DA:  MOVLB  5
091DC:  BRA    9392
.................... 			break; 
091DE:  BRA    936C
....................  
.................... 			case 0x11 : 
.................... 				// SLEEP_SECONDS 
.................... 				fputc(0x06); 
091E0:  MOVLW  06
091E2:  MOVLB  7
091E4:  MOVWF  x29
091E6:  MOVLB  0
091E8:  CALL   7234
.................... 				fputc(0x11); 
091EC:  MOVLW  11
091EE:  MOVLB  7
091F0:  MOVWF  x29
091F2:  MOVLB  0
091F4:  CALL   7234
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_SECONDS); 
091F8:  MOVLW  10
091FA:  MOVWF  FE9
091FC:  MOVFF  44,721
09200:  MOVFF  43,720
09204:  CALL   7C00
.................... 				fputc(0x0A); 
09208:  MOVLW  0A
0920A:  MOVLB  7
0920C:  MOVWF  x29
0920E:  MOVLB  0
09210:  CALL   7234
.................... 				return; 
09214:  MOVLB  5
09216:  BRA    9392
.................... 			break; 
09218:  BRA    936C
....................  
.................... 			case 0x12 : 
.................... 				// SLEEP_HOLDTIME 
.................... 				fputc(0x06); 
0921A:  MOVLW  06
0921C:  MOVLB  7
0921E:  MOVWF  x29
09220:  MOVLB  0
09222:  CALL   7234
.................... 				fputc(0x12); 
09226:  MOVLW  12
09228:  MOVLB  7
0922A:  MOVWF  x29
0922C:  MOVLB  0
0922E:  CALL   7234
.................... 				fprintf(USB,"%ld",DEVICE_CONFIG.SLEEP_HOLDTIME); 
09232:  MOVLW  10
09234:  MOVWF  FE9
09236:  MOVFF  46,721
0923A:  MOVFF  45,720
0923E:  CALL   7C00
.................... 				fputc(0x03); 
09242:  MOVLW  03
09244:  MOVLB  7
09246:  MOVWF  x29
09248:  MOVLB  0
0924A:  CALL   7234
.................... 				return; 
0924E:  MOVLB  5
09250:  BRA    9392
.................... 			break; 
09252:  BRA    936C
.................... 	 
.................... 			case 0x13 : 
.................... 				// SERIAL NUMBER 
.................... 				memcpy(name_buffer,DEVICE_CONFIG.SERIAL,sizeof(name_buffer)); 
09254:  MOVLW  06
09256:  MOVWF  FEA
09258:  MOVLW  C2
0925A:  MOVWF  FE9
0925C:  CLRF   FE2
0925E:  MOVLW  47
09260:  MOVWF  FE1
09262:  MOVLW  14
09264:  MOVWF  01
09266:  MOVFF  FE6,FEE
0926A:  DECFSZ 01,F
0926C:  BRA    9266
....................  
.................... 				fputc(0x06); 
0926E:  MOVLW  06
09270:  MOVLB  7
09272:  MOVWF  x29
09274:  MOVLB  0
09276:  CALL   7234
.................... 				fputc(0x13); 
0927A:  MOVLW  13
0927C:  MOVLB  7
0927E:  MOVWF  x29
09280:  MOVLB  0
09282:  CALL   7234
....................  
.................... 				for(y = 0; y < 20; y++) { 
09286:  MOVLB  6
09288:  CLRF   xD7
0928A:  MOVF   xD7,W
0928C:  SUBLW  13
0928E:  BNC   92C6
.................... 					if(name_buffer[y] == 0xFF) { 
09290:  CLRF   03
09292:  MOVF   xD7,W
09294:  ADDLW  C2
09296:  MOVWF  FE9
09298:  MOVLW  06
0929A:  ADDWFC 03,W
0929C:  MOVWF  FEA
0929E:  INCFSZ FEF,W
092A0:  BRA    92A4
.................... 						break; 
092A2:  BRA    92C6
.................... 					} 
.................... 			 
.................... 					fputc(name_buffer[y],USB); 
092A4:  CLRF   03
092A6:  MOVF   xD7,W
092A8:  ADDLW  C2
092AA:  MOVWF  FE9
092AC:  MOVLW  06
092AE:  ADDWFC 03,W
092B0:  MOVWF  FEA
092B2:  MOVFF  FEF,720
092B6:  MOVFF  720,729
092BA:  MOVLB  0
092BC:  CALL   7234
.................... 				} 
092C0:  MOVLB  6
092C2:  INCF   xD7,F
092C4:  BRA    928A
....................  
.................... 				fputc(0x03); 
092C6:  MOVLW  03
092C8:  MOVLB  7
092CA:  MOVWF  x29
092CC:  MOVLB  0
092CE:  CALL   7234
.................... 				return; 
092D2:  MOVLB  5
092D4:  BRA    9392
.................... 			break; 
092D6:  BRA    936C
....................  
.................... 			case 0x14 : 
.................... 				// GET CURRENT RVC 
....................  
.................... 				int current_adc = read_adc(); 
....................  
.................... 				double percentage = RVC_to_decibel(current_adc); 
092D8:  BSF    FC2.1
092DA:  BTFSC  FC2.1
092DC:  BRA    92DA
092DE:  MOVFF  FC4,71B
092E2:  MOVFF  71B,720
092E6:  MOVLB  0
092E8:  GOTO   7CF6
092EC:  MOVFF  03,71F
092F0:  MOVFF  02,71E
092F4:  MOVFF  01,71D
092F8:  MOVFF  00,71C
....................  
.................... 				fputc(0x16); 
092FC:  MOVLW  16
092FE:  MOVLB  7
09300:  MOVWF  x29
09302:  MOVLB  0
09304:  CALL   7234
.................... 				fputc(0x14); 
09308:  MOVLW  14
0930A:  MOVLB  7
0930C:  MOVWF  x29
0930E:  MOVLB  0
09310:  CALL   7234
.................... 				fputc(current_adc); 
09314:  MOVFF  71B,729
09318:  CALL   7234
0931C:  CLRF   19
0931E:  BTFSC  FF2.7
09320:  BSF    19.7
09322:  BCF    FF2.7
.................... 				fputc((int)percentage); 
09324:  MOVFF  71F,7A3
09328:  MOVFF  71E,7A2
0932C:  MOVFF  71D,7A1
09330:  MOVFF  71C,7A0
09334:  CALL   1978
09338:  BTFSC  19.7
0933A:  BSF    FF2.7
0933C:  MOVFF  01,720
09340:  MOVFF  01,729
09344:  CALL   7234
.................... 				fputc(0x03); 
09348:  MOVLW  03
0934A:  MOVLB  7
0934C:  MOVWF  x29
0934E:  MOVLB  0
09350:  CALL   7234
.................... 				return; 
09354:  MOVLB  5
09356:  BRA    9392
.................... 			break; 
09358:  BRA    936C
.................... 			 
.................... 			default : 
.................... 				// Invalid utility command 
.................... 				send_error(ERR_COMMAND_INVALID); 
0935A:  MOVLW  13
0935C:  MOVLB  7
0935E:  MOVWF  x20
09360:  MOVLB  0
09362:  CALL   727A
.................... 				return; 
09366:  MOVLB  5
09368:  BRA    9392
.................... 			break; 
0936A:  BRA    936C
.................... 		} 
....................  
.................... 	// How did we get here? Should be impossible.. Let's send an error though... 
.................... 	// Someone probably forgot a return statement above... D'oh! 
....................  
....................  
.................... 	fputc(0x15,USB); 
0936C:  MOVLW  15
0936E:  MOVLB  7
09370:  MOVWF  x29
09372:  MOVLB  0
09374:  CALL   7234
.................... 	fputc(ERR_UNKNOWN,USB); 
09378:  MOVLW  09
0937A:  MOVLB  7
0937C:  MOVWF  x29
0937E:  MOVLB  0
09380:  CALL   7234
.................... 	fputc(0x03,USB); 
09384:  MOVLW  03
09386:  MOVLB  7
09388:  MOVWF  x29
0938A:  MOVLB  0
0938C:  CALL   7234
09390:  MOVLB  5
.................... 	return; 
.................... } 
09392:  MOVLB  0
09394:  GOTO   94AE (RETURN)
....................  
....................  
.................... #include <interrupts.c> 
.................... void disable_all_timers() 
.................... { 
.................... 	clear_interrupt(INT_TIMER0); 
*
02EDC:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02EDE:  BCF    F9E.0
.................... 	SETUP_TIMER_0(RTCC_OFF); 
02EE0:  CLRF   FD5
.................... 	setup_timer_1(T1_DISABLED); 
02EE2:  CLRF   FCD
02EE4:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
02EE6:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02EE8:  BCF    F9E.0
.................... } 
02EEA:  GOTO   2F8C (RETURN)
....................  
.................... void enable_all_timers() 
.................... { 
....................  
.................... 	clear_interrupt(INT_TIMER0); 
*
02F5A:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02F5C:  BCF    F9E.0
.................... 	setup_timer_0(T0_INTERNAL|T0_DIV_64); 
02F5E:  MOVLW  85
02F60:  MOVWF  FD5
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
02F62:  MOVLW  37
02F64:  MOVWF  FCD
02F66:  CLRF   FCC
.................... 	clear_interrupt(INT_TIMER0); 
02F68:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1); 
02F6A:  BCF    F9E.0
....................  
.................... 	setup_interrupts(); 
02F6C:  RCALL  2EEE
....................  
.................... } 
02F6E:  GOTO   2F94 (RETURN)
....................  
.................... // SLEEP TIMER is every 1 seconds 
.................... #INT_TIMER0 
.................... void SLEEPTIMER_ISR(void)  
.................... { 
....................  
.................... 	sleepseconds++; 
*
01254:  MOVLB  1
01256:  INCF   x7E,F
01258:  BTFSC  FD8.2
0125A:  INCF   x7F,F
....................  
.................... 	if(sleepseconds >= sleeptimeout_seconds) { 
0125C:  MOVF   x81,W
0125E:  SUBWF  x7F,W
01260:  BNC   1278
01262:  BNZ   126A
01264:  MOVF   x80,W
01266:  SUBWF  x7E,W
01268:  BNC   1278
.................... 		sleepseconds = 0; 
0126A:  CLRF   x7F
0126C:  CLRF   x7E
.................... 		// TIMEOUT ROUTINE HERE 
.................... 		is_in_sleep = 1; 
0126E:  MOVLW  01
01270:  MOVWF  x82
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, AMPLIFIER NOW IN SLEEP MODE\r\n",sleeptimeout_seconds); 
.................... 		} 
....................  
.................... 		disable_interrupts(INT_TIMER0); 
01272:  BCF    FF2.5
.................... 		clear_interrupt(INT_TIMER0); 
01274:  BCF    FF2.2
.................... 		return; 
01276:  BRA    1280
.................... 	} 
....................  
.................... 	set_timer0(7936); 
01278:  MOVLW  1F
0127A:  MOVWF  FD7
0127C:  CLRF   FD6
.................... 	clear_interrupt(INT_TIMER0); 
0127E:  BCF    FF2.2
.................... } 
....................  
.................... // REMOTE VOLUME CONTROL 
01280:  BCF    FF2.2
01282:  MOVLB  0
01284:  GOTO   0884
.................... #INT_TIMER1  
.................... void RVCTIMER_ISR(void)  
.................... { 
....................  
.................... 	pin_in_mute_state = !input(PIN_AMP_nMUTE); 
*
02AE2:  BSF    F94.1
02AE4:  MOVLB  1
02AE6:  CLRF   x7D
02AE8:  BTFSS  F82.1
02AEA:  INCF   x7D,F
.................... 	 
.................... 	set_adc_channel(0); 
02AEC:  MOVLW  00
02AEE:  MOVWF  01
02AF0:  MOVF   FC2,W
02AF2:  ANDLW  83
02AF4:  IORWF  01,W
02AF6:  MOVWF  FC2
.................... 	delay_us(10); 
02AF8:  MOVLW  0B
02AFA:  MOVWF  00
02AFC:  DECFSZ 00,F
02AFE:  BRA    2AFC
02B00:  BRA    2B02
.................... 	current_adc = read_adc(); 
02B02:  BSF    FC2.1
02B04:  BTFSC  FC2.1
02B06:  BRA    2B04
02B08:  MOVFF  FC4,17B
.................... 	 
.................... 	if(pin_in_mute_state && is_muted) { 
02B0C:  MOVF   x7D,F
02B0E:  BZ    2B1E
02B10:  MOVF   x7C,F
02B12:  BZ    2B1E
.................... 		// Do nothing 
.................... 		set_timer1(15550); 
02B14:  MOVLW  3C
02B16:  MOVWF  FCF
02B18:  MOVLW  BE
02B1A:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02B1C:  BCF    F9E.0
.................... 	} 
....................  
.................... 	 
....................  
.................... 	if(pin_in_mute_state && !is_muted) { 
02B1E:  MOVF   x7D,F
02B20:  BZ    2BA4
02B22:  MOVF   x7C,F
02B24:  BNZ   2BA4
.................... 		is_muted = true; 
02B26:  MOVLW  01
02B28:  MOVWF  x7C
.................... 		send_dsp_command(AM_ANALOG1_TRIM,0x00000000); 
02B2A:  MOVLW  83
02B2C:  MOVLB  7
02B2E:  MOVWF  x76
02B30:  CLRF   x75
02B32:  CLRF   x74
02B34:  MOVLW  0A
02B36:  MOVWF  x73
02B38:  CLRF   x7A
02B3A:  CLRF   x79
02B3C:  CLRF   x78
02B3E:  CLRF   x77
02B40:  MOVLB  0
02B42:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG2_TRIM,0x00000000); 
02B46:  MOVLW  83
02B48:  MOVLB  7
02B4A:  MOVWF  x76
02B4C:  CLRF   x75
02B4E:  CLRF   x74
02B50:  MOVLW  0B
02B52:  MOVWF  x73
02B54:  CLRF   x7A
02B56:  CLRF   x79
02B58:  CLRF   x78
02B5A:  CLRF   x77
02B5C:  MOVLB  0
02B5E:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG3_TRIM,0x00000000); 
02B62:  MOVLW  83
02B64:  MOVLB  7
02B66:  MOVWF  x76
02B68:  CLRF   x75
02B6A:  CLRF   x74
02B6C:  MOVLW  0C
02B6E:  MOVWF  x73
02B70:  CLRF   x7A
02B72:  CLRF   x79
02B74:  CLRF   x78
02B76:  CLRF   x77
02B78:  MOVLB  0
02B7A:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG4_TRIM,0x00000000); 
02B7E:  MOVLW  83
02B80:  MOVLB  7
02B82:  MOVWF  x76
02B84:  CLRF   x75
02B86:  CLRF   x74
02B88:  MOVLW  0D
02B8A:  MOVWF  x73
02B8C:  CLRF   x7A
02B8E:  CLRF   x79
02B90:  CLRF   x78
02B92:  CLRF   x77
02B94:  MOVLB  0
02B96:  CALL   1388
.................... 		set_timer1(15550); 
02B9A:  MOVLW  3C
02B9C:  MOVWF  FCF
02B9E:  MOVLW  BE
02BA0:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02BA2:  BCF    F9E.0
....................  
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"Mute pin brought low. Muting\r\n"); 
.................... 		} 
.................... 	} 
....................  
.................... 	unsigned int difference = 0; 
02BA4:  MOVLB  7
02BA6:  CLRF   x6A
....................  
.................... 	if(current_adc > last_adc) { 
02BA8:  MOVLB  1
02BAA:  MOVF   x7B,W
02BAC:  SUBWF  x7A,W
02BAE:  BC    2BBC
.................... 		difference = current_adc - last_adc; 
02BB0:  MOVF   x7A,W
02BB2:  SUBWF  x7B,W
02BB4:  MOVLB  7
02BB6:  MOVWF  x6A
.................... 	} else { 
02BB8:  BRA    2BC4
02BBA:  MOVLB  1
.................... 		difference = last_adc - current_adc; 
02BBC:  MOVF   x7B,W
02BBE:  SUBWF  x7A,W
02BC0:  MOVLB  7
02BC2:  MOVWF  x6A
.................... 	} 
....................  
.................... 	if((!pin_in_mute_state && is_muted) || (difference > RVC_NOISE_FLOOR)) { 
02BC4:  MOVLB  1
02BC6:  MOVF   x7D,F
02BC8:  BNZ   2BCE
02BCA:  MOVF   x7C,F
02BCC:  BNZ   2BDA
02BCE:  MOVLB  7
02BD0:  MOVF   x6A,W
02BD2:  SUBWF  1E,W
02BD4:  BTFSC  FD8.0
02BD6:  BRA    2DBC
02BD8:  MOVLB  1
....................  
.................... 		 
.................... 		double dsp_value = RVC_to_dsp_value(current_adc); 
02BDA:  MOVFF  17B,76F
02BDE:  MOVLB  0
02BE0:  RCALL  2986
02BE2:  MOVFF  03,76E
02BE6:  MOVFF  02,76D
02BEA:  MOVFF  01,76C
02BEE:  MOVFF  00,76B
....................  
.................... 		 
.................... 		if(current_adc < 30) { 
02BF2:  MOVLB  1
02BF4:  MOVF   x7B,W
02BF6:  SUBLW  1D
02BF8:  BNC   2C08
.................... 			dsp_value = 0; 
02BFA:  MOVLB  7
02BFC:  CLRF   x6E
02BFE:  CLRF   x6D
02C00:  CLRF   x6C
02C02:  CLRF   x6B
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = 0.0000\r\n",current_adc); 
.................... 			}	 
.................... 		} else { 
02C04:  BRA    2C06
02C06:  MOVLB  1
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] ADC = %u, Value = %.4f\r\n",current_adc,dsp_value); 
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		//double percentage = ADC_to_percentage(current_adc); 
.................... 		send_dsp_command(AM_ANALOG1_TRIM,(int32)(dsp_value*2147483648.0)); 
02C08:  MOVFF  76E,7A3
02C0C:  MOVFF  76D,7A2
02C10:  MOVFF  76C,7A1
02C14:  MOVFF  76B,7A0
02C18:  MOVLB  7
02C1A:  CLRF   xA7
02C1C:  CLRF   xA6
02C1E:  CLRF   xA5
02C20:  MOVLW  9E
02C22:  MOVWF  xA4
02C24:  MOVLB  0
02C26:  CALL   1808
02C2A:  MOVFF  03,772
02C2E:  MOVFF  02,771
02C32:  MOVFF  01,770
02C36:  MOVFF  00,76F
02C3A:  RCALL  2AA0
02C3C:  MOVFF  03,772
02C40:  MOVFF  02,771
02C44:  MOVFF  01,770
02C48:  MOVFF  00,76F
02C4C:  MOVLW  83
02C4E:  MOVLB  7
02C50:  MOVWF  x76
02C52:  CLRF   x75
02C54:  CLRF   x74
02C56:  MOVLW  0A
02C58:  MOVWF  x73
02C5A:  MOVFF  03,77A
02C5E:  MOVFF  02,779
02C62:  MOVFF  01,778
02C66:  MOVFF  00,777
02C6A:  MOVLB  0
02C6C:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG2_TRIM,(int32)(dsp_value*2147483648.0)); 
02C70:  MOVFF  76E,7A3
02C74:  MOVFF  76D,7A2
02C78:  MOVFF  76C,7A1
02C7C:  MOVFF  76B,7A0
02C80:  MOVLB  7
02C82:  CLRF   xA7
02C84:  CLRF   xA6
02C86:  CLRF   xA5
02C88:  MOVLW  9E
02C8A:  MOVWF  xA4
02C8C:  MOVLB  0
02C8E:  CALL   1808
02C92:  MOVFF  03,772
02C96:  MOVFF  02,771
02C9A:  MOVFF  01,770
02C9E:  MOVFF  00,76F
02CA2:  RCALL  2AA0
02CA4:  MOVFF  03,772
02CA8:  MOVFF  02,771
02CAC:  MOVFF  01,770
02CB0:  MOVFF  00,76F
02CB4:  MOVLW  83
02CB6:  MOVLB  7
02CB8:  MOVWF  x76
02CBA:  CLRF   x75
02CBC:  CLRF   x74
02CBE:  MOVLW  0B
02CC0:  MOVWF  x73
02CC2:  MOVFF  03,77A
02CC6:  MOVFF  02,779
02CCA:  MOVFF  01,778
02CCE:  MOVFF  00,777
02CD2:  MOVLB  0
02CD4:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG3_TRIM,(int32)(dsp_value*2147483648.0)); 
02CD8:  MOVFF  76E,7A3
02CDC:  MOVFF  76D,7A2
02CE0:  MOVFF  76C,7A1
02CE4:  MOVFF  76B,7A0
02CE8:  MOVLB  7
02CEA:  CLRF   xA7
02CEC:  CLRF   xA6
02CEE:  CLRF   xA5
02CF0:  MOVLW  9E
02CF2:  MOVWF  xA4
02CF4:  MOVLB  0
02CF6:  CALL   1808
02CFA:  MOVFF  03,772
02CFE:  MOVFF  02,771
02D02:  MOVFF  01,770
02D06:  MOVFF  00,76F
02D0A:  RCALL  2AA0
02D0C:  MOVFF  03,772
02D10:  MOVFF  02,771
02D14:  MOVFF  01,770
02D18:  MOVFF  00,76F
02D1C:  MOVLW  83
02D1E:  MOVLB  7
02D20:  MOVWF  x76
02D22:  CLRF   x75
02D24:  CLRF   x74
02D26:  MOVLW  0C
02D28:  MOVWF  x73
02D2A:  MOVFF  03,77A
02D2E:  MOVFF  02,779
02D32:  MOVFF  01,778
02D36:  MOVFF  00,777
02D3A:  MOVLB  0
02D3C:  CALL   1388
.................... 		send_dsp_command(AM_ANALOG4_TRIM,(int32)(dsp_value*2147483648.0)); 
02D40:  MOVFF  76E,7A3
02D44:  MOVFF  76D,7A2
02D48:  MOVFF  76C,7A1
02D4C:  MOVFF  76B,7A0
02D50:  MOVLB  7
02D52:  CLRF   xA7
02D54:  CLRF   xA6
02D56:  CLRF   xA5
02D58:  MOVLW  9E
02D5A:  MOVWF  xA4
02D5C:  MOVLB  0
02D5E:  CALL   1808
02D62:  MOVFF  03,772
02D66:  MOVFF  02,771
02D6A:  MOVFF  01,770
02D6E:  MOVFF  00,76F
02D72:  RCALL  2AA0
02D74:  MOVFF  03,772
02D78:  MOVFF  02,771
02D7C:  MOVFF  01,770
02D80:  MOVFF  00,76F
02D84:  MOVLW  83
02D86:  MOVLB  7
02D88:  MOVWF  x76
02D8A:  CLRF   x75
02D8C:  CLRF   x74
02D8E:  MOVLW  0D
02D90:  MOVWF  x73
02D92:  MOVFF  03,77A
02D96:  MOVFF  02,779
02D9A:  MOVFF  01,778
02D9E:  MOVFF  00,777
02DA2:  MOVLB  0
02DA4:  CALL   1388
....................  
.................... 		is_muted = 0; 
02DA8:  MOVLB  1
02DAA:  CLRF   x7C
.................... 		last_adc = current_adc; 
02DAC:  MOVFF  17B,17A
.................... 		set_timer1(15550); 
02DB0:  MOVLW  3C
02DB2:  MOVWF  FCF
02DB4:  MOVLW  BE
02DB6:  MOVWF  FCE
.................... 		clear_interrupt(INT_TIMER1); 
02DB8:  BCF    F9E.0
02DBA:  MOVLB  7
.................... 	}   
.................... } 
....................  
.................... // AUDIO DETECT FOR SLEEP MODE 
02DBC:  BCF    F9E.0
02DBE:  MOVLB  0
02DC0:  GOTO   0884
.................... #INT_EXT 
.................... void AUDIODETECT_ISR(void)  
.................... {  
....................    	disable_interrupts (INT_EXT); 
*
02E2A:  BCF    FF2.4
....................  
.................... 	clear_interrupt(INT_EXT); 
02E2C:  BCF    FF2.1
.................... 	 
....................  
.................... 	if(input(PIN_B0)) { 
02E2E:  BSF    F93.0
02E30:  BTFSS  F81.0
02E32:  BRA    2E48
....................  
.................... 		// Audio is now present 
.................... 		//if(is_in_sleep) { 
.................... 			is_in_sleep = 0; 
02E34:  MOVLB  1
02E36:  CLRF   x82
.................... 			sleep_timer_active = 0; 
02E38:  CLRF   x83
.................... 			clear_interrupt(INT_TIMER0); 
02E3A:  BCF    FF2.2
.................... 			disable_interrupts(INT_TIMER0); 
02E3C:  BCF    FF2.5
.................... 			 
.................... 			if(DEBUG) { 
.................... 				fprintf(RS232,"[DEBUG] AUDIO DETECTED. NO LONGER IN SLEEP MODE\r\n"); 
.................... 			} 
....................  
.................... 			// Now wait for it to go low again... 
....................  
.................... 			 
.................... 		//} 
....................  
.................... 			ext_int_edge(0,H_TO_L);  
02E3E:  BCF    FF1.6
.................... 			 
.................... 			enable_interrupts (INT_EXT); 
02E40:  BSF    FF2.4
.................... 			return; 
02E42:  BRA    2E68
.................... 	} else { 
02E44:  BRA    2E68
02E46:  MOVLB  0
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] NO AUDIO FOR %ld SECONDS, STARTING SLEEP TIMER\r\n",AUDIODETECT_HOLDTIME_SECONDS); 
.................... 		} 
.................... 		// Audio not detected for 1 minute.. start timer 
.................... 		clear_interrupt(INT_TIMER0); 
02E48:  BCF    FF2.2
....................  
.................... 		sleepseconds = AUDIODETECT_HOLDTIME_SECONDS; 
02E4A:  MOVFF  1D,17F
02E4E:  MOVFF  1C,17E
.................... 		set_timer0(7936); 
02E52:  MOVLW  1F
02E54:  MOVWF  FD7
02E56:  CLRF   FD6
.................... 		enable_interrupts(INT_TIMER0); 
02E58:  BSF    FF2.5
.................... 		sleep_timer_active = 1; 
02E5A:  MOVLW  01
02E5C:  MOVLB  1
02E5E:  MOVWF  x83
.................... 		is_in_sleep = 0; 
02E60:  CLRF   x82
....................  
.................... 		ext_int_edge(0,L_TO_H);  
02E62:  BSF    FF1.6
.................... 		enable_interrupts (INT_EXT); 
02E64:  BSF    FF2.4
.................... 		return; 
02E66:  BRA    2E68
.................... 	} 
.................... } 
....................  
.................... // USB DETECTION 
02E68:  BCF    FF2.1
02E6A:  MOVLB  0
02E6C:  GOTO   0884
.................... #INT_EXT1  
.................... void USBDETECT_ISR(void)  
.................... {  
....................  
....................    	disable_interrupts (INT_EXT1); 
*
02F72:  BCF    FF0.3
....................  
.................... 	delay_us(100); 
02F74:  MOVLW  7A
02F76:  MOVWF  00
02F78:  DECFSZ 00,F
02F7A:  BRA    2F78
02F7C:  NOP   
....................  
.................... 	if(input(PIN_B1)) { 
02F7E:  BSF    F93.1
02F80:  BTFSS  F81.1
02F82:  BRA    2F8E
.................... 		IS_USB_CONNECTED = true; 
02F84:  MOVLW  01
02F86:  MOVWF  x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is high. USB CONNECT EVENT. Triggering on H_TO_L.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,H_TO_L);  
02F88:  BCF    FF1.5
....................  
.................... 		disable_all_timers(); 
02F8A:  BRA    2EDC
....................  
.................... 	} else { 
02F8C:  BRA    2F94
.................... 		IS_USB_CONNECTED = false; 
02F8E:  CLRF   x78
.................... 		if(DEBUG) { 
.................... 			fprintf(RS232,"[DEBUG] PIN_B1 is low. USB DISCONNECT EVENT. Triggering on L_TO_H.\r\n"); 
.................... 		} 
.................... 		ext_int_edge(1,L_TO_H);  
02F90:  BSF    FF1.5
....................  
.................... 		enable_all_timers(); 
02F92:  BRA    2F5A
.................... 	} 
.................... 	 
.................... 	enable_interrupts(INT_EXT1); 
02F94:  BSF    FF0.3
.................... 	clear_interrupt(INT_EXT1); 
02F96:  BCF    FF0.0
.................... }  
....................  
....................  
02F98:  BCF    FF0.0
02F9A:  GOTO   0884
.................... void main() 
.................... { 
*
09398:  CLRF   FF8
0939A:  BCF    FD0.7
0939C:  BSF    07.7
0939E:  CLRF   FEA
093A0:  CLRF   FE9
093A2:  MOVLW  01
093A4:  MOVWF  1B
093A6:  MOVLW  DE
093A8:  MOVWF  1A
093AA:  CLRF   1D
093AC:  MOVLW  02
093AE:  MOVWF  1C
093B0:  CLRF   1E
093B2:  CLRF   22
093B4:  CLRF   21
093B6:  MOVLW  70
093B8:  MOVWF  20
093BA:  MOVLW  83
093BC:  MOVWF  1F
093BE:  CLRF   26
093C0:  CLRF   25
093C2:  MOVLW  70
093C4:  MOVWF  24
093C6:  MOVLW  86
093C8:  MOVWF  23
093CA:  MOVLW  01
093CC:  MOVWF  27
093CE:  MOVWF  28
093D0:  MOVWF  29
093D2:  MOVWF  2A
093D4:  MOVWF  2B
093D6:  CLRF   2C
093D8:  MOVWF  2D
093DA:  CLRF   2E
093DC:  CLRF   30
093DE:  MOVLW  41
093E0:  MOVWF  2F
093E2:  CLRF   32
093E4:  MOVLW  3C
093E6:  MOVWF  31
093E8:  MOVLW  01
093EA:  MOVWF  x61
093EC:  MOVWF  x62
093EE:  BCF    F94.5
093F0:  BSF    F8B.5
093F2:  CLRF   x77
093F4:  BCF    F70.3
093F6:  MOVLW  17
093F8:  MOVWF  F75
093FA:  MOVLW  A2
093FC:  MOVWF  F72
093FE:  MOVLW  90
09400:  MOVWF  F71
09402:  BSF    F95.1
09404:  BCF    F95.4
09406:  BCF    F95.0
09408:  BCF    F8C.0
0940A:  CLRF   x79
0940C:  MOVLB  1
0940E:  CLRF   x7A
09410:  CLRF   x7B
09412:  CLRF   x7C
09414:  CLRF   x7D
09416:  CLRF   x81
09418:  MOVLW  0A
0941A:  MOVWF  x80
0941C:  CLRF   x82
0941E:  CLRF   x83
09420:  MOVLB  6
09422:  CLRF   xAE
09424:  CLRF   xAD
09426:  CLRF   xB0
09428:  CLRF   xAF
0942A:  CLRF   xB2
0942C:  CLRF   xB1
0942E:  CLRF   xB3
09430:  CLRF   xB4
09432:  BCF    xB5.0
09434:  CLRF   xB7
09436:  CLRF   xB6
09438:  CLRF   xB8
0943A:  CLRF   xB9
0943C:  CLRF   xBA
0943E:  MOVLB  1
09440:  CLRF   x88
09442:  MOVF   FC1,W
09444:  ANDLW  F0
09446:  MOVWF  FC1
09448:  MOVLW  00
0944A:  MOVLB  F
0944C:  MOVWF  x38
0944E:  MOVWF  x3C
09450:  MOVWF  x39
09452:  MOVWF  x3A
09454:  MOVWF  x3B
09456:  CLRF   F77
09458:  CLRF   F78
0945A:  CLRF   F79
0945C:  CLRF   5B
0945E:  CLRF   5C
09460:  MOVLW  2D
09462:  MOVLB  0
09464:  MOVWF  x63
09466:  MOVLW  44
09468:  MOVWF  x64
0946A:  MOVLW  53
0946C:  MOVWF  x65
0946E:  MOVLW  50
09470:  MOVWF  x66
09472:  MOVLW  31
09474:  MOVWF  x67
09476:  MOVLW  30
09478:  MOVWF  x68
0947A:  MOVWF  x69
0947C:  MOVLW  2D
0947E:  MOVWF  x6A
09480:  MOVLW  32
09482:  MOVWF  x6B
09484:  CLRF   x6C
.................... 	// Setup ADC's and Timers 
.................... 	setup_peripherals(); 
09486:  GOTO   3028
....................  
.................... 	default_addr(); 
0948A:  GOTO   3252
....................  
.................... 	FLASH_ADDR_WRITE(14); 
0948E:  MOVLW  0E
09490:  MOVLB  6
09492:  MOVWF  xD8
09494:  MOVLB  0
09496:  GOTO   5EA4
....................  
.................... 	// Initializes and reads external EEPROM. Loads default DEVICE_CONFIG if necessary 
.................... 	device_boot(); 
0949A:  GOTO   66D0
.................... 	 
.................... 	// Reset amplifier and DSP then load values into DSP 
.................... 	softboot(); 
0949E:  CALL   6D22
....................  
.................... 	// Enable/disable interrupts based on DEVICE_CONFIG parameters 
.................... 	setup_interrupts(); 
094A2:  CALL   2EEE
....................  
.................... 	while(true)	 
.................... 	{	 
.................... 		if(IS_USB_CONNECTED) { 
094A6:  MOVF   x78,F
094A8:  BZ    94AE
.................... 			process_usb_data(); 
094AA:  GOTO   7DE8
.................... 		} 
.................... 	} 
094AE:  BRA    94A6
.................... } 
094B0:  SLEEP 

Configuration Fuses:
   Word  1: E300   HSM NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
